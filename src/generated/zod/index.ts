import { z } from 'zod';
import { Prisma } from '@prisma/client';
import Decimal from 'decimal.js';

/////////////////////////////////////////
// HELPER FUNCTIONS
/////////////////////////////////////////

// JSON
//------------------------------------------------------

export type NullableJsonInput =
  | Prisma.JsonValue
  | null
  | 'JsonNull'
  | 'DbNull'
  | Prisma.NullTypes.DbNull
  | Prisma.NullTypes.JsonNull;

export const transformJsonNull = (v?: NullableJsonInput) => {
  if (!v || v === 'DbNull') return Prisma.DbNull;
  if (v === 'JsonNull') return Prisma.JsonNull;
  return v;
};

export const JsonValueSchema: z.ZodType<Prisma.JsonValue> = z.lazy(() =>
  z.union([
    z.string(),
    z.number(),
    z.boolean(),
    z.literal(null),
    z.record(z.lazy(() => JsonValueSchema.optional())),
    z.array(z.lazy(() => JsonValueSchema)),
  ]),
);

export type JsonValueType = z.infer<typeof JsonValueSchema>;

export const NullableJsonValue = z
  .union([JsonValueSchema, z.literal('DbNull'), z.literal('JsonNull')])
  .nullable()
  .transform((v) => transformJsonNull(v));

export type NullableJsonValueType = z.infer<typeof NullableJsonValue>;

export const InputJsonValueSchema: z.ZodType<Prisma.InputJsonValue> = z.lazy(
  () =>
    z.union([
      z.string(),
      z.number(),
      z.boolean(),
      z.object({ toJSON: z.function(z.tuple([]), z.any()) }),
      z.record(z.lazy(() => z.union([InputJsonValueSchema, z.literal(null)]))),
      z.array(z.lazy(() => z.union([InputJsonValueSchema, z.literal(null)]))),
    ]),
);

export type InputJsonValueType = z.infer<typeof InputJsonValueSchema>;

// DECIMAL
//------------------------------------------------------

export const DecimalJsLikeSchema: z.ZodType<Prisma.DecimalJsLike> = z.object({
  d: z.array(z.number()),
  e: z.number(),
  s: z.number(),
  toFixed: z.function(z.tuple([]), z.string()),
});

export const DECIMAL_STRING_REGEX =
  /^(?:-?Infinity|NaN|-?(?:0[bB][01]+(?:\.[01]+)?(?:[pP][-+]?\d+)?|0[oO][0-7]+(?:\.[0-7]+)?(?:[pP][-+]?\d+)?|0[xX][\da-fA-F]+(?:\.[\da-fA-F]+)?(?:[pP][-+]?\d+)?|(?:\d+|\d*\.\d+)(?:[eE][-+]?\d+)?))$/;

export const isValidDecimalInput = (
  v?: null | string | number | Prisma.DecimalJsLike,
): v is string | number | Prisma.DecimalJsLike => {
  if (v === undefined || v === null) return false;
  return (
    (typeof v === 'object' &&
      'd' in v &&
      'e' in v &&
      's' in v &&
      'toFixed' in v) ||
    (typeof v === 'string' && DECIMAL_STRING_REGEX.test(v)) ||
    typeof v === 'number'
  );
};

/////////////////////////////////////////
// ENUMS
/////////////////////////////////////////

export const TransactionIsolationLevelSchema = z.enum([
  'ReadUncommitted',
  'ReadCommitted',
  'RepeatableRead',
  'Serializable',
]);

export const UserScalarFieldEnumSchema = z.enum([
  'id',
  'email',
  'password',
  'firstName',
  'lastName',
  'fullAddress',
  'city',
  'province',
  'country',
  'phone',
  'status',
  'createdAt',
  'createdBy',
  'updatedAt',
  'deletedAt',
]);

export const VendorScalarFieldEnumSchema = z.enum([
  'id',
  'userID',
  'name',
  'slug',
  'description',
  'logoUrl',
  'taxCode',
  'totalProducts',
  'totalOrders',
  'status',
  'createdAt',
  'createdBy',
  'updatedAt',
  'deletedAt',
]);

export const RoleScalarFieldEnumSchema = z.enum([
  'id',
  'name',
  'description',
  'isSystemRole',
  'createdAt',
  'createdBy',
  'updatedAt',
  'deletedAt',
]);

export const PermissionScalarFieldEnumSchema = z.enum([
  'id',
  'name',
  'description',
  'key',
  'isSystemPermission',
  'createdAt',
  'createdBy',
  'updatedAt',
  'deletedAt',
]);

export const RolePermissionScalarFieldEnumSchema = z.enum([
  'roleID',
  'permissionID',
  'createdAt',
  'createdBy',
]);

export const UserVendorRoleScalarFieldEnumSchema = z.enum([
  'id',
  'userID',
  'vendorID',
  'roleID',
  'status',
  'createdAt',
  'createdBy',
]);

export const CategoryScalarFieldEnumSchema = z.enum([
  'id',
  'name',
  'slug',
  'description',
  'parentID',
  'imageUrl',
  'createdAt',
  'createdBy',
  'updatedAt',
  'deletedAt',
]);

export const ProductScalarFieldEnumSchema = z.enum([
  'id',
  'vendorID',
  'name',
  'slug',
  'description',
  'sku',
  'price',
  'stockQuantity',
  'status',
  'createdAt',
  'createdBy',
  'updatedAt',
  'deletedAt',
]);

export const ProductVariantScalarFieldEnumSchema = z.enum([
  'id',
  'productID',
  'name',
  'sku',
  'price',
  'stockQuantity',
  'attributes',
  'createdAt',
  'createdBy',
  'updatedAt',
  'deletedAt',
]);

export const ProductCategoryScalarFieldEnumSchema = z.enum([
  'productID',
  'categoryID',
]);

export const ProductImageScalarFieldEnumSchema = z.enum([
  'id',
  'name',
  'description',
  'productID',
  'productVariantID',
  'imageUrl',
  'sortOrder',
  'createdAt',
  'createdBy',
  'updatedAt',
  'deletedAt',
]);

export const OrderScalarFieldEnumSchema = z.enum([
  'id',
  'orderNumber',
  'userID',
  'status',
  'subtotal',
  'taxAmount',
  'shippingAmount',
  'discountAmount',
  'totalAmount',
  'currency',
  'notes',
  'shippedAt',
  'deliveredAt',
  'createdAt',
  'createdBy',
  'updatedAt',
  'deletedAt',
]);

export const OrderItemScalarFieldEnumSchema = z.enum([
  'id',
  'orderID',
  'productVariantID',
  'quantity',
  'unitPrice',
  'totalPrice',
  'productVariantSnapshot',
]);

export const OrderAddressScalarFieldEnumSchema = z.enum([
  'id',
  'orderID',
  'type',
  'firstName',
  'lastName',
  'company',
  'fullAddress',
  'city',
  'province',
  'country',
  'phone',
]);

export const PromotionScalarFieldEnumSchema = z.enum([
  'id',
  'code',
  'name',
  'description',
  'type',
  'value',
  'usageLimit',
  'startDate',
  'endDate',
  'status',
  'createdAt',
  'createdBy',
  'updatedAt',
  'deletedAt',
]);

export const OrderPromotionScalarFieldEnumSchema = z.enum([
  'id',
  'orderID',
  'promotionID',
  'discountAmount',
]);

export const CartScalarFieldEnumSchema = z.enum([
  'id',
  'userID',
  'createdAt',
  'updatedAt',
]);

export const CartItemScalarFieldEnumSchema = z.enum([
  'id',
  'cartID',
  'productVariantID',
  'quantity',
  'createdAt',
  'updatedAt',
]);

export const NotificationScalarFieldEnumSchema = z.enum([
  'id',
  'userID',
  'title',
  'message',
  'isRead',
]);

export const PaymentScalarFieldEnumSchema = z.enum([
  'id',
  'orderID',
  'type',
  'status',
  'amount',
  'transactionID',
  'createdAt',
  'createdBy',
  'updatedAt',
  'deletedAt',
]);

export const SortOrderSchema = z.enum(['asc', 'desc']);

export const NullableJsonNullValueInputSchema = z
  .enum(['DbNull', 'JsonNull'])
  .transform((value) =>
    value === 'JsonNull'
      ? Prisma.JsonNull
      : value === 'DbNull'
        ? Prisma.DbNull
        : value,
  );

export const QueryModeSchema = z.enum(['default', 'insensitive']);

export const NullsOrderSchema = z.enum(['first', 'last']);

export const JsonNullValueFilterSchema = z
  .enum(['DbNull', 'JsonNull', 'AnyNull'])
  .transform((value) =>
    value === 'JsonNull'
      ? Prisma.JsonNull
      : value === 'DbNull'
        ? Prisma.JsonNull
        : value === 'AnyNull'
          ? Prisma.AnyNull
          : value,
  );

export const UserStatusSchema = z.enum(['active', 'inactive']);

export type UserStatusType = `${z.infer<typeof UserStatusSchema>}`;

export const VendorStatusSchema = z.enum(['active', 'inactive']);

export type VendorStatusType = `${z.infer<typeof VendorStatusSchema>}`;

export const UserVendorRoleStatusSchema = z.enum(['active', 'inactive']);

export type UserVendorRoleStatusType =
  `${z.infer<typeof UserVendorRoleStatusSchema>}`;

export const ProductStatusSchema = z.enum(['active', 'inactive', 'draft']);

export type ProductStatusType = `${z.infer<typeof ProductStatusSchema>}`;

export const OrderStatusSchema = z.enum([
  'pending',
  'confirmed',
  'processing',
  'shipped',
  'delivered',
  'cancelled',
  'refunded',
]);

export type OrderStatusType = `${z.infer<typeof OrderStatusSchema>}`;

export const AddressTypeSchema = z.enum([
  'shipping',
  'return',
  'billing',
  'pickup',
]);

export type AddressTypeType = `${z.infer<typeof AddressTypeSchema>}`;

export const PromotionStatusSchema = z.enum(['active', 'inactive', 'expired']);

export type PromotionStatusType = `${z.infer<typeof PromotionStatusSchema>}`;

export const PromotionTypeSchema = z.enum([
  'percentage',
  'fixed_amount',
  'free_shipping',
  'buy_x_get_y',
]);

export type PromotionTypeType = `${z.infer<typeof PromotionTypeSchema>}`;

export const PaymentStatusSchema = z.enum([
  'pending',
  'completed',
  'failed',
  'refunded',
]);

export type PaymentStatusType = `${z.infer<typeof PaymentStatusSchema>}`;

export const PaymentTypeSchema = z.enum([
  'creditCard',
  'bankTransfer',
  'eWallet',
]);

export type PaymentTypeType = `${z.infer<typeof PaymentTypeSchema>}`;

/////////////////////////////////////////
// MODELS
/////////////////////////////////////////

/////////////////////////////////////////
// USER SCHEMA
/////////////////////////////////////////

export const UserSchema = z.object({
  status: UserStatusSchema,
  id: z.string().uuid(),
  email: z.string().email(),
  /**
   * FAKE:faker.internet.password()
   */
  password: z.string(),
  firstName: z.string(),
  lastName: z.string().nullable(),
  fullAddress: z.string(),
  city: z.string().nullable(),
  province: z.string().nullable(),
  country: z.string().nullable(),
  phone: z.string().nullable(),
  createdAt: z.coerce.date(),
  createdBy: z.string().nullable(),
  updatedAt: z.coerce.date(),
  deletedAt: z.coerce.date().nullable(),
});

export type User = z.infer<typeof UserSchema>;

/////////////////////////////////////////
// VENDOR SCHEMA
/////////////////////////////////////////

export const VendorSchema = z.object({
  status: VendorStatusSchema,
  id: z.string().uuid(),
  userID: z.string(),
  name: z.string(),
  slug: z.string(),
  description: z.string().nullable(),
  logoUrl: z.string().nullable(),
  taxCode: z.string().nullable(),
  totalProducts: z.number().int(),
  totalOrders: z.number().int(),
  createdAt: z.coerce.date(),
  createdBy: z.string().nullable(),
  updatedAt: z.coerce.date(),
  deletedAt: z.coerce.date().nullable(),
});

export type Vendor = z.infer<typeof VendorSchema>;

/////////////////////////////////////////
// ROLE SCHEMA
/////////////////////////////////////////

export const RoleSchema = z.object({
  id: z.string().uuid(),
  name: z.string(),
  description: z.string().nullable(),
  isSystemRole: z.boolean(),
  createdAt: z.coerce.date(),
  createdBy: z.string().nullable(),
  updatedAt: z.coerce.date(),
  deletedAt: z.coerce.date().nullable(),
});

export type Role = z.infer<typeof RoleSchema>;

/////////////////////////////////////////
// PERMISSION SCHEMA
/////////////////////////////////////////

export const PermissionSchema = z.object({
  id: z.string().uuid(),
  name: z.string(),
  description: z.string().nullable(),
  key: z
    .string()
    .describe(
      'Pattern: [/resource]_[action], e.g: [/product]_[read], [/product]_[create], [/product]_[manage]',
    ),
  isSystemPermission: z.boolean(),
  createdAt: z.coerce.date(),
  createdBy: z.string().nullable(),
  updatedAt: z.coerce.date(),
  deletedAt: z.coerce.date().nullable(),
});

export type Permission = z.infer<typeof PermissionSchema>;

/////////////////////////////////////////
// ROLE PERMISSION SCHEMA
/////////////////////////////////////////

export const RolePermissionSchema = z.object({
  roleID: z.string(),
  permissionID: z.string(),
  createdAt: z.coerce.date(),
  createdBy: z.string().nullable(),
});

export type RolePermission = z.infer<typeof RolePermissionSchema>;

/////////////////////////////////////////
// USER VENDOR ROLE SCHEMA
/////////////////////////////////////////

export const UserVendorRoleSchema = z.object({
  status: UserVendorRoleStatusSchema,
  id: z.string().uuid(),
  userID: z.string(),
  vendorID: z.string(),
  roleID: z.string(),
  createdAt: z.coerce.date(),
  createdBy: z.string().nullable(),
});

export type UserVendorRole = z.infer<typeof UserVendorRoleSchema>;

/////////////////////////////////////////
// CATEGORY SCHEMA
/////////////////////////////////////////

export const CategorySchema = z.object({
  id: z.string().uuid(),
  name: z.string(),
  slug: z.string(),
  description: z.string().nullable(),
  parentID: z.string().nullable(),
  imageUrl: z.string().nullable(),
  createdAt: z.coerce.date(),
  createdBy: z.string().nullable(),
  updatedAt: z.coerce.date(),
  deletedAt: z.coerce.date().nullable(),
});

export type Category = z.infer<typeof CategorySchema>;

/////////////////////////////////////////
// PRODUCT SCHEMA
/////////////////////////////////////////

export const ProductSchema = z.object({
  status: ProductStatusSchema,
  id: z.string().uuid(),
  vendorID: z.string(),
  name: z.string(),
  slug: z.string(),
  description: z.string().nullable(),
  sku: z.string().nullable(),
  price: z.instanceof(Prisma.Decimal, {
    message: "Field 'price' must be a Decimal. Location: ['Models', 'Product']",
  }),
  stockQuantity: z.number().int(),
  createdAt: z.coerce.date(),
  createdBy: z.string().nullable(),
  updatedAt: z.coerce.date(),
  deletedAt: z.coerce.date().nullable(),
});

export type Product = z.infer<typeof ProductSchema>;

/////////////////////////////////////////
// PRODUCT VARIANT SCHEMA
/////////////////////////////////////////

export const ProductVariantSchema = z.object({
  id: z.string().uuid(),
  productID: z.string(),
  name: z.string().nullable(),
  sku: z.string().nullable(),
  price: z.instanceof(Prisma.Decimal, {
    message:
      "Field 'price' must be a Decimal. Location: ['Models', 'ProductVariant']",
  }),
  stockQuantity: z.number().int(),
  attributes: JsonValueSchema.nullable(),
  createdAt: z.coerce.date(),
  createdBy: z.string().nullable(),
  updatedAt: z.coerce.date(),
  deletedAt: z.coerce.date().nullable(),
});

export type ProductVariant = z.infer<typeof ProductVariantSchema>;

/////////////////////////////////////////
// PRODUCT CATEGORY SCHEMA
/////////////////////////////////////////

export const ProductCategorySchema = z.object({
  productID: z.string(),
  categoryID: z.string(),
});

export type ProductCategory = z.infer<typeof ProductCategorySchema>;

/////////////////////////////////////////
// PRODUCT IMAGE SCHEMA
/////////////////////////////////////////

export const ProductImageSchema = z.object({
  id: z.string().uuid(),
  name: z.string(),
  description: z.string().nullable(),
  productID: z.string().nullable(),
  productVariantID: z.string().nullable(),
  /**
   * FAKE:faker.image.url()
   */
  imageUrl: z.string(),
  sortOrder: z.number().int(),
  createdAt: z.coerce.date(),
  createdBy: z.string().nullable(),
  updatedAt: z.coerce.date(),
  deletedAt: z.coerce.date().nullable(),
});

export type ProductImage = z.infer<typeof ProductImageSchema>;

/////////////////////////////////////////
// ORDER SCHEMA
/////////////////////////////////////////

export const OrderSchema = z.object({
  status: OrderStatusSchema,
  id: z.string().uuid(),
  orderNumber: z.string(),
  userID: z.string(),
  subtotal: z.instanceof(Prisma.Decimal, {
    message:
      "Field 'subtotal' must be a Decimal. Location: ['Models', 'Order']",
  }),
  taxAmount: z.instanceof(Prisma.Decimal, {
    message:
      "Field 'taxAmount' must be a Decimal. Location: ['Models', 'Order']",
  }),
  shippingAmount: z.instanceof(Prisma.Decimal, {
    message:
      "Field 'shippingAmount' must be a Decimal. Location: ['Models', 'Order']",
  }),
  discountAmount: z.instanceof(Prisma.Decimal, {
    message:
      "Field 'discountAmount' must be a Decimal. Location: ['Models', 'Order']",
  }),
  totalAmount: z.instanceof(Prisma.Decimal, {
    message:
      "Field 'totalAmount' must be a Decimal. Location: ['Models', 'Order']",
  }),
  currency: z.string(),
  notes: z.string().nullable(),
  shippedAt: z.coerce.date().nullable(),
  deliveredAt: z.coerce.date().nullable(),
  createdAt: z.coerce.date(),
  createdBy: z.string().nullable(),
  updatedAt: z.coerce.date(),
  deletedAt: z.coerce.date().nullable(),
});

export type Order = z.infer<typeof OrderSchema>;

/////////////////////////////////////////
// ORDER ITEM SCHEMA
/////////////////////////////////////////

export const OrderItemSchema = z.object({
  id: z.string().uuid(),
  orderID: z.string(),
  productVariantID: z.string(),
  quantity: z.number().int(),
  unitPrice: z.instanceof(Prisma.Decimal, {
    message:
      "Field 'unitPrice' must be a Decimal. Location: ['Models', 'OrderItem']",
  }),
  totalPrice: z.instanceof(Prisma.Decimal, {
    message:
      "Field 'totalPrice' must be a Decimal. Location: ['Models', 'OrderItem']",
  }),
  /**
   * [ProductVariantSnapshotType]
   */
  productVariantSnapshot: JsonValueSchema.nullable(),
});

export type OrderItem = z.infer<typeof OrderItemSchema>;

/////////////////////////////////////////
// ORDER ADDRESS SCHEMA
/////////////////////////////////////////

export const OrderAddressSchema = z.object({
  type: AddressTypeSchema,
  id: z.string().uuid(),
  orderID: z.string(),
  firstName: z.string(),
  lastName: z.string().nullable(),
  company: z.string().nullable(),
  fullAddress: z.string(),
  city: z.string().nullable(),
  province: z.string().nullable(),
  country: z.string().nullable(),
  phone: z.string(),
});

export type OrderAddress = z.infer<typeof OrderAddressSchema>;

/////////////////////////////////////////
// PROMOTION SCHEMA
/////////////////////////////////////////

export const PromotionSchema = z.object({
  type: PromotionTypeSchema,
  status: PromotionStatusSchema,
  id: z.string().uuid(),
  code: z.string(),
  name: z.string(),
  description: z.string().nullable(),
  value: z.instanceof(Prisma.Decimal, {
    message:
      "Field 'value' must be a Decimal. Location: ['Models', 'Promotion']",
  }),
  usageLimit: z.number().int().nullable(),
  startDate: z.coerce.date(),
  endDate: z.coerce.date().nullable(),
  createdAt: z.coerce.date(),
  createdBy: z.string().nullable(),
  updatedAt: z.coerce.date(),
  deletedAt: z.coerce.date().nullable(),
});

export type Promotion = z.infer<typeof PromotionSchema>;

/////////////////////////////////////////
// ORDER PROMOTION SCHEMA
/////////////////////////////////////////

export const OrderPromotionSchema = z.object({
  id: z.string().uuid(),
  orderID: z.string(),
  promotionID: z.string(),
  discountAmount: z.instanceof(Prisma.Decimal, {
    message:
      "Field 'discountAmount' must be a Decimal. Location: ['Models', 'OrderPromotion']",
  }),
});

export type OrderPromotion = z.infer<typeof OrderPromotionSchema>;

/////////////////////////////////////////
// CART SCHEMA
/////////////////////////////////////////

export const CartSchema = z.object({
  id: z.string().uuid(),
  userID: z.string(),
  createdAt: z.coerce.date(),
  updatedAt: z.coerce.date(),
});

export type Cart = z.infer<typeof CartSchema>;

/////////////////////////////////////////
// CART ITEM SCHEMA
/////////////////////////////////////////

export const CartItemSchema = z.object({
  id: z.string().uuid(),
  cartID: z.string(),
  productVariantID: z.string(),
  quantity: z.number().int(),
  createdAt: z.coerce.date(),
  updatedAt: z.coerce.date(),
});

export type CartItem = z.infer<typeof CartItemSchema>;

/////////////////////////////////////////
// NOTIFICATION SCHEMA
/////////////////////////////////////////

export const NotificationSchema = z.object({
  id: z.string().uuid(),
  userID: z.string(),
  title: z.string(),
  message: z.string(),
  isRead: z.boolean(),
});

export type Notification = z.infer<typeof NotificationSchema>;

/////////////////////////////////////////
// PAYMENT SCHEMA
/////////////////////////////////////////

export const PaymentSchema = z.object({
  type: PaymentTypeSchema,
  status: PaymentStatusSchema,
  id: z.string().uuid(),
  orderID: z.string(),
  amount: z.instanceof(Prisma.Decimal, {
    message:
      "Field 'amount' must be a Decimal. Location: ['Models', 'Payment']",
  }),
  transactionID: z.string().nullable(),
  createdAt: z.coerce.date(),
  createdBy: z.string().nullable(),
  updatedAt: z.coerce.date(),
  deletedAt: z.coerce.date().nullable(),
});

export type Payment = z.infer<typeof PaymentSchema>;

/////////////////////////////////////////
// SELECT & INCLUDE
/////////////////////////////////////////

// USER
//------------------------------------------------------

export const UserIncludeSchema: z.ZodType<Prisma.UserInclude> = z
  .object({
    vendors: z
      .union([z.boolean(), z.lazy(() => VendorFindManyArgsSchema)])
      .optional(),
    userVendorRoles: z
      .union([z.boolean(), z.lazy(() => UserVendorRoleFindManyArgsSchema)])
      .optional(),
    orders: z
      .union([z.boolean(), z.lazy(() => OrderFindManyArgsSchema)])
      .optional(),
    cart: z.union([z.boolean(), z.lazy(() => CartArgsSchema)]).optional(),
    notifications: z
      .union([z.boolean(), z.lazy(() => NotificationFindManyArgsSchema)])
      .optional(),
    _count: z
      .union([z.boolean(), z.lazy(() => UserCountOutputTypeArgsSchema)])
      .optional(),
  })
  .strict();

export const UserArgsSchema: z.ZodType<Prisma.UserDefaultArgs> = z
  .object({
    select: z.lazy(() => UserSelectSchema).optional(),
    include: z.lazy(() => UserIncludeSchema).optional(),
  })
  .strict();

export const UserCountOutputTypeArgsSchema: z.ZodType<Prisma.UserCountOutputTypeDefaultArgs> =
  z
    .object({
      select: z.lazy(() => UserCountOutputTypeSelectSchema).nullish(),
    })
    .strict();

export const UserCountOutputTypeSelectSchema: z.ZodType<Prisma.UserCountOutputTypeSelect> =
  z
    .object({
      vendors: z.boolean().optional(),
      userVendorRoles: z.boolean().optional(),
      orders: z.boolean().optional(),
      notifications: z.boolean().optional(),
    })
    .strict();

export const UserSelectSchema: z.ZodType<Prisma.UserSelect> = z
  .object({
    id: z.boolean().optional(),
    email: z.boolean().optional(),
    password: z.boolean().optional(),
    firstName: z.boolean().optional(),
    lastName: z.boolean().optional(),
    fullAddress: z.boolean().optional(),
    city: z.boolean().optional(),
    province: z.boolean().optional(),
    country: z.boolean().optional(),
    phone: z.boolean().optional(),
    status: z.boolean().optional(),
    createdAt: z.boolean().optional(),
    createdBy: z.boolean().optional(),
    updatedAt: z.boolean().optional(),
    deletedAt: z.boolean().optional(),
    vendors: z
      .union([z.boolean(), z.lazy(() => VendorFindManyArgsSchema)])
      .optional(),
    userVendorRoles: z
      .union([z.boolean(), z.lazy(() => UserVendorRoleFindManyArgsSchema)])
      .optional(),
    orders: z
      .union([z.boolean(), z.lazy(() => OrderFindManyArgsSchema)])
      .optional(),
    cart: z.union([z.boolean(), z.lazy(() => CartArgsSchema)]).optional(),
    notifications: z
      .union([z.boolean(), z.lazy(() => NotificationFindManyArgsSchema)])
      .optional(),
    _count: z
      .union([z.boolean(), z.lazy(() => UserCountOutputTypeArgsSchema)])
      .optional(),
  })
  .strict();

// VENDOR
//------------------------------------------------------

export const VendorIncludeSchema: z.ZodType<Prisma.VendorInclude> = z
  .object({
    user: z.union([z.boolean(), z.lazy(() => UserArgsSchema)]).optional(),
    products: z
      .union([z.boolean(), z.lazy(() => ProductFindManyArgsSchema)])
      .optional(),
    userVendorRoles: z
      .union([z.boolean(), z.lazy(() => UserVendorRoleFindManyArgsSchema)])
      .optional(),
    _count: z
      .union([z.boolean(), z.lazy(() => VendorCountOutputTypeArgsSchema)])
      .optional(),
  })
  .strict();

export const VendorArgsSchema: z.ZodType<Prisma.VendorDefaultArgs> = z
  .object({
    select: z.lazy(() => VendorSelectSchema).optional(),
    include: z.lazy(() => VendorIncludeSchema).optional(),
  })
  .strict();

export const VendorCountOutputTypeArgsSchema: z.ZodType<Prisma.VendorCountOutputTypeDefaultArgs> =
  z
    .object({
      select: z.lazy(() => VendorCountOutputTypeSelectSchema).nullish(),
    })
    .strict();

export const VendorCountOutputTypeSelectSchema: z.ZodType<Prisma.VendorCountOutputTypeSelect> =
  z
    .object({
      products: z.boolean().optional(),
      userVendorRoles: z.boolean().optional(),
    })
    .strict();

export const VendorSelectSchema: z.ZodType<Prisma.VendorSelect> = z
  .object({
    id: z.boolean().optional(),
    userID: z.boolean().optional(),
    name: z.boolean().optional(),
    slug: z.boolean().optional(),
    description: z.boolean().optional(),
    logoUrl: z.boolean().optional(),
    taxCode: z.boolean().optional(),
    totalProducts: z.boolean().optional(),
    totalOrders: z.boolean().optional(),
    status: z.boolean().optional(),
    createdAt: z.boolean().optional(),
    createdBy: z.boolean().optional(),
    updatedAt: z.boolean().optional(),
    deletedAt: z.boolean().optional(),
    user: z.union([z.boolean(), z.lazy(() => UserArgsSchema)]).optional(),
    products: z
      .union([z.boolean(), z.lazy(() => ProductFindManyArgsSchema)])
      .optional(),
    userVendorRoles: z
      .union([z.boolean(), z.lazy(() => UserVendorRoleFindManyArgsSchema)])
      .optional(),
    _count: z
      .union([z.boolean(), z.lazy(() => VendorCountOutputTypeArgsSchema)])
      .optional(),
  })
  .strict();

// ROLE
//------------------------------------------------------

export const RoleIncludeSchema: z.ZodType<Prisma.RoleInclude> = z
  .object({
    userVendorRoles: z
      .union([z.boolean(), z.lazy(() => UserVendorRoleFindManyArgsSchema)])
      .optional(),
    rolePermissions: z
      .union([z.boolean(), z.lazy(() => RolePermissionFindManyArgsSchema)])
      .optional(),
    _count: z
      .union([z.boolean(), z.lazy(() => RoleCountOutputTypeArgsSchema)])
      .optional(),
  })
  .strict();

export const RoleArgsSchema: z.ZodType<Prisma.RoleDefaultArgs> = z
  .object({
    select: z.lazy(() => RoleSelectSchema).optional(),
    include: z.lazy(() => RoleIncludeSchema).optional(),
  })
  .strict();

export const RoleCountOutputTypeArgsSchema: z.ZodType<Prisma.RoleCountOutputTypeDefaultArgs> =
  z
    .object({
      select: z.lazy(() => RoleCountOutputTypeSelectSchema).nullish(),
    })
    .strict();

export const RoleCountOutputTypeSelectSchema: z.ZodType<Prisma.RoleCountOutputTypeSelect> =
  z
    .object({
      userVendorRoles: z.boolean().optional(),
      rolePermissions: z.boolean().optional(),
    })
    .strict();

export const RoleSelectSchema: z.ZodType<Prisma.RoleSelect> = z
  .object({
    id: z.boolean().optional(),
    name: z.boolean().optional(),
    description: z.boolean().optional(),
    isSystemRole: z.boolean().optional(),
    createdAt: z.boolean().optional(),
    createdBy: z.boolean().optional(),
    updatedAt: z.boolean().optional(),
    deletedAt: z.boolean().optional(),
    userVendorRoles: z
      .union([z.boolean(), z.lazy(() => UserVendorRoleFindManyArgsSchema)])
      .optional(),
    rolePermissions: z
      .union([z.boolean(), z.lazy(() => RolePermissionFindManyArgsSchema)])
      .optional(),
    _count: z
      .union([z.boolean(), z.lazy(() => RoleCountOutputTypeArgsSchema)])
      .optional(),
  })
  .strict();

// PERMISSION
//------------------------------------------------------

export const PermissionIncludeSchema: z.ZodType<Prisma.PermissionInclude> = z
  .object({
    rolePermissions: z
      .union([z.boolean(), z.lazy(() => RolePermissionFindManyArgsSchema)])
      .optional(),
    _count: z
      .union([z.boolean(), z.lazy(() => PermissionCountOutputTypeArgsSchema)])
      .optional(),
  })
  .strict();

export const PermissionArgsSchema: z.ZodType<Prisma.PermissionDefaultArgs> = z
  .object({
    select: z.lazy(() => PermissionSelectSchema).optional(),
    include: z.lazy(() => PermissionIncludeSchema).optional(),
  })
  .strict();

export const PermissionCountOutputTypeArgsSchema: z.ZodType<Prisma.PermissionCountOutputTypeDefaultArgs> =
  z
    .object({
      select: z.lazy(() => PermissionCountOutputTypeSelectSchema).nullish(),
    })
    .strict();

export const PermissionCountOutputTypeSelectSchema: z.ZodType<Prisma.PermissionCountOutputTypeSelect> =
  z
    .object({
      rolePermissions: z.boolean().optional(),
    })
    .strict();

export const PermissionSelectSchema: z.ZodType<Prisma.PermissionSelect> = z
  .object({
    id: z.boolean().optional(),
    name: z.boolean().optional(),
    description: z.boolean().optional(),
    key: z.boolean().optional(),
    isSystemPermission: z.boolean().optional(),
    createdAt: z.boolean().optional(),
    createdBy: z.boolean().optional(),
    updatedAt: z.boolean().optional(),
    deletedAt: z.boolean().optional(),
    rolePermissions: z
      .union([z.boolean(), z.lazy(() => RolePermissionFindManyArgsSchema)])
      .optional(),
    _count: z
      .union([z.boolean(), z.lazy(() => PermissionCountOutputTypeArgsSchema)])
      .optional(),
  })
  .strict();

// ROLE PERMISSION
//------------------------------------------------------

export const RolePermissionIncludeSchema: z.ZodType<Prisma.RolePermissionInclude> =
  z
    .object({
      role: z.union([z.boolean(), z.lazy(() => RoleArgsSchema)]).optional(),
      permission: z
        .union([z.boolean(), z.lazy(() => PermissionArgsSchema)])
        .optional(),
    })
    .strict();

export const RolePermissionArgsSchema: z.ZodType<Prisma.RolePermissionDefaultArgs> =
  z
    .object({
      select: z.lazy(() => RolePermissionSelectSchema).optional(),
      include: z.lazy(() => RolePermissionIncludeSchema).optional(),
    })
    .strict();

export const RolePermissionSelectSchema: z.ZodType<Prisma.RolePermissionSelect> =
  z
    .object({
      roleID: z.boolean().optional(),
      permissionID: z.boolean().optional(),
      createdAt: z.boolean().optional(),
      createdBy: z.boolean().optional(),
      role: z.union([z.boolean(), z.lazy(() => RoleArgsSchema)]).optional(),
      permission: z
        .union([z.boolean(), z.lazy(() => PermissionArgsSchema)])
        .optional(),
    })
    .strict();

// USER VENDOR ROLE
//------------------------------------------------------

export const UserVendorRoleIncludeSchema: z.ZodType<Prisma.UserVendorRoleInclude> =
  z
    .object({
      user: z.union([z.boolean(), z.lazy(() => UserArgsSchema)]).optional(),
      vendor: z.union([z.boolean(), z.lazy(() => VendorArgsSchema)]).optional(),
      role: z.union([z.boolean(), z.lazy(() => RoleArgsSchema)]).optional(),
    })
    .strict();

export const UserVendorRoleArgsSchema: z.ZodType<Prisma.UserVendorRoleDefaultArgs> =
  z
    .object({
      select: z.lazy(() => UserVendorRoleSelectSchema).optional(),
      include: z.lazy(() => UserVendorRoleIncludeSchema).optional(),
    })
    .strict();

export const UserVendorRoleSelectSchema: z.ZodType<Prisma.UserVendorRoleSelect> =
  z
    .object({
      id: z.boolean().optional(),
      userID: z.boolean().optional(),
      vendorID: z.boolean().optional(),
      roleID: z.boolean().optional(),
      status: z.boolean().optional(),
      createdAt: z.boolean().optional(),
      createdBy: z.boolean().optional(),
      user: z.union([z.boolean(), z.lazy(() => UserArgsSchema)]).optional(),
      vendor: z.union([z.boolean(), z.lazy(() => VendorArgsSchema)]).optional(),
      role: z.union([z.boolean(), z.lazy(() => RoleArgsSchema)]).optional(),
    })
    .strict();

// CATEGORY
//------------------------------------------------------

export const CategoryIncludeSchema: z.ZodType<Prisma.CategoryInclude> = z
  .object({
    parent: z.union([z.boolean(), z.lazy(() => CategoryArgsSchema)]).optional(),
    children: z
      .union([z.boolean(), z.lazy(() => CategoryFindManyArgsSchema)])
      .optional(),
    productCategories: z
      .union([z.boolean(), z.lazy(() => ProductCategoryFindManyArgsSchema)])
      .optional(),
    _count: z
      .union([z.boolean(), z.lazy(() => CategoryCountOutputTypeArgsSchema)])
      .optional(),
  })
  .strict();

export const CategoryArgsSchema: z.ZodType<Prisma.CategoryDefaultArgs> = z
  .object({
    select: z.lazy(() => CategorySelectSchema).optional(),
    include: z.lazy(() => CategoryIncludeSchema).optional(),
  })
  .strict();

export const CategoryCountOutputTypeArgsSchema: z.ZodType<Prisma.CategoryCountOutputTypeDefaultArgs> =
  z
    .object({
      select: z.lazy(() => CategoryCountOutputTypeSelectSchema).nullish(),
    })
    .strict();

export const CategoryCountOutputTypeSelectSchema: z.ZodType<Prisma.CategoryCountOutputTypeSelect> =
  z
    .object({
      children: z.boolean().optional(),
      productCategories: z.boolean().optional(),
    })
    .strict();

export const CategorySelectSchema: z.ZodType<Prisma.CategorySelect> = z
  .object({
    id: z.boolean().optional(),
    name: z.boolean().optional(),
    slug: z.boolean().optional(),
    description: z.boolean().optional(),
    parentID: z.boolean().optional(),
    imageUrl: z.boolean().optional(),
    createdAt: z.boolean().optional(),
    createdBy: z.boolean().optional(),
    updatedAt: z.boolean().optional(),
    deletedAt: z.boolean().optional(),
    parent: z.union([z.boolean(), z.lazy(() => CategoryArgsSchema)]).optional(),
    children: z
      .union([z.boolean(), z.lazy(() => CategoryFindManyArgsSchema)])
      .optional(),
    productCategories: z
      .union([z.boolean(), z.lazy(() => ProductCategoryFindManyArgsSchema)])
      .optional(),
    _count: z
      .union([z.boolean(), z.lazy(() => CategoryCountOutputTypeArgsSchema)])
      .optional(),
  })
  .strict();

// PRODUCT
//------------------------------------------------------

export const ProductIncludeSchema: z.ZodType<Prisma.ProductInclude> = z
  .object({
    vendor: z.union([z.boolean(), z.lazy(() => VendorArgsSchema)]).optional(),
    productCategories: z
      .union([z.boolean(), z.lazy(() => ProductCategoryFindManyArgsSchema)])
      .optional(),
    productImages: z
      .union([z.boolean(), z.lazy(() => ProductImageFindManyArgsSchema)])
      .optional(),
    productVariants: z
      .union([z.boolean(), z.lazy(() => ProductVariantFindManyArgsSchema)])
      .optional(),
    _count: z
      .union([z.boolean(), z.lazy(() => ProductCountOutputTypeArgsSchema)])
      .optional(),
  })
  .strict();

export const ProductArgsSchema: z.ZodType<Prisma.ProductDefaultArgs> = z
  .object({
    select: z.lazy(() => ProductSelectSchema).optional(),
    include: z.lazy(() => ProductIncludeSchema).optional(),
  })
  .strict();

export const ProductCountOutputTypeArgsSchema: z.ZodType<Prisma.ProductCountOutputTypeDefaultArgs> =
  z
    .object({
      select: z.lazy(() => ProductCountOutputTypeSelectSchema).nullish(),
    })
    .strict();

export const ProductCountOutputTypeSelectSchema: z.ZodType<Prisma.ProductCountOutputTypeSelect> =
  z
    .object({
      productCategories: z.boolean().optional(),
      productImages: z.boolean().optional(),
      productVariants: z.boolean().optional(),
    })
    .strict();

export const ProductSelectSchema: z.ZodType<Prisma.ProductSelect> = z
  .object({
    id: z.boolean().optional(),
    vendorID: z.boolean().optional(),
    name: z.boolean().optional(),
    slug: z.boolean().optional(),
    description: z.boolean().optional(),
    sku: z.boolean().optional(),
    price: z.boolean().optional(),
    stockQuantity: z.boolean().optional(),
    status: z.boolean().optional(),
    createdAt: z.boolean().optional(),
    createdBy: z.boolean().optional(),
    updatedAt: z.boolean().optional(),
    deletedAt: z.boolean().optional(),
    vendor: z.union([z.boolean(), z.lazy(() => VendorArgsSchema)]).optional(),
    productCategories: z
      .union([z.boolean(), z.lazy(() => ProductCategoryFindManyArgsSchema)])
      .optional(),
    productImages: z
      .union([z.boolean(), z.lazy(() => ProductImageFindManyArgsSchema)])
      .optional(),
    productVariants: z
      .union([z.boolean(), z.lazy(() => ProductVariantFindManyArgsSchema)])
      .optional(),
    _count: z
      .union([z.boolean(), z.lazy(() => ProductCountOutputTypeArgsSchema)])
      .optional(),
  })
  .strict();

// PRODUCT VARIANT
//------------------------------------------------------

export const ProductVariantIncludeSchema: z.ZodType<Prisma.ProductVariantInclude> =
  z
    .object({
      product: z
        .union([z.boolean(), z.lazy(() => ProductArgsSchema)])
        .optional(),
      productImages: z
        .union([z.boolean(), z.lazy(() => ProductImageFindManyArgsSchema)])
        .optional(),
      orderItems: z
        .union([z.boolean(), z.lazy(() => OrderItemFindManyArgsSchema)])
        .optional(),
      cartItems: z
        .union([z.boolean(), z.lazy(() => CartItemFindManyArgsSchema)])
        .optional(),
      _count: z
        .union([
          z.boolean(),
          z.lazy(() => ProductVariantCountOutputTypeArgsSchema),
        ])
        .optional(),
    })
    .strict();

export const ProductVariantArgsSchema: z.ZodType<Prisma.ProductVariantDefaultArgs> =
  z
    .object({
      select: z.lazy(() => ProductVariantSelectSchema).optional(),
      include: z.lazy(() => ProductVariantIncludeSchema).optional(),
    })
    .strict();

export const ProductVariantCountOutputTypeArgsSchema: z.ZodType<Prisma.ProductVariantCountOutputTypeDefaultArgs> =
  z
    .object({
      select: z.lazy(() => ProductVariantCountOutputTypeSelectSchema).nullish(),
    })
    .strict();

export const ProductVariantCountOutputTypeSelectSchema: z.ZodType<Prisma.ProductVariantCountOutputTypeSelect> =
  z
    .object({
      productImages: z.boolean().optional(),
      orderItems: z.boolean().optional(),
      cartItems: z.boolean().optional(),
    })
    .strict();

export const ProductVariantSelectSchema: z.ZodType<Prisma.ProductVariantSelect> =
  z
    .object({
      id: z.boolean().optional(),
      productID: z.boolean().optional(),
      name: z.boolean().optional(),
      sku: z.boolean().optional(),
      price: z.boolean().optional(),
      stockQuantity: z.boolean().optional(),
      attributes: z.boolean().optional(),
      createdAt: z.boolean().optional(),
      createdBy: z.boolean().optional(),
      updatedAt: z.boolean().optional(),
      deletedAt: z.boolean().optional(),
      product: z
        .union([z.boolean(), z.lazy(() => ProductArgsSchema)])
        .optional(),
      productImages: z
        .union([z.boolean(), z.lazy(() => ProductImageFindManyArgsSchema)])
        .optional(),
      orderItems: z
        .union([z.boolean(), z.lazy(() => OrderItemFindManyArgsSchema)])
        .optional(),
      cartItems: z
        .union([z.boolean(), z.lazy(() => CartItemFindManyArgsSchema)])
        .optional(),
      _count: z
        .union([
          z.boolean(),
          z.lazy(() => ProductVariantCountOutputTypeArgsSchema),
        ])
        .optional(),
    })
    .strict();

// PRODUCT CATEGORY
//------------------------------------------------------

export const ProductCategoryIncludeSchema: z.ZodType<Prisma.ProductCategoryInclude> =
  z
    .object({
      product: z
        .union([z.boolean(), z.lazy(() => ProductArgsSchema)])
        .optional(),
      category: z
        .union([z.boolean(), z.lazy(() => CategoryArgsSchema)])
        .optional(),
    })
    .strict();

export const ProductCategoryArgsSchema: z.ZodType<Prisma.ProductCategoryDefaultArgs> =
  z
    .object({
      select: z.lazy(() => ProductCategorySelectSchema).optional(),
      include: z.lazy(() => ProductCategoryIncludeSchema).optional(),
    })
    .strict();

export const ProductCategorySelectSchema: z.ZodType<Prisma.ProductCategorySelect> =
  z
    .object({
      productID: z.boolean().optional(),
      categoryID: z.boolean().optional(),
      product: z
        .union([z.boolean(), z.lazy(() => ProductArgsSchema)])
        .optional(),
      category: z
        .union([z.boolean(), z.lazy(() => CategoryArgsSchema)])
        .optional(),
    })
    .strict();

// PRODUCT IMAGE
//------------------------------------------------------

export const ProductImageIncludeSchema: z.ZodType<Prisma.ProductImageInclude> =
  z
    .object({
      product: z
        .union([z.boolean(), z.lazy(() => ProductArgsSchema)])
        .optional(),
      productVariant: z
        .union([z.boolean(), z.lazy(() => ProductVariantArgsSchema)])
        .optional(),
    })
    .strict();

export const ProductImageArgsSchema: z.ZodType<Prisma.ProductImageDefaultArgs> =
  z
    .object({
      select: z.lazy(() => ProductImageSelectSchema).optional(),
      include: z.lazy(() => ProductImageIncludeSchema).optional(),
    })
    .strict();

export const ProductImageSelectSchema: z.ZodType<Prisma.ProductImageSelect> = z
  .object({
    id: z.boolean().optional(),
    name: z.boolean().optional(),
    description: z.boolean().optional(),
    productID: z.boolean().optional(),
    productVariantID: z.boolean().optional(),
    imageUrl: z.boolean().optional(),
    sortOrder: z.boolean().optional(),
    createdAt: z.boolean().optional(),
    createdBy: z.boolean().optional(),
    updatedAt: z.boolean().optional(),
    deletedAt: z.boolean().optional(),
    product: z.union([z.boolean(), z.lazy(() => ProductArgsSchema)]).optional(),
    productVariant: z
      .union([z.boolean(), z.lazy(() => ProductVariantArgsSchema)])
      .optional(),
  })
  .strict();

// ORDER
//------------------------------------------------------

export const OrderIncludeSchema: z.ZodType<Prisma.OrderInclude> = z
  .object({
    user: z.union([z.boolean(), z.lazy(() => UserArgsSchema)]).optional(),
    orderItems: z
      .union([z.boolean(), z.lazy(() => OrderItemFindManyArgsSchema)])
      .optional(),
    orderAddresses: z
      .union([z.boolean(), z.lazy(() => OrderAddressFindManyArgsSchema)])
      .optional(),
    orderPromotions: z
      .union([z.boolean(), z.lazy(() => OrderPromotionFindManyArgsSchema)])
      .optional(),
    payments: z
      .union([z.boolean(), z.lazy(() => PaymentFindManyArgsSchema)])
      .optional(),
    _count: z
      .union([z.boolean(), z.lazy(() => OrderCountOutputTypeArgsSchema)])
      .optional(),
  })
  .strict();

export const OrderArgsSchema: z.ZodType<Prisma.OrderDefaultArgs> = z
  .object({
    select: z.lazy(() => OrderSelectSchema).optional(),
    include: z.lazy(() => OrderIncludeSchema).optional(),
  })
  .strict();

export const OrderCountOutputTypeArgsSchema: z.ZodType<Prisma.OrderCountOutputTypeDefaultArgs> =
  z
    .object({
      select: z.lazy(() => OrderCountOutputTypeSelectSchema).nullish(),
    })
    .strict();

export const OrderCountOutputTypeSelectSchema: z.ZodType<Prisma.OrderCountOutputTypeSelect> =
  z
    .object({
      orderItems: z.boolean().optional(),
      orderAddresses: z.boolean().optional(),
      orderPromotions: z.boolean().optional(),
      payments: z.boolean().optional(),
    })
    .strict();

export const OrderSelectSchema: z.ZodType<Prisma.OrderSelect> = z
  .object({
    id: z.boolean().optional(),
    orderNumber: z.boolean().optional(),
    userID: z.boolean().optional(),
    status: z.boolean().optional(),
    subtotal: z.boolean().optional(),
    taxAmount: z.boolean().optional(),
    shippingAmount: z.boolean().optional(),
    discountAmount: z.boolean().optional(),
    totalAmount: z.boolean().optional(),
    currency: z.boolean().optional(),
    notes: z.boolean().optional(),
    shippedAt: z.boolean().optional(),
    deliveredAt: z.boolean().optional(),
    createdAt: z.boolean().optional(),
    createdBy: z.boolean().optional(),
    updatedAt: z.boolean().optional(),
    deletedAt: z.boolean().optional(),
    user: z.union([z.boolean(), z.lazy(() => UserArgsSchema)]).optional(),
    orderItems: z
      .union([z.boolean(), z.lazy(() => OrderItemFindManyArgsSchema)])
      .optional(),
    orderAddresses: z
      .union([z.boolean(), z.lazy(() => OrderAddressFindManyArgsSchema)])
      .optional(),
    orderPromotions: z
      .union([z.boolean(), z.lazy(() => OrderPromotionFindManyArgsSchema)])
      .optional(),
    payments: z
      .union([z.boolean(), z.lazy(() => PaymentFindManyArgsSchema)])
      .optional(),
    _count: z
      .union([z.boolean(), z.lazy(() => OrderCountOutputTypeArgsSchema)])
      .optional(),
  })
  .strict();

// ORDER ITEM
//------------------------------------------------------

export const OrderItemIncludeSchema: z.ZodType<Prisma.OrderItemInclude> = z
  .object({
    productVariant: z
      .union([z.boolean(), z.lazy(() => ProductVariantArgsSchema)])
      .optional(),
    order: z.union([z.boolean(), z.lazy(() => OrderArgsSchema)]).optional(),
  })
  .strict();

export const OrderItemArgsSchema: z.ZodType<Prisma.OrderItemDefaultArgs> = z
  .object({
    select: z.lazy(() => OrderItemSelectSchema).optional(),
    include: z.lazy(() => OrderItemIncludeSchema).optional(),
  })
  .strict();

export const OrderItemSelectSchema: z.ZodType<Prisma.OrderItemSelect> = z
  .object({
    id: z.boolean().optional(),
    orderID: z.boolean().optional(),
    productVariantID: z.boolean().optional(),
    quantity: z.boolean().optional(),
    unitPrice: z.boolean().optional(),
    totalPrice: z.boolean().optional(),
    productVariantSnapshot: z.boolean().optional(),
    productVariant: z
      .union([z.boolean(), z.lazy(() => ProductVariantArgsSchema)])
      .optional(),
    order: z.union([z.boolean(), z.lazy(() => OrderArgsSchema)]).optional(),
  })
  .strict();

// ORDER ADDRESS
//------------------------------------------------------

export const OrderAddressIncludeSchema: z.ZodType<Prisma.OrderAddressInclude> =
  z
    .object({
      order: z.union([z.boolean(), z.lazy(() => OrderArgsSchema)]).optional(),
    })
    .strict();

export const OrderAddressArgsSchema: z.ZodType<Prisma.OrderAddressDefaultArgs> =
  z
    .object({
      select: z.lazy(() => OrderAddressSelectSchema).optional(),
      include: z.lazy(() => OrderAddressIncludeSchema).optional(),
    })
    .strict();

export const OrderAddressSelectSchema: z.ZodType<Prisma.OrderAddressSelect> = z
  .object({
    id: z.boolean().optional(),
    orderID: z.boolean().optional(),
    type: z.boolean().optional(),
    firstName: z.boolean().optional(),
    lastName: z.boolean().optional(),
    company: z.boolean().optional(),
    fullAddress: z.boolean().optional(),
    city: z.boolean().optional(),
    province: z.boolean().optional(),
    country: z.boolean().optional(),
    phone: z.boolean().optional(),
    order: z.union([z.boolean(), z.lazy(() => OrderArgsSchema)]).optional(),
  })
  .strict();

// PROMOTION
//------------------------------------------------------

export const PromotionIncludeSchema: z.ZodType<Prisma.PromotionInclude> = z
  .object({
    orderPromotions: z
      .union([z.boolean(), z.lazy(() => OrderPromotionFindManyArgsSchema)])
      .optional(),
    _count: z
      .union([z.boolean(), z.lazy(() => PromotionCountOutputTypeArgsSchema)])
      .optional(),
  })
  .strict();

export const PromotionArgsSchema: z.ZodType<Prisma.PromotionDefaultArgs> = z
  .object({
    select: z.lazy(() => PromotionSelectSchema).optional(),
    include: z.lazy(() => PromotionIncludeSchema).optional(),
  })
  .strict();

export const PromotionCountOutputTypeArgsSchema: z.ZodType<Prisma.PromotionCountOutputTypeDefaultArgs> =
  z
    .object({
      select: z.lazy(() => PromotionCountOutputTypeSelectSchema).nullish(),
    })
    .strict();

export const PromotionCountOutputTypeSelectSchema: z.ZodType<Prisma.PromotionCountOutputTypeSelect> =
  z
    .object({
      orderPromotions: z.boolean().optional(),
    })
    .strict();

export const PromotionSelectSchema: z.ZodType<Prisma.PromotionSelect> = z
  .object({
    id: z.boolean().optional(),
    code: z.boolean().optional(),
    name: z.boolean().optional(),
    description: z.boolean().optional(),
    type: z.boolean().optional(),
    value: z.boolean().optional(),
    usageLimit: z.boolean().optional(),
    startDate: z.boolean().optional(),
    endDate: z.boolean().optional(),
    status: z.boolean().optional(),
    createdAt: z.boolean().optional(),
    createdBy: z.boolean().optional(),
    updatedAt: z.boolean().optional(),
    deletedAt: z.boolean().optional(),
    orderPromotions: z
      .union([z.boolean(), z.lazy(() => OrderPromotionFindManyArgsSchema)])
      .optional(),
    _count: z
      .union([z.boolean(), z.lazy(() => PromotionCountOutputTypeArgsSchema)])
      .optional(),
  })
  .strict();

// ORDER PROMOTION
//------------------------------------------------------

export const OrderPromotionIncludeSchema: z.ZodType<Prisma.OrderPromotionInclude> =
  z
    .object({
      order: z.union([z.boolean(), z.lazy(() => OrderArgsSchema)]).optional(),
      promotion: z
        .union([z.boolean(), z.lazy(() => PromotionArgsSchema)])
        .optional(),
    })
    .strict();

export const OrderPromotionArgsSchema: z.ZodType<Prisma.OrderPromotionDefaultArgs> =
  z
    .object({
      select: z.lazy(() => OrderPromotionSelectSchema).optional(),
      include: z.lazy(() => OrderPromotionIncludeSchema).optional(),
    })
    .strict();

export const OrderPromotionSelectSchema: z.ZodType<Prisma.OrderPromotionSelect> =
  z
    .object({
      id: z.boolean().optional(),
      orderID: z.boolean().optional(),
      promotionID: z.boolean().optional(),
      discountAmount: z.boolean().optional(),
      order: z.union([z.boolean(), z.lazy(() => OrderArgsSchema)]).optional(),
      promotion: z
        .union([z.boolean(), z.lazy(() => PromotionArgsSchema)])
        .optional(),
    })
    .strict();

// CART
//------------------------------------------------------

export const CartIncludeSchema: z.ZodType<Prisma.CartInclude> = z
  .object({
    user: z.union([z.boolean(), z.lazy(() => UserArgsSchema)]).optional(),
    cartItems: z
      .union([z.boolean(), z.lazy(() => CartItemFindManyArgsSchema)])
      .optional(),
    _count: z
      .union([z.boolean(), z.lazy(() => CartCountOutputTypeArgsSchema)])
      .optional(),
  })
  .strict();

export const CartArgsSchema: z.ZodType<Prisma.CartDefaultArgs> = z
  .object({
    select: z.lazy(() => CartSelectSchema).optional(),
    include: z.lazy(() => CartIncludeSchema).optional(),
  })
  .strict();

export const CartCountOutputTypeArgsSchema: z.ZodType<Prisma.CartCountOutputTypeDefaultArgs> =
  z
    .object({
      select: z.lazy(() => CartCountOutputTypeSelectSchema).nullish(),
    })
    .strict();

export const CartCountOutputTypeSelectSchema: z.ZodType<Prisma.CartCountOutputTypeSelect> =
  z
    .object({
      cartItems: z.boolean().optional(),
    })
    .strict();

export const CartSelectSchema: z.ZodType<Prisma.CartSelect> = z
  .object({
    id: z.boolean().optional(),
    userID: z.boolean().optional(),
    createdAt: z.boolean().optional(),
    updatedAt: z.boolean().optional(),
    user: z.union([z.boolean(), z.lazy(() => UserArgsSchema)]).optional(),
    cartItems: z
      .union([z.boolean(), z.lazy(() => CartItemFindManyArgsSchema)])
      .optional(),
    _count: z
      .union([z.boolean(), z.lazy(() => CartCountOutputTypeArgsSchema)])
      .optional(),
  })
  .strict();

// CART ITEM
//------------------------------------------------------

export const CartItemIncludeSchema: z.ZodType<Prisma.CartItemInclude> = z
  .object({
    cart: z.union([z.boolean(), z.lazy(() => CartArgsSchema)]).optional(),
    productVariant: z
      .union([z.boolean(), z.lazy(() => ProductVariantArgsSchema)])
      .optional(),
  })
  .strict();

export const CartItemArgsSchema: z.ZodType<Prisma.CartItemDefaultArgs> = z
  .object({
    select: z.lazy(() => CartItemSelectSchema).optional(),
    include: z.lazy(() => CartItemIncludeSchema).optional(),
  })
  .strict();

export const CartItemSelectSchema: z.ZodType<Prisma.CartItemSelect> = z
  .object({
    id: z.boolean().optional(),
    cartID: z.boolean().optional(),
    productVariantID: z.boolean().optional(),
    quantity: z.boolean().optional(),
    createdAt: z.boolean().optional(),
    updatedAt: z.boolean().optional(),
    cart: z.union([z.boolean(), z.lazy(() => CartArgsSchema)]).optional(),
    productVariant: z
      .union([z.boolean(), z.lazy(() => ProductVariantArgsSchema)])
      .optional(),
  })
  .strict();

// NOTIFICATION
//------------------------------------------------------

export const NotificationIncludeSchema: z.ZodType<Prisma.NotificationInclude> =
  z
    .object({
      User: z.union([z.boolean(), z.lazy(() => UserArgsSchema)]).optional(),
    })
    .strict();

export const NotificationArgsSchema: z.ZodType<Prisma.NotificationDefaultArgs> =
  z
    .object({
      select: z.lazy(() => NotificationSelectSchema).optional(),
      include: z.lazy(() => NotificationIncludeSchema).optional(),
    })
    .strict();

export const NotificationSelectSchema: z.ZodType<Prisma.NotificationSelect> = z
  .object({
    id: z.boolean().optional(),
    userID: z.boolean().optional(),
    title: z.boolean().optional(),
    message: z.boolean().optional(),
    isRead: z.boolean().optional(),
    User: z.union([z.boolean(), z.lazy(() => UserArgsSchema)]).optional(),
  })
  .strict();

// PAYMENT
//------------------------------------------------------

export const PaymentIncludeSchema: z.ZodType<Prisma.PaymentInclude> = z
  .object({
    order: z.union([z.boolean(), z.lazy(() => OrderArgsSchema)]).optional(),
  })
  .strict();

export const PaymentArgsSchema: z.ZodType<Prisma.PaymentDefaultArgs> = z
  .object({
    select: z.lazy(() => PaymentSelectSchema).optional(),
    include: z.lazy(() => PaymentIncludeSchema).optional(),
  })
  .strict();

export const PaymentSelectSchema: z.ZodType<Prisma.PaymentSelect> = z
  .object({
    id: z.boolean().optional(),
    orderID: z.boolean().optional(),
    type: z.boolean().optional(),
    status: z.boolean().optional(),
    amount: z.boolean().optional(),
    transactionID: z.boolean().optional(),
    createdAt: z.boolean().optional(),
    createdBy: z.boolean().optional(),
    updatedAt: z.boolean().optional(),
    deletedAt: z.boolean().optional(),
    order: z.union([z.boolean(), z.lazy(() => OrderArgsSchema)]).optional(),
  })
  .strict();

/////////////////////////////////////////
// INPUT TYPES
/////////////////////////////////////////

export const UserWhereInputSchema: z.ZodType<Prisma.UserWhereInput> = z
  .object({
    AND: z
      .union([
        z.lazy(() => UserWhereInputSchema),
        z.lazy(() => UserWhereInputSchema).array(),
      ])
      .optional(),
    OR: z
      .lazy(() => UserWhereInputSchema)
      .array()
      .optional(),
    NOT: z
      .union([
        z.lazy(() => UserWhereInputSchema),
        z.lazy(() => UserWhereInputSchema).array(),
      ])
      .optional(),
    id: z.union([z.lazy(() => StringFilterSchema), z.string()]).optional(),
    email: z.union([z.lazy(() => StringFilterSchema), z.string()]).optional(),
    password: z
      .union([z.lazy(() => StringFilterSchema), z.string()])
      .optional(),
    firstName: z
      .union([z.lazy(() => StringFilterSchema), z.string()])
      .optional(),
    lastName: z
      .union([z.lazy(() => StringNullableFilterSchema), z.string()])
      .optional()
      .nullable(),
    fullAddress: z
      .union([z.lazy(() => StringFilterSchema), z.string()])
      .optional(),
    city: z
      .union([z.lazy(() => StringNullableFilterSchema), z.string()])
      .optional()
      .nullable(),
    province: z
      .union([z.lazy(() => StringNullableFilterSchema), z.string()])
      .optional()
      .nullable(),
    country: z
      .union([z.lazy(() => StringNullableFilterSchema), z.string()])
      .optional()
      .nullable(),
    phone: z
      .union([z.lazy(() => StringNullableFilterSchema), z.string()])
      .optional()
      .nullable(),
    status: z
      .union([
        z.lazy(() => EnumUserStatusFilterSchema),
        z.lazy(() => UserStatusSchema),
      ])
      .optional(),
    createdAt: z
      .union([z.lazy(() => DateTimeFilterSchema), z.coerce.date()])
      .optional(),
    createdBy: z
      .union([z.lazy(() => StringNullableFilterSchema), z.string()])
      .optional()
      .nullable(),
    updatedAt: z
      .union([z.lazy(() => DateTimeFilterSchema), z.coerce.date()])
      .optional(),
    deletedAt: z
      .union([z.lazy(() => DateTimeNullableFilterSchema), z.coerce.date()])
      .optional()
      .nullable(),
    vendors: z.lazy(() => VendorListRelationFilterSchema).optional(),
    userVendorRoles: z
      .lazy(() => UserVendorRoleListRelationFilterSchema)
      .optional(),
    orders: z.lazy(() => OrderListRelationFilterSchema).optional(),
    cart: z
      .union([
        z.lazy(() => CartNullableScalarRelationFilterSchema),
        z.lazy(() => CartWhereInputSchema),
      ])
      .optional()
      .nullable(),
    notifications: z
      .lazy(() => NotificationListRelationFilterSchema)
      .optional(),
  })
  .strict() as z.ZodType<Prisma.UserWhereInput>;

export const UserOrderByWithRelationInputSchema: z.ZodType<Prisma.UserOrderByWithRelationInput> =
  z
    .object({
      id: z.lazy(() => SortOrderSchema).optional(),
      email: z.lazy(() => SortOrderSchema).optional(),
      password: z.lazy(() => SortOrderSchema).optional(),
      firstName: z.lazy(() => SortOrderSchema).optional(),
      lastName: z
        .union([
          z.lazy(() => SortOrderSchema),
          z.lazy(() => SortOrderInputSchema),
        ])
        .optional(),
      fullAddress: z.lazy(() => SortOrderSchema).optional(),
      city: z
        .union([
          z.lazy(() => SortOrderSchema),
          z.lazy(() => SortOrderInputSchema),
        ])
        .optional(),
      province: z
        .union([
          z.lazy(() => SortOrderSchema),
          z.lazy(() => SortOrderInputSchema),
        ])
        .optional(),
      country: z
        .union([
          z.lazy(() => SortOrderSchema),
          z.lazy(() => SortOrderInputSchema),
        ])
        .optional(),
      phone: z
        .union([
          z.lazy(() => SortOrderSchema),
          z.lazy(() => SortOrderInputSchema),
        ])
        .optional(),
      status: z.lazy(() => SortOrderSchema).optional(),
      createdAt: z.lazy(() => SortOrderSchema).optional(),
      createdBy: z
        .union([
          z.lazy(() => SortOrderSchema),
          z.lazy(() => SortOrderInputSchema),
        ])
        .optional(),
      updatedAt: z.lazy(() => SortOrderSchema).optional(),
      deletedAt: z
        .union([
          z.lazy(() => SortOrderSchema),
          z.lazy(() => SortOrderInputSchema),
        ])
        .optional(),
      vendors: z
        .lazy(() => VendorOrderByRelationAggregateInputSchema)
        .optional(),
      userVendorRoles: z
        .lazy(() => UserVendorRoleOrderByRelationAggregateInputSchema)
        .optional(),
      orders: z.lazy(() => OrderOrderByRelationAggregateInputSchema).optional(),
      cart: z.lazy(() => CartOrderByWithRelationInputSchema).optional(),
      notifications: z
        .lazy(() => NotificationOrderByRelationAggregateInputSchema)
        .optional(),
    })
    .strict() as z.ZodType<Prisma.UserOrderByWithRelationInput>;

export const UserWhereUniqueInputSchema: z.ZodType<Prisma.UserWhereUniqueInput> =
  z
    .union([
      z.object({
        id: z.string().uuid(),
        email: z.string().email(),
      }),
      z.object({
        id: z.string().uuid(),
      }),
      z.object({
        email: z.string().email(),
      }),
    ])
    .and(
      z
        .object({
          id: z.string().uuid().optional(),
          email: z.string().email().optional(),
          AND: z
            .union([
              z.lazy(() => UserWhereInputSchema),
              z.lazy(() => UserWhereInputSchema).array(),
            ])
            .optional(),
          OR: z
            .lazy(() => UserWhereInputSchema)
            .array()
            .optional(),
          NOT: z
            .union([
              z.lazy(() => UserWhereInputSchema),
              z.lazy(() => UserWhereInputSchema).array(),
            ])
            .optional(),
          password: z
            .union([z.lazy(() => StringFilterSchema), z.string()])
            .optional(),
          firstName: z
            .union([z.lazy(() => StringFilterSchema), z.string()])
            .optional(),
          lastName: z
            .union([z.lazy(() => StringNullableFilterSchema), z.string()])
            .optional()
            .nullable(),
          fullAddress: z
            .union([z.lazy(() => StringFilterSchema), z.string()])
            .optional(),
          city: z
            .union([z.lazy(() => StringNullableFilterSchema), z.string()])
            .optional()
            .nullable(),
          province: z
            .union([z.lazy(() => StringNullableFilterSchema), z.string()])
            .optional()
            .nullable(),
          country: z
            .union([z.lazy(() => StringNullableFilterSchema), z.string()])
            .optional()
            .nullable(),
          phone: z
            .union([z.lazy(() => StringNullableFilterSchema), z.string()])
            .optional()
            .nullable(),
          status: z
            .union([
              z.lazy(() => EnumUserStatusFilterSchema),
              z.lazy(() => UserStatusSchema),
            ])
            .optional(),
          createdAt: z
            .union([z.lazy(() => DateTimeFilterSchema), z.coerce.date()])
            .optional(),
          createdBy: z
            .union([z.lazy(() => StringNullableFilterSchema), z.string()])
            .optional()
            .nullable(),
          updatedAt: z
            .union([z.lazy(() => DateTimeFilterSchema), z.coerce.date()])
            .optional(),
          deletedAt: z
            .union([
              z.lazy(() => DateTimeNullableFilterSchema),
              z.coerce.date(),
            ])
            .optional()
            .nullable(),
          vendors: z.lazy(() => VendorListRelationFilterSchema).optional(),
          userVendorRoles: z
            .lazy(() => UserVendorRoleListRelationFilterSchema)
            .optional(),
          orders: z.lazy(() => OrderListRelationFilterSchema).optional(),
          cart: z
            .union([
              z.lazy(() => CartNullableScalarRelationFilterSchema),
              z.lazy(() => CartWhereInputSchema),
            ])
            .optional()
            .nullable(),
          notifications: z
            .lazy(() => NotificationListRelationFilterSchema)
            .optional(),
        })
        .strict(),
    ) as z.ZodType<Prisma.UserWhereUniqueInput>;

export const UserOrderByWithAggregationInputSchema: z.ZodType<Prisma.UserOrderByWithAggregationInput> =
  z
    .object({
      id: z.lazy(() => SortOrderSchema).optional(),
      email: z.lazy(() => SortOrderSchema).optional(),
      password: z.lazy(() => SortOrderSchema).optional(),
      firstName: z.lazy(() => SortOrderSchema).optional(),
      lastName: z
        .union([
          z.lazy(() => SortOrderSchema),
          z.lazy(() => SortOrderInputSchema),
        ])
        .optional(),
      fullAddress: z.lazy(() => SortOrderSchema).optional(),
      city: z
        .union([
          z.lazy(() => SortOrderSchema),
          z.lazy(() => SortOrderInputSchema),
        ])
        .optional(),
      province: z
        .union([
          z.lazy(() => SortOrderSchema),
          z.lazy(() => SortOrderInputSchema),
        ])
        .optional(),
      country: z
        .union([
          z.lazy(() => SortOrderSchema),
          z.lazy(() => SortOrderInputSchema),
        ])
        .optional(),
      phone: z
        .union([
          z.lazy(() => SortOrderSchema),
          z.lazy(() => SortOrderInputSchema),
        ])
        .optional(),
      status: z.lazy(() => SortOrderSchema).optional(),
      createdAt: z.lazy(() => SortOrderSchema).optional(),
      createdBy: z
        .union([
          z.lazy(() => SortOrderSchema),
          z.lazy(() => SortOrderInputSchema),
        ])
        .optional(),
      updatedAt: z.lazy(() => SortOrderSchema).optional(),
      deletedAt: z
        .union([
          z.lazy(() => SortOrderSchema),
          z.lazy(() => SortOrderInputSchema),
        ])
        .optional(),
      _count: z.lazy(() => UserCountOrderByAggregateInputSchema).optional(),
      _max: z.lazy(() => UserMaxOrderByAggregateInputSchema).optional(),
      _min: z.lazy(() => UserMinOrderByAggregateInputSchema).optional(),
    })
    .strict() as z.ZodType<Prisma.UserOrderByWithAggregationInput>;

export const UserScalarWhereWithAggregatesInputSchema: z.ZodType<Prisma.UserScalarWhereWithAggregatesInput> =
  z
    .object({
      AND: z
        .union([
          z.lazy(() => UserScalarWhereWithAggregatesInputSchema),
          z.lazy(() => UserScalarWhereWithAggregatesInputSchema).array(),
        ])
        .optional(),
      OR: z
        .lazy(() => UserScalarWhereWithAggregatesInputSchema)
        .array()
        .optional(),
      NOT: z
        .union([
          z.lazy(() => UserScalarWhereWithAggregatesInputSchema),
          z.lazy(() => UserScalarWhereWithAggregatesInputSchema).array(),
        ])
        .optional(),
      id: z
        .union([z.lazy(() => StringWithAggregatesFilterSchema), z.string()])
        .optional(),
      email: z
        .union([z.lazy(() => StringWithAggregatesFilterSchema), z.string()])
        .optional(),
      password: z
        .union([z.lazy(() => StringWithAggregatesFilterSchema), z.string()])
        .optional(),
      firstName: z
        .union([z.lazy(() => StringWithAggregatesFilterSchema), z.string()])
        .optional(),
      lastName: z
        .union([
          z.lazy(() => StringNullableWithAggregatesFilterSchema),
          z.string(),
        ])
        .optional()
        .nullable(),
      fullAddress: z
        .union([z.lazy(() => StringWithAggregatesFilterSchema), z.string()])
        .optional(),
      city: z
        .union([
          z.lazy(() => StringNullableWithAggregatesFilterSchema),
          z.string(),
        ])
        .optional()
        .nullable(),
      province: z
        .union([
          z.lazy(() => StringNullableWithAggregatesFilterSchema),
          z.string(),
        ])
        .optional()
        .nullable(),
      country: z
        .union([
          z.lazy(() => StringNullableWithAggregatesFilterSchema),
          z.string(),
        ])
        .optional()
        .nullable(),
      phone: z
        .union([
          z.lazy(() => StringNullableWithAggregatesFilterSchema),
          z.string(),
        ])
        .optional()
        .nullable(),
      status: z
        .union([
          z.lazy(() => EnumUserStatusWithAggregatesFilterSchema),
          z.lazy(() => UserStatusSchema),
        ])
        .optional(),
      createdAt: z
        .union([
          z.lazy(() => DateTimeWithAggregatesFilterSchema),
          z.coerce.date(),
        ])
        .optional(),
      createdBy: z
        .union([
          z.lazy(() => StringNullableWithAggregatesFilterSchema),
          z.string(),
        ])
        .optional()
        .nullable(),
      updatedAt: z
        .union([
          z.lazy(() => DateTimeWithAggregatesFilterSchema),
          z.coerce.date(),
        ])
        .optional(),
      deletedAt: z
        .union([
          z.lazy(() => DateTimeNullableWithAggregatesFilterSchema),
          z.coerce.date(),
        ])
        .optional()
        .nullable(),
    })
    .strict() as z.ZodType<Prisma.UserScalarWhereWithAggregatesInput>;

export const VendorWhereInputSchema: z.ZodType<Prisma.VendorWhereInput> = z
  .object({
    AND: z
      .union([
        z.lazy(() => VendorWhereInputSchema),
        z.lazy(() => VendorWhereInputSchema).array(),
      ])
      .optional(),
    OR: z
      .lazy(() => VendorWhereInputSchema)
      .array()
      .optional(),
    NOT: z
      .union([
        z.lazy(() => VendorWhereInputSchema),
        z.lazy(() => VendorWhereInputSchema).array(),
      ])
      .optional(),
    id: z.union([z.lazy(() => StringFilterSchema), z.string()]).optional(),
    userID: z.union([z.lazy(() => StringFilterSchema), z.string()]).optional(),
    name: z.union([z.lazy(() => StringFilterSchema), z.string()]).optional(),
    slug: z.union([z.lazy(() => StringFilterSchema), z.string()]).optional(),
    description: z
      .union([z.lazy(() => StringNullableFilterSchema), z.string()])
      .optional()
      .nullable(),
    logoUrl: z
      .union([z.lazy(() => StringNullableFilterSchema), z.string()])
      .optional()
      .nullable(),
    taxCode: z
      .union([z.lazy(() => StringNullableFilterSchema), z.string()])
      .optional()
      .nullable(),
    totalProducts: z
      .union([z.lazy(() => IntFilterSchema), z.number()])
      .optional(),
    totalOrders: z
      .union([z.lazy(() => IntFilterSchema), z.number()])
      .optional(),
    status: z
      .union([
        z.lazy(() => EnumVendorStatusFilterSchema),
        z.lazy(() => VendorStatusSchema),
      ])
      .optional(),
    createdAt: z
      .union([z.lazy(() => DateTimeFilterSchema), z.coerce.date()])
      .optional(),
    createdBy: z
      .union([z.lazy(() => StringNullableFilterSchema), z.string()])
      .optional()
      .nullable(),
    updatedAt: z
      .union([z.lazy(() => DateTimeFilterSchema), z.coerce.date()])
      .optional(),
    deletedAt: z
      .union([z.lazy(() => DateTimeNullableFilterSchema), z.coerce.date()])
      .optional()
      .nullable(),
    user: z
      .union([
        z.lazy(() => UserScalarRelationFilterSchema),
        z.lazy(() => UserWhereInputSchema),
      ])
      .optional(),
    products: z.lazy(() => ProductListRelationFilterSchema).optional(),
    userVendorRoles: z
      .lazy(() => UserVendorRoleListRelationFilterSchema)
      .optional(),
  })
  .strict() as z.ZodType<Prisma.VendorWhereInput>;

export const VendorOrderByWithRelationInputSchema: z.ZodType<Prisma.VendorOrderByWithRelationInput> =
  z
    .object({
      id: z.lazy(() => SortOrderSchema).optional(),
      userID: z.lazy(() => SortOrderSchema).optional(),
      name: z.lazy(() => SortOrderSchema).optional(),
      slug: z.lazy(() => SortOrderSchema).optional(),
      description: z
        .union([
          z.lazy(() => SortOrderSchema),
          z.lazy(() => SortOrderInputSchema),
        ])
        .optional(),
      logoUrl: z
        .union([
          z.lazy(() => SortOrderSchema),
          z.lazy(() => SortOrderInputSchema),
        ])
        .optional(),
      taxCode: z
        .union([
          z.lazy(() => SortOrderSchema),
          z.lazy(() => SortOrderInputSchema),
        ])
        .optional(),
      totalProducts: z.lazy(() => SortOrderSchema).optional(),
      totalOrders: z.lazy(() => SortOrderSchema).optional(),
      status: z.lazy(() => SortOrderSchema).optional(),
      createdAt: z.lazy(() => SortOrderSchema).optional(),
      createdBy: z
        .union([
          z.lazy(() => SortOrderSchema),
          z.lazy(() => SortOrderInputSchema),
        ])
        .optional(),
      updatedAt: z.lazy(() => SortOrderSchema).optional(),
      deletedAt: z
        .union([
          z.lazy(() => SortOrderSchema),
          z.lazy(() => SortOrderInputSchema),
        ])
        .optional(),
      user: z.lazy(() => UserOrderByWithRelationInputSchema).optional(),
      products: z
        .lazy(() => ProductOrderByRelationAggregateInputSchema)
        .optional(),
      userVendorRoles: z
        .lazy(() => UserVendorRoleOrderByRelationAggregateInputSchema)
        .optional(),
    })
    .strict() as z.ZodType<Prisma.VendorOrderByWithRelationInput>;

export const VendorWhereUniqueInputSchema: z.ZodType<Prisma.VendorWhereUniqueInput> =
  z
    .union([
      z.object({
        id: z.string().uuid(),
        slug: z.string(),
      }),
      z.object({
        id: z.string().uuid(),
      }),
      z.object({
        slug: z.string(),
      }),
    ])
    .and(
      z
        .object({
          id: z.string().uuid().optional(),
          slug: z.string().optional(),
          AND: z
            .union([
              z.lazy(() => VendorWhereInputSchema),
              z.lazy(() => VendorWhereInputSchema).array(),
            ])
            .optional(),
          OR: z
            .lazy(() => VendorWhereInputSchema)
            .array()
            .optional(),
          NOT: z
            .union([
              z.lazy(() => VendorWhereInputSchema),
              z.lazy(() => VendorWhereInputSchema).array(),
            ])
            .optional(),
          userID: z
            .union([z.lazy(() => StringFilterSchema), z.string()])
            .optional(),
          name: z
            .union([z.lazy(() => StringFilterSchema), z.string()])
            .optional(),
          description: z
            .union([z.lazy(() => StringNullableFilterSchema), z.string()])
            .optional()
            .nullable(),
          logoUrl: z
            .union([z.lazy(() => StringNullableFilterSchema), z.string()])
            .optional()
            .nullable(),
          taxCode: z
            .union([z.lazy(() => StringNullableFilterSchema), z.string()])
            .optional()
            .nullable(),
          totalProducts: z
            .union([z.lazy(() => IntFilterSchema), z.number().int()])
            .optional(),
          totalOrders: z
            .union([z.lazy(() => IntFilterSchema), z.number().int()])
            .optional(),
          status: z
            .union([
              z.lazy(() => EnumVendorStatusFilterSchema),
              z.lazy(() => VendorStatusSchema),
            ])
            .optional(),
          createdAt: z
            .union([z.lazy(() => DateTimeFilterSchema), z.coerce.date()])
            .optional(),
          createdBy: z
            .union([z.lazy(() => StringNullableFilterSchema), z.string()])
            .optional()
            .nullable(),
          updatedAt: z
            .union([z.lazy(() => DateTimeFilterSchema), z.coerce.date()])
            .optional(),
          deletedAt: z
            .union([
              z.lazy(() => DateTimeNullableFilterSchema),
              z.coerce.date(),
            ])
            .optional()
            .nullable(),
          user: z
            .union([
              z.lazy(() => UserScalarRelationFilterSchema),
              z.lazy(() => UserWhereInputSchema),
            ])
            .optional(),
          products: z.lazy(() => ProductListRelationFilterSchema).optional(),
          userVendorRoles: z
            .lazy(() => UserVendorRoleListRelationFilterSchema)
            .optional(),
        })
        .strict(),
    ) as z.ZodType<Prisma.VendorWhereUniqueInput>;

export const VendorOrderByWithAggregationInputSchema: z.ZodType<Prisma.VendorOrderByWithAggregationInput> =
  z
    .object({
      id: z.lazy(() => SortOrderSchema).optional(),
      userID: z.lazy(() => SortOrderSchema).optional(),
      name: z.lazy(() => SortOrderSchema).optional(),
      slug: z.lazy(() => SortOrderSchema).optional(),
      description: z
        .union([
          z.lazy(() => SortOrderSchema),
          z.lazy(() => SortOrderInputSchema),
        ])
        .optional(),
      logoUrl: z
        .union([
          z.lazy(() => SortOrderSchema),
          z.lazy(() => SortOrderInputSchema),
        ])
        .optional(),
      taxCode: z
        .union([
          z.lazy(() => SortOrderSchema),
          z.lazy(() => SortOrderInputSchema),
        ])
        .optional(),
      totalProducts: z.lazy(() => SortOrderSchema).optional(),
      totalOrders: z.lazy(() => SortOrderSchema).optional(),
      status: z.lazy(() => SortOrderSchema).optional(),
      createdAt: z.lazy(() => SortOrderSchema).optional(),
      createdBy: z
        .union([
          z.lazy(() => SortOrderSchema),
          z.lazy(() => SortOrderInputSchema),
        ])
        .optional(),
      updatedAt: z.lazy(() => SortOrderSchema).optional(),
      deletedAt: z
        .union([
          z.lazy(() => SortOrderSchema),
          z.lazy(() => SortOrderInputSchema),
        ])
        .optional(),
      _count: z.lazy(() => VendorCountOrderByAggregateInputSchema).optional(),
      _avg: z.lazy(() => VendorAvgOrderByAggregateInputSchema).optional(),
      _max: z.lazy(() => VendorMaxOrderByAggregateInputSchema).optional(),
      _min: z.lazy(() => VendorMinOrderByAggregateInputSchema).optional(),
      _sum: z.lazy(() => VendorSumOrderByAggregateInputSchema).optional(),
    })
    .strict() as z.ZodType<Prisma.VendorOrderByWithAggregationInput>;

export const VendorScalarWhereWithAggregatesInputSchema: z.ZodType<Prisma.VendorScalarWhereWithAggregatesInput> =
  z
    .object({
      AND: z
        .union([
          z.lazy(() => VendorScalarWhereWithAggregatesInputSchema),
          z.lazy(() => VendorScalarWhereWithAggregatesInputSchema).array(),
        ])
        .optional(),
      OR: z
        .lazy(() => VendorScalarWhereWithAggregatesInputSchema)
        .array()
        .optional(),
      NOT: z
        .union([
          z.lazy(() => VendorScalarWhereWithAggregatesInputSchema),
          z.lazy(() => VendorScalarWhereWithAggregatesInputSchema).array(),
        ])
        .optional(),
      id: z
        .union([z.lazy(() => StringWithAggregatesFilterSchema), z.string()])
        .optional(),
      userID: z
        .union([z.lazy(() => StringWithAggregatesFilterSchema), z.string()])
        .optional(),
      name: z
        .union([z.lazy(() => StringWithAggregatesFilterSchema), z.string()])
        .optional(),
      slug: z
        .union([z.lazy(() => StringWithAggregatesFilterSchema), z.string()])
        .optional(),
      description: z
        .union([
          z.lazy(() => StringNullableWithAggregatesFilterSchema),
          z.string(),
        ])
        .optional()
        .nullable(),
      logoUrl: z
        .union([
          z.lazy(() => StringNullableWithAggregatesFilterSchema),
          z.string(),
        ])
        .optional()
        .nullable(),
      taxCode: z
        .union([
          z.lazy(() => StringNullableWithAggregatesFilterSchema),
          z.string(),
        ])
        .optional()
        .nullable(),
      totalProducts: z
        .union([z.lazy(() => IntWithAggregatesFilterSchema), z.number()])
        .optional(),
      totalOrders: z
        .union([z.lazy(() => IntWithAggregatesFilterSchema), z.number()])
        .optional(),
      status: z
        .union([
          z.lazy(() => EnumVendorStatusWithAggregatesFilterSchema),
          z.lazy(() => VendorStatusSchema),
        ])
        .optional(),
      createdAt: z
        .union([
          z.lazy(() => DateTimeWithAggregatesFilterSchema),
          z.coerce.date(),
        ])
        .optional(),
      createdBy: z
        .union([
          z.lazy(() => StringNullableWithAggregatesFilterSchema),
          z.string(),
        ])
        .optional()
        .nullable(),
      updatedAt: z
        .union([
          z.lazy(() => DateTimeWithAggregatesFilterSchema),
          z.coerce.date(),
        ])
        .optional(),
      deletedAt: z
        .union([
          z.lazy(() => DateTimeNullableWithAggregatesFilterSchema),
          z.coerce.date(),
        ])
        .optional()
        .nullable(),
    })
    .strict() as z.ZodType<Prisma.VendorScalarWhereWithAggregatesInput>;

export const RoleWhereInputSchema: z.ZodType<Prisma.RoleWhereInput> = z
  .object({
    AND: z
      .union([
        z.lazy(() => RoleWhereInputSchema),
        z.lazy(() => RoleWhereInputSchema).array(),
      ])
      .optional(),
    OR: z
      .lazy(() => RoleWhereInputSchema)
      .array()
      .optional(),
    NOT: z
      .union([
        z.lazy(() => RoleWhereInputSchema),
        z.lazy(() => RoleWhereInputSchema).array(),
      ])
      .optional(),
    id: z.union([z.lazy(() => StringFilterSchema), z.string()]).optional(),
    name: z.union([z.lazy(() => StringFilterSchema), z.string()]).optional(),
    description: z
      .union([z.lazy(() => StringNullableFilterSchema), z.string()])
      .optional()
      .nullable(),
    isSystemRole: z
      .union([z.lazy(() => BoolFilterSchema), z.boolean()])
      .optional(),
    createdAt: z
      .union([z.lazy(() => DateTimeFilterSchema), z.coerce.date()])
      .optional(),
    createdBy: z
      .union([z.lazy(() => StringNullableFilterSchema), z.string()])
      .optional()
      .nullable(),
    updatedAt: z
      .union([z.lazy(() => DateTimeFilterSchema), z.coerce.date()])
      .optional(),
    deletedAt: z
      .union([z.lazy(() => DateTimeNullableFilterSchema), z.coerce.date()])
      .optional()
      .nullable(),
    userVendorRoles: z
      .lazy(() => UserVendorRoleListRelationFilterSchema)
      .optional(),
    rolePermissions: z
      .lazy(() => RolePermissionListRelationFilterSchema)
      .optional(),
  })
  .strict() as z.ZodType<Prisma.RoleWhereInput>;

export const RoleOrderByWithRelationInputSchema: z.ZodType<Prisma.RoleOrderByWithRelationInput> =
  z
    .object({
      id: z.lazy(() => SortOrderSchema).optional(),
      name: z.lazy(() => SortOrderSchema).optional(),
      description: z
        .union([
          z.lazy(() => SortOrderSchema),
          z.lazy(() => SortOrderInputSchema),
        ])
        .optional(),
      isSystemRole: z.lazy(() => SortOrderSchema).optional(),
      createdAt: z.lazy(() => SortOrderSchema).optional(),
      createdBy: z
        .union([
          z.lazy(() => SortOrderSchema),
          z.lazy(() => SortOrderInputSchema),
        ])
        .optional(),
      updatedAt: z.lazy(() => SortOrderSchema).optional(),
      deletedAt: z
        .union([
          z.lazy(() => SortOrderSchema),
          z.lazy(() => SortOrderInputSchema),
        ])
        .optional(),
      userVendorRoles: z
        .lazy(() => UserVendorRoleOrderByRelationAggregateInputSchema)
        .optional(),
      rolePermissions: z
        .lazy(() => RolePermissionOrderByRelationAggregateInputSchema)
        .optional(),
    })
    .strict() as z.ZodType<Prisma.RoleOrderByWithRelationInput>;

export const RoleWhereUniqueInputSchema: z.ZodType<Prisma.RoleWhereUniqueInput> =
  z
    .union([
      z.object({
        id: z.string().uuid(),
        name: z.string(),
      }),
      z.object({
        id: z.string().uuid(),
      }),
      z.object({
        name: z.string(),
      }),
    ])
    .and(
      z
        .object({
          id: z.string().uuid().optional(),
          name: z.string().optional(),
          AND: z
            .union([
              z.lazy(() => RoleWhereInputSchema),
              z.lazy(() => RoleWhereInputSchema).array(),
            ])
            .optional(),
          OR: z
            .lazy(() => RoleWhereInputSchema)
            .array()
            .optional(),
          NOT: z
            .union([
              z.lazy(() => RoleWhereInputSchema),
              z.lazy(() => RoleWhereInputSchema).array(),
            ])
            .optional(),
          description: z
            .union([z.lazy(() => StringNullableFilterSchema), z.string()])
            .optional()
            .nullable(),
          isSystemRole: z
            .union([z.lazy(() => BoolFilterSchema), z.boolean()])
            .optional(),
          createdAt: z
            .union([z.lazy(() => DateTimeFilterSchema), z.coerce.date()])
            .optional(),
          createdBy: z
            .union([z.lazy(() => StringNullableFilterSchema), z.string()])
            .optional()
            .nullable(),
          updatedAt: z
            .union([z.lazy(() => DateTimeFilterSchema), z.coerce.date()])
            .optional(),
          deletedAt: z
            .union([
              z.lazy(() => DateTimeNullableFilterSchema),
              z.coerce.date(),
            ])
            .optional()
            .nullable(),
          userVendorRoles: z
            .lazy(() => UserVendorRoleListRelationFilterSchema)
            .optional(),
          rolePermissions: z
            .lazy(() => RolePermissionListRelationFilterSchema)
            .optional(),
        })
        .strict(),
    ) as z.ZodType<Prisma.RoleWhereUniqueInput>;

export const RoleOrderByWithAggregationInputSchema: z.ZodType<Prisma.RoleOrderByWithAggregationInput> =
  z
    .object({
      id: z.lazy(() => SortOrderSchema).optional(),
      name: z.lazy(() => SortOrderSchema).optional(),
      description: z
        .union([
          z.lazy(() => SortOrderSchema),
          z.lazy(() => SortOrderInputSchema),
        ])
        .optional(),
      isSystemRole: z.lazy(() => SortOrderSchema).optional(),
      createdAt: z.lazy(() => SortOrderSchema).optional(),
      createdBy: z
        .union([
          z.lazy(() => SortOrderSchema),
          z.lazy(() => SortOrderInputSchema),
        ])
        .optional(),
      updatedAt: z.lazy(() => SortOrderSchema).optional(),
      deletedAt: z
        .union([
          z.lazy(() => SortOrderSchema),
          z.lazy(() => SortOrderInputSchema),
        ])
        .optional(),
      _count: z.lazy(() => RoleCountOrderByAggregateInputSchema).optional(),
      _max: z.lazy(() => RoleMaxOrderByAggregateInputSchema).optional(),
      _min: z.lazy(() => RoleMinOrderByAggregateInputSchema).optional(),
    })
    .strict() as z.ZodType<Prisma.RoleOrderByWithAggregationInput>;

export const RoleScalarWhereWithAggregatesInputSchema: z.ZodType<Prisma.RoleScalarWhereWithAggregatesInput> =
  z
    .object({
      AND: z
        .union([
          z.lazy(() => RoleScalarWhereWithAggregatesInputSchema),
          z.lazy(() => RoleScalarWhereWithAggregatesInputSchema).array(),
        ])
        .optional(),
      OR: z
        .lazy(() => RoleScalarWhereWithAggregatesInputSchema)
        .array()
        .optional(),
      NOT: z
        .union([
          z.lazy(() => RoleScalarWhereWithAggregatesInputSchema),
          z.lazy(() => RoleScalarWhereWithAggregatesInputSchema).array(),
        ])
        .optional(),
      id: z
        .union([z.lazy(() => StringWithAggregatesFilterSchema), z.string()])
        .optional(),
      name: z
        .union([z.lazy(() => StringWithAggregatesFilterSchema), z.string()])
        .optional(),
      description: z
        .union([
          z.lazy(() => StringNullableWithAggregatesFilterSchema),
          z.string(),
        ])
        .optional()
        .nullable(),
      isSystemRole: z
        .union([z.lazy(() => BoolWithAggregatesFilterSchema), z.boolean()])
        .optional(),
      createdAt: z
        .union([
          z.lazy(() => DateTimeWithAggregatesFilterSchema),
          z.coerce.date(),
        ])
        .optional(),
      createdBy: z
        .union([
          z.lazy(() => StringNullableWithAggregatesFilterSchema),
          z.string(),
        ])
        .optional()
        .nullable(),
      updatedAt: z
        .union([
          z.lazy(() => DateTimeWithAggregatesFilterSchema),
          z.coerce.date(),
        ])
        .optional(),
      deletedAt: z
        .union([
          z.lazy(() => DateTimeNullableWithAggregatesFilterSchema),
          z.coerce.date(),
        ])
        .optional()
        .nullable(),
    })
    .strict() as z.ZodType<Prisma.RoleScalarWhereWithAggregatesInput>;

export const PermissionWhereInputSchema: z.ZodType<Prisma.PermissionWhereInput> =
  z
    .object({
      AND: z
        .union([
          z.lazy(() => PermissionWhereInputSchema),
          z.lazy(() => PermissionWhereInputSchema).array(),
        ])
        .optional(),
      OR: z
        .lazy(() => PermissionWhereInputSchema)
        .array()
        .optional(),
      NOT: z
        .union([
          z.lazy(() => PermissionWhereInputSchema),
          z.lazy(() => PermissionWhereInputSchema).array(),
        ])
        .optional(),
      id: z.union([z.lazy(() => StringFilterSchema), z.string()]).optional(),
      name: z.union([z.lazy(() => StringFilterSchema), z.string()]).optional(),
      description: z
        .union([z.lazy(() => StringNullableFilterSchema), z.string()])
        .optional()
        .nullable(),
      key: z.union([z.lazy(() => StringFilterSchema), z.string()]).optional(),
      isSystemPermission: z
        .union([z.lazy(() => BoolFilterSchema), z.boolean()])
        .optional(),
      createdAt: z
        .union([z.lazy(() => DateTimeFilterSchema), z.coerce.date()])
        .optional(),
      createdBy: z
        .union([z.lazy(() => StringNullableFilterSchema), z.string()])
        .optional()
        .nullable(),
      updatedAt: z
        .union([z.lazy(() => DateTimeFilterSchema), z.coerce.date()])
        .optional(),
      deletedAt: z
        .union([z.lazy(() => DateTimeNullableFilterSchema), z.coerce.date()])
        .optional()
        .nullable(),
      rolePermissions: z
        .lazy(() => RolePermissionListRelationFilterSchema)
        .optional(),
    })
    .strict() as z.ZodType<Prisma.PermissionWhereInput>;

export const PermissionOrderByWithRelationInputSchema: z.ZodType<Prisma.PermissionOrderByWithRelationInput> =
  z
    .object({
      id: z.lazy(() => SortOrderSchema).optional(),
      name: z.lazy(() => SortOrderSchema).optional(),
      description: z
        .union([
          z.lazy(() => SortOrderSchema),
          z.lazy(() => SortOrderInputSchema),
        ])
        .optional(),
      key: z.lazy(() => SortOrderSchema).optional(),
      isSystemPermission: z.lazy(() => SortOrderSchema).optional(),
      createdAt: z.lazy(() => SortOrderSchema).optional(),
      createdBy: z
        .union([
          z.lazy(() => SortOrderSchema),
          z.lazy(() => SortOrderInputSchema),
        ])
        .optional(),
      updatedAt: z.lazy(() => SortOrderSchema).optional(),
      deletedAt: z
        .union([
          z.lazy(() => SortOrderSchema),
          z.lazy(() => SortOrderInputSchema),
        ])
        .optional(),
      rolePermissions: z
        .lazy(() => RolePermissionOrderByRelationAggregateInputSchema)
        .optional(),
    })
    .strict() as z.ZodType<Prisma.PermissionOrderByWithRelationInput>;

export const PermissionWhereUniqueInputSchema: z.ZodType<Prisma.PermissionWhereUniqueInput> =
  z
    .union([
      z.object({
        id: z.string().uuid(),
        name_key: z.lazy(() => PermissionNameKeyCompoundUniqueInputSchema),
      }),
      z.object({
        id: z.string().uuid(),
      }),
      z.object({
        name_key: z.lazy(() => PermissionNameKeyCompoundUniqueInputSchema),
      }),
    ])
    .and(
      z
        .object({
          id: z.string().uuid().optional(),
          name_key: z
            .lazy(() => PermissionNameKeyCompoundUniqueInputSchema)
            .optional(),
          AND: z
            .union([
              z.lazy(() => PermissionWhereInputSchema),
              z.lazy(() => PermissionWhereInputSchema).array(),
            ])
            .optional(),
          OR: z
            .lazy(() => PermissionWhereInputSchema)
            .array()
            .optional(),
          NOT: z
            .union([
              z.lazy(() => PermissionWhereInputSchema),
              z.lazy(() => PermissionWhereInputSchema).array(),
            ])
            .optional(),
          name: z
            .union([z.lazy(() => StringFilterSchema), z.string()])
            .optional(),
          description: z
            .union([z.lazy(() => StringNullableFilterSchema), z.string()])
            .optional()
            .nullable(),
          key: z
            .union([
              z.lazy(() => StringFilterSchema),
              z
                .string()
                .describe(
                  'Pattern: [/resource]_[action], e.g: [/product]_[read], [/product]_[create], [/product]_[manage]',
                ),
            ])
            .optional(),
          isSystemPermission: z
            .union([z.lazy(() => BoolFilterSchema), z.boolean()])
            .optional(),
          createdAt: z
            .union([z.lazy(() => DateTimeFilterSchema), z.coerce.date()])
            .optional(),
          createdBy: z
            .union([z.lazy(() => StringNullableFilterSchema), z.string()])
            .optional()
            .nullable(),
          updatedAt: z
            .union([z.lazy(() => DateTimeFilterSchema), z.coerce.date()])
            .optional(),
          deletedAt: z
            .union([
              z.lazy(() => DateTimeNullableFilterSchema),
              z.coerce.date(),
            ])
            .optional()
            .nullable(),
          rolePermissions: z
            .lazy(() => RolePermissionListRelationFilterSchema)
            .optional(),
        })
        .strict(),
    ) as z.ZodType<Prisma.PermissionWhereUniqueInput>;

export const PermissionOrderByWithAggregationInputSchema: z.ZodType<Prisma.PermissionOrderByWithAggregationInput> =
  z
    .object({
      id: z.lazy(() => SortOrderSchema).optional(),
      name: z.lazy(() => SortOrderSchema).optional(),
      description: z
        .union([
          z.lazy(() => SortOrderSchema),
          z.lazy(() => SortOrderInputSchema),
        ])
        .optional(),
      key: z.lazy(() => SortOrderSchema).optional(),
      isSystemPermission: z.lazy(() => SortOrderSchema).optional(),
      createdAt: z.lazy(() => SortOrderSchema).optional(),
      createdBy: z
        .union([
          z.lazy(() => SortOrderSchema),
          z.lazy(() => SortOrderInputSchema),
        ])
        .optional(),
      updatedAt: z.lazy(() => SortOrderSchema).optional(),
      deletedAt: z
        .union([
          z.lazy(() => SortOrderSchema),
          z.lazy(() => SortOrderInputSchema),
        ])
        .optional(),
      _count: z
        .lazy(() => PermissionCountOrderByAggregateInputSchema)
        .optional(),
      _max: z.lazy(() => PermissionMaxOrderByAggregateInputSchema).optional(),
      _min: z.lazy(() => PermissionMinOrderByAggregateInputSchema).optional(),
    })
    .strict() as z.ZodType<Prisma.PermissionOrderByWithAggregationInput>;

export const PermissionScalarWhereWithAggregatesInputSchema: z.ZodType<Prisma.PermissionScalarWhereWithAggregatesInput> =
  z
    .object({
      AND: z
        .union([
          z.lazy(() => PermissionScalarWhereWithAggregatesInputSchema),
          z.lazy(() => PermissionScalarWhereWithAggregatesInputSchema).array(),
        ])
        .optional(),
      OR: z
        .lazy(() => PermissionScalarWhereWithAggregatesInputSchema)
        .array()
        .optional(),
      NOT: z
        .union([
          z.lazy(() => PermissionScalarWhereWithAggregatesInputSchema),
          z.lazy(() => PermissionScalarWhereWithAggregatesInputSchema).array(),
        ])
        .optional(),
      id: z
        .union([z.lazy(() => StringWithAggregatesFilterSchema), z.string()])
        .optional(),
      name: z
        .union([z.lazy(() => StringWithAggregatesFilterSchema), z.string()])
        .optional(),
      description: z
        .union([
          z.lazy(() => StringNullableWithAggregatesFilterSchema),
          z.string(),
        ])
        .optional()
        .nullable(),
      key: z
        .union([z.lazy(() => StringWithAggregatesFilterSchema), z.string()])
        .optional(),
      isSystemPermission: z
        .union([z.lazy(() => BoolWithAggregatesFilterSchema), z.boolean()])
        .optional(),
      createdAt: z
        .union([
          z.lazy(() => DateTimeWithAggregatesFilterSchema),
          z.coerce.date(),
        ])
        .optional(),
      createdBy: z
        .union([
          z.lazy(() => StringNullableWithAggregatesFilterSchema),
          z.string(),
        ])
        .optional()
        .nullable(),
      updatedAt: z
        .union([
          z.lazy(() => DateTimeWithAggregatesFilterSchema),
          z.coerce.date(),
        ])
        .optional(),
      deletedAt: z
        .union([
          z.lazy(() => DateTimeNullableWithAggregatesFilterSchema),
          z.coerce.date(),
        ])
        .optional()
        .nullable(),
    })
    .strict() as z.ZodType<Prisma.PermissionScalarWhereWithAggregatesInput>;

export const RolePermissionWhereInputSchema: z.ZodType<Prisma.RolePermissionWhereInput> =
  z
    .object({
      AND: z
        .union([
          z.lazy(() => RolePermissionWhereInputSchema),
          z.lazy(() => RolePermissionWhereInputSchema).array(),
        ])
        .optional(),
      OR: z
        .lazy(() => RolePermissionWhereInputSchema)
        .array()
        .optional(),
      NOT: z
        .union([
          z.lazy(() => RolePermissionWhereInputSchema),
          z.lazy(() => RolePermissionWhereInputSchema).array(),
        ])
        .optional(),
      roleID: z
        .union([z.lazy(() => StringFilterSchema), z.string()])
        .optional(),
      permissionID: z
        .union([z.lazy(() => StringFilterSchema), z.string()])
        .optional(),
      createdAt: z
        .union([z.lazy(() => DateTimeFilterSchema), z.coerce.date()])
        .optional(),
      createdBy: z
        .union([z.lazy(() => StringNullableFilterSchema), z.string()])
        .optional()
        .nullable(),
      role: z
        .union([
          z.lazy(() => RoleScalarRelationFilterSchema),
          z.lazy(() => RoleWhereInputSchema),
        ])
        .optional(),
      permission: z
        .union([
          z.lazy(() => PermissionScalarRelationFilterSchema),
          z.lazy(() => PermissionWhereInputSchema),
        ])
        .optional(),
    })
    .strict() as z.ZodType<Prisma.RolePermissionWhereInput>;

export const RolePermissionOrderByWithRelationInputSchema: z.ZodType<Prisma.RolePermissionOrderByWithRelationInput> =
  z
    .object({
      roleID: z.lazy(() => SortOrderSchema).optional(),
      permissionID: z.lazy(() => SortOrderSchema).optional(),
      createdAt: z.lazy(() => SortOrderSchema).optional(),
      createdBy: z
        .union([
          z.lazy(() => SortOrderSchema),
          z.lazy(() => SortOrderInputSchema),
        ])
        .optional(),
      role: z.lazy(() => RoleOrderByWithRelationInputSchema).optional(),
      permission: z
        .lazy(() => PermissionOrderByWithRelationInputSchema)
        .optional(),
    })
    .strict() as z.ZodType<Prisma.RolePermissionOrderByWithRelationInput>;

export const RolePermissionWhereUniqueInputSchema: z.ZodType<Prisma.RolePermissionWhereUniqueInput> =
  z
    .object({
      roleID_permissionID: z.lazy(
        () => RolePermissionRoleIDPermissionIDCompoundUniqueInputSchema,
      ),
    })
    .and(
      z
        .object({
          roleID_permissionID: z
            .lazy(
              () => RolePermissionRoleIDPermissionIDCompoundUniqueInputSchema,
            )
            .optional(),
          AND: z
            .union([
              z.lazy(() => RolePermissionWhereInputSchema),
              z.lazy(() => RolePermissionWhereInputSchema).array(),
            ])
            .optional(),
          OR: z
            .lazy(() => RolePermissionWhereInputSchema)
            .array()
            .optional(),
          NOT: z
            .union([
              z.lazy(() => RolePermissionWhereInputSchema),
              z.lazy(() => RolePermissionWhereInputSchema).array(),
            ])
            .optional(),
          roleID: z
            .union([z.lazy(() => StringFilterSchema), z.string()])
            .optional(),
          permissionID: z
            .union([z.lazy(() => StringFilterSchema), z.string()])
            .optional(),
          createdAt: z
            .union([z.lazy(() => DateTimeFilterSchema), z.coerce.date()])
            .optional(),
          createdBy: z
            .union([z.lazy(() => StringNullableFilterSchema), z.string()])
            .optional()
            .nullable(),
          role: z
            .union([
              z.lazy(() => RoleScalarRelationFilterSchema),
              z.lazy(() => RoleWhereInputSchema),
            ])
            .optional(),
          permission: z
            .union([
              z.lazy(() => PermissionScalarRelationFilterSchema),
              z.lazy(() => PermissionWhereInputSchema),
            ])
            .optional(),
        })
        .strict(),
    ) as z.ZodType<Prisma.RolePermissionWhereUniqueInput>;

export const RolePermissionOrderByWithAggregationInputSchema: z.ZodType<Prisma.RolePermissionOrderByWithAggregationInput> =
  z
    .object({
      roleID: z.lazy(() => SortOrderSchema).optional(),
      permissionID: z.lazy(() => SortOrderSchema).optional(),
      createdAt: z.lazy(() => SortOrderSchema).optional(),
      createdBy: z
        .union([
          z.lazy(() => SortOrderSchema),
          z.lazy(() => SortOrderInputSchema),
        ])
        .optional(),
      _count: z
        .lazy(() => RolePermissionCountOrderByAggregateInputSchema)
        .optional(),
      _max: z
        .lazy(() => RolePermissionMaxOrderByAggregateInputSchema)
        .optional(),
      _min: z
        .lazy(() => RolePermissionMinOrderByAggregateInputSchema)
        .optional(),
    })
    .strict() as z.ZodType<Prisma.RolePermissionOrderByWithAggregationInput>;

export const RolePermissionScalarWhereWithAggregatesInputSchema: z.ZodType<Prisma.RolePermissionScalarWhereWithAggregatesInput> =
  z
    .object({
      AND: z
        .union([
          z.lazy(() => RolePermissionScalarWhereWithAggregatesInputSchema),
          z
            .lazy(() => RolePermissionScalarWhereWithAggregatesInputSchema)
            .array(),
        ])
        .optional(),
      OR: z
        .lazy(() => RolePermissionScalarWhereWithAggregatesInputSchema)
        .array()
        .optional(),
      NOT: z
        .union([
          z.lazy(() => RolePermissionScalarWhereWithAggregatesInputSchema),
          z
            .lazy(() => RolePermissionScalarWhereWithAggregatesInputSchema)
            .array(),
        ])
        .optional(),
      roleID: z
        .union([z.lazy(() => StringWithAggregatesFilterSchema), z.string()])
        .optional(),
      permissionID: z
        .union([z.lazy(() => StringWithAggregatesFilterSchema), z.string()])
        .optional(),
      createdAt: z
        .union([
          z.lazy(() => DateTimeWithAggregatesFilterSchema),
          z.coerce.date(),
        ])
        .optional(),
      createdBy: z
        .union([
          z.lazy(() => StringNullableWithAggregatesFilterSchema),
          z.string(),
        ])
        .optional()
        .nullable(),
    })
    .strict() as z.ZodType<Prisma.RolePermissionScalarWhereWithAggregatesInput>;

export const UserVendorRoleWhereInputSchema: z.ZodType<Prisma.UserVendorRoleWhereInput> =
  z
    .object({
      AND: z
        .union([
          z.lazy(() => UserVendorRoleWhereInputSchema),
          z.lazy(() => UserVendorRoleWhereInputSchema).array(),
        ])
        .optional(),
      OR: z
        .lazy(() => UserVendorRoleWhereInputSchema)
        .array()
        .optional(),
      NOT: z
        .union([
          z.lazy(() => UserVendorRoleWhereInputSchema),
          z.lazy(() => UserVendorRoleWhereInputSchema).array(),
        ])
        .optional(),
      id: z.union([z.lazy(() => StringFilterSchema), z.string()]).optional(),
      userID: z
        .union([z.lazy(() => StringFilterSchema), z.string()])
        .optional(),
      vendorID: z
        .union([z.lazy(() => StringFilterSchema), z.string()])
        .optional(),
      roleID: z
        .union([z.lazy(() => StringFilterSchema), z.string()])
        .optional(),
      status: z
        .union([
          z.lazy(() => EnumUserVendorRoleStatusFilterSchema),
          z.lazy(() => UserVendorRoleStatusSchema),
        ])
        .optional(),
      createdAt: z
        .union([z.lazy(() => DateTimeFilterSchema), z.coerce.date()])
        .optional(),
      createdBy: z
        .union([z.lazy(() => StringNullableFilterSchema), z.string()])
        .optional()
        .nullable(),
      user: z
        .union([
          z.lazy(() => UserScalarRelationFilterSchema),
          z.lazy(() => UserWhereInputSchema),
        ])
        .optional(),
      vendor: z
        .union([
          z.lazy(() => VendorScalarRelationFilterSchema),
          z.lazy(() => VendorWhereInputSchema),
        ])
        .optional(),
      role: z
        .union([
          z.lazy(() => RoleScalarRelationFilterSchema),
          z.lazy(() => RoleWhereInputSchema),
        ])
        .optional(),
    })
    .strict() as z.ZodType<Prisma.UserVendorRoleWhereInput>;

export const UserVendorRoleOrderByWithRelationInputSchema: z.ZodType<Prisma.UserVendorRoleOrderByWithRelationInput> =
  z
    .object({
      id: z.lazy(() => SortOrderSchema).optional(),
      userID: z.lazy(() => SortOrderSchema).optional(),
      vendorID: z.lazy(() => SortOrderSchema).optional(),
      roleID: z.lazy(() => SortOrderSchema).optional(),
      status: z.lazy(() => SortOrderSchema).optional(),
      createdAt: z.lazy(() => SortOrderSchema).optional(),
      createdBy: z
        .union([
          z.lazy(() => SortOrderSchema),
          z.lazy(() => SortOrderInputSchema),
        ])
        .optional(),
      user: z.lazy(() => UserOrderByWithRelationInputSchema).optional(),
      vendor: z.lazy(() => VendorOrderByWithRelationInputSchema).optional(),
      role: z.lazy(() => RoleOrderByWithRelationInputSchema).optional(),
    })
    .strict() as z.ZodType<Prisma.UserVendorRoleOrderByWithRelationInput>;

export const UserVendorRoleWhereUniqueInputSchema: z.ZodType<Prisma.UserVendorRoleWhereUniqueInput> =
  z
    .union([
      z.object({
        id: z.string().uuid(),
        userID_vendorID: z.lazy(
          () => UserVendorRoleUserIDVendorIDCompoundUniqueInputSchema,
        ),
      }),
      z.object({
        id: z.string().uuid(),
      }),
      z.object({
        userID_vendorID: z.lazy(
          () => UserVendorRoleUserIDVendorIDCompoundUniqueInputSchema,
        ),
      }),
    ])
    .and(
      z
        .object({
          id: z.string().uuid().optional(),
          userID_vendorID: z
            .lazy(() => UserVendorRoleUserIDVendorIDCompoundUniqueInputSchema)
            .optional(),
          AND: z
            .union([
              z.lazy(() => UserVendorRoleWhereInputSchema),
              z.lazy(() => UserVendorRoleWhereInputSchema).array(),
            ])
            .optional(),
          OR: z
            .lazy(() => UserVendorRoleWhereInputSchema)
            .array()
            .optional(),
          NOT: z
            .union([
              z.lazy(() => UserVendorRoleWhereInputSchema),
              z.lazy(() => UserVendorRoleWhereInputSchema).array(),
            ])
            .optional(),
          userID: z
            .union([z.lazy(() => StringFilterSchema), z.string()])
            .optional(),
          vendorID: z
            .union([z.lazy(() => StringFilterSchema), z.string()])
            .optional(),
          roleID: z
            .union([z.lazy(() => StringFilterSchema), z.string()])
            .optional(),
          status: z
            .union([
              z.lazy(() => EnumUserVendorRoleStatusFilterSchema),
              z.lazy(() => UserVendorRoleStatusSchema),
            ])
            .optional(),
          createdAt: z
            .union([z.lazy(() => DateTimeFilterSchema), z.coerce.date()])
            .optional(),
          createdBy: z
            .union([z.lazy(() => StringNullableFilterSchema), z.string()])
            .optional()
            .nullable(),
          user: z
            .union([
              z.lazy(() => UserScalarRelationFilterSchema),
              z.lazy(() => UserWhereInputSchema),
            ])
            .optional(),
          vendor: z
            .union([
              z.lazy(() => VendorScalarRelationFilterSchema),
              z.lazy(() => VendorWhereInputSchema),
            ])
            .optional(),
          role: z
            .union([
              z.lazy(() => RoleScalarRelationFilterSchema),
              z.lazy(() => RoleWhereInputSchema),
            ])
            .optional(),
        })
        .strict(),
    ) as z.ZodType<Prisma.UserVendorRoleWhereUniqueInput>;

export const UserVendorRoleOrderByWithAggregationInputSchema: z.ZodType<Prisma.UserVendorRoleOrderByWithAggregationInput> =
  z
    .object({
      id: z.lazy(() => SortOrderSchema).optional(),
      userID: z.lazy(() => SortOrderSchema).optional(),
      vendorID: z.lazy(() => SortOrderSchema).optional(),
      roleID: z.lazy(() => SortOrderSchema).optional(),
      status: z.lazy(() => SortOrderSchema).optional(),
      createdAt: z.lazy(() => SortOrderSchema).optional(),
      createdBy: z
        .union([
          z.lazy(() => SortOrderSchema),
          z.lazy(() => SortOrderInputSchema),
        ])
        .optional(),
      _count: z
        .lazy(() => UserVendorRoleCountOrderByAggregateInputSchema)
        .optional(),
      _max: z
        .lazy(() => UserVendorRoleMaxOrderByAggregateInputSchema)
        .optional(),
      _min: z
        .lazy(() => UserVendorRoleMinOrderByAggregateInputSchema)
        .optional(),
    })
    .strict() as z.ZodType<Prisma.UserVendorRoleOrderByWithAggregationInput>;

export const UserVendorRoleScalarWhereWithAggregatesInputSchema: z.ZodType<Prisma.UserVendorRoleScalarWhereWithAggregatesInput> =
  z
    .object({
      AND: z
        .union([
          z.lazy(() => UserVendorRoleScalarWhereWithAggregatesInputSchema),
          z
            .lazy(() => UserVendorRoleScalarWhereWithAggregatesInputSchema)
            .array(),
        ])
        .optional(),
      OR: z
        .lazy(() => UserVendorRoleScalarWhereWithAggregatesInputSchema)
        .array()
        .optional(),
      NOT: z
        .union([
          z.lazy(() => UserVendorRoleScalarWhereWithAggregatesInputSchema),
          z
            .lazy(() => UserVendorRoleScalarWhereWithAggregatesInputSchema)
            .array(),
        ])
        .optional(),
      id: z
        .union([z.lazy(() => StringWithAggregatesFilterSchema), z.string()])
        .optional(),
      userID: z
        .union([z.lazy(() => StringWithAggregatesFilterSchema), z.string()])
        .optional(),
      vendorID: z
        .union([z.lazy(() => StringWithAggregatesFilterSchema), z.string()])
        .optional(),
      roleID: z
        .union([z.lazy(() => StringWithAggregatesFilterSchema), z.string()])
        .optional(),
      status: z
        .union([
          z.lazy(() => EnumUserVendorRoleStatusWithAggregatesFilterSchema),
          z.lazy(() => UserVendorRoleStatusSchema),
        ])
        .optional(),
      createdAt: z
        .union([
          z.lazy(() => DateTimeWithAggregatesFilterSchema),
          z.coerce.date(),
        ])
        .optional(),
      createdBy: z
        .union([
          z.lazy(() => StringNullableWithAggregatesFilterSchema),
          z.string(),
        ])
        .optional()
        .nullable(),
    })
    .strict() as z.ZodType<Prisma.UserVendorRoleScalarWhereWithAggregatesInput>;

export const CategoryWhereInputSchema: z.ZodType<Prisma.CategoryWhereInput> = z
  .object({
    AND: z
      .union([
        z.lazy(() => CategoryWhereInputSchema),
        z.lazy(() => CategoryWhereInputSchema).array(),
      ])
      .optional(),
    OR: z
      .lazy(() => CategoryWhereInputSchema)
      .array()
      .optional(),
    NOT: z
      .union([
        z.lazy(() => CategoryWhereInputSchema),
        z.lazy(() => CategoryWhereInputSchema).array(),
      ])
      .optional(),
    id: z.union([z.lazy(() => StringFilterSchema), z.string()]).optional(),
    name: z.union([z.lazy(() => StringFilterSchema), z.string()]).optional(),
    slug: z.union([z.lazy(() => StringFilterSchema), z.string()]).optional(),
    description: z
      .union([z.lazy(() => StringNullableFilterSchema), z.string()])
      .optional()
      .nullable(),
    parentID: z
      .union([z.lazy(() => StringNullableFilterSchema), z.string()])
      .optional()
      .nullable(),
    imageUrl: z
      .union([z.lazy(() => StringNullableFilterSchema), z.string()])
      .optional()
      .nullable(),
    createdAt: z
      .union([z.lazy(() => DateTimeFilterSchema), z.coerce.date()])
      .optional(),
    createdBy: z
      .union([z.lazy(() => StringNullableFilterSchema), z.string()])
      .optional()
      .nullable(),
    updatedAt: z
      .union([z.lazy(() => DateTimeFilterSchema), z.coerce.date()])
      .optional(),
    deletedAt: z
      .union([z.lazy(() => DateTimeNullableFilterSchema), z.coerce.date()])
      .optional()
      .nullable(),
    parent: z
      .union([
        z.lazy(() => CategoryNullableScalarRelationFilterSchema),
        z.lazy(() => CategoryWhereInputSchema),
      ])
      .optional()
      .nullable(),
    children: z.lazy(() => CategoryListRelationFilterSchema).optional(),
    productCategories: z
      .lazy(() => ProductCategoryListRelationFilterSchema)
      .optional(),
  })
  .strict() as z.ZodType<Prisma.CategoryWhereInput>;

export const CategoryOrderByWithRelationInputSchema: z.ZodType<Prisma.CategoryOrderByWithRelationInput> =
  z
    .object({
      id: z.lazy(() => SortOrderSchema).optional(),
      name: z.lazy(() => SortOrderSchema).optional(),
      slug: z.lazy(() => SortOrderSchema).optional(),
      description: z
        .union([
          z.lazy(() => SortOrderSchema),
          z.lazy(() => SortOrderInputSchema),
        ])
        .optional(),
      parentID: z
        .union([
          z.lazy(() => SortOrderSchema),
          z.lazy(() => SortOrderInputSchema),
        ])
        .optional(),
      imageUrl: z
        .union([
          z.lazy(() => SortOrderSchema),
          z.lazy(() => SortOrderInputSchema),
        ])
        .optional(),
      createdAt: z.lazy(() => SortOrderSchema).optional(),
      createdBy: z
        .union([
          z.lazy(() => SortOrderSchema),
          z.lazy(() => SortOrderInputSchema),
        ])
        .optional(),
      updatedAt: z.lazy(() => SortOrderSchema).optional(),
      deletedAt: z
        .union([
          z.lazy(() => SortOrderSchema),
          z.lazy(() => SortOrderInputSchema),
        ])
        .optional(),
      parent: z.lazy(() => CategoryOrderByWithRelationInputSchema).optional(),
      children: z
        .lazy(() => CategoryOrderByRelationAggregateInputSchema)
        .optional(),
      productCategories: z
        .lazy(() => ProductCategoryOrderByRelationAggregateInputSchema)
        .optional(),
    })
    .strict() as z.ZodType<Prisma.CategoryOrderByWithRelationInput>;

export const CategoryWhereUniqueInputSchema: z.ZodType<Prisma.CategoryWhereUniqueInput> =
  z
    .union([
      z.object({
        id: z.string().uuid(),
        slug: z.string(),
      }),
      z.object({
        id: z.string().uuid(),
      }),
      z.object({
        slug: z.string(),
      }),
    ])
    .and(
      z
        .object({
          id: z.string().uuid().optional(),
          slug: z.string().optional(),
          AND: z
            .union([
              z.lazy(() => CategoryWhereInputSchema),
              z.lazy(() => CategoryWhereInputSchema).array(),
            ])
            .optional(),
          OR: z
            .lazy(() => CategoryWhereInputSchema)
            .array()
            .optional(),
          NOT: z
            .union([
              z.lazy(() => CategoryWhereInputSchema),
              z.lazy(() => CategoryWhereInputSchema).array(),
            ])
            .optional(),
          name: z
            .union([z.lazy(() => StringFilterSchema), z.string()])
            .optional(),
          description: z
            .union([z.lazy(() => StringNullableFilterSchema), z.string()])
            .optional()
            .nullable(),
          parentID: z
            .union([z.lazy(() => StringNullableFilterSchema), z.string()])
            .optional()
            .nullable(),
          imageUrl: z
            .union([z.lazy(() => StringNullableFilterSchema), z.string()])
            .optional()
            .nullable(),
          createdAt: z
            .union([z.lazy(() => DateTimeFilterSchema), z.coerce.date()])
            .optional(),
          createdBy: z
            .union([z.lazy(() => StringNullableFilterSchema), z.string()])
            .optional()
            .nullable(),
          updatedAt: z
            .union([z.lazy(() => DateTimeFilterSchema), z.coerce.date()])
            .optional(),
          deletedAt: z
            .union([
              z.lazy(() => DateTimeNullableFilterSchema),
              z.coerce.date(),
            ])
            .optional()
            .nullable(),
          parent: z
            .union([
              z.lazy(() => CategoryNullableScalarRelationFilterSchema),
              z.lazy(() => CategoryWhereInputSchema),
            ])
            .optional()
            .nullable(),
          children: z.lazy(() => CategoryListRelationFilterSchema).optional(),
          productCategories: z
            .lazy(() => ProductCategoryListRelationFilterSchema)
            .optional(),
        })
        .strict(),
    ) as z.ZodType<Prisma.CategoryWhereUniqueInput>;

export const CategoryOrderByWithAggregationInputSchema: z.ZodType<Prisma.CategoryOrderByWithAggregationInput> =
  z
    .object({
      id: z.lazy(() => SortOrderSchema).optional(),
      name: z.lazy(() => SortOrderSchema).optional(),
      slug: z.lazy(() => SortOrderSchema).optional(),
      description: z
        .union([
          z.lazy(() => SortOrderSchema),
          z.lazy(() => SortOrderInputSchema),
        ])
        .optional(),
      parentID: z
        .union([
          z.lazy(() => SortOrderSchema),
          z.lazy(() => SortOrderInputSchema),
        ])
        .optional(),
      imageUrl: z
        .union([
          z.lazy(() => SortOrderSchema),
          z.lazy(() => SortOrderInputSchema),
        ])
        .optional(),
      createdAt: z.lazy(() => SortOrderSchema).optional(),
      createdBy: z
        .union([
          z.lazy(() => SortOrderSchema),
          z.lazy(() => SortOrderInputSchema),
        ])
        .optional(),
      updatedAt: z.lazy(() => SortOrderSchema).optional(),
      deletedAt: z
        .union([
          z.lazy(() => SortOrderSchema),
          z.lazy(() => SortOrderInputSchema),
        ])
        .optional(),
      _count: z.lazy(() => CategoryCountOrderByAggregateInputSchema).optional(),
      _max: z.lazy(() => CategoryMaxOrderByAggregateInputSchema).optional(),
      _min: z.lazy(() => CategoryMinOrderByAggregateInputSchema).optional(),
    })
    .strict() as z.ZodType<Prisma.CategoryOrderByWithAggregationInput>;

export const CategoryScalarWhereWithAggregatesInputSchema: z.ZodType<Prisma.CategoryScalarWhereWithAggregatesInput> =
  z
    .object({
      AND: z
        .union([
          z.lazy(() => CategoryScalarWhereWithAggregatesInputSchema),
          z.lazy(() => CategoryScalarWhereWithAggregatesInputSchema).array(),
        ])
        .optional(),
      OR: z
        .lazy(() => CategoryScalarWhereWithAggregatesInputSchema)
        .array()
        .optional(),
      NOT: z
        .union([
          z.lazy(() => CategoryScalarWhereWithAggregatesInputSchema),
          z.lazy(() => CategoryScalarWhereWithAggregatesInputSchema).array(),
        ])
        .optional(),
      id: z
        .union([z.lazy(() => StringWithAggregatesFilterSchema), z.string()])
        .optional(),
      name: z
        .union([z.lazy(() => StringWithAggregatesFilterSchema), z.string()])
        .optional(),
      slug: z
        .union([z.lazy(() => StringWithAggregatesFilterSchema), z.string()])
        .optional(),
      description: z
        .union([
          z.lazy(() => StringNullableWithAggregatesFilterSchema),
          z.string(),
        ])
        .optional()
        .nullable(),
      parentID: z
        .union([
          z.lazy(() => StringNullableWithAggregatesFilterSchema),
          z.string(),
        ])
        .optional()
        .nullable(),
      imageUrl: z
        .union([
          z.lazy(() => StringNullableWithAggregatesFilterSchema),
          z.string(),
        ])
        .optional()
        .nullable(),
      createdAt: z
        .union([
          z.lazy(() => DateTimeWithAggregatesFilterSchema),
          z.coerce.date(),
        ])
        .optional(),
      createdBy: z
        .union([
          z.lazy(() => StringNullableWithAggregatesFilterSchema),
          z.string(),
        ])
        .optional()
        .nullable(),
      updatedAt: z
        .union([
          z.lazy(() => DateTimeWithAggregatesFilterSchema),
          z.coerce.date(),
        ])
        .optional(),
      deletedAt: z
        .union([
          z.lazy(() => DateTimeNullableWithAggregatesFilterSchema),
          z.coerce.date(),
        ])
        .optional()
        .nullable(),
    })
    .strict() as z.ZodType<Prisma.CategoryScalarWhereWithAggregatesInput>;

export const ProductWhereInputSchema: z.ZodType<Prisma.ProductWhereInput> = z
  .object({
    AND: z
      .union([
        z.lazy(() => ProductWhereInputSchema),
        z.lazy(() => ProductWhereInputSchema).array(),
      ])
      .optional(),
    OR: z
      .lazy(() => ProductWhereInputSchema)
      .array()
      .optional(),
    NOT: z
      .union([
        z.lazy(() => ProductWhereInputSchema),
        z.lazy(() => ProductWhereInputSchema).array(),
      ])
      .optional(),
    id: z.union([z.lazy(() => StringFilterSchema), z.string()]).optional(),
    vendorID: z
      .union([z.lazy(() => StringFilterSchema), z.string()])
      .optional(),
    name: z.union([z.lazy(() => StringFilterSchema), z.string()]).optional(),
    slug: z.union([z.lazy(() => StringFilterSchema), z.string()]).optional(),
    description: z
      .union([z.lazy(() => StringNullableFilterSchema), z.string()])
      .optional()
      .nullable(),
    sku: z
      .union([z.lazy(() => StringNullableFilterSchema), z.string()])
      .optional()
      .nullable(),
    price: z
      .union([
        z.lazy(() => DecimalFilterSchema),
        z
          .union([
            z.number(),
            z.string(),
            z.instanceof(Decimal),
            z.instanceof(Prisma.Decimal),
            DecimalJsLikeSchema,
          ])
          .refine((v) => isValidDecimalInput(v), {
            message: 'Must be a Decimal',
          }),
      ])
      .optional(),
    stockQuantity: z
      .union([z.lazy(() => IntFilterSchema), z.number()])
      .optional(),
    status: z
      .union([
        z.lazy(() => EnumProductStatusFilterSchema),
        z.lazy(() => ProductStatusSchema),
      ])
      .optional(),
    createdAt: z
      .union([z.lazy(() => DateTimeFilterSchema), z.coerce.date()])
      .optional(),
    createdBy: z
      .union([z.lazy(() => StringNullableFilterSchema), z.string()])
      .optional()
      .nullable(),
    updatedAt: z
      .union([z.lazy(() => DateTimeFilterSchema), z.coerce.date()])
      .optional(),
    deletedAt: z
      .union([z.lazy(() => DateTimeNullableFilterSchema), z.coerce.date()])
      .optional()
      .nullable(),
    vendor: z
      .union([
        z.lazy(() => VendorScalarRelationFilterSchema),
        z.lazy(() => VendorWhereInputSchema),
      ])
      .optional(),
    productCategories: z
      .lazy(() => ProductCategoryListRelationFilterSchema)
      .optional(),
    productImages: z
      .lazy(() => ProductImageListRelationFilterSchema)
      .optional(),
    productVariants: z
      .lazy(() => ProductVariantListRelationFilterSchema)
      .optional(),
  })
  .strict() as z.ZodType<Prisma.ProductWhereInput>;

export const ProductOrderByWithRelationInputSchema: z.ZodType<Prisma.ProductOrderByWithRelationInput> =
  z
    .object({
      id: z.lazy(() => SortOrderSchema).optional(),
      vendorID: z.lazy(() => SortOrderSchema).optional(),
      name: z.lazy(() => SortOrderSchema).optional(),
      slug: z.lazy(() => SortOrderSchema).optional(),
      description: z
        .union([
          z.lazy(() => SortOrderSchema),
          z.lazy(() => SortOrderInputSchema),
        ])
        .optional(),
      sku: z
        .union([
          z.lazy(() => SortOrderSchema),
          z.lazy(() => SortOrderInputSchema),
        ])
        .optional(),
      price: z.lazy(() => SortOrderSchema).optional(),
      stockQuantity: z.lazy(() => SortOrderSchema).optional(),
      status: z.lazy(() => SortOrderSchema).optional(),
      createdAt: z.lazy(() => SortOrderSchema).optional(),
      createdBy: z
        .union([
          z.lazy(() => SortOrderSchema),
          z.lazy(() => SortOrderInputSchema),
        ])
        .optional(),
      updatedAt: z.lazy(() => SortOrderSchema).optional(),
      deletedAt: z
        .union([
          z.lazy(() => SortOrderSchema),
          z.lazy(() => SortOrderInputSchema),
        ])
        .optional(),
      vendor: z.lazy(() => VendorOrderByWithRelationInputSchema).optional(),
      productCategories: z
        .lazy(() => ProductCategoryOrderByRelationAggregateInputSchema)
        .optional(),
      productImages: z
        .lazy(() => ProductImageOrderByRelationAggregateInputSchema)
        .optional(),
      productVariants: z
        .lazy(() => ProductVariantOrderByRelationAggregateInputSchema)
        .optional(),
    })
    .strict() as z.ZodType<Prisma.ProductOrderByWithRelationInput>;

export const ProductWhereUniqueInputSchema: z.ZodType<Prisma.ProductWhereUniqueInput> =
  z
    .union([
      z.object({
        id: z.string().uuid(),
        slug: z.string(),
        sku: z.string(),
      }),
      z.object({
        id: z.string().uuid(),
        slug: z.string(),
      }),
      z.object({
        id: z.string().uuid(),
        sku: z.string(),
      }),
      z.object({
        id: z.string().uuid(),
      }),
      z.object({
        slug: z.string(),
        sku: z.string(),
      }),
      z.object({
        slug: z.string(),
      }),
      z.object({
        sku: z.string(),
      }),
    ])
    .and(
      z
        .object({
          id: z.string().uuid().optional(),
          slug: z.string().optional(),
          sku: z.string().optional(),
          AND: z
            .union([
              z.lazy(() => ProductWhereInputSchema),
              z.lazy(() => ProductWhereInputSchema).array(),
            ])
            .optional(),
          OR: z
            .lazy(() => ProductWhereInputSchema)
            .array()
            .optional(),
          NOT: z
            .union([
              z.lazy(() => ProductWhereInputSchema),
              z.lazy(() => ProductWhereInputSchema).array(),
            ])
            .optional(),
          vendorID: z
            .union([z.lazy(() => StringFilterSchema), z.string()])
            .optional(),
          name: z
            .union([z.lazy(() => StringFilterSchema), z.string()])
            .optional(),
          description: z
            .union([z.lazy(() => StringNullableFilterSchema), z.string()])
            .optional()
            .nullable(),
          price: z
            .union([
              z.lazy(() => DecimalFilterSchema),
              z
                .union([
                  z.number(),
                  z.string(),
                  z.instanceof(Decimal),
                  z.instanceof(Prisma.Decimal),
                  DecimalJsLikeSchema,
                ])
                .refine((v) => isValidDecimalInput(v), {
                  message: 'Must be a Decimal',
                }),
            ])
            .optional(),
          stockQuantity: z
            .union([z.lazy(() => IntFilterSchema), z.number().int()])
            .optional(),
          status: z
            .union([
              z.lazy(() => EnumProductStatusFilterSchema),
              z.lazy(() => ProductStatusSchema),
            ])
            .optional(),
          createdAt: z
            .union([z.lazy(() => DateTimeFilterSchema), z.coerce.date()])
            .optional(),
          createdBy: z
            .union([z.lazy(() => StringNullableFilterSchema), z.string()])
            .optional()
            .nullable(),
          updatedAt: z
            .union([z.lazy(() => DateTimeFilterSchema), z.coerce.date()])
            .optional(),
          deletedAt: z
            .union([
              z.lazy(() => DateTimeNullableFilterSchema),
              z.coerce.date(),
            ])
            .optional()
            .nullable(),
          vendor: z
            .union([
              z.lazy(() => VendorScalarRelationFilterSchema),
              z.lazy(() => VendorWhereInputSchema),
            ])
            .optional(),
          productCategories: z
            .lazy(() => ProductCategoryListRelationFilterSchema)
            .optional(),
          productImages: z
            .lazy(() => ProductImageListRelationFilterSchema)
            .optional(),
          productVariants: z
            .lazy(() => ProductVariantListRelationFilterSchema)
            .optional(),
        })
        .strict(),
    ) as z.ZodType<Prisma.ProductWhereUniqueInput>;

export const ProductOrderByWithAggregationInputSchema: z.ZodType<Prisma.ProductOrderByWithAggregationInput> =
  z
    .object({
      id: z.lazy(() => SortOrderSchema).optional(),
      vendorID: z.lazy(() => SortOrderSchema).optional(),
      name: z.lazy(() => SortOrderSchema).optional(),
      slug: z.lazy(() => SortOrderSchema).optional(),
      description: z
        .union([
          z.lazy(() => SortOrderSchema),
          z.lazy(() => SortOrderInputSchema),
        ])
        .optional(),
      sku: z
        .union([
          z.lazy(() => SortOrderSchema),
          z.lazy(() => SortOrderInputSchema),
        ])
        .optional(),
      price: z.lazy(() => SortOrderSchema).optional(),
      stockQuantity: z.lazy(() => SortOrderSchema).optional(),
      status: z.lazy(() => SortOrderSchema).optional(),
      createdAt: z.lazy(() => SortOrderSchema).optional(),
      createdBy: z
        .union([
          z.lazy(() => SortOrderSchema),
          z.lazy(() => SortOrderInputSchema),
        ])
        .optional(),
      updatedAt: z.lazy(() => SortOrderSchema).optional(),
      deletedAt: z
        .union([
          z.lazy(() => SortOrderSchema),
          z.lazy(() => SortOrderInputSchema),
        ])
        .optional(),
      _count: z.lazy(() => ProductCountOrderByAggregateInputSchema).optional(),
      _avg: z.lazy(() => ProductAvgOrderByAggregateInputSchema).optional(),
      _max: z.lazy(() => ProductMaxOrderByAggregateInputSchema).optional(),
      _min: z.lazy(() => ProductMinOrderByAggregateInputSchema).optional(),
      _sum: z.lazy(() => ProductSumOrderByAggregateInputSchema).optional(),
    })
    .strict() as z.ZodType<Prisma.ProductOrderByWithAggregationInput>;

export const ProductScalarWhereWithAggregatesInputSchema: z.ZodType<Prisma.ProductScalarWhereWithAggregatesInput> =
  z
    .object({
      AND: z
        .union([
          z.lazy(() => ProductScalarWhereWithAggregatesInputSchema),
          z.lazy(() => ProductScalarWhereWithAggregatesInputSchema).array(),
        ])
        .optional(),
      OR: z
        .lazy(() => ProductScalarWhereWithAggregatesInputSchema)
        .array()
        .optional(),
      NOT: z
        .union([
          z.lazy(() => ProductScalarWhereWithAggregatesInputSchema),
          z.lazy(() => ProductScalarWhereWithAggregatesInputSchema).array(),
        ])
        .optional(),
      id: z
        .union([z.lazy(() => StringWithAggregatesFilterSchema), z.string()])
        .optional(),
      vendorID: z
        .union([z.lazy(() => StringWithAggregatesFilterSchema), z.string()])
        .optional(),
      name: z
        .union([z.lazy(() => StringWithAggregatesFilterSchema), z.string()])
        .optional(),
      slug: z
        .union([z.lazy(() => StringWithAggregatesFilterSchema), z.string()])
        .optional(),
      description: z
        .union([
          z.lazy(() => StringNullableWithAggregatesFilterSchema),
          z.string(),
        ])
        .optional()
        .nullable(),
      sku: z
        .union([
          z.lazy(() => StringNullableWithAggregatesFilterSchema),
          z.string(),
        ])
        .optional()
        .nullable(),
      price: z
        .union([
          z.lazy(() => DecimalWithAggregatesFilterSchema),
          z
            .union([
              z.number(),
              z.string(),
              z.instanceof(Decimal),
              z.instanceof(Prisma.Decimal),
              DecimalJsLikeSchema,
            ])
            .refine((v) => isValidDecimalInput(v), {
              message: 'Must be a Decimal',
            }),
        ])
        .optional(),
      stockQuantity: z
        .union([z.lazy(() => IntWithAggregatesFilterSchema), z.number()])
        .optional(),
      status: z
        .union([
          z.lazy(() => EnumProductStatusWithAggregatesFilterSchema),
          z.lazy(() => ProductStatusSchema),
        ])
        .optional(),
      createdAt: z
        .union([
          z.lazy(() => DateTimeWithAggregatesFilterSchema),
          z.coerce.date(),
        ])
        .optional(),
      createdBy: z
        .union([
          z.lazy(() => StringNullableWithAggregatesFilterSchema),
          z.string(),
        ])
        .optional()
        .nullable(),
      updatedAt: z
        .union([
          z.lazy(() => DateTimeWithAggregatesFilterSchema),
          z.coerce.date(),
        ])
        .optional(),
      deletedAt: z
        .union([
          z.lazy(() => DateTimeNullableWithAggregatesFilterSchema),
          z.coerce.date(),
        ])
        .optional()
        .nullable(),
    })
    .strict() as z.ZodType<Prisma.ProductScalarWhereWithAggregatesInput>;

export const ProductVariantWhereInputSchema: z.ZodType<Prisma.ProductVariantWhereInput> =
  z
    .object({
      AND: z
        .union([
          z.lazy(() => ProductVariantWhereInputSchema),
          z.lazy(() => ProductVariantWhereInputSchema).array(),
        ])
        .optional(),
      OR: z
        .lazy(() => ProductVariantWhereInputSchema)
        .array()
        .optional(),
      NOT: z
        .union([
          z.lazy(() => ProductVariantWhereInputSchema),
          z.lazy(() => ProductVariantWhereInputSchema).array(),
        ])
        .optional(),
      id: z.union([z.lazy(() => StringFilterSchema), z.string()]).optional(),
      productID: z
        .union([z.lazy(() => StringFilterSchema), z.string()])
        .optional(),
      name: z
        .union([z.lazy(() => StringNullableFilterSchema), z.string()])
        .optional()
        .nullable(),
      sku: z
        .union([z.lazy(() => StringNullableFilterSchema), z.string()])
        .optional()
        .nullable(),
      price: z
        .union([
          z.lazy(() => DecimalFilterSchema),
          z
            .union([
              z.number(),
              z.string(),
              z.instanceof(Decimal),
              z.instanceof(Prisma.Decimal),
              DecimalJsLikeSchema,
            ])
            .refine((v) => isValidDecimalInput(v), {
              message: 'Must be a Decimal',
            }),
        ])
        .optional(),
      stockQuantity: z
        .union([z.lazy(() => IntFilterSchema), z.number()])
        .optional(),
      attributes: z.lazy(() => JsonNullableFilterSchema).optional(),
      createdAt: z
        .union([z.lazy(() => DateTimeFilterSchema), z.coerce.date()])
        .optional(),
      createdBy: z
        .union([z.lazy(() => StringNullableFilterSchema), z.string()])
        .optional()
        .nullable(),
      updatedAt: z
        .union([z.lazy(() => DateTimeFilterSchema), z.coerce.date()])
        .optional(),
      deletedAt: z
        .union([z.lazy(() => DateTimeNullableFilterSchema), z.coerce.date()])
        .optional()
        .nullable(),
      product: z
        .union([
          z.lazy(() => ProductScalarRelationFilterSchema),
          z.lazy(() => ProductWhereInputSchema),
        ])
        .optional(),
      productImages: z
        .lazy(() => ProductImageListRelationFilterSchema)
        .optional(),
      orderItems: z.lazy(() => OrderItemListRelationFilterSchema).optional(),
      cartItems: z.lazy(() => CartItemListRelationFilterSchema).optional(),
    })
    .strict() as z.ZodType<Prisma.ProductVariantWhereInput>;

export const ProductVariantOrderByWithRelationInputSchema: z.ZodType<Prisma.ProductVariantOrderByWithRelationInput> =
  z
    .object({
      id: z.lazy(() => SortOrderSchema).optional(),
      productID: z.lazy(() => SortOrderSchema).optional(),
      name: z
        .union([
          z.lazy(() => SortOrderSchema),
          z.lazy(() => SortOrderInputSchema),
        ])
        .optional(),
      sku: z
        .union([
          z.lazy(() => SortOrderSchema),
          z.lazy(() => SortOrderInputSchema),
        ])
        .optional(),
      price: z.lazy(() => SortOrderSchema).optional(),
      stockQuantity: z.lazy(() => SortOrderSchema).optional(),
      attributes: z
        .union([
          z.lazy(() => SortOrderSchema),
          z.lazy(() => SortOrderInputSchema),
        ])
        .optional(),
      createdAt: z.lazy(() => SortOrderSchema).optional(),
      createdBy: z
        .union([
          z.lazy(() => SortOrderSchema),
          z.lazy(() => SortOrderInputSchema),
        ])
        .optional(),
      updatedAt: z.lazy(() => SortOrderSchema).optional(),
      deletedAt: z
        .union([
          z.lazy(() => SortOrderSchema),
          z.lazy(() => SortOrderInputSchema),
        ])
        .optional(),
      product: z.lazy(() => ProductOrderByWithRelationInputSchema).optional(),
      productImages: z
        .lazy(() => ProductImageOrderByRelationAggregateInputSchema)
        .optional(),
      orderItems: z
        .lazy(() => OrderItemOrderByRelationAggregateInputSchema)
        .optional(),
      cartItems: z
        .lazy(() => CartItemOrderByRelationAggregateInputSchema)
        .optional(),
    })
    .strict() as z.ZodType<Prisma.ProductVariantOrderByWithRelationInput>;

export const ProductVariantWhereUniqueInputSchema: z.ZodType<Prisma.ProductVariantWhereUniqueInput> =
  z
    .union([
      z.object({
        id: z.string().uuid(),
        sku: z.string(),
      }),
      z.object({
        id: z.string().uuid(),
      }),
      z.object({
        sku: z.string(),
      }),
    ])
    .and(
      z
        .object({
          id: z.string().uuid().optional(),
          sku: z.string().optional(),
          AND: z
            .union([
              z.lazy(() => ProductVariantWhereInputSchema),
              z.lazy(() => ProductVariantWhereInputSchema).array(),
            ])
            .optional(),
          OR: z
            .lazy(() => ProductVariantWhereInputSchema)
            .array()
            .optional(),
          NOT: z
            .union([
              z.lazy(() => ProductVariantWhereInputSchema),
              z.lazy(() => ProductVariantWhereInputSchema).array(),
            ])
            .optional(),
          productID: z
            .union([z.lazy(() => StringFilterSchema), z.string()])
            .optional(),
          name: z
            .union([z.lazy(() => StringNullableFilterSchema), z.string()])
            .optional()
            .nullable(),
          price: z
            .union([
              z.lazy(() => DecimalFilterSchema),
              z
                .union([
                  z.number(),
                  z.string(),
                  z.instanceof(Decimal),
                  z.instanceof(Prisma.Decimal),
                  DecimalJsLikeSchema,
                ])
                .refine((v) => isValidDecimalInput(v), {
                  message: 'Must be a Decimal',
                }),
            ])
            .optional(),
          stockQuantity: z
            .union([z.lazy(() => IntFilterSchema), z.number().int()])
            .optional(),
          attributes: z.lazy(() => JsonNullableFilterSchema).optional(),
          createdAt: z
            .union([z.lazy(() => DateTimeFilterSchema), z.coerce.date()])
            .optional(),
          createdBy: z
            .union([z.lazy(() => StringNullableFilterSchema), z.string()])
            .optional()
            .nullable(),
          updatedAt: z
            .union([z.lazy(() => DateTimeFilterSchema), z.coerce.date()])
            .optional(),
          deletedAt: z
            .union([
              z.lazy(() => DateTimeNullableFilterSchema),
              z.coerce.date(),
            ])
            .optional()
            .nullable(),
          product: z
            .union([
              z.lazy(() => ProductScalarRelationFilterSchema),
              z.lazy(() => ProductWhereInputSchema),
            ])
            .optional(),
          productImages: z
            .lazy(() => ProductImageListRelationFilterSchema)
            .optional(),
          orderItems: z
            .lazy(() => OrderItemListRelationFilterSchema)
            .optional(),
          cartItems: z.lazy(() => CartItemListRelationFilterSchema).optional(),
        })
        .strict(),
    ) as z.ZodType<Prisma.ProductVariantWhereUniqueInput>;

export const ProductVariantOrderByWithAggregationInputSchema: z.ZodType<Prisma.ProductVariantOrderByWithAggregationInput> =
  z
    .object({
      id: z.lazy(() => SortOrderSchema).optional(),
      productID: z.lazy(() => SortOrderSchema).optional(),
      name: z
        .union([
          z.lazy(() => SortOrderSchema),
          z.lazy(() => SortOrderInputSchema),
        ])
        .optional(),
      sku: z
        .union([
          z.lazy(() => SortOrderSchema),
          z.lazy(() => SortOrderInputSchema),
        ])
        .optional(),
      price: z.lazy(() => SortOrderSchema).optional(),
      stockQuantity: z.lazy(() => SortOrderSchema).optional(),
      attributes: z
        .union([
          z.lazy(() => SortOrderSchema),
          z.lazy(() => SortOrderInputSchema),
        ])
        .optional(),
      createdAt: z.lazy(() => SortOrderSchema).optional(),
      createdBy: z
        .union([
          z.lazy(() => SortOrderSchema),
          z.lazy(() => SortOrderInputSchema),
        ])
        .optional(),
      updatedAt: z.lazy(() => SortOrderSchema).optional(),
      deletedAt: z
        .union([
          z.lazy(() => SortOrderSchema),
          z.lazy(() => SortOrderInputSchema),
        ])
        .optional(),
      _count: z
        .lazy(() => ProductVariantCountOrderByAggregateInputSchema)
        .optional(),
      _avg: z
        .lazy(() => ProductVariantAvgOrderByAggregateInputSchema)
        .optional(),
      _max: z
        .lazy(() => ProductVariantMaxOrderByAggregateInputSchema)
        .optional(),
      _min: z
        .lazy(() => ProductVariantMinOrderByAggregateInputSchema)
        .optional(),
      _sum: z
        .lazy(() => ProductVariantSumOrderByAggregateInputSchema)
        .optional(),
    })
    .strict() as z.ZodType<Prisma.ProductVariantOrderByWithAggregationInput>;

export const ProductVariantScalarWhereWithAggregatesInputSchema: z.ZodType<Prisma.ProductVariantScalarWhereWithAggregatesInput> =
  z
    .object({
      AND: z
        .union([
          z.lazy(() => ProductVariantScalarWhereWithAggregatesInputSchema),
          z
            .lazy(() => ProductVariantScalarWhereWithAggregatesInputSchema)
            .array(),
        ])
        .optional(),
      OR: z
        .lazy(() => ProductVariantScalarWhereWithAggregatesInputSchema)
        .array()
        .optional(),
      NOT: z
        .union([
          z.lazy(() => ProductVariantScalarWhereWithAggregatesInputSchema),
          z
            .lazy(() => ProductVariantScalarWhereWithAggregatesInputSchema)
            .array(),
        ])
        .optional(),
      id: z
        .union([z.lazy(() => StringWithAggregatesFilterSchema), z.string()])
        .optional(),
      productID: z
        .union([z.lazy(() => StringWithAggregatesFilterSchema), z.string()])
        .optional(),
      name: z
        .union([
          z.lazy(() => StringNullableWithAggregatesFilterSchema),
          z.string(),
        ])
        .optional()
        .nullable(),
      sku: z
        .union([
          z.lazy(() => StringNullableWithAggregatesFilterSchema),
          z.string(),
        ])
        .optional()
        .nullable(),
      price: z
        .union([
          z.lazy(() => DecimalWithAggregatesFilterSchema),
          z
            .union([
              z.number(),
              z.string(),
              z.instanceof(Decimal),
              z.instanceof(Prisma.Decimal),
              DecimalJsLikeSchema,
            ])
            .refine((v) => isValidDecimalInput(v), {
              message: 'Must be a Decimal',
            }),
        ])
        .optional(),
      stockQuantity: z
        .union([z.lazy(() => IntWithAggregatesFilterSchema), z.number()])
        .optional(),
      attributes: z
        .lazy(() => JsonNullableWithAggregatesFilterSchema)
        .optional(),
      createdAt: z
        .union([
          z.lazy(() => DateTimeWithAggregatesFilterSchema),
          z.coerce.date(),
        ])
        .optional(),
      createdBy: z
        .union([
          z.lazy(() => StringNullableWithAggregatesFilterSchema),
          z.string(),
        ])
        .optional()
        .nullable(),
      updatedAt: z
        .union([
          z.lazy(() => DateTimeWithAggregatesFilterSchema),
          z.coerce.date(),
        ])
        .optional(),
      deletedAt: z
        .union([
          z.lazy(() => DateTimeNullableWithAggregatesFilterSchema),
          z.coerce.date(),
        ])
        .optional()
        .nullable(),
    })
    .strict() as z.ZodType<Prisma.ProductVariantScalarWhereWithAggregatesInput>;

export const ProductCategoryWhereInputSchema: z.ZodType<Prisma.ProductCategoryWhereInput> =
  z
    .object({
      AND: z
        .union([
          z.lazy(() => ProductCategoryWhereInputSchema),
          z.lazy(() => ProductCategoryWhereInputSchema).array(),
        ])
        .optional(),
      OR: z
        .lazy(() => ProductCategoryWhereInputSchema)
        .array()
        .optional(),
      NOT: z
        .union([
          z.lazy(() => ProductCategoryWhereInputSchema),
          z.lazy(() => ProductCategoryWhereInputSchema).array(),
        ])
        .optional(),
      productID: z
        .union([z.lazy(() => StringFilterSchema), z.string()])
        .optional(),
      categoryID: z
        .union([z.lazy(() => StringFilterSchema), z.string()])
        .optional(),
      product: z
        .union([
          z.lazy(() => ProductScalarRelationFilterSchema),
          z.lazy(() => ProductWhereInputSchema),
        ])
        .optional(),
      category: z
        .union([
          z.lazy(() => CategoryScalarRelationFilterSchema),
          z.lazy(() => CategoryWhereInputSchema),
        ])
        .optional(),
    })
    .strict() as z.ZodType<Prisma.ProductCategoryWhereInput>;

export const ProductCategoryOrderByWithRelationInputSchema: z.ZodType<Prisma.ProductCategoryOrderByWithRelationInput> =
  z
    .object({
      productID: z.lazy(() => SortOrderSchema).optional(),
      categoryID: z.lazy(() => SortOrderSchema).optional(),
      product: z.lazy(() => ProductOrderByWithRelationInputSchema).optional(),
      category: z.lazy(() => CategoryOrderByWithRelationInputSchema).optional(),
    })
    .strict() as z.ZodType<Prisma.ProductCategoryOrderByWithRelationInput>;

export const ProductCategoryWhereUniqueInputSchema: z.ZodType<Prisma.ProductCategoryWhereUniqueInput> =
  z
    .object({
      productID_categoryID: z.lazy(
        () => ProductCategoryProductIDCategoryIDCompoundUniqueInputSchema,
      ),
    })
    .and(
      z
        .object({
          productID_categoryID: z
            .lazy(
              () => ProductCategoryProductIDCategoryIDCompoundUniqueInputSchema,
            )
            .optional(),
          AND: z
            .union([
              z.lazy(() => ProductCategoryWhereInputSchema),
              z.lazy(() => ProductCategoryWhereInputSchema).array(),
            ])
            .optional(),
          OR: z
            .lazy(() => ProductCategoryWhereInputSchema)
            .array()
            .optional(),
          NOT: z
            .union([
              z.lazy(() => ProductCategoryWhereInputSchema),
              z.lazy(() => ProductCategoryWhereInputSchema).array(),
            ])
            .optional(),
          productID: z
            .union([z.lazy(() => StringFilterSchema), z.string()])
            .optional(),
          categoryID: z
            .union([z.lazy(() => StringFilterSchema), z.string()])
            .optional(),
          product: z
            .union([
              z.lazy(() => ProductScalarRelationFilterSchema),
              z.lazy(() => ProductWhereInputSchema),
            ])
            .optional(),
          category: z
            .union([
              z.lazy(() => CategoryScalarRelationFilterSchema),
              z.lazy(() => CategoryWhereInputSchema),
            ])
            .optional(),
        })
        .strict(),
    ) as z.ZodType<Prisma.ProductCategoryWhereUniqueInput>;

export const ProductCategoryOrderByWithAggregationInputSchema: z.ZodType<Prisma.ProductCategoryOrderByWithAggregationInput> =
  z
    .object({
      productID: z.lazy(() => SortOrderSchema).optional(),
      categoryID: z.lazy(() => SortOrderSchema).optional(),
      _count: z
        .lazy(() => ProductCategoryCountOrderByAggregateInputSchema)
        .optional(),
      _max: z
        .lazy(() => ProductCategoryMaxOrderByAggregateInputSchema)
        .optional(),
      _min: z
        .lazy(() => ProductCategoryMinOrderByAggregateInputSchema)
        .optional(),
    })
    .strict() as z.ZodType<Prisma.ProductCategoryOrderByWithAggregationInput>;

export const ProductCategoryScalarWhereWithAggregatesInputSchema: z.ZodType<Prisma.ProductCategoryScalarWhereWithAggregatesInput> =
  z
    .object({
      AND: z
        .union([
          z.lazy(() => ProductCategoryScalarWhereWithAggregatesInputSchema),
          z
            .lazy(() => ProductCategoryScalarWhereWithAggregatesInputSchema)
            .array(),
        ])
        .optional(),
      OR: z
        .lazy(() => ProductCategoryScalarWhereWithAggregatesInputSchema)
        .array()
        .optional(),
      NOT: z
        .union([
          z.lazy(() => ProductCategoryScalarWhereWithAggregatesInputSchema),
          z
            .lazy(() => ProductCategoryScalarWhereWithAggregatesInputSchema)
            .array(),
        ])
        .optional(),
      productID: z
        .union([z.lazy(() => StringWithAggregatesFilterSchema), z.string()])
        .optional(),
      categoryID: z
        .union([z.lazy(() => StringWithAggregatesFilterSchema), z.string()])
        .optional(),
    })
    .strict() as z.ZodType<Prisma.ProductCategoryScalarWhereWithAggregatesInput>;

export const ProductImageWhereInputSchema: z.ZodType<Prisma.ProductImageWhereInput> =
  z
    .object({
      AND: z
        .union([
          z.lazy(() => ProductImageWhereInputSchema),
          z.lazy(() => ProductImageWhereInputSchema).array(),
        ])
        .optional(),
      OR: z
        .lazy(() => ProductImageWhereInputSchema)
        .array()
        .optional(),
      NOT: z
        .union([
          z.lazy(() => ProductImageWhereInputSchema),
          z.lazy(() => ProductImageWhereInputSchema).array(),
        ])
        .optional(),
      id: z.union([z.lazy(() => StringFilterSchema), z.string()]).optional(),
      name: z.union([z.lazy(() => StringFilterSchema), z.string()]).optional(),
      description: z
        .union([z.lazy(() => StringNullableFilterSchema), z.string()])
        .optional()
        .nullable(),
      productID: z
        .union([z.lazy(() => StringNullableFilterSchema), z.string()])
        .optional()
        .nullable(),
      productVariantID: z
        .union([z.lazy(() => StringNullableFilterSchema), z.string()])
        .optional()
        .nullable(),
      imageUrl: z
        .union([z.lazy(() => StringFilterSchema), z.string()])
        .optional(),
      sortOrder: z
        .union([z.lazy(() => IntFilterSchema), z.number()])
        .optional(),
      createdAt: z
        .union([z.lazy(() => DateTimeFilterSchema), z.coerce.date()])
        .optional(),
      createdBy: z
        .union([z.lazy(() => StringNullableFilterSchema), z.string()])
        .optional()
        .nullable(),
      updatedAt: z
        .union([z.lazy(() => DateTimeFilterSchema), z.coerce.date()])
        .optional(),
      deletedAt: z
        .union([z.lazy(() => DateTimeNullableFilterSchema), z.coerce.date()])
        .optional()
        .nullable(),
      product: z
        .union([
          z.lazy(() => ProductNullableScalarRelationFilterSchema),
          z.lazy(() => ProductWhereInputSchema),
        ])
        .optional()
        .nullable(),
      productVariant: z
        .union([
          z.lazy(() => ProductVariantNullableScalarRelationFilterSchema),
          z.lazy(() => ProductVariantWhereInputSchema),
        ])
        .optional()
        .nullable(),
    })
    .strict() as z.ZodType<Prisma.ProductImageWhereInput>;

export const ProductImageOrderByWithRelationInputSchema: z.ZodType<Prisma.ProductImageOrderByWithRelationInput> =
  z
    .object({
      id: z.lazy(() => SortOrderSchema).optional(),
      name: z.lazy(() => SortOrderSchema).optional(),
      description: z
        .union([
          z.lazy(() => SortOrderSchema),
          z.lazy(() => SortOrderInputSchema),
        ])
        .optional(),
      productID: z
        .union([
          z.lazy(() => SortOrderSchema),
          z.lazy(() => SortOrderInputSchema),
        ])
        .optional(),
      productVariantID: z
        .union([
          z.lazy(() => SortOrderSchema),
          z.lazy(() => SortOrderInputSchema),
        ])
        .optional(),
      imageUrl: z.lazy(() => SortOrderSchema).optional(),
      sortOrder: z.lazy(() => SortOrderSchema).optional(),
      createdAt: z.lazy(() => SortOrderSchema).optional(),
      createdBy: z
        .union([
          z.lazy(() => SortOrderSchema),
          z.lazy(() => SortOrderInputSchema),
        ])
        .optional(),
      updatedAt: z.lazy(() => SortOrderSchema).optional(),
      deletedAt: z
        .union([
          z.lazy(() => SortOrderSchema),
          z.lazy(() => SortOrderInputSchema),
        ])
        .optional(),
      product: z.lazy(() => ProductOrderByWithRelationInputSchema).optional(),
      productVariant: z
        .lazy(() => ProductVariantOrderByWithRelationInputSchema)
        .optional(),
    })
    .strict() as z.ZodType<Prisma.ProductImageOrderByWithRelationInput>;

export const ProductImageWhereUniqueInputSchema: z.ZodType<Prisma.ProductImageWhereUniqueInput> =
  z
    .object({
      id: z.string().uuid(),
    })
    .and(
      z
        .object({
          id: z.string().uuid().optional(),
          AND: z
            .union([
              z.lazy(() => ProductImageWhereInputSchema),
              z.lazy(() => ProductImageWhereInputSchema).array(),
            ])
            .optional(),
          OR: z
            .lazy(() => ProductImageWhereInputSchema)
            .array()
            .optional(),
          NOT: z
            .union([
              z.lazy(() => ProductImageWhereInputSchema),
              z.lazy(() => ProductImageWhereInputSchema).array(),
            ])
            .optional(),
          name: z
            .union([z.lazy(() => StringFilterSchema), z.string()])
            .optional(),
          description: z
            .union([z.lazy(() => StringNullableFilterSchema), z.string()])
            .optional()
            .nullable(),
          productID: z
            .union([z.lazy(() => StringNullableFilterSchema), z.string()])
            .optional()
            .nullable(),
          productVariantID: z
            .union([z.lazy(() => StringNullableFilterSchema), z.string()])
            .optional()
            .nullable(),
          imageUrl: z
            .union([z.lazy(() => StringFilterSchema), z.string()])
            .optional(),
          sortOrder: z
            .union([z.lazy(() => IntFilterSchema), z.number().int()])
            .optional(),
          createdAt: z
            .union([z.lazy(() => DateTimeFilterSchema), z.coerce.date()])
            .optional(),
          createdBy: z
            .union([z.lazy(() => StringNullableFilterSchema), z.string()])
            .optional()
            .nullable(),
          updatedAt: z
            .union([z.lazy(() => DateTimeFilterSchema), z.coerce.date()])
            .optional(),
          deletedAt: z
            .union([
              z.lazy(() => DateTimeNullableFilterSchema),
              z.coerce.date(),
            ])
            .optional()
            .nullable(),
          product: z
            .union([
              z.lazy(() => ProductNullableScalarRelationFilterSchema),
              z.lazy(() => ProductWhereInputSchema),
            ])
            .optional()
            .nullable(),
          productVariant: z
            .union([
              z.lazy(() => ProductVariantNullableScalarRelationFilterSchema),
              z.lazy(() => ProductVariantWhereInputSchema),
            ])
            .optional()
            .nullable(),
        })
        .strict(),
    ) as z.ZodType<Prisma.ProductImageWhereUniqueInput>;

export const ProductImageOrderByWithAggregationInputSchema: z.ZodType<Prisma.ProductImageOrderByWithAggregationInput> =
  z
    .object({
      id: z.lazy(() => SortOrderSchema).optional(),
      name: z.lazy(() => SortOrderSchema).optional(),
      description: z
        .union([
          z.lazy(() => SortOrderSchema),
          z.lazy(() => SortOrderInputSchema),
        ])
        .optional(),
      productID: z
        .union([
          z.lazy(() => SortOrderSchema),
          z.lazy(() => SortOrderInputSchema),
        ])
        .optional(),
      productVariantID: z
        .union([
          z.lazy(() => SortOrderSchema),
          z.lazy(() => SortOrderInputSchema),
        ])
        .optional(),
      imageUrl: z.lazy(() => SortOrderSchema).optional(),
      sortOrder: z.lazy(() => SortOrderSchema).optional(),
      createdAt: z.lazy(() => SortOrderSchema).optional(),
      createdBy: z
        .union([
          z.lazy(() => SortOrderSchema),
          z.lazy(() => SortOrderInputSchema),
        ])
        .optional(),
      updatedAt: z.lazy(() => SortOrderSchema).optional(),
      deletedAt: z
        .union([
          z.lazy(() => SortOrderSchema),
          z.lazy(() => SortOrderInputSchema),
        ])
        .optional(),
      _count: z
        .lazy(() => ProductImageCountOrderByAggregateInputSchema)
        .optional(),
      _avg: z.lazy(() => ProductImageAvgOrderByAggregateInputSchema).optional(),
      _max: z.lazy(() => ProductImageMaxOrderByAggregateInputSchema).optional(),
      _min: z.lazy(() => ProductImageMinOrderByAggregateInputSchema).optional(),
      _sum: z.lazy(() => ProductImageSumOrderByAggregateInputSchema).optional(),
    })
    .strict() as z.ZodType<Prisma.ProductImageOrderByWithAggregationInput>;

export const ProductImageScalarWhereWithAggregatesInputSchema: z.ZodType<Prisma.ProductImageScalarWhereWithAggregatesInput> =
  z
    .object({
      AND: z
        .union([
          z.lazy(() => ProductImageScalarWhereWithAggregatesInputSchema),
          z
            .lazy(() => ProductImageScalarWhereWithAggregatesInputSchema)
            .array(),
        ])
        .optional(),
      OR: z
        .lazy(() => ProductImageScalarWhereWithAggregatesInputSchema)
        .array()
        .optional(),
      NOT: z
        .union([
          z.lazy(() => ProductImageScalarWhereWithAggregatesInputSchema),
          z
            .lazy(() => ProductImageScalarWhereWithAggregatesInputSchema)
            .array(),
        ])
        .optional(),
      id: z
        .union([z.lazy(() => StringWithAggregatesFilterSchema), z.string()])
        .optional(),
      name: z
        .union([z.lazy(() => StringWithAggregatesFilterSchema), z.string()])
        .optional(),
      description: z
        .union([
          z.lazy(() => StringNullableWithAggregatesFilterSchema),
          z.string(),
        ])
        .optional()
        .nullable(),
      productID: z
        .union([
          z.lazy(() => StringNullableWithAggregatesFilterSchema),
          z.string(),
        ])
        .optional()
        .nullable(),
      productVariantID: z
        .union([
          z.lazy(() => StringNullableWithAggregatesFilterSchema),
          z.string(),
        ])
        .optional()
        .nullable(),
      imageUrl: z
        .union([z.lazy(() => StringWithAggregatesFilterSchema), z.string()])
        .optional(),
      sortOrder: z
        .union([z.lazy(() => IntWithAggregatesFilterSchema), z.number()])
        .optional(),
      createdAt: z
        .union([
          z.lazy(() => DateTimeWithAggregatesFilterSchema),
          z.coerce.date(),
        ])
        .optional(),
      createdBy: z
        .union([
          z.lazy(() => StringNullableWithAggregatesFilterSchema),
          z.string(),
        ])
        .optional()
        .nullable(),
      updatedAt: z
        .union([
          z.lazy(() => DateTimeWithAggregatesFilterSchema),
          z.coerce.date(),
        ])
        .optional(),
      deletedAt: z
        .union([
          z.lazy(() => DateTimeNullableWithAggregatesFilterSchema),
          z.coerce.date(),
        ])
        .optional()
        .nullable(),
    })
    .strict() as z.ZodType<Prisma.ProductImageScalarWhereWithAggregatesInput>;

export const OrderWhereInputSchema: z.ZodType<Prisma.OrderWhereInput> = z
  .object({
    AND: z
      .union([
        z.lazy(() => OrderWhereInputSchema),
        z.lazy(() => OrderWhereInputSchema).array(),
      ])
      .optional(),
    OR: z
      .lazy(() => OrderWhereInputSchema)
      .array()
      .optional(),
    NOT: z
      .union([
        z.lazy(() => OrderWhereInputSchema),
        z.lazy(() => OrderWhereInputSchema).array(),
      ])
      .optional(),
    id: z.union([z.lazy(() => StringFilterSchema), z.string()]).optional(),
    orderNumber: z
      .union([z.lazy(() => StringFilterSchema), z.string()])
      .optional(),
    userID: z.union([z.lazy(() => StringFilterSchema), z.string()]).optional(),
    status: z
      .union([
        z.lazy(() => EnumOrderStatusFilterSchema),
        z.lazy(() => OrderStatusSchema),
      ])
      .optional(),
    subtotal: z
      .union([
        z.lazy(() => DecimalFilterSchema),
        z
          .union([
            z.number(),
            z.string(),
            z.instanceof(Decimal),
            z.instanceof(Prisma.Decimal),
            DecimalJsLikeSchema,
          ])
          .refine((v) => isValidDecimalInput(v), {
            message: 'Must be a Decimal',
          }),
      ])
      .optional(),
    taxAmount: z
      .union([
        z.lazy(() => DecimalFilterSchema),
        z
          .union([
            z.number(),
            z.string(),
            z.instanceof(Decimal),
            z.instanceof(Prisma.Decimal),
            DecimalJsLikeSchema,
          ])
          .refine((v) => isValidDecimalInput(v), {
            message: 'Must be a Decimal',
          }),
      ])
      .optional(),
    shippingAmount: z
      .union([
        z.lazy(() => DecimalFilterSchema),
        z
          .union([
            z.number(),
            z.string(),
            z.instanceof(Decimal),
            z.instanceof(Prisma.Decimal),
            DecimalJsLikeSchema,
          ])
          .refine((v) => isValidDecimalInput(v), {
            message: 'Must be a Decimal',
          }),
      ])
      .optional(),
    discountAmount: z
      .union([
        z.lazy(() => DecimalFilterSchema),
        z
          .union([
            z.number(),
            z.string(),
            z.instanceof(Decimal),
            z.instanceof(Prisma.Decimal),
            DecimalJsLikeSchema,
          ])
          .refine((v) => isValidDecimalInput(v), {
            message: 'Must be a Decimal',
          }),
      ])
      .optional(),
    totalAmount: z
      .union([
        z.lazy(() => DecimalFilterSchema),
        z
          .union([
            z.number(),
            z.string(),
            z.instanceof(Decimal),
            z.instanceof(Prisma.Decimal),
            DecimalJsLikeSchema,
          ])
          .refine((v) => isValidDecimalInput(v), {
            message: 'Must be a Decimal',
          }),
      ])
      .optional(),
    currency: z
      .union([z.lazy(() => StringFilterSchema), z.string()])
      .optional(),
    notes: z
      .union([z.lazy(() => StringNullableFilterSchema), z.string()])
      .optional()
      .nullable(),
    shippedAt: z
      .union([z.lazy(() => DateTimeNullableFilterSchema), z.coerce.date()])
      .optional()
      .nullable(),
    deliveredAt: z
      .union([z.lazy(() => DateTimeNullableFilterSchema), z.coerce.date()])
      .optional()
      .nullable(),
    createdAt: z
      .union([z.lazy(() => DateTimeFilterSchema), z.coerce.date()])
      .optional(),
    createdBy: z
      .union([z.lazy(() => StringNullableFilterSchema), z.string()])
      .optional()
      .nullable(),
    updatedAt: z
      .union([z.lazy(() => DateTimeFilterSchema), z.coerce.date()])
      .optional(),
    deletedAt: z
      .union([z.lazy(() => DateTimeNullableFilterSchema), z.coerce.date()])
      .optional()
      .nullable(),
    user: z
      .union([
        z.lazy(() => UserScalarRelationFilterSchema),
        z.lazy(() => UserWhereInputSchema),
      ])
      .optional(),
    orderItems: z.lazy(() => OrderItemListRelationFilterSchema).optional(),
    orderAddresses: z
      .lazy(() => OrderAddressListRelationFilterSchema)
      .optional(),
    orderPromotions: z
      .lazy(() => OrderPromotionListRelationFilterSchema)
      .optional(),
    payments: z.lazy(() => PaymentListRelationFilterSchema).optional(),
  })
  .strict() as z.ZodType<Prisma.OrderWhereInput>;

export const OrderOrderByWithRelationInputSchema: z.ZodType<Prisma.OrderOrderByWithRelationInput> =
  z
    .object({
      id: z.lazy(() => SortOrderSchema).optional(),
      orderNumber: z.lazy(() => SortOrderSchema).optional(),
      userID: z.lazy(() => SortOrderSchema).optional(),
      status: z.lazy(() => SortOrderSchema).optional(),
      subtotal: z.lazy(() => SortOrderSchema).optional(),
      taxAmount: z.lazy(() => SortOrderSchema).optional(),
      shippingAmount: z.lazy(() => SortOrderSchema).optional(),
      discountAmount: z.lazy(() => SortOrderSchema).optional(),
      totalAmount: z.lazy(() => SortOrderSchema).optional(),
      currency: z.lazy(() => SortOrderSchema).optional(),
      notes: z
        .union([
          z.lazy(() => SortOrderSchema),
          z.lazy(() => SortOrderInputSchema),
        ])
        .optional(),
      shippedAt: z
        .union([
          z.lazy(() => SortOrderSchema),
          z.lazy(() => SortOrderInputSchema),
        ])
        .optional(),
      deliveredAt: z
        .union([
          z.lazy(() => SortOrderSchema),
          z.lazy(() => SortOrderInputSchema),
        ])
        .optional(),
      createdAt: z.lazy(() => SortOrderSchema).optional(),
      createdBy: z
        .union([
          z.lazy(() => SortOrderSchema),
          z.lazy(() => SortOrderInputSchema),
        ])
        .optional(),
      updatedAt: z.lazy(() => SortOrderSchema).optional(),
      deletedAt: z
        .union([
          z.lazy(() => SortOrderSchema),
          z.lazy(() => SortOrderInputSchema),
        ])
        .optional(),
      user: z.lazy(() => UserOrderByWithRelationInputSchema).optional(),
      orderItems: z
        .lazy(() => OrderItemOrderByRelationAggregateInputSchema)
        .optional(),
      orderAddresses: z
        .lazy(() => OrderAddressOrderByRelationAggregateInputSchema)
        .optional(),
      orderPromotions: z
        .lazy(() => OrderPromotionOrderByRelationAggregateInputSchema)
        .optional(),
      payments: z
        .lazy(() => PaymentOrderByRelationAggregateInputSchema)
        .optional(),
    })
    .strict() as z.ZodType<Prisma.OrderOrderByWithRelationInput>;

export const OrderWhereUniqueInputSchema: z.ZodType<Prisma.OrderWhereUniqueInput> =
  z
    .union([
      z.object({
        id: z.string().uuid(),
        orderNumber: z.string(),
      }),
      z.object({
        id: z.string().uuid(),
      }),
      z.object({
        orderNumber: z.string(),
      }),
    ])
    .and(
      z
        .object({
          id: z.string().uuid().optional(),
          orderNumber: z.string().optional(),
          AND: z
            .union([
              z.lazy(() => OrderWhereInputSchema),
              z.lazy(() => OrderWhereInputSchema).array(),
            ])
            .optional(),
          OR: z
            .lazy(() => OrderWhereInputSchema)
            .array()
            .optional(),
          NOT: z
            .union([
              z.lazy(() => OrderWhereInputSchema),
              z.lazy(() => OrderWhereInputSchema).array(),
            ])
            .optional(),
          userID: z
            .union([z.lazy(() => StringFilterSchema), z.string()])
            .optional(),
          status: z
            .union([
              z.lazy(() => EnumOrderStatusFilterSchema),
              z.lazy(() => OrderStatusSchema),
            ])
            .optional(),
          subtotal: z
            .union([
              z.lazy(() => DecimalFilterSchema),
              z
                .union([
                  z.number(),
                  z.string(),
                  z.instanceof(Decimal),
                  z.instanceof(Prisma.Decimal),
                  DecimalJsLikeSchema,
                ])
                .refine((v) => isValidDecimalInput(v), {
                  message: 'Must be a Decimal',
                }),
            ])
            .optional(),
          taxAmount: z
            .union([
              z.lazy(() => DecimalFilterSchema),
              z
                .union([
                  z.number(),
                  z.string(),
                  z.instanceof(Decimal),
                  z.instanceof(Prisma.Decimal),
                  DecimalJsLikeSchema,
                ])
                .refine((v) => isValidDecimalInput(v), {
                  message: 'Must be a Decimal',
                }),
            ])
            .optional(),
          shippingAmount: z
            .union([
              z.lazy(() => DecimalFilterSchema),
              z
                .union([
                  z.number(),
                  z.string(),
                  z.instanceof(Decimal),
                  z.instanceof(Prisma.Decimal),
                  DecimalJsLikeSchema,
                ])
                .refine((v) => isValidDecimalInput(v), {
                  message: 'Must be a Decimal',
                }),
            ])
            .optional(),
          discountAmount: z
            .union([
              z.lazy(() => DecimalFilterSchema),
              z
                .union([
                  z.number(),
                  z.string(),
                  z.instanceof(Decimal),
                  z.instanceof(Prisma.Decimal),
                  DecimalJsLikeSchema,
                ])
                .refine((v) => isValidDecimalInput(v), {
                  message: 'Must be a Decimal',
                }),
            ])
            .optional(),
          totalAmount: z
            .union([
              z.lazy(() => DecimalFilterSchema),
              z
                .union([
                  z.number(),
                  z.string(),
                  z.instanceof(Decimal),
                  z.instanceof(Prisma.Decimal),
                  DecimalJsLikeSchema,
                ])
                .refine((v) => isValidDecimalInput(v), {
                  message: 'Must be a Decimal',
                }),
            ])
            .optional(),
          currency: z
            .union([z.lazy(() => StringFilterSchema), z.string()])
            .optional(),
          notes: z
            .union([z.lazy(() => StringNullableFilterSchema), z.string()])
            .optional()
            .nullable(),
          shippedAt: z
            .union([
              z.lazy(() => DateTimeNullableFilterSchema),
              z.coerce.date(),
            ])
            .optional()
            .nullable(),
          deliveredAt: z
            .union([
              z.lazy(() => DateTimeNullableFilterSchema),
              z.coerce.date(),
            ])
            .optional()
            .nullable(),
          createdAt: z
            .union([z.lazy(() => DateTimeFilterSchema), z.coerce.date()])
            .optional(),
          createdBy: z
            .union([z.lazy(() => StringNullableFilterSchema), z.string()])
            .optional()
            .nullable(),
          updatedAt: z
            .union([z.lazy(() => DateTimeFilterSchema), z.coerce.date()])
            .optional(),
          deletedAt: z
            .union([
              z.lazy(() => DateTimeNullableFilterSchema),
              z.coerce.date(),
            ])
            .optional()
            .nullable(),
          user: z
            .union([
              z.lazy(() => UserScalarRelationFilterSchema),
              z.lazy(() => UserWhereInputSchema),
            ])
            .optional(),
          orderItems: z
            .lazy(() => OrderItemListRelationFilterSchema)
            .optional(),
          orderAddresses: z
            .lazy(() => OrderAddressListRelationFilterSchema)
            .optional(),
          orderPromotions: z
            .lazy(() => OrderPromotionListRelationFilterSchema)
            .optional(),
          payments: z.lazy(() => PaymentListRelationFilterSchema).optional(),
        })
        .strict(),
    ) as z.ZodType<Prisma.OrderWhereUniqueInput>;

export const OrderOrderByWithAggregationInputSchema: z.ZodType<Prisma.OrderOrderByWithAggregationInput> =
  z
    .object({
      id: z.lazy(() => SortOrderSchema).optional(),
      orderNumber: z.lazy(() => SortOrderSchema).optional(),
      userID: z.lazy(() => SortOrderSchema).optional(),
      status: z.lazy(() => SortOrderSchema).optional(),
      subtotal: z.lazy(() => SortOrderSchema).optional(),
      taxAmount: z.lazy(() => SortOrderSchema).optional(),
      shippingAmount: z.lazy(() => SortOrderSchema).optional(),
      discountAmount: z.lazy(() => SortOrderSchema).optional(),
      totalAmount: z.lazy(() => SortOrderSchema).optional(),
      currency: z.lazy(() => SortOrderSchema).optional(),
      notes: z
        .union([
          z.lazy(() => SortOrderSchema),
          z.lazy(() => SortOrderInputSchema),
        ])
        .optional(),
      shippedAt: z
        .union([
          z.lazy(() => SortOrderSchema),
          z.lazy(() => SortOrderInputSchema),
        ])
        .optional(),
      deliveredAt: z
        .union([
          z.lazy(() => SortOrderSchema),
          z.lazy(() => SortOrderInputSchema),
        ])
        .optional(),
      createdAt: z.lazy(() => SortOrderSchema).optional(),
      createdBy: z
        .union([
          z.lazy(() => SortOrderSchema),
          z.lazy(() => SortOrderInputSchema),
        ])
        .optional(),
      updatedAt: z.lazy(() => SortOrderSchema).optional(),
      deletedAt: z
        .union([
          z.lazy(() => SortOrderSchema),
          z.lazy(() => SortOrderInputSchema),
        ])
        .optional(),
      _count: z.lazy(() => OrderCountOrderByAggregateInputSchema).optional(),
      _avg: z.lazy(() => OrderAvgOrderByAggregateInputSchema).optional(),
      _max: z.lazy(() => OrderMaxOrderByAggregateInputSchema).optional(),
      _min: z.lazy(() => OrderMinOrderByAggregateInputSchema).optional(),
      _sum: z.lazy(() => OrderSumOrderByAggregateInputSchema).optional(),
    })
    .strict() as z.ZodType<Prisma.OrderOrderByWithAggregationInput>;

export const OrderScalarWhereWithAggregatesInputSchema: z.ZodType<Prisma.OrderScalarWhereWithAggregatesInput> =
  z
    .object({
      AND: z
        .union([
          z.lazy(() => OrderScalarWhereWithAggregatesInputSchema),
          z.lazy(() => OrderScalarWhereWithAggregatesInputSchema).array(),
        ])
        .optional(),
      OR: z
        .lazy(() => OrderScalarWhereWithAggregatesInputSchema)
        .array()
        .optional(),
      NOT: z
        .union([
          z.lazy(() => OrderScalarWhereWithAggregatesInputSchema),
          z.lazy(() => OrderScalarWhereWithAggregatesInputSchema).array(),
        ])
        .optional(),
      id: z
        .union([z.lazy(() => StringWithAggregatesFilterSchema), z.string()])
        .optional(),
      orderNumber: z
        .union([z.lazy(() => StringWithAggregatesFilterSchema), z.string()])
        .optional(),
      userID: z
        .union([z.lazy(() => StringWithAggregatesFilterSchema), z.string()])
        .optional(),
      status: z
        .union([
          z.lazy(() => EnumOrderStatusWithAggregatesFilterSchema),
          z.lazy(() => OrderStatusSchema),
        ])
        .optional(),
      subtotal: z
        .union([
          z.lazy(() => DecimalWithAggregatesFilterSchema),
          z
            .union([
              z.number(),
              z.string(),
              z.instanceof(Decimal),
              z.instanceof(Prisma.Decimal),
              DecimalJsLikeSchema,
            ])
            .refine((v) => isValidDecimalInput(v), {
              message: 'Must be a Decimal',
            }),
        ])
        .optional(),
      taxAmount: z
        .union([
          z.lazy(() => DecimalWithAggregatesFilterSchema),
          z
            .union([
              z.number(),
              z.string(),
              z.instanceof(Decimal),
              z.instanceof(Prisma.Decimal),
              DecimalJsLikeSchema,
            ])
            .refine((v) => isValidDecimalInput(v), {
              message: 'Must be a Decimal',
            }),
        ])
        .optional(),
      shippingAmount: z
        .union([
          z.lazy(() => DecimalWithAggregatesFilterSchema),
          z
            .union([
              z.number(),
              z.string(),
              z.instanceof(Decimal),
              z.instanceof(Prisma.Decimal),
              DecimalJsLikeSchema,
            ])
            .refine((v) => isValidDecimalInput(v), {
              message: 'Must be a Decimal',
            }),
        ])
        .optional(),
      discountAmount: z
        .union([
          z.lazy(() => DecimalWithAggregatesFilterSchema),
          z
            .union([
              z.number(),
              z.string(),
              z.instanceof(Decimal),
              z.instanceof(Prisma.Decimal),
              DecimalJsLikeSchema,
            ])
            .refine((v) => isValidDecimalInput(v), {
              message: 'Must be a Decimal',
            }),
        ])
        .optional(),
      totalAmount: z
        .union([
          z.lazy(() => DecimalWithAggregatesFilterSchema),
          z
            .union([
              z.number(),
              z.string(),
              z.instanceof(Decimal),
              z.instanceof(Prisma.Decimal),
              DecimalJsLikeSchema,
            ])
            .refine((v) => isValidDecimalInput(v), {
              message: 'Must be a Decimal',
            }),
        ])
        .optional(),
      currency: z
        .union([z.lazy(() => StringWithAggregatesFilterSchema), z.string()])
        .optional(),
      notes: z
        .union([
          z.lazy(() => StringNullableWithAggregatesFilterSchema),
          z.string(),
        ])
        .optional()
        .nullable(),
      shippedAt: z
        .union([
          z.lazy(() => DateTimeNullableWithAggregatesFilterSchema),
          z.coerce.date(),
        ])
        .optional()
        .nullable(),
      deliveredAt: z
        .union([
          z.lazy(() => DateTimeNullableWithAggregatesFilterSchema),
          z.coerce.date(),
        ])
        .optional()
        .nullable(),
      createdAt: z
        .union([
          z.lazy(() => DateTimeWithAggregatesFilterSchema),
          z.coerce.date(),
        ])
        .optional(),
      createdBy: z
        .union([
          z.lazy(() => StringNullableWithAggregatesFilterSchema),
          z.string(),
        ])
        .optional()
        .nullable(),
      updatedAt: z
        .union([
          z.lazy(() => DateTimeWithAggregatesFilterSchema),
          z.coerce.date(),
        ])
        .optional(),
      deletedAt: z
        .union([
          z.lazy(() => DateTimeNullableWithAggregatesFilterSchema),
          z.coerce.date(),
        ])
        .optional()
        .nullable(),
    })
    .strict() as z.ZodType<Prisma.OrderScalarWhereWithAggregatesInput>;

export const OrderItemWhereInputSchema: z.ZodType<Prisma.OrderItemWhereInput> =
  z
    .object({
      AND: z
        .union([
          z.lazy(() => OrderItemWhereInputSchema),
          z.lazy(() => OrderItemWhereInputSchema).array(),
        ])
        .optional(),
      OR: z
        .lazy(() => OrderItemWhereInputSchema)
        .array()
        .optional(),
      NOT: z
        .union([
          z.lazy(() => OrderItemWhereInputSchema),
          z.lazy(() => OrderItemWhereInputSchema).array(),
        ])
        .optional(),
      id: z.union([z.lazy(() => StringFilterSchema), z.string()]).optional(),
      orderID: z
        .union([z.lazy(() => StringFilterSchema), z.string()])
        .optional(),
      productVariantID: z
        .union([z.lazy(() => StringFilterSchema), z.string()])
        .optional(),
      quantity: z.union([z.lazy(() => IntFilterSchema), z.number()]).optional(),
      unitPrice: z
        .union([
          z.lazy(() => DecimalFilterSchema),
          z
            .union([
              z.number(),
              z.string(),
              z.instanceof(Decimal),
              z.instanceof(Prisma.Decimal),
              DecimalJsLikeSchema,
            ])
            .refine((v) => isValidDecimalInput(v), {
              message: 'Must be a Decimal',
            }),
        ])
        .optional(),
      totalPrice: z
        .union([
          z.lazy(() => DecimalFilterSchema),
          z
            .union([
              z.number(),
              z.string(),
              z.instanceof(Decimal),
              z.instanceof(Prisma.Decimal),
              DecimalJsLikeSchema,
            ])
            .refine((v) => isValidDecimalInput(v), {
              message: 'Must be a Decimal',
            }),
        ])
        .optional(),
      productVariantSnapshot: z.lazy(() => JsonNullableFilterSchema).optional(),
      productVariant: z
        .union([
          z.lazy(() => ProductVariantScalarRelationFilterSchema),
          z.lazy(() => ProductVariantWhereInputSchema),
        ])
        .optional(),
      order: z
        .union([
          z.lazy(() => OrderScalarRelationFilterSchema),
          z.lazy(() => OrderWhereInputSchema),
        ])
        .optional(),
    })
    .strict() as z.ZodType<Prisma.OrderItemWhereInput>;

export const OrderItemOrderByWithRelationInputSchema: z.ZodType<Prisma.OrderItemOrderByWithRelationInput> =
  z
    .object({
      id: z.lazy(() => SortOrderSchema).optional(),
      orderID: z.lazy(() => SortOrderSchema).optional(),
      productVariantID: z.lazy(() => SortOrderSchema).optional(),
      quantity: z.lazy(() => SortOrderSchema).optional(),
      unitPrice: z.lazy(() => SortOrderSchema).optional(),
      totalPrice: z.lazy(() => SortOrderSchema).optional(),
      productVariantSnapshot: z
        .union([
          z.lazy(() => SortOrderSchema),
          z.lazy(() => SortOrderInputSchema),
        ])
        .optional(),
      productVariant: z
        .lazy(() => ProductVariantOrderByWithRelationInputSchema)
        .optional(),
      order: z.lazy(() => OrderOrderByWithRelationInputSchema).optional(),
    })
    .strict() as z.ZodType<Prisma.OrderItemOrderByWithRelationInput>;

export const OrderItemWhereUniqueInputSchema: z.ZodType<Prisma.OrderItemWhereUniqueInput> =
  z
    .object({
      id: z.string().uuid(),
    })
    .and(
      z
        .object({
          id: z.string().uuid().optional(),
          AND: z
            .union([
              z.lazy(() => OrderItemWhereInputSchema),
              z.lazy(() => OrderItemWhereInputSchema).array(),
            ])
            .optional(),
          OR: z
            .lazy(() => OrderItemWhereInputSchema)
            .array()
            .optional(),
          NOT: z
            .union([
              z.lazy(() => OrderItemWhereInputSchema),
              z.lazy(() => OrderItemWhereInputSchema).array(),
            ])
            .optional(),
          orderID: z
            .union([z.lazy(() => StringFilterSchema), z.string()])
            .optional(),
          productVariantID: z
            .union([z.lazy(() => StringFilterSchema), z.string()])
            .optional(),
          quantity: z
            .union([z.lazy(() => IntFilterSchema), z.number().int()])
            .optional(),
          unitPrice: z
            .union([
              z.lazy(() => DecimalFilterSchema),
              z
                .union([
                  z.number(),
                  z.string(),
                  z.instanceof(Decimal),
                  z.instanceof(Prisma.Decimal),
                  DecimalJsLikeSchema,
                ])
                .refine((v) => isValidDecimalInput(v), {
                  message: 'Must be a Decimal',
                }),
            ])
            .optional(),
          totalPrice: z
            .union([
              z.lazy(() => DecimalFilterSchema),
              z
                .union([
                  z.number(),
                  z.string(),
                  z.instanceof(Decimal),
                  z.instanceof(Prisma.Decimal),
                  DecimalJsLikeSchema,
                ])
                .refine((v) => isValidDecimalInput(v), {
                  message: 'Must be a Decimal',
                }),
            ])
            .optional(),
          productVariantSnapshot: z
            .lazy(() => JsonNullableFilterSchema)
            .optional(),
          productVariant: z
            .union([
              z.lazy(() => ProductVariantScalarRelationFilterSchema),
              z.lazy(() => ProductVariantWhereInputSchema),
            ])
            .optional(),
          order: z
            .union([
              z.lazy(() => OrderScalarRelationFilterSchema),
              z.lazy(() => OrderWhereInputSchema),
            ])
            .optional(),
        })
        .strict(),
    ) as z.ZodType<Prisma.OrderItemWhereUniqueInput>;

export const OrderItemOrderByWithAggregationInputSchema: z.ZodType<Prisma.OrderItemOrderByWithAggregationInput> =
  z
    .object({
      id: z.lazy(() => SortOrderSchema).optional(),
      orderID: z.lazy(() => SortOrderSchema).optional(),
      productVariantID: z.lazy(() => SortOrderSchema).optional(),
      quantity: z.lazy(() => SortOrderSchema).optional(),
      unitPrice: z.lazy(() => SortOrderSchema).optional(),
      totalPrice: z.lazy(() => SortOrderSchema).optional(),
      productVariantSnapshot: z
        .union([
          z.lazy(() => SortOrderSchema),
          z.lazy(() => SortOrderInputSchema),
        ])
        .optional(),
      _count: z
        .lazy(() => OrderItemCountOrderByAggregateInputSchema)
        .optional(),
      _avg: z.lazy(() => OrderItemAvgOrderByAggregateInputSchema).optional(),
      _max: z.lazy(() => OrderItemMaxOrderByAggregateInputSchema).optional(),
      _min: z.lazy(() => OrderItemMinOrderByAggregateInputSchema).optional(),
      _sum: z.lazy(() => OrderItemSumOrderByAggregateInputSchema).optional(),
    })
    .strict() as z.ZodType<Prisma.OrderItemOrderByWithAggregationInput>;

export const OrderItemScalarWhereWithAggregatesInputSchema: z.ZodType<Prisma.OrderItemScalarWhereWithAggregatesInput> =
  z
    .object({
      AND: z
        .union([
          z.lazy(() => OrderItemScalarWhereWithAggregatesInputSchema),
          z.lazy(() => OrderItemScalarWhereWithAggregatesInputSchema).array(),
        ])
        .optional(),
      OR: z
        .lazy(() => OrderItemScalarWhereWithAggregatesInputSchema)
        .array()
        .optional(),
      NOT: z
        .union([
          z.lazy(() => OrderItemScalarWhereWithAggregatesInputSchema),
          z.lazy(() => OrderItemScalarWhereWithAggregatesInputSchema).array(),
        ])
        .optional(),
      id: z
        .union([z.lazy(() => StringWithAggregatesFilterSchema), z.string()])
        .optional(),
      orderID: z
        .union([z.lazy(() => StringWithAggregatesFilterSchema), z.string()])
        .optional(),
      productVariantID: z
        .union([z.lazy(() => StringWithAggregatesFilterSchema), z.string()])
        .optional(),
      quantity: z
        .union([z.lazy(() => IntWithAggregatesFilterSchema), z.number()])
        .optional(),
      unitPrice: z
        .union([
          z.lazy(() => DecimalWithAggregatesFilterSchema),
          z
            .union([
              z.number(),
              z.string(),
              z.instanceof(Decimal),
              z.instanceof(Prisma.Decimal),
              DecimalJsLikeSchema,
            ])
            .refine((v) => isValidDecimalInput(v), {
              message: 'Must be a Decimal',
            }),
        ])
        .optional(),
      totalPrice: z
        .union([
          z.lazy(() => DecimalWithAggregatesFilterSchema),
          z
            .union([
              z.number(),
              z.string(),
              z.instanceof(Decimal),
              z.instanceof(Prisma.Decimal),
              DecimalJsLikeSchema,
            ])
            .refine((v) => isValidDecimalInput(v), {
              message: 'Must be a Decimal',
            }),
        ])
        .optional(),
      productVariantSnapshot: z
        .lazy(() => JsonNullableWithAggregatesFilterSchema)
        .optional(),
    })
    .strict() as z.ZodType<Prisma.OrderItemScalarWhereWithAggregatesInput>;

export const OrderAddressWhereInputSchema: z.ZodType<Prisma.OrderAddressWhereInput> =
  z
    .object({
      AND: z
        .union([
          z.lazy(() => OrderAddressWhereInputSchema),
          z.lazy(() => OrderAddressWhereInputSchema).array(),
        ])
        .optional(),
      OR: z
        .lazy(() => OrderAddressWhereInputSchema)
        .array()
        .optional(),
      NOT: z
        .union([
          z.lazy(() => OrderAddressWhereInputSchema),
          z.lazy(() => OrderAddressWhereInputSchema).array(),
        ])
        .optional(),
      id: z.union([z.lazy(() => StringFilterSchema), z.string()]).optional(),
      orderID: z
        .union([z.lazy(() => StringFilterSchema), z.string()])
        .optional(),
      type: z
        .union([
          z.lazy(() => EnumAddressTypeFilterSchema),
          z.lazy(() => AddressTypeSchema),
        ])
        .optional(),
      firstName: z
        .union([z.lazy(() => StringFilterSchema), z.string()])
        .optional(),
      lastName: z
        .union([z.lazy(() => StringNullableFilterSchema), z.string()])
        .optional()
        .nullable(),
      company: z
        .union([z.lazy(() => StringNullableFilterSchema), z.string()])
        .optional()
        .nullable(),
      fullAddress: z
        .union([z.lazy(() => StringFilterSchema), z.string()])
        .optional(),
      city: z
        .union([z.lazy(() => StringNullableFilterSchema), z.string()])
        .optional()
        .nullable(),
      province: z
        .union([z.lazy(() => StringNullableFilterSchema), z.string()])
        .optional()
        .nullable(),
      country: z
        .union([z.lazy(() => StringNullableFilterSchema), z.string()])
        .optional()
        .nullable(),
      phone: z.union([z.lazy(() => StringFilterSchema), z.string()]).optional(),
      order: z
        .union([
          z.lazy(() => OrderScalarRelationFilterSchema),
          z.lazy(() => OrderWhereInputSchema),
        ])
        .optional(),
    })
    .strict() as z.ZodType<Prisma.OrderAddressWhereInput>;

export const OrderAddressOrderByWithRelationInputSchema: z.ZodType<Prisma.OrderAddressOrderByWithRelationInput> =
  z
    .object({
      id: z.lazy(() => SortOrderSchema).optional(),
      orderID: z.lazy(() => SortOrderSchema).optional(),
      type: z.lazy(() => SortOrderSchema).optional(),
      firstName: z.lazy(() => SortOrderSchema).optional(),
      lastName: z
        .union([
          z.lazy(() => SortOrderSchema),
          z.lazy(() => SortOrderInputSchema),
        ])
        .optional(),
      company: z
        .union([
          z.lazy(() => SortOrderSchema),
          z.lazy(() => SortOrderInputSchema),
        ])
        .optional(),
      fullAddress: z.lazy(() => SortOrderSchema).optional(),
      city: z
        .union([
          z.lazy(() => SortOrderSchema),
          z.lazy(() => SortOrderInputSchema),
        ])
        .optional(),
      province: z
        .union([
          z.lazy(() => SortOrderSchema),
          z.lazy(() => SortOrderInputSchema),
        ])
        .optional(),
      country: z
        .union([
          z.lazy(() => SortOrderSchema),
          z.lazy(() => SortOrderInputSchema),
        ])
        .optional(),
      phone: z.lazy(() => SortOrderSchema).optional(),
      order: z.lazy(() => OrderOrderByWithRelationInputSchema).optional(),
    })
    .strict() as z.ZodType<Prisma.OrderAddressOrderByWithRelationInput>;

export const OrderAddressWhereUniqueInputSchema: z.ZodType<Prisma.OrderAddressWhereUniqueInput> =
  z
    .object({
      id: z.string().uuid(),
    })
    .and(
      z
        .object({
          id: z.string().uuid().optional(),
          AND: z
            .union([
              z.lazy(() => OrderAddressWhereInputSchema),
              z.lazy(() => OrderAddressWhereInputSchema).array(),
            ])
            .optional(),
          OR: z
            .lazy(() => OrderAddressWhereInputSchema)
            .array()
            .optional(),
          NOT: z
            .union([
              z.lazy(() => OrderAddressWhereInputSchema),
              z.lazy(() => OrderAddressWhereInputSchema).array(),
            ])
            .optional(),
          orderID: z
            .union([z.lazy(() => StringFilterSchema), z.string()])
            .optional(),
          type: z
            .union([
              z.lazy(() => EnumAddressTypeFilterSchema),
              z.lazy(() => AddressTypeSchema),
            ])
            .optional(),
          firstName: z
            .union([z.lazy(() => StringFilterSchema), z.string()])
            .optional(),
          lastName: z
            .union([z.lazy(() => StringNullableFilterSchema), z.string()])
            .optional()
            .nullable(),
          company: z
            .union([z.lazy(() => StringNullableFilterSchema), z.string()])
            .optional()
            .nullable(),
          fullAddress: z
            .union([z.lazy(() => StringFilterSchema), z.string()])
            .optional(),
          city: z
            .union([z.lazy(() => StringNullableFilterSchema), z.string()])
            .optional()
            .nullable(),
          province: z
            .union([z.lazy(() => StringNullableFilterSchema), z.string()])
            .optional()
            .nullable(),
          country: z
            .union([z.lazy(() => StringNullableFilterSchema), z.string()])
            .optional()
            .nullable(),
          phone: z
            .union([z.lazy(() => StringFilterSchema), z.string()])
            .optional(),
          order: z
            .union([
              z.lazy(() => OrderScalarRelationFilterSchema),
              z.lazy(() => OrderWhereInputSchema),
            ])
            .optional(),
        })
        .strict(),
    ) as z.ZodType<Prisma.OrderAddressWhereUniqueInput>;

export const OrderAddressOrderByWithAggregationInputSchema: z.ZodType<Prisma.OrderAddressOrderByWithAggregationInput> =
  z
    .object({
      id: z.lazy(() => SortOrderSchema).optional(),
      orderID: z.lazy(() => SortOrderSchema).optional(),
      type: z.lazy(() => SortOrderSchema).optional(),
      firstName: z.lazy(() => SortOrderSchema).optional(),
      lastName: z
        .union([
          z.lazy(() => SortOrderSchema),
          z.lazy(() => SortOrderInputSchema),
        ])
        .optional(),
      company: z
        .union([
          z.lazy(() => SortOrderSchema),
          z.lazy(() => SortOrderInputSchema),
        ])
        .optional(),
      fullAddress: z.lazy(() => SortOrderSchema).optional(),
      city: z
        .union([
          z.lazy(() => SortOrderSchema),
          z.lazy(() => SortOrderInputSchema),
        ])
        .optional(),
      province: z
        .union([
          z.lazy(() => SortOrderSchema),
          z.lazy(() => SortOrderInputSchema),
        ])
        .optional(),
      country: z
        .union([
          z.lazy(() => SortOrderSchema),
          z.lazy(() => SortOrderInputSchema),
        ])
        .optional(),
      phone: z.lazy(() => SortOrderSchema).optional(),
      _count: z
        .lazy(() => OrderAddressCountOrderByAggregateInputSchema)
        .optional(),
      _max: z.lazy(() => OrderAddressMaxOrderByAggregateInputSchema).optional(),
      _min: z.lazy(() => OrderAddressMinOrderByAggregateInputSchema).optional(),
    })
    .strict() as z.ZodType<Prisma.OrderAddressOrderByWithAggregationInput>;

export const OrderAddressScalarWhereWithAggregatesInputSchema: z.ZodType<Prisma.OrderAddressScalarWhereWithAggregatesInput> =
  z
    .object({
      AND: z
        .union([
          z.lazy(() => OrderAddressScalarWhereWithAggregatesInputSchema),
          z
            .lazy(() => OrderAddressScalarWhereWithAggregatesInputSchema)
            .array(),
        ])
        .optional(),
      OR: z
        .lazy(() => OrderAddressScalarWhereWithAggregatesInputSchema)
        .array()
        .optional(),
      NOT: z
        .union([
          z.lazy(() => OrderAddressScalarWhereWithAggregatesInputSchema),
          z
            .lazy(() => OrderAddressScalarWhereWithAggregatesInputSchema)
            .array(),
        ])
        .optional(),
      id: z
        .union([z.lazy(() => StringWithAggregatesFilterSchema), z.string()])
        .optional(),
      orderID: z
        .union([z.lazy(() => StringWithAggregatesFilterSchema), z.string()])
        .optional(),
      type: z
        .union([
          z.lazy(() => EnumAddressTypeWithAggregatesFilterSchema),
          z.lazy(() => AddressTypeSchema),
        ])
        .optional(),
      firstName: z
        .union([z.lazy(() => StringWithAggregatesFilterSchema), z.string()])
        .optional(),
      lastName: z
        .union([
          z.lazy(() => StringNullableWithAggregatesFilterSchema),
          z.string(),
        ])
        .optional()
        .nullable(),
      company: z
        .union([
          z.lazy(() => StringNullableWithAggregatesFilterSchema),
          z.string(),
        ])
        .optional()
        .nullable(),
      fullAddress: z
        .union([z.lazy(() => StringWithAggregatesFilterSchema), z.string()])
        .optional(),
      city: z
        .union([
          z.lazy(() => StringNullableWithAggregatesFilterSchema),
          z.string(),
        ])
        .optional()
        .nullable(),
      province: z
        .union([
          z.lazy(() => StringNullableWithAggregatesFilterSchema),
          z.string(),
        ])
        .optional()
        .nullable(),
      country: z
        .union([
          z.lazy(() => StringNullableWithAggregatesFilterSchema),
          z.string(),
        ])
        .optional()
        .nullable(),
      phone: z
        .union([z.lazy(() => StringWithAggregatesFilterSchema), z.string()])
        .optional(),
    })
    .strict() as z.ZodType<Prisma.OrderAddressScalarWhereWithAggregatesInput>;

export const PromotionWhereInputSchema: z.ZodType<Prisma.PromotionWhereInput> =
  z
    .object({
      AND: z
        .union([
          z.lazy(() => PromotionWhereInputSchema),
          z.lazy(() => PromotionWhereInputSchema).array(),
        ])
        .optional(),
      OR: z
        .lazy(() => PromotionWhereInputSchema)
        .array()
        .optional(),
      NOT: z
        .union([
          z.lazy(() => PromotionWhereInputSchema),
          z.lazy(() => PromotionWhereInputSchema).array(),
        ])
        .optional(),
      id: z.union([z.lazy(() => StringFilterSchema), z.string()]).optional(),
      code: z.union([z.lazy(() => StringFilterSchema), z.string()]).optional(),
      name: z.union([z.lazy(() => StringFilterSchema), z.string()]).optional(),
      description: z
        .union([z.lazy(() => StringNullableFilterSchema), z.string()])
        .optional()
        .nullable(),
      type: z
        .union([
          z.lazy(() => EnumPromotionTypeFilterSchema),
          z.lazy(() => PromotionTypeSchema),
        ])
        .optional(),
      value: z
        .union([
          z.lazy(() => DecimalFilterSchema),
          z
            .union([
              z.number(),
              z.string(),
              z.instanceof(Decimal),
              z.instanceof(Prisma.Decimal),
              DecimalJsLikeSchema,
            ])
            .refine((v) => isValidDecimalInput(v), {
              message: 'Must be a Decimal',
            }),
        ])
        .optional(),
      usageLimit: z
        .union([z.lazy(() => IntNullableFilterSchema), z.number()])
        .optional()
        .nullable(),
      startDate: z
        .union([z.lazy(() => DateTimeFilterSchema), z.coerce.date()])
        .optional(),
      endDate: z
        .union([z.lazy(() => DateTimeNullableFilterSchema), z.coerce.date()])
        .optional()
        .nullable(),
      status: z
        .union([
          z.lazy(() => EnumPromotionStatusFilterSchema),
          z.lazy(() => PromotionStatusSchema),
        ])
        .optional(),
      createdAt: z
        .union([z.lazy(() => DateTimeFilterSchema), z.coerce.date()])
        .optional(),
      createdBy: z
        .union([z.lazy(() => StringNullableFilterSchema), z.string()])
        .optional()
        .nullable(),
      updatedAt: z
        .union([z.lazy(() => DateTimeFilterSchema), z.coerce.date()])
        .optional(),
      deletedAt: z
        .union([z.lazy(() => DateTimeNullableFilterSchema), z.coerce.date()])
        .optional()
        .nullable(),
      orderPromotions: z
        .lazy(() => OrderPromotionListRelationFilterSchema)
        .optional(),
    })
    .strict() as z.ZodType<Prisma.PromotionWhereInput>;

export const PromotionOrderByWithRelationInputSchema: z.ZodType<Prisma.PromotionOrderByWithRelationInput> =
  z
    .object({
      id: z.lazy(() => SortOrderSchema).optional(),
      code: z.lazy(() => SortOrderSchema).optional(),
      name: z.lazy(() => SortOrderSchema).optional(),
      description: z
        .union([
          z.lazy(() => SortOrderSchema),
          z.lazy(() => SortOrderInputSchema),
        ])
        .optional(),
      type: z.lazy(() => SortOrderSchema).optional(),
      value: z.lazy(() => SortOrderSchema).optional(),
      usageLimit: z
        .union([
          z.lazy(() => SortOrderSchema),
          z.lazy(() => SortOrderInputSchema),
        ])
        .optional(),
      startDate: z.lazy(() => SortOrderSchema).optional(),
      endDate: z
        .union([
          z.lazy(() => SortOrderSchema),
          z.lazy(() => SortOrderInputSchema),
        ])
        .optional(),
      status: z.lazy(() => SortOrderSchema).optional(),
      createdAt: z.lazy(() => SortOrderSchema).optional(),
      createdBy: z
        .union([
          z.lazy(() => SortOrderSchema),
          z.lazy(() => SortOrderInputSchema),
        ])
        .optional(),
      updatedAt: z.lazy(() => SortOrderSchema).optional(),
      deletedAt: z
        .union([
          z.lazy(() => SortOrderSchema),
          z.lazy(() => SortOrderInputSchema),
        ])
        .optional(),
      orderPromotions: z
        .lazy(() => OrderPromotionOrderByRelationAggregateInputSchema)
        .optional(),
    })
    .strict() as z.ZodType<Prisma.PromotionOrderByWithRelationInput>;

export const PromotionWhereUniqueInputSchema: z.ZodType<Prisma.PromotionWhereUniqueInput> =
  z
    .union([
      z.object({
        id: z.string().uuid(),
        code: z.string(),
      }),
      z.object({
        id: z.string().uuid(),
      }),
      z.object({
        code: z.string(),
      }),
    ])
    .and(
      z
        .object({
          id: z.string().uuid().optional(),
          code: z.string().optional(),
          AND: z
            .union([
              z.lazy(() => PromotionWhereInputSchema),
              z.lazy(() => PromotionWhereInputSchema).array(),
            ])
            .optional(),
          OR: z
            .lazy(() => PromotionWhereInputSchema)
            .array()
            .optional(),
          NOT: z
            .union([
              z.lazy(() => PromotionWhereInputSchema),
              z.lazy(() => PromotionWhereInputSchema).array(),
            ])
            .optional(),
          name: z
            .union([z.lazy(() => StringFilterSchema), z.string()])
            .optional(),
          description: z
            .union([z.lazy(() => StringNullableFilterSchema), z.string()])
            .optional()
            .nullable(),
          type: z
            .union([
              z.lazy(() => EnumPromotionTypeFilterSchema),
              z.lazy(() => PromotionTypeSchema),
            ])
            .optional(),
          value: z
            .union([
              z.lazy(() => DecimalFilterSchema),
              z
                .union([
                  z.number(),
                  z.string(),
                  z.instanceof(Decimal),
                  z.instanceof(Prisma.Decimal),
                  DecimalJsLikeSchema,
                ])
                .refine((v) => isValidDecimalInput(v), {
                  message: 'Must be a Decimal',
                }),
            ])
            .optional(),
          usageLimit: z
            .union([z.lazy(() => IntNullableFilterSchema), z.number().int()])
            .optional()
            .nullable(),
          startDate: z
            .union([z.lazy(() => DateTimeFilterSchema), z.coerce.date()])
            .optional(),
          endDate: z
            .union([
              z.lazy(() => DateTimeNullableFilterSchema),
              z.coerce.date(),
            ])
            .optional()
            .nullable(),
          status: z
            .union([
              z.lazy(() => EnumPromotionStatusFilterSchema),
              z.lazy(() => PromotionStatusSchema),
            ])
            .optional(),
          createdAt: z
            .union([z.lazy(() => DateTimeFilterSchema), z.coerce.date()])
            .optional(),
          createdBy: z
            .union([z.lazy(() => StringNullableFilterSchema), z.string()])
            .optional()
            .nullable(),
          updatedAt: z
            .union([z.lazy(() => DateTimeFilterSchema), z.coerce.date()])
            .optional(),
          deletedAt: z
            .union([
              z.lazy(() => DateTimeNullableFilterSchema),
              z.coerce.date(),
            ])
            .optional()
            .nullable(),
          orderPromotions: z
            .lazy(() => OrderPromotionListRelationFilterSchema)
            .optional(),
        })
        .strict(),
    ) as z.ZodType<Prisma.PromotionWhereUniqueInput>;

export const PromotionOrderByWithAggregationInputSchema: z.ZodType<Prisma.PromotionOrderByWithAggregationInput> =
  z
    .object({
      id: z.lazy(() => SortOrderSchema).optional(),
      code: z.lazy(() => SortOrderSchema).optional(),
      name: z.lazy(() => SortOrderSchema).optional(),
      description: z
        .union([
          z.lazy(() => SortOrderSchema),
          z.lazy(() => SortOrderInputSchema),
        ])
        .optional(),
      type: z.lazy(() => SortOrderSchema).optional(),
      value: z.lazy(() => SortOrderSchema).optional(),
      usageLimit: z
        .union([
          z.lazy(() => SortOrderSchema),
          z.lazy(() => SortOrderInputSchema),
        ])
        .optional(),
      startDate: z.lazy(() => SortOrderSchema).optional(),
      endDate: z
        .union([
          z.lazy(() => SortOrderSchema),
          z.lazy(() => SortOrderInputSchema),
        ])
        .optional(),
      status: z.lazy(() => SortOrderSchema).optional(),
      createdAt: z.lazy(() => SortOrderSchema).optional(),
      createdBy: z
        .union([
          z.lazy(() => SortOrderSchema),
          z.lazy(() => SortOrderInputSchema),
        ])
        .optional(),
      updatedAt: z.lazy(() => SortOrderSchema).optional(),
      deletedAt: z
        .union([
          z.lazy(() => SortOrderSchema),
          z.lazy(() => SortOrderInputSchema),
        ])
        .optional(),
      _count: z
        .lazy(() => PromotionCountOrderByAggregateInputSchema)
        .optional(),
      _avg: z.lazy(() => PromotionAvgOrderByAggregateInputSchema).optional(),
      _max: z.lazy(() => PromotionMaxOrderByAggregateInputSchema).optional(),
      _min: z.lazy(() => PromotionMinOrderByAggregateInputSchema).optional(),
      _sum: z.lazy(() => PromotionSumOrderByAggregateInputSchema).optional(),
    })
    .strict() as z.ZodType<Prisma.PromotionOrderByWithAggregationInput>;

export const PromotionScalarWhereWithAggregatesInputSchema: z.ZodType<Prisma.PromotionScalarWhereWithAggregatesInput> =
  z
    .object({
      AND: z
        .union([
          z.lazy(() => PromotionScalarWhereWithAggregatesInputSchema),
          z.lazy(() => PromotionScalarWhereWithAggregatesInputSchema).array(),
        ])
        .optional(),
      OR: z
        .lazy(() => PromotionScalarWhereWithAggregatesInputSchema)
        .array()
        .optional(),
      NOT: z
        .union([
          z.lazy(() => PromotionScalarWhereWithAggregatesInputSchema),
          z.lazy(() => PromotionScalarWhereWithAggregatesInputSchema).array(),
        ])
        .optional(),
      id: z
        .union([z.lazy(() => StringWithAggregatesFilterSchema), z.string()])
        .optional(),
      code: z
        .union([z.lazy(() => StringWithAggregatesFilterSchema), z.string()])
        .optional(),
      name: z
        .union([z.lazy(() => StringWithAggregatesFilterSchema), z.string()])
        .optional(),
      description: z
        .union([
          z.lazy(() => StringNullableWithAggregatesFilterSchema),
          z.string(),
        ])
        .optional()
        .nullable(),
      type: z
        .union([
          z.lazy(() => EnumPromotionTypeWithAggregatesFilterSchema),
          z.lazy(() => PromotionTypeSchema),
        ])
        .optional(),
      value: z
        .union([
          z.lazy(() => DecimalWithAggregatesFilterSchema),
          z
            .union([
              z.number(),
              z.string(),
              z.instanceof(Decimal),
              z.instanceof(Prisma.Decimal),
              DecimalJsLikeSchema,
            ])
            .refine((v) => isValidDecimalInput(v), {
              message: 'Must be a Decimal',
            }),
        ])
        .optional(),
      usageLimit: z
        .union([
          z.lazy(() => IntNullableWithAggregatesFilterSchema),
          z.number(),
        ])
        .optional()
        .nullable(),
      startDate: z
        .union([
          z.lazy(() => DateTimeWithAggregatesFilterSchema),
          z.coerce.date(),
        ])
        .optional(),
      endDate: z
        .union([
          z.lazy(() => DateTimeNullableWithAggregatesFilterSchema),
          z.coerce.date(),
        ])
        .optional()
        .nullable(),
      status: z
        .union([
          z.lazy(() => EnumPromotionStatusWithAggregatesFilterSchema),
          z.lazy(() => PromotionStatusSchema),
        ])
        .optional(),
      createdAt: z
        .union([
          z.lazy(() => DateTimeWithAggregatesFilterSchema),
          z.coerce.date(),
        ])
        .optional(),
      createdBy: z
        .union([
          z.lazy(() => StringNullableWithAggregatesFilterSchema),
          z.string(),
        ])
        .optional()
        .nullable(),
      updatedAt: z
        .union([
          z.lazy(() => DateTimeWithAggregatesFilterSchema),
          z.coerce.date(),
        ])
        .optional(),
      deletedAt: z
        .union([
          z.lazy(() => DateTimeNullableWithAggregatesFilterSchema),
          z.coerce.date(),
        ])
        .optional()
        .nullable(),
    })
    .strict() as z.ZodType<Prisma.PromotionScalarWhereWithAggregatesInput>;

export const OrderPromotionWhereInputSchema: z.ZodType<Prisma.OrderPromotionWhereInput> =
  z
    .object({
      AND: z
        .union([
          z.lazy(() => OrderPromotionWhereInputSchema),
          z.lazy(() => OrderPromotionWhereInputSchema).array(),
        ])
        .optional(),
      OR: z
        .lazy(() => OrderPromotionWhereInputSchema)
        .array()
        .optional(),
      NOT: z
        .union([
          z.lazy(() => OrderPromotionWhereInputSchema),
          z.lazy(() => OrderPromotionWhereInputSchema).array(),
        ])
        .optional(),
      id: z.union([z.lazy(() => StringFilterSchema), z.string()]).optional(),
      orderID: z
        .union([z.lazy(() => StringFilterSchema), z.string()])
        .optional(),
      promotionID: z
        .union([z.lazy(() => StringFilterSchema), z.string()])
        .optional(),
      discountAmount: z
        .union([
          z.lazy(() => DecimalFilterSchema),
          z
            .union([
              z.number(),
              z.string(),
              z.instanceof(Decimal),
              z.instanceof(Prisma.Decimal),
              DecimalJsLikeSchema,
            ])
            .refine((v) => isValidDecimalInput(v), {
              message: 'Must be a Decimal',
            }),
        ])
        .optional(),
      order: z
        .union([
          z.lazy(() => OrderScalarRelationFilterSchema),
          z.lazy(() => OrderWhereInputSchema),
        ])
        .optional(),
      promotion: z
        .union([
          z.lazy(() => PromotionScalarRelationFilterSchema),
          z.lazy(() => PromotionWhereInputSchema),
        ])
        .optional(),
    })
    .strict() as z.ZodType<Prisma.OrderPromotionWhereInput>;

export const OrderPromotionOrderByWithRelationInputSchema: z.ZodType<Prisma.OrderPromotionOrderByWithRelationInput> =
  z
    .object({
      id: z.lazy(() => SortOrderSchema).optional(),
      orderID: z.lazy(() => SortOrderSchema).optional(),
      promotionID: z.lazy(() => SortOrderSchema).optional(),
      discountAmount: z.lazy(() => SortOrderSchema).optional(),
      order: z.lazy(() => OrderOrderByWithRelationInputSchema).optional(),
      promotion: z
        .lazy(() => PromotionOrderByWithRelationInputSchema)
        .optional(),
    })
    .strict() as z.ZodType<Prisma.OrderPromotionOrderByWithRelationInput>;

export const OrderPromotionWhereUniqueInputSchema: z.ZodType<Prisma.OrderPromotionWhereUniqueInput> =
  z
    .union([
      z.object({
        id: z.string().uuid(),
        orderID_promotionID: z.lazy(
          () => OrderPromotionOrderIDPromotionIDCompoundUniqueInputSchema,
        ),
      }),
      z.object({
        id: z.string().uuid(),
      }),
      z.object({
        orderID_promotionID: z.lazy(
          () => OrderPromotionOrderIDPromotionIDCompoundUniqueInputSchema,
        ),
      }),
    ])
    .and(
      z
        .object({
          id: z.string().uuid().optional(),
          orderID_promotionID: z
            .lazy(
              () => OrderPromotionOrderIDPromotionIDCompoundUniqueInputSchema,
            )
            .optional(),
          AND: z
            .union([
              z.lazy(() => OrderPromotionWhereInputSchema),
              z.lazy(() => OrderPromotionWhereInputSchema).array(),
            ])
            .optional(),
          OR: z
            .lazy(() => OrderPromotionWhereInputSchema)
            .array()
            .optional(),
          NOT: z
            .union([
              z.lazy(() => OrderPromotionWhereInputSchema),
              z.lazy(() => OrderPromotionWhereInputSchema).array(),
            ])
            .optional(),
          orderID: z
            .union([z.lazy(() => StringFilterSchema), z.string()])
            .optional(),
          promotionID: z
            .union([z.lazy(() => StringFilterSchema), z.string()])
            .optional(),
          discountAmount: z
            .union([
              z.lazy(() => DecimalFilterSchema),
              z
                .union([
                  z.number(),
                  z.string(),
                  z.instanceof(Decimal),
                  z.instanceof(Prisma.Decimal),
                  DecimalJsLikeSchema,
                ])
                .refine((v) => isValidDecimalInput(v), {
                  message: 'Must be a Decimal',
                }),
            ])
            .optional(),
          order: z
            .union([
              z.lazy(() => OrderScalarRelationFilterSchema),
              z.lazy(() => OrderWhereInputSchema),
            ])
            .optional(),
          promotion: z
            .union([
              z.lazy(() => PromotionScalarRelationFilterSchema),
              z.lazy(() => PromotionWhereInputSchema),
            ])
            .optional(),
        })
        .strict(),
    ) as z.ZodType<Prisma.OrderPromotionWhereUniqueInput>;

export const OrderPromotionOrderByWithAggregationInputSchema: z.ZodType<Prisma.OrderPromotionOrderByWithAggregationInput> =
  z
    .object({
      id: z.lazy(() => SortOrderSchema).optional(),
      orderID: z.lazy(() => SortOrderSchema).optional(),
      promotionID: z.lazy(() => SortOrderSchema).optional(),
      discountAmount: z.lazy(() => SortOrderSchema).optional(),
      _count: z
        .lazy(() => OrderPromotionCountOrderByAggregateInputSchema)
        .optional(),
      _avg: z
        .lazy(() => OrderPromotionAvgOrderByAggregateInputSchema)
        .optional(),
      _max: z
        .lazy(() => OrderPromotionMaxOrderByAggregateInputSchema)
        .optional(),
      _min: z
        .lazy(() => OrderPromotionMinOrderByAggregateInputSchema)
        .optional(),
      _sum: z
        .lazy(() => OrderPromotionSumOrderByAggregateInputSchema)
        .optional(),
    })
    .strict() as z.ZodType<Prisma.OrderPromotionOrderByWithAggregationInput>;

export const OrderPromotionScalarWhereWithAggregatesInputSchema: z.ZodType<Prisma.OrderPromotionScalarWhereWithAggregatesInput> =
  z
    .object({
      AND: z
        .union([
          z.lazy(() => OrderPromotionScalarWhereWithAggregatesInputSchema),
          z
            .lazy(() => OrderPromotionScalarWhereWithAggregatesInputSchema)
            .array(),
        ])
        .optional(),
      OR: z
        .lazy(() => OrderPromotionScalarWhereWithAggregatesInputSchema)
        .array()
        .optional(),
      NOT: z
        .union([
          z.lazy(() => OrderPromotionScalarWhereWithAggregatesInputSchema),
          z
            .lazy(() => OrderPromotionScalarWhereWithAggregatesInputSchema)
            .array(),
        ])
        .optional(),
      id: z
        .union([z.lazy(() => StringWithAggregatesFilterSchema), z.string()])
        .optional(),
      orderID: z
        .union([z.lazy(() => StringWithAggregatesFilterSchema), z.string()])
        .optional(),
      promotionID: z
        .union([z.lazy(() => StringWithAggregatesFilterSchema), z.string()])
        .optional(),
      discountAmount: z
        .union([
          z.lazy(() => DecimalWithAggregatesFilterSchema),
          z
            .union([
              z.number(),
              z.string(),
              z.instanceof(Decimal),
              z.instanceof(Prisma.Decimal),
              DecimalJsLikeSchema,
            ])
            .refine((v) => isValidDecimalInput(v), {
              message: 'Must be a Decimal',
            }),
        ])
        .optional(),
    })
    .strict() as z.ZodType<Prisma.OrderPromotionScalarWhereWithAggregatesInput>;

export const CartWhereInputSchema: z.ZodType<Prisma.CartWhereInput> = z
  .object({
    AND: z
      .union([
        z.lazy(() => CartWhereInputSchema),
        z.lazy(() => CartWhereInputSchema).array(),
      ])
      .optional(),
    OR: z
      .lazy(() => CartWhereInputSchema)
      .array()
      .optional(),
    NOT: z
      .union([
        z.lazy(() => CartWhereInputSchema),
        z.lazy(() => CartWhereInputSchema).array(),
      ])
      .optional(),
    id: z.union([z.lazy(() => StringFilterSchema), z.string()]).optional(),
    userID: z.union([z.lazy(() => StringFilterSchema), z.string()]).optional(),
    createdAt: z
      .union([z.lazy(() => DateTimeFilterSchema), z.coerce.date()])
      .optional(),
    updatedAt: z
      .union([z.lazy(() => DateTimeFilterSchema), z.coerce.date()])
      .optional(),
    user: z
      .union([
        z.lazy(() => UserScalarRelationFilterSchema),
        z.lazy(() => UserWhereInputSchema),
      ])
      .optional(),
    cartItems: z.lazy(() => CartItemListRelationFilterSchema).optional(),
  })
  .strict() as z.ZodType<Prisma.CartWhereInput>;

export const CartOrderByWithRelationInputSchema: z.ZodType<Prisma.CartOrderByWithRelationInput> =
  z
    .object({
      id: z.lazy(() => SortOrderSchema).optional(),
      userID: z.lazy(() => SortOrderSchema).optional(),
      createdAt: z.lazy(() => SortOrderSchema).optional(),
      updatedAt: z.lazy(() => SortOrderSchema).optional(),
      user: z.lazy(() => UserOrderByWithRelationInputSchema).optional(),
      cartItems: z
        .lazy(() => CartItemOrderByRelationAggregateInputSchema)
        .optional(),
    })
    .strict() as z.ZodType<Prisma.CartOrderByWithRelationInput>;

export const CartWhereUniqueInputSchema: z.ZodType<Prisma.CartWhereUniqueInput> =
  z
    .union([
      z.object({
        id: z.string().uuid(),
        userID: z.string(),
      }),
      z.object({
        id: z.string().uuid(),
      }),
      z.object({
        userID: z.string(),
      }),
    ])
    .and(
      z
        .object({
          id: z.string().uuid().optional(),
          userID: z.string().optional(),
          AND: z
            .union([
              z.lazy(() => CartWhereInputSchema),
              z.lazy(() => CartWhereInputSchema).array(),
            ])
            .optional(),
          OR: z
            .lazy(() => CartWhereInputSchema)
            .array()
            .optional(),
          NOT: z
            .union([
              z.lazy(() => CartWhereInputSchema),
              z.lazy(() => CartWhereInputSchema).array(),
            ])
            .optional(),
          createdAt: z
            .union([z.lazy(() => DateTimeFilterSchema), z.coerce.date()])
            .optional(),
          updatedAt: z
            .union([z.lazy(() => DateTimeFilterSchema), z.coerce.date()])
            .optional(),
          user: z
            .union([
              z.lazy(() => UserScalarRelationFilterSchema),
              z.lazy(() => UserWhereInputSchema),
            ])
            .optional(),
          cartItems: z.lazy(() => CartItemListRelationFilterSchema).optional(),
        })
        .strict(),
    ) as z.ZodType<Prisma.CartWhereUniqueInput>;

export const CartOrderByWithAggregationInputSchema: z.ZodType<Prisma.CartOrderByWithAggregationInput> =
  z
    .object({
      id: z.lazy(() => SortOrderSchema).optional(),
      userID: z.lazy(() => SortOrderSchema).optional(),
      createdAt: z.lazy(() => SortOrderSchema).optional(),
      updatedAt: z.lazy(() => SortOrderSchema).optional(),
      _count: z.lazy(() => CartCountOrderByAggregateInputSchema).optional(),
      _max: z.lazy(() => CartMaxOrderByAggregateInputSchema).optional(),
      _min: z.lazy(() => CartMinOrderByAggregateInputSchema).optional(),
    })
    .strict() as z.ZodType<Prisma.CartOrderByWithAggregationInput>;

export const CartScalarWhereWithAggregatesInputSchema: z.ZodType<Prisma.CartScalarWhereWithAggregatesInput> =
  z
    .object({
      AND: z
        .union([
          z.lazy(() => CartScalarWhereWithAggregatesInputSchema),
          z.lazy(() => CartScalarWhereWithAggregatesInputSchema).array(),
        ])
        .optional(),
      OR: z
        .lazy(() => CartScalarWhereWithAggregatesInputSchema)
        .array()
        .optional(),
      NOT: z
        .union([
          z.lazy(() => CartScalarWhereWithAggregatesInputSchema),
          z.lazy(() => CartScalarWhereWithAggregatesInputSchema).array(),
        ])
        .optional(),
      id: z
        .union([z.lazy(() => StringWithAggregatesFilterSchema), z.string()])
        .optional(),
      userID: z
        .union([z.lazy(() => StringWithAggregatesFilterSchema), z.string()])
        .optional(),
      createdAt: z
        .union([
          z.lazy(() => DateTimeWithAggregatesFilterSchema),
          z.coerce.date(),
        ])
        .optional(),
      updatedAt: z
        .union([
          z.lazy(() => DateTimeWithAggregatesFilterSchema),
          z.coerce.date(),
        ])
        .optional(),
    })
    .strict() as z.ZodType<Prisma.CartScalarWhereWithAggregatesInput>;

export const CartItemWhereInputSchema: z.ZodType<Prisma.CartItemWhereInput> = z
  .object({
    AND: z
      .union([
        z.lazy(() => CartItemWhereInputSchema),
        z.lazy(() => CartItemWhereInputSchema).array(),
      ])
      .optional(),
    OR: z
      .lazy(() => CartItemWhereInputSchema)
      .array()
      .optional(),
    NOT: z
      .union([
        z.lazy(() => CartItemWhereInputSchema),
        z.lazy(() => CartItemWhereInputSchema).array(),
      ])
      .optional(),
    id: z.union([z.lazy(() => StringFilterSchema), z.string()]).optional(),
    cartID: z.union([z.lazy(() => StringFilterSchema), z.string()]).optional(),
    productVariantID: z
      .union([z.lazy(() => StringFilterSchema), z.string()])
      .optional(),
    quantity: z.union([z.lazy(() => IntFilterSchema), z.number()]).optional(),
    createdAt: z
      .union([z.lazy(() => DateTimeFilterSchema), z.coerce.date()])
      .optional(),
    updatedAt: z
      .union([z.lazy(() => DateTimeFilterSchema), z.coerce.date()])
      .optional(),
    cart: z
      .union([
        z.lazy(() => CartScalarRelationFilterSchema),
        z.lazy(() => CartWhereInputSchema),
      ])
      .optional(),
    productVariant: z
      .union([
        z.lazy(() => ProductVariantScalarRelationFilterSchema),
        z.lazy(() => ProductVariantWhereInputSchema),
      ])
      .optional(),
  })
  .strict() as z.ZodType<Prisma.CartItemWhereInput>;

export const CartItemOrderByWithRelationInputSchema: z.ZodType<Prisma.CartItemOrderByWithRelationInput> =
  z
    .object({
      id: z.lazy(() => SortOrderSchema).optional(),
      cartID: z.lazy(() => SortOrderSchema).optional(),
      productVariantID: z.lazy(() => SortOrderSchema).optional(),
      quantity: z.lazy(() => SortOrderSchema).optional(),
      createdAt: z.lazy(() => SortOrderSchema).optional(),
      updatedAt: z.lazy(() => SortOrderSchema).optional(),
      cart: z.lazy(() => CartOrderByWithRelationInputSchema).optional(),
      productVariant: z
        .lazy(() => ProductVariantOrderByWithRelationInputSchema)
        .optional(),
    })
    .strict() as z.ZodType<Prisma.CartItemOrderByWithRelationInput>;

export const CartItemWhereUniqueInputSchema: z.ZodType<Prisma.CartItemWhereUniqueInput> =
  z
    .union([
      z.object({
        id: z.string().uuid(),
        cartID_productVariantID: z.lazy(
          () => CartItemCartIDProductVariantIDCompoundUniqueInputSchema,
        ),
      }),
      z.object({
        id: z.string().uuid(),
      }),
      z.object({
        cartID_productVariantID: z.lazy(
          () => CartItemCartIDProductVariantIDCompoundUniqueInputSchema,
        ),
      }),
    ])
    .and(
      z
        .object({
          id: z.string().uuid().optional(),
          cartID_productVariantID: z
            .lazy(() => CartItemCartIDProductVariantIDCompoundUniqueInputSchema)
            .optional(),
          AND: z
            .union([
              z.lazy(() => CartItemWhereInputSchema),
              z.lazy(() => CartItemWhereInputSchema).array(),
            ])
            .optional(),
          OR: z
            .lazy(() => CartItemWhereInputSchema)
            .array()
            .optional(),
          NOT: z
            .union([
              z.lazy(() => CartItemWhereInputSchema),
              z.lazy(() => CartItemWhereInputSchema).array(),
            ])
            .optional(),
          cartID: z
            .union([z.lazy(() => StringFilterSchema), z.string()])
            .optional(),
          productVariantID: z
            .union([z.lazy(() => StringFilterSchema), z.string()])
            .optional(),
          quantity: z
            .union([z.lazy(() => IntFilterSchema), z.number().int()])
            .optional(),
          createdAt: z
            .union([z.lazy(() => DateTimeFilterSchema), z.coerce.date()])
            .optional(),
          updatedAt: z
            .union([z.lazy(() => DateTimeFilterSchema), z.coerce.date()])
            .optional(),
          cart: z
            .union([
              z.lazy(() => CartScalarRelationFilterSchema),
              z.lazy(() => CartWhereInputSchema),
            ])
            .optional(),
          productVariant: z
            .union([
              z.lazy(() => ProductVariantScalarRelationFilterSchema),
              z.lazy(() => ProductVariantWhereInputSchema),
            ])
            .optional(),
        })
        .strict(),
    ) as z.ZodType<Prisma.CartItemWhereUniqueInput>;

export const CartItemOrderByWithAggregationInputSchema: z.ZodType<Prisma.CartItemOrderByWithAggregationInput> =
  z
    .object({
      id: z.lazy(() => SortOrderSchema).optional(),
      cartID: z.lazy(() => SortOrderSchema).optional(),
      productVariantID: z.lazy(() => SortOrderSchema).optional(),
      quantity: z.lazy(() => SortOrderSchema).optional(),
      createdAt: z.lazy(() => SortOrderSchema).optional(),
      updatedAt: z.lazy(() => SortOrderSchema).optional(),
      _count: z.lazy(() => CartItemCountOrderByAggregateInputSchema).optional(),
      _avg: z.lazy(() => CartItemAvgOrderByAggregateInputSchema).optional(),
      _max: z.lazy(() => CartItemMaxOrderByAggregateInputSchema).optional(),
      _min: z.lazy(() => CartItemMinOrderByAggregateInputSchema).optional(),
      _sum: z.lazy(() => CartItemSumOrderByAggregateInputSchema).optional(),
    })
    .strict() as z.ZodType<Prisma.CartItemOrderByWithAggregationInput>;

export const CartItemScalarWhereWithAggregatesInputSchema: z.ZodType<Prisma.CartItemScalarWhereWithAggregatesInput> =
  z
    .object({
      AND: z
        .union([
          z.lazy(() => CartItemScalarWhereWithAggregatesInputSchema),
          z.lazy(() => CartItemScalarWhereWithAggregatesInputSchema).array(),
        ])
        .optional(),
      OR: z
        .lazy(() => CartItemScalarWhereWithAggregatesInputSchema)
        .array()
        .optional(),
      NOT: z
        .union([
          z.lazy(() => CartItemScalarWhereWithAggregatesInputSchema),
          z.lazy(() => CartItemScalarWhereWithAggregatesInputSchema).array(),
        ])
        .optional(),
      id: z
        .union([z.lazy(() => StringWithAggregatesFilterSchema), z.string()])
        .optional(),
      cartID: z
        .union([z.lazy(() => StringWithAggregatesFilterSchema), z.string()])
        .optional(),
      productVariantID: z
        .union([z.lazy(() => StringWithAggregatesFilterSchema), z.string()])
        .optional(),
      quantity: z
        .union([z.lazy(() => IntWithAggregatesFilterSchema), z.number()])
        .optional(),
      createdAt: z
        .union([
          z.lazy(() => DateTimeWithAggregatesFilterSchema),
          z.coerce.date(),
        ])
        .optional(),
      updatedAt: z
        .union([
          z.lazy(() => DateTimeWithAggregatesFilterSchema),
          z.coerce.date(),
        ])
        .optional(),
    })
    .strict() as z.ZodType<Prisma.CartItemScalarWhereWithAggregatesInput>;

export const NotificationWhereInputSchema: z.ZodType<Prisma.NotificationWhereInput> =
  z
    .object({
      AND: z
        .union([
          z.lazy(() => NotificationWhereInputSchema),
          z.lazy(() => NotificationWhereInputSchema).array(),
        ])
        .optional(),
      OR: z
        .lazy(() => NotificationWhereInputSchema)
        .array()
        .optional(),
      NOT: z
        .union([
          z.lazy(() => NotificationWhereInputSchema),
          z.lazy(() => NotificationWhereInputSchema).array(),
        ])
        .optional(),
      id: z.union([z.lazy(() => StringFilterSchema), z.string()]).optional(),
      userID: z
        .union([z.lazy(() => StringFilterSchema), z.string()])
        .optional(),
      title: z.union([z.lazy(() => StringFilterSchema), z.string()]).optional(),
      message: z
        .union([z.lazy(() => StringFilterSchema), z.string()])
        .optional(),
      isRead: z.union([z.lazy(() => BoolFilterSchema), z.boolean()]).optional(),
      User: z
        .union([
          z.lazy(() => UserNullableScalarRelationFilterSchema),
          z.lazy(() => UserWhereInputSchema),
        ])
        .optional()
        .nullable(),
    })
    .strict() as z.ZodType<Prisma.NotificationWhereInput>;

export const NotificationOrderByWithRelationInputSchema: z.ZodType<Prisma.NotificationOrderByWithRelationInput> =
  z
    .object({
      id: z.lazy(() => SortOrderSchema).optional(),
      userID: z.lazy(() => SortOrderSchema).optional(),
      title: z.lazy(() => SortOrderSchema).optional(),
      message: z.lazy(() => SortOrderSchema).optional(),
      isRead: z.lazy(() => SortOrderSchema).optional(),
      User: z.lazy(() => UserOrderByWithRelationInputSchema).optional(),
    })
    .strict() as z.ZodType<Prisma.NotificationOrderByWithRelationInput>;

export const NotificationWhereUniqueInputSchema: z.ZodType<Prisma.NotificationWhereUniqueInput> =
  z
    .object({
      id: z.string().uuid(),
    })
    .and(
      z
        .object({
          id: z.string().uuid().optional(),
          AND: z
            .union([
              z.lazy(() => NotificationWhereInputSchema),
              z.lazy(() => NotificationWhereInputSchema).array(),
            ])
            .optional(),
          OR: z
            .lazy(() => NotificationWhereInputSchema)
            .array()
            .optional(),
          NOT: z
            .union([
              z.lazy(() => NotificationWhereInputSchema),
              z.lazy(() => NotificationWhereInputSchema).array(),
            ])
            .optional(),
          userID: z
            .union([z.lazy(() => StringFilterSchema), z.string()])
            .optional(),
          title: z
            .union([z.lazy(() => StringFilterSchema), z.string()])
            .optional(),
          message: z
            .union([z.lazy(() => StringFilterSchema), z.string()])
            .optional(),
          isRead: z
            .union([z.lazy(() => BoolFilterSchema), z.boolean()])
            .optional(),
          User: z
            .union([
              z.lazy(() => UserNullableScalarRelationFilterSchema),
              z.lazy(() => UserWhereInputSchema),
            ])
            .optional()
            .nullable(),
        })
        .strict(),
    ) as z.ZodType<Prisma.NotificationWhereUniqueInput>;

export const NotificationOrderByWithAggregationInputSchema: z.ZodType<Prisma.NotificationOrderByWithAggregationInput> =
  z
    .object({
      id: z.lazy(() => SortOrderSchema).optional(),
      userID: z.lazy(() => SortOrderSchema).optional(),
      title: z.lazy(() => SortOrderSchema).optional(),
      message: z.lazy(() => SortOrderSchema).optional(),
      isRead: z.lazy(() => SortOrderSchema).optional(),
      _count: z
        .lazy(() => NotificationCountOrderByAggregateInputSchema)
        .optional(),
      _max: z.lazy(() => NotificationMaxOrderByAggregateInputSchema).optional(),
      _min: z.lazy(() => NotificationMinOrderByAggregateInputSchema).optional(),
    })
    .strict() as z.ZodType<Prisma.NotificationOrderByWithAggregationInput>;

export const NotificationScalarWhereWithAggregatesInputSchema: z.ZodType<Prisma.NotificationScalarWhereWithAggregatesInput> =
  z
    .object({
      AND: z
        .union([
          z.lazy(() => NotificationScalarWhereWithAggregatesInputSchema),
          z
            .lazy(() => NotificationScalarWhereWithAggregatesInputSchema)
            .array(),
        ])
        .optional(),
      OR: z
        .lazy(() => NotificationScalarWhereWithAggregatesInputSchema)
        .array()
        .optional(),
      NOT: z
        .union([
          z.lazy(() => NotificationScalarWhereWithAggregatesInputSchema),
          z
            .lazy(() => NotificationScalarWhereWithAggregatesInputSchema)
            .array(),
        ])
        .optional(),
      id: z
        .union([z.lazy(() => StringWithAggregatesFilterSchema), z.string()])
        .optional(),
      userID: z
        .union([z.lazy(() => StringWithAggregatesFilterSchema), z.string()])
        .optional(),
      title: z
        .union([z.lazy(() => StringWithAggregatesFilterSchema), z.string()])
        .optional(),
      message: z
        .union([z.lazy(() => StringWithAggregatesFilterSchema), z.string()])
        .optional(),
      isRead: z
        .union([z.lazy(() => BoolWithAggregatesFilterSchema), z.boolean()])
        .optional(),
    })
    .strict() as z.ZodType<Prisma.NotificationScalarWhereWithAggregatesInput>;

export const PaymentWhereInputSchema: z.ZodType<Prisma.PaymentWhereInput> = z
  .object({
    AND: z
      .union([
        z.lazy(() => PaymentWhereInputSchema),
        z.lazy(() => PaymentWhereInputSchema).array(),
      ])
      .optional(),
    OR: z
      .lazy(() => PaymentWhereInputSchema)
      .array()
      .optional(),
    NOT: z
      .union([
        z.lazy(() => PaymentWhereInputSchema),
        z.lazy(() => PaymentWhereInputSchema).array(),
      ])
      .optional(),
    id: z.union([z.lazy(() => StringFilterSchema), z.string()]).optional(),
    orderID: z.union([z.lazy(() => StringFilterSchema), z.string()]).optional(),
    type: z
      .union([
        z.lazy(() => EnumPaymentTypeFilterSchema),
        z.lazy(() => PaymentTypeSchema),
      ])
      .optional(),
    status: z
      .union([
        z.lazy(() => EnumPaymentStatusFilterSchema),
        z.lazy(() => PaymentStatusSchema),
      ])
      .optional(),
    amount: z
      .union([
        z.lazy(() => DecimalFilterSchema),
        z
          .union([
            z.number(),
            z.string(),
            z.instanceof(Decimal),
            z.instanceof(Prisma.Decimal),
            DecimalJsLikeSchema,
          ])
          .refine((v) => isValidDecimalInput(v), {
            message: 'Must be a Decimal',
          }),
      ])
      .optional(),
    transactionID: z
      .union([z.lazy(() => StringNullableFilterSchema), z.string()])
      .optional()
      .nullable(),
    createdAt: z
      .union([z.lazy(() => DateTimeFilterSchema), z.coerce.date()])
      .optional(),
    createdBy: z
      .union([z.lazy(() => StringNullableFilterSchema), z.string()])
      .optional()
      .nullable(),
    updatedAt: z
      .union([z.lazy(() => DateTimeFilterSchema), z.coerce.date()])
      .optional(),
    deletedAt: z
      .union([z.lazy(() => DateTimeNullableFilterSchema), z.coerce.date()])
      .optional()
      .nullable(),
    order: z
      .union([
        z.lazy(() => OrderScalarRelationFilterSchema),
        z.lazy(() => OrderWhereInputSchema),
      ])
      .optional(),
  })
  .strict() as z.ZodType<Prisma.PaymentWhereInput>;

export const PaymentOrderByWithRelationInputSchema: z.ZodType<Prisma.PaymentOrderByWithRelationInput> =
  z
    .object({
      id: z.lazy(() => SortOrderSchema).optional(),
      orderID: z.lazy(() => SortOrderSchema).optional(),
      type: z.lazy(() => SortOrderSchema).optional(),
      status: z.lazy(() => SortOrderSchema).optional(),
      amount: z.lazy(() => SortOrderSchema).optional(),
      transactionID: z
        .union([
          z.lazy(() => SortOrderSchema),
          z.lazy(() => SortOrderInputSchema),
        ])
        .optional(),
      createdAt: z.lazy(() => SortOrderSchema).optional(),
      createdBy: z
        .union([
          z.lazy(() => SortOrderSchema),
          z.lazy(() => SortOrderInputSchema),
        ])
        .optional(),
      updatedAt: z.lazy(() => SortOrderSchema).optional(),
      deletedAt: z
        .union([
          z.lazy(() => SortOrderSchema),
          z.lazy(() => SortOrderInputSchema),
        ])
        .optional(),
      order: z.lazy(() => OrderOrderByWithRelationInputSchema).optional(),
    })
    .strict() as z.ZodType<Prisma.PaymentOrderByWithRelationInput>;

export const PaymentWhereUniqueInputSchema: z.ZodType<Prisma.PaymentWhereUniqueInput> =
  z
    .object({
      id: z.string().uuid(),
    })
    .and(
      z
        .object({
          id: z.string().uuid().optional(),
          AND: z
            .union([
              z.lazy(() => PaymentWhereInputSchema),
              z.lazy(() => PaymentWhereInputSchema).array(),
            ])
            .optional(),
          OR: z
            .lazy(() => PaymentWhereInputSchema)
            .array()
            .optional(),
          NOT: z
            .union([
              z.lazy(() => PaymentWhereInputSchema),
              z.lazy(() => PaymentWhereInputSchema).array(),
            ])
            .optional(),
          orderID: z
            .union([z.lazy(() => StringFilterSchema), z.string()])
            .optional(),
          type: z
            .union([
              z.lazy(() => EnumPaymentTypeFilterSchema),
              z.lazy(() => PaymentTypeSchema),
            ])
            .optional(),
          status: z
            .union([
              z.lazy(() => EnumPaymentStatusFilterSchema),
              z.lazy(() => PaymentStatusSchema),
            ])
            .optional(),
          amount: z
            .union([
              z.lazy(() => DecimalFilterSchema),
              z
                .union([
                  z.number(),
                  z.string(),
                  z.instanceof(Decimal),
                  z.instanceof(Prisma.Decimal),
                  DecimalJsLikeSchema,
                ])
                .refine((v) => isValidDecimalInput(v), {
                  message: 'Must be a Decimal',
                }),
            ])
            .optional(),
          transactionID: z
            .union([z.lazy(() => StringNullableFilterSchema), z.string()])
            .optional()
            .nullable(),
          createdAt: z
            .union([z.lazy(() => DateTimeFilterSchema), z.coerce.date()])
            .optional(),
          createdBy: z
            .union([z.lazy(() => StringNullableFilterSchema), z.string()])
            .optional()
            .nullable(),
          updatedAt: z
            .union([z.lazy(() => DateTimeFilterSchema), z.coerce.date()])
            .optional(),
          deletedAt: z
            .union([
              z.lazy(() => DateTimeNullableFilterSchema),
              z.coerce.date(),
            ])
            .optional()
            .nullable(),
          order: z
            .union([
              z.lazy(() => OrderScalarRelationFilterSchema),
              z.lazy(() => OrderWhereInputSchema),
            ])
            .optional(),
        })
        .strict(),
    ) as z.ZodType<Prisma.PaymentWhereUniqueInput>;

export const PaymentOrderByWithAggregationInputSchema: z.ZodType<Prisma.PaymentOrderByWithAggregationInput> =
  z
    .object({
      id: z.lazy(() => SortOrderSchema).optional(),
      orderID: z.lazy(() => SortOrderSchema).optional(),
      type: z.lazy(() => SortOrderSchema).optional(),
      status: z.lazy(() => SortOrderSchema).optional(),
      amount: z.lazy(() => SortOrderSchema).optional(),
      transactionID: z
        .union([
          z.lazy(() => SortOrderSchema),
          z.lazy(() => SortOrderInputSchema),
        ])
        .optional(),
      createdAt: z.lazy(() => SortOrderSchema).optional(),
      createdBy: z
        .union([
          z.lazy(() => SortOrderSchema),
          z.lazy(() => SortOrderInputSchema),
        ])
        .optional(),
      updatedAt: z.lazy(() => SortOrderSchema).optional(),
      deletedAt: z
        .union([
          z.lazy(() => SortOrderSchema),
          z.lazy(() => SortOrderInputSchema),
        ])
        .optional(),
      _count: z.lazy(() => PaymentCountOrderByAggregateInputSchema).optional(),
      _avg: z.lazy(() => PaymentAvgOrderByAggregateInputSchema).optional(),
      _max: z.lazy(() => PaymentMaxOrderByAggregateInputSchema).optional(),
      _min: z.lazy(() => PaymentMinOrderByAggregateInputSchema).optional(),
      _sum: z.lazy(() => PaymentSumOrderByAggregateInputSchema).optional(),
    })
    .strict() as z.ZodType<Prisma.PaymentOrderByWithAggregationInput>;

export const PaymentScalarWhereWithAggregatesInputSchema: z.ZodType<Prisma.PaymentScalarWhereWithAggregatesInput> =
  z
    .object({
      AND: z
        .union([
          z.lazy(() => PaymentScalarWhereWithAggregatesInputSchema),
          z.lazy(() => PaymentScalarWhereWithAggregatesInputSchema).array(),
        ])
        .optional(),
      OR: z
        .lazy(() => PaymentScalarWhereWithAggregatesInputSchema)
        .array()
        .optional(),
      NOT: z
        .union([
          z.lazy(() => PaymentScalarWhereWithAggregatesInputSchema),
          z.lazy(() => PaymentScalarWhereWithAggregatesInputSchema).array(),
        ])
        .optional(),
      id: z
        .union([z.lazy(() => StringWithAggregatesFilterSchema), z.string()])
        .optional(),
      orderID: z
        .union([z.lazy(() => StringWithAggregatesFilterSchema), z.string()])
        .optional(),
      type: z
        .union([
          z.lazy(() => EnumPaymentTypeWithAggregatesFilterSchema),
          z.lazy(() => PaymentTypeSchema),
        ])
        .optional(),
      status: z
        .union([
          z.lazy(() => EnumPaymentStatusWithAggregatesFilterSchema),
          z.lazy(() => PaymentStatusSchema),
        ])
        .optional(),
      amount: z
        .union([
          z.lazy(() => DecimalWithAggregatesFilterSchema),
          z
            .union([
              z.number(),
              z.string(),
              z.instanceof(Decimal),
              z.instanceof(Prisma.Decimal),
              DecimalJsLikeSchema,
            ])
            .refine((v) => isValidDecimalInput(v), {
              message: 'Must be a Decimal',
            }),
        ])
        .optional(),
      transactionID: z
        .union([
          z.lazy(() => StringNullableWithAggregatesFilterSchema),
          z.string(),
        ])
        .optional()
        .nullable(),
      createdAt: z
        .union([
          z.lazy(() => DateTimeWithAggregatesFilterSchema),
          z.coerce.date(),
        ])
        .optional(),
      createdBy: z
        .union([
          z.lazy(() => StringNullableWithAggregatesFilterSchema),
          z.string(),
        ])
        .optional()
        .nullable(),
      updatedAt: z
        .union([
          z.lazy(() => DateTimeWithAggregatesFilterSchema),
          z.coerce.date(),
        ])
        .optional(),
      deletedAt: z
        .union([
          z.lazy(() => DateTimeNullableWithAggregatesFilterSchema),
          z.coerce.date(),
        ])
        .optional()
        .nullable(),
    })
    .strict() as z.ZodType<Prisma.PaymentScalarWhereWithAggregatesInput>;

export const UserCreateInputSchema: z.ZodType<Prisma.UserCreateInput> = z
  .object({
    id: z.string().uuid().optional(),
    email: z.string().email(),
    password: z.string(),
    firstName: z.string(),
    lastName: z.string().optional().nullable(),
    fullAddress: z.string(),
    city: z.string().optional().nullable(),
    province: z.string().optional().nullable(),
    country: z.string().optional().nullable(),
    phone: z.string().optional().nullable(),
    status: z.lazy(() => UserStatusSchema).optional(),
    createdAt: z.coerce.date().optional(),
    createdBy: z.string().optional().nullable(),
    updatedAt: z.coerce.date().optional(),
    deletedAt: z.coerce.date().optional().nullable(),
    vendors: z
      .lazy(() => VendorCreateNestedManyWithoutUserInputSchema)
      .optional(),
    userVendorRoles: z
      .lazy(() => UserVendorRoleCreateNestedManyWithoutUserInputSchema)
      .optional(),
    orders: z
      .lazy(() => OrderCreateNestedManyWithoutUserInputSchema)
      .optional(),
    cart: z.lazy(() => CartCreateNestedOneWithoutUserInputSchema).optional(),
    notifications: z
      .lazy(() => NotificationCreateNestedManyWithoutUserInputSchema)
      .optional(),
  })
  .strict() as z.ZodType<Prisma.UserCreateInput>;

export const UserUncheckedCreateInputSchema: z.ZodType<Prisma.UserUncheckedCreateInput> =
  z
    .object({
      id: z.string().uuid().optional(),
      email: z.string().email(),
      password: z.string(),
      firstName: z.string(),
      lastName: z.string().optional().nullable(),
      fullAddress: z.string(),
      city: z.string().optional().nullable(),
      province: z.string().optional().nullable(),
      country: z.string().optional().nullable(),
      phone: z.string().optional().nullable(),
      status: z.lazy(() => UserStatusSchema).optional(),
      createdAt: z.coerce.date().optional(),
      createdBy: z.string().optional().nullable(),
      updatedAt: z.coerce.date().optional(),
      deletedAt: z.coerce.date().optional().nullable(),
      vendors: z
        .lazy(() => VendorUncheckedCreateNestedManyWithoutUserInputSchema)
        .optional(),
      userVendorRoles: z
        .lazy(
          () => UserVendorRoleUncheckedCreateNestedManyWithoutUserInputSchema,
        )
        .optional(),
      orders: z
        .lazy(() => OrderUncheckedCreateNestedManyWithoutUserInputSchema)
        .optional(),
      cart: z
        .lazy(() => CartUncheckedCreateNestedOneWithoutUserInputSchema)
        .optional(),
      notifications: z
        .lazy(() => NotificationUncheckedCreateNestedManyWithoutUserInputSchema)
        .optional(),
    })
    .strict() as z.ZodType<Prisma.UserUncheckedCreateInput>;

export const UserUpdateInputSchema: z.ZodType<Prisma.UserUpdateInput> = z
  .object({
    id: z
      .union([
        z.string().uuid(),
        z.lazy(() => StringFieldUpdateOperationsInputSchema),
      ])
      .optional(),
    email: z
      .union([
        z.string().email(),
        z.lazy(() => StringFieldUpdateOperationsInputSchema),
      ])
      .optional(),
    password: z
      .union([z.string(), z.lazy(() => StringFieldUpdateOperationsInputSchema)])
      .optional(),
    firstName: z
      .union([z.string(), z.lazy(() => StringFieldUpdateOperationsInputSchema)])
      .optional(),
    lastName: z
      .union([
        z.string(),
        z.lazy(() => NullableStringFieldUpdateOperationsInputSchema),
      ])
      .optional()
      .nullable(),
    fullAddress: z
      .union([z.string(), z.lazy(() => StringFieldUpdateOperationsInputSchema)])
      .optional(),
    city: z
      .union([
        z.string(),
        z.lazy(() => NullableStringFieldUpdateOperationsInputSchema),
      ])
      .optional()
      .nullable(),
    province: z
      .union([
        z.string(),
        z.lazy(() => NullableStringFieldUpdateOperationsInputSchema),
      ])
      .optional()
      .nullable(),
    country: z
      .union([
        z.string(),
        z.lazy(() => NullableStringFieldUpdateOperationsInputSchema),
      ])
      .optional()
      .nullable(),
    phone: z
      .union([
        z.string(),
        z.lazy(() => NullableStringFieldUpdateOperationsInputSchema),
      ])
      .optional()
      .nullable(),
    status: z
      .union([
        z.lazy(() => UserStatusSchema),
        z.lazy(() => EnumUserStatusFieldUpdateOperationsInputSchema),
      ])
      .optional(),
    createdAt: z
      .union([
        z.coerce.date(),
        z.lazy(() => DateTimeFieldUpdateOperationsInputSchema),
      ])
      .optional(),
    createdBy: z
      .union([
        z.string(),
        z.lazy(() => NullableStringFieldUpdateOperationsInputSchema),
      ])
      .optional()
      .nullable(),
    updatedAt: z
      .union([
        z.coerce.date(),
        z.lazy(() => DateTimeFieldUpdateOperationsInputSchema),
      ])
      .optional(),
    deletedAt: z
      .union([
        z.coerce.date(),
        z.lazy(() => NullableDateTimeFieldUpdateOperationsInputSchema),
      ])
      .optional()
      .nullable(),
    vendors: z
      .lazy(() => VendorUpdateManyWithoutUserNestedInputSchema)
      .optional(),
    userVendorRoles: z
      .lazy(() => UserVendorRoleUpdateManyWithoutUserNestedInputSchema)
      .optional(),
    orders: z
      .lazy(() => OrderUpdateManyWithoutUserNestedInputSchema)
      .optional(),
    cart: z.lazy(() => CartUpdateOneWithoutUserNestedInputSchema).optional(),
    notifications: z
      .lazy(() => NotificationUpdateManyWithoutUserNestedInputSchema)
      .optional(),
  })
  .strict() as z.ZodType<Prisma.UserUpdateInput>;

export const UserUncheckedUpdateInputSchema: z.ZodType<Prisma.UserUncheckedUpdateInput> =
  z
    .object({
      id: z
        .union([
          z.string().uuid(),
          z.lazy(() => StringFieldUpdateOperationsInputSchema),
        ])
        .optional(),
      email: z
        .union([
          z.string().email(),
          z.lazy(() => StringFieldUpdateOperationsInputSchema),
        ])
        .optional(),
      password: z
        .union([
          z.string(),
          z.lazy(() => StringFieldUpdateOperationsInputSchema),
        ])
        .optional(),
      firstName: z
        .union([
          z.string(),
          z.lazy(() => StringFieldUpdateOperationsInputSchema),
        ])
        .optional(),
      lastName: z
        .union([
          z.string(),
          z.lazy(() => NullableStringFieldUpdateOperationsInputSchema),
        ])
        .optional()
        .nullable(),
      fullAddress: z
        .union([
          z.string(),
          z.lazy(() => StringFieldUpdateOperationsInputSchema),
        ])
        .optional(),
      city: z
        .union([
          z.string(),
          z.lazy(() => NullableStringFieldUpdateOperationsInputSchema),
        ])
        .optional()
        .nullable(),
      province: z
        .union([
          z.string(),
          z.lazy(() => NullableStringFieldUpdateOperationsInputSchema),
        ])
        .optional()
        .nullable(),
      country: z
        .union([
          z.string(),
          z.lazy(() => NullableStringFieldUpdateOperationsInputSchema),
        ])
        .optional()
        .nullable(),
      phone: z
        .union([
          z.string(),
          z.lazy(() => NullableStringFieldUpdateOperationsInputSchema),
        ])
        .optional()
        .nullable(),
      status: z
        .union([
          z.lazy(() => UserStatusSchema),
          z.lazy(() => EnumUserStatusFieldUpdateOperationsInputSchema),
        ])
        .optional(),
      createdAt: z
        .union([
          z.coerce.date(),
          z.lazy(() => DateTimeFieldUpdateOperationsInputSchema),
        ])
        .optional(),
      createdBy: z
        .union([
          z.string(),
          z.lazy(() => NullableStringFieldUpdateOperationsInputSchema),
        ])
        .optional()
        .nullable(),
      updatedAt: z
        .union([
          z.coerce.date(),
          z.lazy(() => DateTimeFieldUpdateOperationsInputSchema),
        ])
        .optional(),
      deletedAt: z
        .union([
          z.coerce.date(),
          z.lazy(() => NullableDateTimeFieldUpdateOperationsInputSchema),
        ])
        .optional()
        .nullable(),
      vendors: z
        .lazy(() => VendorUncheckedUpdateManyWithoutUserNestedInputSchema)
        .optional(),
      userVendorRoles: z
        .lazy(
          () => UserVendorRoleUncheckedUpdateManyWithoutUserNestedInputSchema,
        )
        .optional(),
      orders: z
        .lazy(() => OrderUncheckedUpdateManyWithoutUserNestedInputSchema)
        .optional(),
      cart: z
        .lazy(() => CartUncheckedUpdateOneWithoutUserNestedInputSchema)
        .optional(),
      notifications: z
        .lazy(() => NotificationUncheckedUpdateManyWithoutUserNestedInputSchema)
        .optional(),
    })
    .strict() as z.ZodType<Prisma.UserUncheckedUpdateInput>;

export const UserCreateManyInputSchema: z.ZodType<Prisma.UserCreateManyInput> =
  z
    .object({
      id: z.string().uuid().optional(),
      email: z.string().email(),
      password: z.string(),
      firstName: z.string(),
      lastName: z.string().optional().nullable(),
      fullAddress: z.string(),
      city: z.string().optional().nullable(),
      province: z.string().optional().nullable(),
      country: z.string().optional().nullable(),
      phone: z.string().optional().nullable(),
      status: z.lazy(() => UserStatusSchema).optional(),
      createdAt: z.coerce.date().optional(),
      createdBy: z.string().optional().nullable(),
      updatedAt: z.coerce.date().optional(),
      deletedAt: z.coerce.date().optional().nullable(),
    })
    .strict() as z.ZodType<Prisma.UserCreateManyInput>;

export const UserUpdateManyMutationInputSchema: z.ZodType<Prisma.UserUpdateManyMutationInput> =
  z
    .object({
      id: z
        .union([
          z.string().uuid(),
          z.lazy(() => StringFieldUpdateOperationsInputSchema),
        ])
        .optional(),
      email: z
        .union([
          z.string().email(),
          z.lazy(() => StringFieldUpdateOperationsInputSchema),
        ])
        .optional(),
      password: z
        .union([
          z.string(),
          z.lazy(() => StringFieldUpdateOperationsInputSchema),
        ])
        .optional(),
      firstName: z
        .union([
          z.string(),
          z.lazy(() => StringFieldUpdateOperationsInputSchema),
        ])
        .optional(),
      lastName: z
        .union([
          z.string(),
          z.lazy(() => NullableStringFieldUpdateOperationsInputSchema),
        ])
        .optional()
        .nullable(),
      fullAddress: z
        .union([
          z.string(),
          z.lazy(() => StringFieldUpdateOperationsInputSchema),
        ])
        .optional(),
      city: z
        .union([
          z.string(),
          z.lazy(() => NullableStringFieldUpdateOperationsInputSchema),
        ])
        .optional()
        .nullable(),
      province: z
        .union([
          z.string(),
          z.lazy(() => NullableStringFieldUpdateOperationsInputSchema),
        ])
        .optional()
        .nullable(),
      country: z
        .union([
          z.string(),
          z.lazy(() => NullableStringFieldUpdateOperationsInputSchema),
        ])
        .optional()
        .nullable(),
      phone: z
        .union([
          z.string(),
          z.lazy(() => NullableStringFieldUpdateOperationsInputSchema),
        ])
        .optional()
        .nullable(),
      status: z
        .union([
          z.lazy(() => UserStatusSchema),
          z.lazy(() => EnumUserStatusFieldUpdateOperationsInputSchema),
        ])
        .optional(),
      createdAt: z
        .union([
          z.coerce.date(),
          z.lazy(() => DateTimeFieldUpdateOperationsInputSchema),
        ])
        .optional(),
      createdBy: z
        .union([
          z.string(),
          z.lazy(() => NullableStringFieldUpdateOperationsInputSchema),
        ])
        .optional()
        .nullable(),
      updatedAt: z
        .union([
          z.coerce.date(),
          z.lazy(() => DateTimeFieldUpdateOperationsInputSchema),
        ])
        .optional(),
      deletedAt: z
        .union([
          z.coerce.date(),
          z.lazy(() => NullableDateTimeFieldUpdateOperationsInputSchema),
        ])
        .optional()
        .nullable(),
    })
    .strict() as z.ZodType<Prisma.UserUpdateManyMutationInput>;

export const UserUncheckedUpdateManyInputSchema: z.ZodType<Prisma.UserUncheckedUpdateManyInput> =
  z
    .object({
      id: z
        .union([
          z.string().uuid(),
          z.lazy(() => StringFieldUpdateOperationsInputSchema),
        ])
        .optional(),
      email: z
        .union([
          z.string().email(),
          z.lazy(() => StringFieldUpdateOperationsInputSchema),
        ])
        .optional(),
      password: z
        .union([
          z.string(),
          z.lazy(() => StringFieldUpdateOperationsInputSchema),
        ])
        .optional(),
      firstName: z
        .union([
          z.string(),
          z.lazy(() => StringFieldUpdateOperationsInputSchema),
        ])
        .optional(),
      lastName: z
        .union([
          z.string(),
          z.lazy(() => NullableStringFieldUpdateOperationsInputSchema),
        ])
        .optional()
        .nullable(),
      fullAddress: z
        .union([
          z.string(),
          z.lazy(() => StringFieldUpdateOperationsInputSchema),
        ])
        .optional(),
      city: z
        .union([
          z.string(),
          z.lazy(() => NullableStringFieldUpdateOperationsInputSchema),
        ])
        .optional()
        .nullable(),
      province: z
        .union([
          z.string(),
          z.lazy(() => NullableStringFieldUpdateOperationsInputSchema),
        ])
        .optional()
        .nullable(),
      country: z
        .union([
          z.string(),
          z.lazy(() => NullableStringFieldUpdateOperationsInputSchema),
        ])
        .optional()
        .nullable(),
      phone: z
        .union([
          z.string(),
          z.lazy(() => NullableStringFieldUpdateOperationsInputSchema),
        ])
        .optional()
        .nullable(),
      status: z
        .union([
          z.lazy(() => UserStatusSchema),
          z.lazy(() => EnumUserStatusFieldUpdateOperationsInputSchema),
        ])
        .optional(),
      createdAt: z
        .union([
          z.coerce.date(),
          z.lazy(() => DateTimeFieldUpdateOperationsInputSchema),
        ])
        .optional(),
      createdBy: z
        .union([
          z.string(),
          z.lazy(() => NullableStringFieldUpdateOperationsInputSchema),
        ])
        .optional()
        .nullable(),
      updatedAt: z
        .union([
          z.coerce.date(),
          z.lazy(() => DateTimeFieldUpdateOperationsInputSchema),
        ])
        .optional(),
      deletedAt: z
        .union([
          z.coerce.date(),
          z.lazy(() => NullableDateTimeFieldUpdateOperationsInputSchema),
        ])
        .optional()
        .nullable(),
    })
    .strict() as z.ZodType<Prisma.UserUncheckedUpdateManyInput>;

export const VendorCreateInputSchema: z.ZodType<Prisma.VendorCreateInput> = z
  .object({
    id: z.string().uuid().optional(),
    name: z.string(),
    slug: z.string(),
    description: z.string().optional().nullable(),
    logoUrl: z.string().optional().nullable(),
    taxCode: z.string().optional().nullable(),
    totalProducts: z.number().int().optional(),
    totalOrders: z.number().int().optional(),
    status: z.lazy(() => VendorStatusSchema).optional(),
    createdAt: z.coerce.date().optional(),
    createdBy: z.string().optional().nullable(),
    updatedAt: z.coerce.date().optional(),
    deletedAt: z.coerce.date().optional().nullable(),
    user: z.lazy(() => UserCreateNestedOneWithoutVendorsInputSchema),
    products: z
      .lazy(() => ProductCreateNestedManyWithoutVendorInputSchema)
      .optional(),
    userVendorRoles: z
      .lazy(() => UserVendorRoleCreateNestedManyWithoutVendorInputSchema)
      .optional(),
  })
  .strict() as z.ZodType<Prisma.VendorCreateInput>;

export const VendorUncheckedCreateInputSchema: z.ZodType<Prisma.VendorUncheckedCreateInput> =
  z
    .object({
      id: z.string().uuid().optional(),
      userID: z.string(),
      name: z.string(),
      slug: z.string(),
      description: z.string().optional().nullable(),
      logoUrl: z.string().optional().nullable(),
      taxCode: z.string().optional().nullable(),
      totalProducts: z.number().int().optional(),
      totalOrders: z.number().int().optional(),
      status: z.lazy(() => VendorStatusSchema).optional(),
      createdAt: z.coerce.date().optional(),
      createdBy: z.string().optional().nullable(),
      updatedAt: z.coerce.date().optional(),
      deletedAt: z.coerce.date().optional().nullable(),
      products: z
        .lazy(() => ProductUncheckedCreateNestedManyWithoutVendorInputSchema)
        .optional(),
      userVendorRoles: z
        .lazy(
          () => UserVendorRoleUncheckedCreateNestedManyWithoutVendorInputSchema,
        )
        .optional(),
    })
    .strict() as z.ZodType<Prisma.VendorUncheckedCreateInput>;

export const VendorUpdateInputSchema: z.ZodType<Prisma.VendorUpdateInput> = z
  .object({
    id: z
      .union([
        z.string().uuid(),
        z.lazy(() => StringFieldUpdateOperationsInputSchema),
      ])
      .optional(),
    name: z
      .union([z.string(), z.lazy(() => StringFieldUpdateOperationsInputSchema)])
      .optional(),
    slug: z
      .union([z.string(), z.lazy(() => StringFieldUpdateOperationsInputSchema)])
      .optional(),
    description: z
      .union([
        z.string(),
        z.lazy(() => NullableStringFieldUpdateOperationsInputSchema),
      ])
      .optional()
      .nullable(),
    logoUrl: z
      .union([
        z.string(),
        z.lazy(() => NullableStringFieldUpdateOperationsInputSchema),
      ])
      .optional()
      .nullable(),
    taxCode: z
      .union([
        z.string(),
        z.lazy(() => NullableStringFieldUpdateOperationsInputSchema),
      ])
      .optional()
      .nullable(),
    totalProducts: z
      .union([
        z.number().int(),
        z.lazy(() => IntFieldUpdateOperationsInputSchema),
      ])
      .optional(),
    totalOrders: z
      .union([
        z.number().int(),
        z.lazy(() => IntFieldUpdateOperationsInputSchema),
      ])
      .optional(),
    status: z
      .union([
        z.lazy(() => VendorStatusSchema),
        z.lazy(() => EnumVendorStatusFieldUpdateOperationsInputSchema),
      ])
      .optional(),
    createdAt: z
      .union([
        z.coerce.date(),
        z.lazy(() => DateTimeFieldUpdateOperationsInputSchema),
      ])
      .optional(),
    createdBy: z
      .union([
        z.string(),
        z.lazy(() => NullableStringFieldUpdateOperationsInputSchema),
      ])
      .optional()
      .nullable(),
    updatedAt: z
      .union([
        z.coerce.date(),
        z.lazy(() => DateTimeFieldUpdateOperationsInputSchema),
      ])
      .optional(),
    deletedAt: z
      .union([
        z.coerce.date(),
        z.lazy(() => NullableDateTimeFieldUpdateOperationsInputSchema),
      ])
      .optional()
      .nullable(),
    user: z
      .lazy(() => UserUpdateOneRequiredWithoutVendorsNestedInputSchema)
      .optional(),
    products: z
      .lazy(() => ProductUpdateManyWithoutVendorNestedInputSchema)
      .optional(),
    userVendorRoles: z
      .lazy(() => UserVendorRoleUpdateManyWithoutVendorNestedInputSchema)
      .optional(),
  })
  .strict() as z.ZodType<Prisma.VendorUpdateInput>;

export const VendorUncheckedUpdateInputSchema: z.ZodType<Prisma.VendorUncheckedUpdateInput> =
  z
    .object({
      id: z
        .union([
          z.string().uuid(),
          z.lazy(() => StringFieldUpdateOperationsInputSchema),
        ])
        .optional(),
      userID: z
        .union([
          z.string(),
          z.lazy(() => StringFieldUpdateOperationsInputSchema),
        ])
        .optional(),
      name: z
        .union([
          z.string(),
          z.lazy(() => StringFieldUpdateOperationsInputSchema),
        ])
        .optional(),
      slug: z
        .union([
          z.string(),
          z.lazy(() => StringFieldUpdateOperationsInputSchema),
        ])
        .optional(),
      description: z
        .union([
          z.string(),
          z.lazy(() => NullableStringFieldUpdateOperationsInputSchema),
        ])
        .optional()
        .nullable(),
      logoUrl: z
        .union([
          z.string(),
          z.lazy(() => NullableStringFieldUpdateOperationsInputSchema),
        ])
        .optional()
        .nullable(),
      taxCode: z
        .union([
          z.string(),
          z.lazy(() => NullableStringFieldUpdateOperationsInputSchema),
        ])
        .optional()
        .nullable(),
      totalProducts: z
        .union([
          z.number().int(),
          z.lazy(() => IntFieldUpdateOperationsInputSchema),
        ])
        .optional(),
      totalOrders: z
        .union([
          z.number().int(),
          z.lazy(() => IntFieldUpdateOperationsInputSchema),
        ])
        .optional(),
      status: z
        .union([
          z.lazy(() => VendorStatusSchema),
          z.lazy(() => EnumVendorStatusFieldUpdateOperationsInputSchema),
        ])
        .optional(),
      createdAt: z
        .union([
          z.coerce.date(),
          z.lazy(() => DateTimeFieldUpdateOperationsInputSchema),
        ])
        .optional(),
      createdBy: z
        .union([
          z.string(),
          z.lazy(() => NullableStringFieldUpdateOperationsInputSchema),
        ])
        .optional()
        .nullable(),
      updatedAt: z
        .union([
          z.coerce.date(),
          z.lazy(() => DateTimeFieldUpdateOperationsInputSchema),
        ])
        .optional(),
      deletedAt: z
        .union([
          z.coerce.date(),
          z.lazy(() => NullableDateTimeFieldUpdateOperationsInputSchema),
        ])
        .optional()
        .nullable(),
      products: z
        .lazy(() => ProductUncheckedUpdateManyWithoutVendorNestedInputSchema)
        .optional(),
      userVendorRoles: z
        .lazy(
          () => UserVendorRoleUncheckedUpdateManyWithoutVendorNestedInputSchema,
        )
        .optional(),
    })
    .strict() as z.ZodType<Prisma.VendorUncheckedUpdateInput>;

export const VendorCreateManyInputSchema: z.ZodType<Prisma.VendorCreateManyInput> =
  z
    .object({
      id: z.string().uuid().optional(),
      userID: z.string(),
      name: z.string(),
      slug: z.string(),
      description: z.string().optional().nullable(),
      logoUrl: z.string().optional().nullable(),
      taxCode: z.string().optional().nullable(),
      totalProducts: z.number().int().optional(),
      totalOrders: z.number().int().optional(),
      status: z.lazy(() => VendorStatusSchema).optional(),
      createdAt: z.coerce.date().optional(),
      createdBy: z.string().optional().nullable(),
      updatedAt: z.coerce.date().optional(),
      deletedAt: z.coerce.date().optional().nullable(),
    })
    .strict() as z.ZodType<Prisma.VendorCreateManyInput>;

export const VendorUpdateManyMutationInputSchema: z.ZodType<Prisma.VendorUpdateManyMutationInput> =
  z
    .object({
      id: z
        .union([
          z.string().uuid(),
          z.lazy(() => StringFieldUpdateOperationsInputSchema),
        ])
        .optional(),
      name: z
        .union([
          z.string(),
          z.lazy(() => StringFieldUpdateOperationsInputSchema),
        ])
        .optional(),
      slug: z
        .union([
          z.string(),
          z.lazy(() => StringFieldUpdateOperationsInputSchema),
        ])
        .optional(),
      description: z
        .union([
          z.string(),
          z.lazy(() => NullableStringFieldUpdateOperationsInputSchema),
        ])
        .optional()
        .nullable(),
      logoUrl: z
        .union([
          z.string(),
          z.lazy(() => NullableStringFieldUpdateOperationsInputSchema),
        ])
        .optional()
        .nullable(),
      taxCode: z
        .union([
          z.string(),
          z.lazy(() => NullableStringFieldUpdateOperationsInputSchema),
        ])
        .optional()
        .nullable(),
      totalProducts: z
        .union([
          z.number().int(),
          z.lazy(() => IntFieldUpdateOperationsInputSchema),
        ])
        .optional(),
      totalOrders: z
        .union([
          z.number().int(),
          z.lazy(() => IntFieldUpdateOperationsInputSchema),
        ])
        .optional(),
      status: z
        .union([
          z.lazy(() => VendorStatusSchema),
          z.lazy(() => EnumVendorStatusFieldUpdateOperationsInputSchema),
        ])
        .optional(),
      createdAt: z
        .union([
          z.coerce.date(),
          z.lazy(() => DateTimeFieldUpdateOperationsInputSchema),
        ])
        .optional(),
      createdBy: z
        .union([
          z.string(),
          z.lazy(() => NullableStringFieldUpdateOperationsInputSchema),
        ])
        .optional()
        .nullable(),
      updatedAt: z
        .union([
          z.coerce.date(),
          z.lazy(() => DateTimeFieldUpdateOperationsInputSchema),
        ])
        .optional(),
      deletedAt: z
        .union([
          z.coerce.date(),
          z.lazy(() => NullableDateTimeFieldUpdateOperationsInputSchema),
        ])
        .optional()
        .nullable(),
    })
    .strict() as z.ZodType<Prisma.VendorUpdateManyMutationInput>;

export const VendorUncheckedUpdateManyInputSchema: z.ZodType<Prisma.VendorUncheckedUpdateManyInput> =
  z
    .object({
      id: z
        .union([
          z.string().uuid(),
          z.lazy(() => StringFieldUpdateOperationsInputSchema),
        ])
        .optional(),
      userID: z
        .union([
          z.string(),
          z.lazy(() => StringFieldUpdateOperationsInputSchema),
        ])
        .optional(),
      name: z
        .union([
          z.string(),
          z.lazy(() => StringFieldUpdateOperationsInputSchema),
        ])
        .optional(),
      slug: z
        .union([
          z.string(),
          z.lazy(() => StringFieldUpdateOperationsInputSchema),
        ])
        .optional(),
      description: z
        .union([
          z.string(),
          z.lazy(() => NullableStringFieldUpdateOperationsInputSchema),
        ])
        .optional()
        .nullable(),
      logoUrl: z
        .union([
          z.string(),
          z.lazy(() => NullableStringFieldUpdateOperationsInputSchema),
        ])
        .optional()
        .nullable(),
      taxCode: z
        .union([
          z.string(),
          z.lazy(() => NullableStringFieldUpdateOperationsInputSchema),
        ])
        .optional()
        .nullable(),
      totalProducts: z
        .union([
          z.number().int(),
          z.lazy(() => IntFieldUpdateOperationsInputSchema),
        ])
        .optional(),
      totalOrders: z
        .union([
          z.number().int(),
          z.lazy(() => IntFieldUpdateOperationsInputSchema),
        ])
        .optional(),
      status: z
        .union([
          z.lazy(() => VendorStatusSchema),
          z.lazy(() => EnumVendorStatusFieldUpdateOperationsInputSchema),
        ])
        .optional(),
      createdAt: z
        .union([
          z.coerce.date(),
          z.lazy(() => DateTimeFieldUpdateOperationsInputSchema),
        ])
        .optional(),
      createdBy: z
        .union([
          z.string(),
          z.lazy(() => NullableStringFieldUpdateOperationsInputSchema),
        ])
        .optional()
        .nullable(),
      updatedAt: z
        .union([
          z.coerce.date(),
          z.lazy(() => DateTimeFieldUpdateOperationsInputSchema),
        ])
        .optional(),
      deletedAt: z
        .union([
          z.coerce.date(),
          z.lazy(() => NullableDateTimeFieldUpdateOperationsInputSchema),
        ])
        .optional()
        .nullable(),
    })
    .strict() as z.ZodType<Prisma.VendorUncheckedUpdateManyInput>;

export const RoleCreateInputSchema: z.ZodType<Prisma.RoleCreateInput> = z
  .object({
    id: z.string().uuid().optional(),
    name: z.string(),
    description: z.string().optional().nullable(),
    isSystemRole: z.boolean().optional(),
    createdAt: z.coerce.date().optional(),
    createdBy: z.string().optional().nullable(),
    updatedAt: z.coerce.date().optional(),
    deletedAt: z.coerce.date().optional().nullable(),
    userVendorRoles: z
      .lazy(() => UserVendorRoleCreateNestedManyWithoutRoleInputSchema)
      .optional(),
    rolePermissions: z
      .lazy(() => RolePermissionCreateNestedManyWithoutRoleInputSchema)
      .optional(),
  })
  .strict() as z.ZodType<Prisma.RoleCreateInput>;

export const RoleUncheckedCreateInputSchema: z.ZodType<Prisma.RoleUncheckedCreateInput> =
  z
    .object({
      id: z.string().uuid().optional(),
      name: z.string(),
      description: z.string().optional().nullable(),
      isSystemRole: z.boolean().optional(),
      createdAt: z.coerce.date().optional(),
      createdBy: z.string().optional().nullable(),
      updatedAt: z.coerce.date().optional(),
      deletedAt: z.coerce.date().optional().nullable(),
      userVendorRoles: z
        .lazy(
          () => UserVendorRoleUncheckedCreateNestedManyWithoutRoleInputSchema,
        )
        .optional(),
      rolePermissions: z
        .lazy(
          () => RolePermissionUncheckedCreateNestedManyWithoutRoleInputSchema,
        )
        .optional(),
    })
    .strict() as z.ZodType<Prisma.RoleUncheckedCreateInput>;

export const RoleUpdateInputSchema: z.ZodType<Prisma.RoleUpdateInput> = z
  .object({
    id: z
      .union([
        z.string().uuid(),
        z.lazy(() => StringFieldUpdateOperationsInputSchema),
      ])
      .optional(),
    name: z
      .union([z.string(), z.lazy(() => StringFieldUpdateOperationsInputSchema)])
      .optional(),
    description: z
      .union([
        z.string(),
        z.lazy(() => NullableStringFieldUpdateOperationsInputSchema),
      ])
      .optional()
      .nullable(),
    isSystemRole: z
      .union([z.boolean(), z.lazy(() => BoolFieldUpdateOperationsInputSchema)])
      .optional(),
    createdAt: z
      .union([
        z.coerce.date(),
        z.lazy(() => DateTimeFieldUpdateOperationsInputSchema),
      ])
      .optional(),
    createdBy: z
      .union([
        z.string(),
        z.lazy(() => NullableStringFieldUpdateOperationsInputSchema),
      ])
      .optional()
      .nullable(),
    updatedAt: z
      .union([
        z.coerce.date(),
        z.lazy(() => DateTimeFieldUpdateOperationsInputSchema),
      ])
      .optional(),
    deletedAt: z
      .union([
        z.coerce.date(),
        z.lazy(() => NullableDateTimeFieldUpdateOperationsInputSchema),
      ])
      .optional()
      .nullable(),
    userVendorRoles: z
      .lazy(() => UserVendorRoleUpdateManyWithoutRoleNestedInputSchema)
      .optional(),
    rolePermissions: z
      .lazy(() => RolePermissionUpdateManyWithoutRoleNestedInputSchema)
      .optional(),
  })
  .strict() as z.ZodType<Prisma.RoleUpdateInput>;

export const RoleUncheckedUpdateInputSchema: z.ZodType<Prisma.RoleUncheckedUpdateInput> =
  z
    .object({
      id: z
        .union([
          z.string().uuid(),
          z.lazy(() => StringFieldUpdateOperationsInputSchema),
        ])
        .optional(),
      name: z
        .union([
          z.string(),
          z.lazy(() => StringFieldUpdateOperationsInputSchema),
        ])
        .optional(),
      description: z
        .union([
          z.string(),
          z.lazy(() => NullableStringFieldUpdateOperationsInputSchema),
        ])
        .optional()
        .nullable(),
      isSystemRole: z
        .union([
          z.boolean(),
          z.lazy(() => BoolFieldUpdateOperationsInputSchema),
        ])
        .optional(),
      createdAt: z
        .union([
          z.coerce.date(),
          z.lazy(() => DateTimeFieldUpdateOperationsInputSchema),
        ])
        .optional(),
      createdBy: z
        .union([
          z.string(),
          z.lazy(() => NullableStringFieldUpdateOperationsInputSchema),
        ])
        .optional()
        .nullable(),
      updatedAt: z
        .union([
          z.coerce.date(),
          z.lazy(() => DateTimeFieldUpdateOperationsInputSchema),
        ])
        .optional(),
      deletedAt: z
        .union([
          z.coerce.date(),
          z.lazy(() => NullableDateTimeFieldUpdateOperationsInputSchema),
        ])
        .optional()
        .nullable(),
      userVendorRoles: z
        .lazy(
          () => UserVendorRoleUncheckedUpdateManyWithoutRoleNestedInputSchema,
        )
        .optional(),
      rolePermissions: z
        .lazy(
          () => RolePermissionUncheckedUpdateManyWithoutRoleNestedInputSchema,
        )
        .optional(),
    })
    .strict() as z.ZodType<Prisma.RoleUncheckedUpdateInput>;

export const RoleCreateManyInputSchema: z.ZodType<Prisma.RoleCreateManyInput> =
  z
    .object({
      id: z.string().uuid().optional(),
      name: z.string(),
      description: z.string().optional().nullable(),
      isSystemRole: z.boolean().optional(),
      createdAt: z.coerce.date().optional(),
      createdBy: z.string().optional().nullable(),
      updatedAt: z.coerce.date().optional(),
      deletedAt: z.coerce.date().optional().nullable(),
    })
    .strict() as z.ZodType<Prisma.RoleCreateManyInput>;

export const RoleUpdateManyMutationInputSchema: z.ZodType<Prisma.RoleUpdateManyMutationInput> =
  z
    .object({
      id: z
        .union([
          z.string().uuid(),
          z.lazy(() => StringFieldUpdateOperationsInputSchema),
        ])
        .optional(),
      name: z
        .union([
          z.string(),
          z.lazy(() => StringFieldUpdateOperationsInputSchema),
        ])
        .optional(),
      description: z
        .union([
          z.string(),
          z.lazy(() => NullableStringFieldUpdateOperationsInputSchema),
        ])
        .optional()
        .nullable(),
      isSystemRole: z
        .union([
          z.boolean(),
          z.lazy(() => BoolFieldUpdateOperationsInputSchema),
        ])
        .optional(),
      createdAt: z
        .union([
          z.coerce.date(),
          z.lazy(() => DateTimeFieldUpdateOperationsInputSchema),
        ])
        .optional(),
      createdBy: z
        .union([
          z.string(),
          z.lazy(() => NullableStringFieldUpdateOperationsInputSchema),
        ])
        .optional()
        .nullable(),
      updatedAt: z
        .union([
          z.coerce.date(),
          z.lazy(() => DateTimeFieldUpdateOperationsInputSchema),
        ])
        .optional(),
      deletedAt: z
        .union([
          z.coerce.date(),
          z.lazy(() => NullableDateTimeFieldUpdateOperationsInputSchema),
        ])
        .optional()
        .nullable(),
    })
    .strict() as z.ZodType<Prisma.RoleUpdateManyMutationInput>;

export const RoleUncheckedUpdateManyInputSchema: z.ZodType<Prisma.RoleUncheckedUpdateManyInput> =
  z
    .object({
      id: z
        .union([
          z.string().uuid(),
          z.lazy(() => StringFieldUpdateOperationsInputSchema),
        ])
        .optional(),
      name: z
        .union([
          z.string(),
          z.lazy(() => StringFieldUpdateOperationsInputSchema),
        ])
        .optional(),
      description: z
        .union([
          z.string(),
          z.lazy(() => NullableStringFieldUpdateOperationsInputSchema),
        ])
        .optional()
        .nullable(),
      isSystemRole: z
        .union([
          z.boolean(),
          z.lazy(() => BoolFieldUpdateOperationsInputSchema),
        ])
        .optional(),
      createdAt: z
        .union([
          z.coerce.date(),
          z.lazy(() => DateTimeFieldUpdateOperationsInputSchema),
        ])
        .optional(),
      createdBy: z
        .union([
          z.string(),
          z.lazy(() => NullableStringFieldUpdateOperationsInputSchema),
        ])
        .optional()
        .nullable(),
      updatedAt: z
        .union([
          z.coerce.date(),
          z.lazy(() => DateTimeFieldUpdateOperationsInputSchema),
        ])
        .optional(),
      deletedAt: z
        .union([
          z.coerce.date(),
          z.lazy(() => NullableDateTimeFieldUpdateOperationsInputSchema),
        ])
        .optional()
        .nullable(),
    })
    .strict() as z.ZodType<Prisma.RoleUncheckedUpdateManyInput>;

export const PermissionCreateInputSchema: z.ZodType<Prisma.PermissionCreateInput> =
  z
    .object({
      id: z.string().uuid().optional(),
      name: z.string(),
      description: z.string().optional().nullable(),
      key: z
        .string()
        .describe(
          'Pattern: [/resource]_[action], e.g: [/product]_[read], [/product]_[create], [/product]_[manage]',
        ),
      isSystemPermission: z.boolean().optional(),
      createdAt: z.coerce.date().optional(),
      createdBy: z.string().optional().nullable(),
      updatedAt: z.coerce.date().optional(),
      deletedAt: z.coerce.date().optional().nullable(),
      rolePermissions: z
        .lazy(() => RolePermissionCreateNestedManyWithoutPermissionInputSchema)
        .optional(),
    })
    .strict() as z.ZodType<Prisma.PermissionCreateInput>;

export const PermissionUncheckedCreateInputSchema: z.ZodType<Prisma.PermissionUncheckedCreateInput> =
  z
    .object({
      id: z.string().uuid().optional(),
      name: z.string(),
      description: z.string().optional().nullable(),
      key: z
        .string()
        .describe(
          'Pattern: [/resource]_[action], e.g: [/product]_[read], [/product]_[create], [/product]_[manage]',
        ),
      isSystemPermission: z.boolean().optional(),
      createdAt: z.coerce.date().optional(),
      createdBy: z.string().optional().nullable(),
      updatedAt: z.coerce.date().optional(),
      deletedAt: z.coerce.date().optional().nullable(),
      rolePermissions: z
        .lazy(
          () =>
            RolePermissionUncheckedCreateNestedManyWithoutPermissionInputSchema,
        )
        .optional(),
    })
    .strict() as z.ZodType<Prisma.PermissionUncheckedCreateInput>;

export const PermissionUpdateInputSchema: z.ZodType<Prisma.PermissionUpdateInput> =
  z
    .object({
      id: z
        .union([
          z.string().uuid(),
          z.lazy(() => StringFieldUpdateOperationsInputSchema),
        ])
        .optional(),
      name: z
        .union([
          z.string(),
          z.lazy(() => StringFieldUpdateOperationsInputSchema),
        ])
        .optional(),
      description: z
        .union([
          z.string(),
          z.lazy(() => NullableStringFieldUpdateOperationsInputSchema),
        ])
        .optional()
        .nullable(),
      key: z
        .union([
          z
            .string()
            .describe(
              'Pattern: [/resource]_[action], e.g: [/product]_[read], [/product]_[create], [/product]_[manage]',
            ),
          z.lazy(() => StringFieldUpdateOperationsInputSchema),
        ])
        .optional(),
      isSystemPermission: z
        .union([
          z.boolean(),
          z.lazy(() => BoolFieldUpdateOperationsInputSchema),
        ])
        .optional(),
      createdAt: z
        .union([
          z.coerce.date(),
          z.lazy(() => DateTimeFieldUpdateOperationsInputSchema),
        ])
        .optional(),
      createdBy: z
        .union([
          z.string(),
          z.lazy(() => NullableStringFieldUpdateOperationsInputSchema),
        ])
        .optional()
        .nullable(),
      updatedAt: z
        .union([
          z.coerce.date(),
          z.lazy(() => DateTimeFieldUpdateOperationsInputSchema),
        ])
        .optional(),
      deletedAt: z
        .union([
          z.coerce.date(),
          z.lazy(() => NullableDateTimeFieldUpdateOperationsInputSchema),
        ])
        .optional()
        .nullable(),
      rolePermissions: z
        .lazy(() => RolePermissionUpdateManyWithoutPermissionNestedInputSchema)
        .optional(),
    })
    .strict() as z.ZodType<Prisma.PermissionUpdateInput>;

export const PermissionUncheckedUpdateInputSchema: z.ZodType<Prisma.PermissionUncheckedUpdateInput> =
  z
    .object({
      id: z
        .union([
          z.string().uuid(),
          z.lazy(() => StringFieldUpdateOperationsInputSchema),
        ])
        .optional(),
      name: z
        .union([
          z.string(),
          z.lazy(() => StringFieldUpdateOperationsInputSchema),
        ])
        .optional(),
      description: z
        .union([
          z.string(),
          z.lazy(() => NullableStringFieldUpdateOperationsInputSchema),
        ])
        .optional()
        .nullable(),
      key: z
        .union([
          z
            .string()
            .describe(
              'Pattern: [/resource]_[action], e.g: [/product]_[read], [/product]_[create], [/product]_[manage]',
            ),
          z.lazy(() => StringFieldUpdateOperationsInputSchema),
        ])
        .optional(),
      isSystemPermission: z
        .union([
          z.boolean(),
          z.lazy(() => BoolFieldUpdateOperationsInputSchema),
        ])
        .optional(),
      createdAt: z
        .union([
          z.coerce.date(),
          z.lazy(() => DateTimeFieldUpdateOperationsInputSchema),
        ])
        .optional(),
      createdBy: z
        .union([
          z.string(),
          z.lazy(() => NullableStringFieldUpdateOperationsInputSchema),
        ])
        .optional()
        .nullable(),
      updatedAt: z
        .union([
          z.coerce.date(),
          z.lazy(() => DateTimeFieldUpdateOperationsInputSchema),
        ])
        .optional(),
      deletedAt: z
        .union([
          z.coerce.date(),
          z.lazy(() => NullableDateTimeFieldUpdateOperationsInputSchema),
        ])
        .optional()
        .nullable(),
      rolePermissions: z
        .lazy(
          () =>
            RolePermissionUncheckedUpdateManyWithoutPermissionNestedInputSchema,
        )
        .optional(),
    })
    .strict() as z.ZodType<Prisma.PermissionUncheckedUpdateInput>;

export const PermissionCreateManyInputSchema: z.ZodType<Prisma.PermissionCreateManyInput> =
  z
    .object({
      id: z.string().uuid().optional(),
      name: z.string(),
      description: z.string().optional().nullable(),
      key: z
        .string()
        .describe(
          'Pattern: [/resource]_[action], e.g: [/product]_[read], [/product]_[create], [/product]_[manage]',
        ),
      isSystemPermission: z.boolean().optional(),
      createdAt: z.coerce.date().optional(),
      createdBy: z.string().optional().nullable(),
      updatedAt: z.coerce.date().optional(),
      deletedAt: z.coerce.date().optional().nullable(),
    })
    .strict() as z.ZodType<Prisma.PermissionCreateManyInput>;

export const PermissionUpdateManyMutationInputSchema: z.ZodType<Prisma.PermissionUpdateManyMutationInput> =
  z
    .object({
      id: z
        .union([
          z.string().uuid(),
          z.lazy(() => StringFieldUpdateOperationsInputSchema),
        ])
        .optional(),
      name: z
        .union([
          z.string(),
          z.lazy(() => StringFieldUpdateOperationsInputSchema),
        ])
        .optional(),
      description: z
        .union([
          z.string(),
          z.lazy(() => NullableStringFieldUpdateOperationsInputSchema),
        ])
        .optional()
        .nullable(),
      key: z
        .union([
          z
            .string()
            .describe(
              'Pattern: [/resource]_[action], e.g: [/product]_[read], [/product]_[create], [/product]_[manage]',
            ),
          z.lazy(() => StringFieldUpdateOperationsInputSchema),
        ])
        .optional(),
      isSystemPermission: z
        .union([
          z.boolean(),
          z.lazy(() => BoolFieldUpdateOperationsInputSchema),
        ])
        .optional(),
      createdAt: z
        .union([
          z.coerce.date(),
          z.lazy(() => DateTimeFieldUpdateOperationsInputSchema),
        ])
        .optional(),
      createdBy: z
        .union([
          z.string(),
          z.lazy(() => NullableStringFieldUpdateOperationsInputSchema),
        ])
        .optional()
        .nullable(),
      updatedAt: z
        .union([
          z.coerce.date(),
          z.lazy(() => DateTimeFieldUpdateOperationsInputSchema),
        ])
        .optional(),
      deletedAt: z
        .union([
          z.coerce.date(),
          z.lazy(() => NullableDateTimeFieldUpdateOperationsInputSchema),
        ])
        .optional()
        .nullable(),
    })
    .strict() as z.ZodType<Prisma.PermissionUpdateManyMutationInput>;

export const PermissionUncheckedUpdateManyInputSchema: z.ZodType<Prisma.PermissionUncheckedUpdateManyInput> =
  z
    .object({
      id: z
        .union([
          z.string().uuid(),
          z.lazy(() => StringFieldUpdateOperationsInputSchema),
        ])
        .optional(),
      name: z
        .union([
          z.string(),
          z.lazy(() => StringFieldUpdateOperationsInputSchema),
        ])
        .optional(),
      description: z
        .union([
          z.string(),
          z.lazy(() => NullableStringFieldUpdateOperationsInputSchema),
        ])
        .optional()
        .nullable(),
      key: z
        .union([
          z
            .string()
            .describe(
              'Pattern: [/resource]_[action], e.g: [/product]_[read], [/product]_[create], [/product]_[manage]',
            ),
          z.lazy(() => StringFieldUpdateOperationsInputSchema),
        ])
        .optional(),
      isSystemPermission: z
        .union([
          z.boolean(),
          z.lazy(() => BoolFieldUpdateOperationsInputSchema),
        ])
        .optional(),
      createdAt: z
        .union([
          z.coerce.date(),
          z.lazy(() => DateTimeFieldUpdateOperationsInputSchema),
        ])
        .optional(),
      createdBy: z
        .union([
          z.string(),
          z.lazy(() => NullableStringFieldUpdateOperationsInputSchema),
        ])
        .optional()
        .nullable(),
      updatedAt: z
        .union([
          z.coerce.date(),
          z.lazy(() => DateTimeFieldUpdateOperationsInputSchema),
        ])
        .optional(),
      deletedAt: z
        .union([
          z.coerce.date(),
          z.lazy(() => NullableDateTimeFieldUpdateOperationsInputSchema),
        ])
        .optional()
        .nullable(),
    })
    .strict() as z.ZodType<Prisma.PermissionUncheckedUpdateManyInput>;

export const RolePermissionCreateInputSchema: z.ZodType<Prisma.RolePermissionCreateInput> =
  z
    .object({
      createdAt: z.coerce.date().optional(),
      createdBy: z.string().optional().nullable(),
      role: z.lazy(() => RoleCreateNestedOneWithoutRolePermissionsInputSchema),
      permission: z.lazy(
        () => PermissionCreateNestedOneWithoutRolePermissionsInputSchema,
      ),
    })
    .strict() as z.ZodType<Prisma.RolePermissionCreateInput>;

export const RolePermissionUncheckedCreateInputSchema: z.ZodType<Prisma.RolePermissionUncheckedCreateInput> =
  z
    .object({
      roleID: z.string(),
      permissionID: z.string(),
      createdAt: z.coerce.date().optional(),
      createdBy: z.string().optional().nullable(),
    })
    .strict() as z.ZodType<Prisma.RolePermissionUncheckedCreateInput>;

export const RolePermissionUpdateInputSchema: z.ZodType<Prisma.RolePermissionUpdateInput> =
  z
    .object({
      createdAt: z
        .union([
          z.coerce.date(),
          z.lazy(() => DateTimeFieldUpdateOperationsInputSchema),
        ])
        .optional(),
      createdBy: z
        .union([
          z.string(),
          z.lazy(() => NullableStringFieldUpdateOperationsInputSchema),
        ])
        .optional()
        .nullable(),
      role: z
        .lazy(
          () => RoleUpdateOneRequiredWithoutRolePermissionsNestedInputSchema,
        )
        .optional(),
      permission: z
        .lazy(
          () =>
            PermissionUpdateOneRequiredWithoutRolePermissionsNestedInputSchema,
        )
        .optional(),
    })
    .strict() as z.ZodType<Prisma.RolePermissionUpdateInput>;

export const RolePermissionUncheckedUpdateInputSchema: z.ZodType<Prisma.RolePermissionUncheckedUpdateInput> =
  z
    .object({
      roleID: z
        .union([
          z.string(),
          z.lazy(() => StringFieldUpdateOperationsInputSchema),
        ])
        .optional(),
      permissionID: z
        .union([
          z.string(),
          z.lazy(() => StringFieldUpdateOperationsInputSchema),
        ])
        .optional(),
      createdAt: z
        .union([
          z.coerce.date(),
          z.lazy(() => DateTimeFieldUpdateOperationsInputSchema),
        ])
        .optional(),
      createdBy: z
        .union([
          z.string(),
          z.lazy(() => NullableStringFieldUpdateOperationsInputSchema),
        ])
        .optional()
        .nullable(),
    })
    .strict() as z.ZodType<Prisma.RolePermissionUncheckedUpdateInput>;

export const RolePermissionCreateManyInputSchema: z.ZodType<Prisma.RolePermissionCreateManyInput> =
  z
    .object({
      roleID: z.string(),
      permissionID: z.string(),
      createdAt: z.coerce.date().optional(),
      createdBy: z.string().optional().nullable(),
    })
    .strict() as z.ZodType<Prisma.RolePermissionCreateManyInput>;

export const RolePermissionUpdateManyMutationInputSchema: z.ZodType<Prisma.RolePermissionUpdateManyMutationInput> =
  z
    .object({
      createdAt: z
        .union([
          z.coerce.date(),
          z.lazy(() => DateTimeFieldUpdateOperationsInputSchema),
        ])
        .optional(),
      createdBy: z
        .union([
          z.string(),
          z.lazy(() => NullableStringFieldUpdateOperationsInputSchema),
        ])
        .optional()
        .nullable(),
    })
    .strict() as z.ZodType<Prisma.RolePermissionUpdateManyMutationInput>;

export const RolePermissionUncheckedUpdateManyInputSchema: z.ZodType<Prisma.RolePermissionUncheckedUpdateManyInput> =
  z
    .object({
      roleID: z
        .union([
          z.string(),
          z.lazy(() => StringFieldUpdateOperationsInputSchema),
        ])
        .optional(),
      permissionID: z
        .union([
          z.string(),
          z.lazy(() => StringFieldUpdateOperationsInputSchema),
        ])
        .optional(),
      createdAt: z
        .union([
          z.coerce.date(),
          z.lazy(() => DateTimeFieldUpdateOperationsInputSchema),
        ])
        .optional(),
      createdBy: z
        .union([
          z.string(),
          z.lazy(() => NullableStringFieldUpdateOperationsInputSchema),
        ])
        .optional()
        .nullable(),
    })
    .strict() as z.ZodType<Prisma.RolePermissionUncheckedUpdateManyInput>;

export const UserVendorRoleCreateInputSchema: z.ZodType<Prisma.UserVendorRoleCreateInput> =
  z
    .object({
      id: z.string().uuid().optional(),
      status: z.lazy(() => UserVendorRoleStatusSchema).optional(),
      createdAt: z.coerce.date().optional(),
      createdBy: z.string().optional().nullable(),
      user: z.lazy(() => UserCreateNestedOneWithoutUserVendorRolesInputSchema),
      vendor: z.lazy(
        () => VendorCreateNestedOneWithoutUserVendorRolesInputSchema,
      ),
      role: z.lazy(() => RoleCreateNestedOneWithoutUserVendorRolesInputSchema),
    })
    .strict() as z.ZodType<Prisma.UserVendorRoleCreateInput>;

export const UserVendorRoleUncheckedCreateInputSchema: z.ZodType<Prisma.UserVendorRoleUncheckedCreateInput> =
  z
    .object({
      id: z.string().uuid().optional(),
      userID: z.string(),
      vendorID: z.string(),
      roleID: z.string(),
      status: z.lazy(() => UserVendorRoleStatusSchema).optional(),
      createdAt: z.coerce.date().optional(),
      createdBy: z.string().optional().nullable(),
    })
    .strict() as z.ZodType<Prisma.UserVendorRoleUncheckedCreateInput>;

export const UserVendorRoleUpdateInputSchema: z.ZodType<Prisma.UserVendorRoleUpdateInput> =
  z
    .object({
      id: z
        .union([
          z.string().uuid(),
          z.lazy(() => StringFieldUpdateOperationsInputSchema),
        ])
        .optional(),
      status: z
        .union([
          z.lazy(() => UserVendorRoleStatusSchema),
          z.lazy(
            () => EnumUserVendorRoleStatusFieldUpdateOperationsInputSchema,
          ),
        ])
        .optional(),
      createdAt: z
        .union([
          z.coerce.date(),
          z.lazy(() => DateTimeFieldUpdateOperationsInputSchema),
        ])
        .optional(),
      createdBy: z
        .union([
          z.string(),
          z.lazy(() => NullableStringFieldUpdateOperationsInputSchema),
        ])
        .optional()
        .nullable(),
      user: z
        .lazy(
          () => UserUpdateOneRequiredWithoutUserVendorRolesNestedInputSchema,
        )
        .optional(),
      vendor: z
        .lazy(
          () => VendorUpdateOneRequiredWithoutUserVendorRolesNestedInputSchema,
        )
        .optional(),
      role: z
        .lazy(
          () => RoleUpdateOneRequiredWithoutUserVendorRolesNestedInputSchema,
        )
        .optional(),
    })
    .strict() as z.ZodType<Prisma.UserVendorRoleUpdateInput>;

export const UserVendorRoleUncheckedUpdateInputSchema: z.ZodType<Prisma.UserVendorRoleUncheckedUpdateInput> =
  z
    .object({
      id: z
        .union([
          z.string().uuid(),
          z.lazy(() => StringFieldUpdateOperationsInputSchema),
        ])
        .optional(),
      userID: z
        .union([
          z.string(),
          z.lazy(() => StringFieldUpdateOperationsInputSchema),
        ])
        .optional(),
      vendorID: z
        .union([
          z.string(),
          z.lazy(() => StringFieldUpdateOperationsInputSchema),
        ])
        .optional(),
      roleID: z
        .union([
          z.string(),
          z.lazy(() => StringFieldUpdateOperationsInputSchema),
        ])
        .optional(),
      status: z
        .union([
          z.lazy(() => UserVendorRoleStatusSchema),
          z.lazy(
            () => EnumUserVendorRoleStatusFieldUpdateOperationsInputSchema,
          ),
        ])
        .optional(),
      createdAt: z
        .union([
          z.coerce.date(),
          z.lazy(() => DateTimeFieldUpdateOperationsInputSchema),
        ])
        .optional(),
      createdBy: z
        .union([
          z.string(),
          z.lazy(() => NullableStringFieldUpdateOperationsInputSchema),
        ])
        .optional()
        .nullable(),
    })
    .strict() as z.ZodType<Prisma.UserVendorRoleUncheckedUpdateInput>;

export const UserVendorRoleCreateManyInputSchema: z.ZodType<Prisma.UserVendorRoleCreateManyInput> =
  z
    .object({
      id: z.string().uuid().optional(),
      userID: z.string(),
      vendorID: z.string(),
      roleID: z.string(),
      status: z.lazy(() => UserVendorRoleStatusSchema).optional(),
      createdAt: z.coerce.date().optional(),
      createdBy: z.string().optional().nullable(),
    })
    .strict() as z.ZodType<Prisma.UserVendorRoleCreateManyInput>;

export const UserVendorRoleUpdateManyMutationInputSchema: z.ZodType<Prisma.UserVendorRoleUpdateManyMutationInput> =
  z
    .object({
      id: z
        .union([
          z.string().uuid(),
          z.lazy(() => StringFieldUpdateOperationsInputSchema),
        ])
        .optional(),
      status: z
        .union([
          z.lazy(() => UserVendorRoleStatusSchema),
          z.lazy(
            () => EnumUserVendorRoleStatusFieldUpdateOperationsInputSchema,
          ),
        ])
        .optional(),
      createdAt: z
        .union([
          z.coerce.date(),
          z.lazy(() => DateTimeFieldUpdateOperationsInputSchema),
        ])
        .optional(),
      createdBy: z
        .union([
          z.string(),
          z.lazy(() => NullableStringFieldUpdateOperationsInputSchema),
        ])
        .optional()
        .nullable(),
    })
    .strict() as z.ZodType<Prisma.UserVendorRoleUpdateManyMutationInput>;

export const UserVendorRoleUncheckedUpdateManyInputSchema: z.ZodType<Prisma.UserVendorRoleUncheckedUpdateManyInput> =
  z
    .object({
      id: z
        .union([
          z.string().uuid(),
          z.lazy(() => StringFieldUpdateOperationsInputSchema),
        ])
        .optional(),
      userID: z
        .union([
          z.string(),
          z.lazy(() => StringFieldUpdateOperationsInputSchema),
        ])
        .optional(),
      vendorID: z
        .union([
          z.string(),
          z.lazy(() => StringFieldUpdateOperationsInputSchema),
        ])
        .optional(),
      roleID: z
        .union([
          z.string(),
          z.lazy(() => StringFieldUpdateOperationsInputSchema),
        ])
        .optional(),
      status: z
        .union([
          z.lazy(() => UserVendorRoleStatusSchema),
          z.lazy(
            () => EnumUserVendorRoleStatusFieldUpdateOperationsInputSchema,
          ),
        ])
        .optional(),
      createdAt: z
        .union([
          z.coerce.date(),
          z.lazy(() => DateTimeFieldUpdateOperationsInputSchema),
        ])
        .optional(),
      createdBy: z
        .union([
          z.string(),
          z.lazy(() => NullableStringFieldUpdateOperationsInputSchema),
        ])
        .optional()
        .nullable(),
    })
    .strict() as z.ZodType<Prisma.UserVendorRoleUncheckedUpdateManyInput>;

export const CategoryCreateInputSchema: z.ZodType<Prisma.CategoryCreateInput> =
  z
    .object({
      id: z.string().uuid().optional(),
      name: z.string(),
      slug: z.string(),
      description: z.string().optional().nullable(),
      imageUrl: z.string().optional().nullable(),
      createdAt: z.coerce.date().optional(),
      createdBy: z.string().optional().nullable(),
      updatedAt: z.coerce.date().optional(),
      deletedAt: z.coerce.date().optional().nullable(),
      parent: z
        .lazy(() => CategoryCreateNestedOneWithoutChildrenInputSchema)
        .optional(),
      children: z
        .lazy(() => CategoryCreateNestedManyWithoutParentInputSchema)
        .optional(),
      productCategories: z
        .lazy(() => ProductCategoryCreateNestedManyWithoutCategoryInputSchema)
        .optional(),
    })
    .strict() as z.ZodType<Prisma.CategoryCreateInput>;

export const CategoryUncheckedCreateInputSchema: z.ZodType<Prisma.CategoryUncheckedCreateInput> =
  z
    .object({
      id: z.string().uuid().optional(),
      name: z.string(),
      slug: z.string(),
      description: z.string().optional().nullable(),
      parentID: z.string().optional().nullable(),
      imageUrl: z.string().optional().nullable(),
      createdAt: z.coerce.date().optional(),
      createdBy: z.string().optional().nullable(),
      updatedAt: z.coerce.date().optional(),
      deletedAt: z.coerce.date().optional().nullable(),
      children: z
        .lazy(() => CategoryUncheckedCreateNestedManyWithoutParentInputSchema)
        .optional(),
      productCategories: z
        .lazy(
          () =>
            ProductCategoryUncheckedCreateNestedManyWithoutCategoryInputSchema,
        )
        .optional(),
    })
    .strict() as z.ZodType<Prisma.CategoryUncheckedCreateInput>;

export const CategoryUpdateInputSchema: z.ZodType<Prisma.CategoryUpdateInput> =
  z
    .object({
      id: z
        .union([
          z.string().uuid(),
          z.lazy(() => StringFieldUpdateOperationsInputSchema),
        ])
        .optional(),
      name: z
        .union([
          z.string(),
          z.lazy(() => StringFieldUpdateOperationsInputSchema),
        ])
        .optional(),
      slug: z
        .union([
          z.string(),
          z.lazy(() => StringFieldUpdateOperationsInputSchema),
        ])
        .optional(),
      description: z
        .union([
          z.string(),
          z.lazy(() => NullableStringFieldUpdateOperationsInputSchema),
        ])
        .optional()
        .nullable(),
      imageUrl: z
        .union([
          z.string(),
          z.lazy(() => NullableStringFieldUpdateOperationsInputSchema),
        ])
        .optional()
        .nullable(),
      createdAt: z
        .union([
          z.coerce.date(),
          z.lazy(() => DateTimeFieldUpdateOperationsInputSchema),
        ])
        .optional(),
      createdBy: z
        .union([
          z.string(),
          z.lazy(() => NullableStringFieldUpdateOperationsInputSchema),
        ])
        .optional()
        .nullable(),
      updatedAt: z
        .union([
          z.coerce.date(),
          z.lazy(() => DateTimeFieldUpdateOperationsInputSchema),
        ])
        .optional(),
      deletedAt: z
        .union([
          z.coerce.date(),
          z.lazy(() => NullableDateTimeFieldUpdateOperationsInputSchema),
        ])
        .optional()
        .nullable(),
      parent: z
        .lazy(() => CategoryUpdateOneWithoutChildrenNestedInputSchema)
        .optional(),
      children: z
        .lazy(() => CategoryUpdateManyWithoutParentNestedInputSchema)
        .optional(),
      productCategories: z
        .lazy(() => ProductCategoryUpdateManyWithoutCategoryNestedInputSchema)
        .optional(),
    })
    .strict() as z.ZodType<Prisma.CategoryUpdateInput>;

export const CategoryUncheckedUpdateInputSchema: z.ZodType<Prisma.CategoryUncheckedUpdateInput> =
  z
    .object({
      id: z
        .union([
          z.string().uuid(),
          z.lazy(() => StringFieldUpdateOperationsInputSchema),
        ])
        .optional(),
      name: z
        .union([
          z.string(),
          z.lazy(() => StringFieldUpdateOperationsInputSchema),
        ])
        .optional(),
      slug: z
        .union([
          z.string(),
          z.lazy(() => StringFieldUpdateOperationsInputSchema),
        ])
        .optional(),
      description: z
        .union([
          z.string(),
          z.lazy(() => NullableStringFieldUpdateOperationsInputSchema),
        ])
        .optional()
        .nullable(),
      parentID: z
        .union([
          z.string(),
          z.lazy(() => NullableStringFieldUpdateOperationsInputSchema),
        ])
        .optional()
        .nullable(),
      imageUrl: z
        .union([
          z.string(),
          z.lazy(() => NullableStringFieldUpdateOperationsInputSchema),
        ])
        .optional()
        .nullable(),
      createdAt: z
        .union([
          z.coerce.date(),
          z.lazy(() => DateTimeFieldUpdateOperationsInputSchema),
        ])
        .optional(),
      createdBy: z
        .union([
          z.string(),
          z.lazy(() => NullableStringFieldUpdateOperationsInputSchema),
        ])
        .optional()
        .nullable(),
      updatedAt: z
        .union([
          z.coerce.date(),
          z.lazy(() => DateTimeFieldUpdateOperationsInputSchema),
        ])
        .optional(),
      deletedAt: z
        .union([
          z.coerce.date(),
          z.lazy(() => NullableDateTimeFieldUpdateOperationsInputSchema),
        ])
        .optional()
        .nullable(),
      children: z
        .lazy(() => CategoryUncheckedUpdateManyWithoutParentNestedInputSchema)
        .optional(),
      productCategories: z
        .lazy(
          () =>
            ProductCategoryUncheckedUpdateManyWithoutCategoryNestedInputSchema,
        )
        .optional(),
    })
    .strict() as z.ZodType<Prisma.CategoryUncheckedUpdateInput>;

export const CategoryCreateManyInputSchema: z.ZodType<Prisma.CategoryCreateManyInput> =
  z
    .object({
      id: z.string().uuid().optional(),
      name: z.string(),
      slug: z.string(),
      description: z.string().optional().nullable(),
      parentID: z.string().optional().nullable(),
      imageUrl: z.string().optional().nullable(),
      createdAt: z.coerce.date().optional(),
      createdBy: z.string().optional().nullable(),
      updatedAt: z.coerce.date().optional(),
      deletedAt: z.coerce.date().optional().nullable(),
    })
    .strict() as z.ZodType<Prisma.CategoryCreateManyInput>;

export const CategoryUpdateManyMutationInputSchema: z.ZodType<Prisma.CategoryUpdateManyMutationInput> =
  z
    .object({
      id: z
        .union([
          z.string().uuid(),
          z.lazy(() => StringFieldUpdateOperationsInputSchema),
        ])
        .optional(),
      name: z
        .union([
          z.string(),
          z.lazy(() => StringFieldUpdateOperationsInputSchema),
        ])
        .optional(),
      slug: z
        .union([
          z.string(),
          z.lazy(() => StringFieldUpdateOperationsInputSchema),
        ])
        .optional(),
      description: z
        .union([
          z.string(),
          z.lazy(() => NullableStringFieldUpdateOperationsInputSchema),
        ])
        .optional()
        .nullable(),
      imageUrl: z
        .union([
          z.string(),
          z.lazy(() => NullableStringFieldUpdateOperationsInputSchema),
        ])
        .optional()
        .nullable(),
      createdAt: z
        .union([
          z.coerce.date(),
          z.lazy(() => DateTimeFieldUpdateOperationsInputSchema),
        ])
        .optional(),
      createdBy: z
        .union([
          z.string(),
          z.lazy(() => NullableStringFieldUpdateOperationsInputSchema),
        ])
        .optional()
        .nullable(),
      updatedAt: z
        .union([
          z.coerce.date(),
          z.lazy(() => DateTimeFieldUpdateOperationsInputSchema),
        ])
        .optional(),
      deletedAt: z
        .union([
          z.coerce.date(),
          z.lazy(() => NullableDateTimeFieldUpdateOperationsInputSchema),
        ])
        .optional()
        .nullable(),
    })
    .strict() as z.ZodType<Prisma.CategoryUpdateManyMutationInput>;

export const CategoryUncheckedUpdateManyInputSchema: z.ZodType<Prisma.CategoryUncheckedUpdateManyInput> =
  z
    .object({
      id: z
        .union([
          z.string().uuid(),
          z.lazy(() => StringFieldUpdateOperationsInputSchema),
        ])
        .optional(),
      name: z
        .union([
          z.string(),
          z.lazy(() => StringFieldUpdateOperationsInputSchema),
        ])
        .optional(),
      slug: z
        .union([
          z.string(),
          z.lazy(() => StringFieldUpdateOperationsInputSchema),
        ])
        .optional(),
      description: z
        .union([
          z.string(),
          z.lazy(() => NullableStringFieldUpdateOperationsInputSchema),
        ])
        .optional()
        .nullable(),
      parentID: z
        .union([
          z.string(),
          z.lazy(() => NullableStringFieldUpdateOperationsInputSchema),
        ])
        .optional()
        .nullable(),
      imageUrl: z
        .union([
          z.string(),
          z.lazy(() => NullableStringFieldUpdateOperationsInputSchema),
        ])
        .optional()
        .nullable(),
      createdAt: z
        .union([
          z.coerce.date(),
          z.lazy(() => DateTimeFieldUpdateOperationsInputSchema),
        ])
        .optional(),
      createdBy: z
        .union([
          z.string(),
          z.lazy(() => NullableStringFieldUpdateOperationsInputSchema),
        ])
        .optional()
        .nullable(),
      updatedAt: z
        .union([
          z.coerce.date(),
          z.lazy(() => DateTimeFieldUpdateOperationsInputSchema),
        ])
        .optional(),
      deletedAt: z
        .union([
          z.coerce.date(),
          z.lazy(() => NullableDateTimeFieldUpdateOperationsInputSchema),
        ])
        .optional()
        .nullable(),
    })
    .strict() as z.ZodType<Prisma.CategoryUncheckedUpdateManyInput>;

export const ProductCreateInputSchema: z.ZodType<Prisma.ProductCreateInput> = z
  .object({
    id: z.string().uuid().optional(),
    name: z.string(),
    slug: z.string(),
    description: z.string().optional().nullable(),
    sku: z.string().optional().nullable(),
    price: z
      .union([
        z.number(),
        z.string(),
        z.instanceof(Decimal),
        z.instanceof(Prisma.Decimal),
        DecimalJsLikeSchema,
      ])
      .refine((v) => isValidDecimalInput(v), { message: 'Must be a Decimal' }),
    stockQuantity: z.number().int().optional(),
    status: z.lazy(() => ProductStatusSchema).optional(),
    createdAt: z.coerce.date().optional(),
    createdBy: z.string().optional().nullable(),
    updatedAt: z.coerce.date().optional(),
    deletedAt: z.coerce.date().optional().nullable(),
    vendor: z.lazy(() => VendorCreateNestedOneWithoutProductsInputSchema),
    productCategories: z
      .lazy(() => ProductCategoryCreateNestedManyWithoutProductInputSchema)
      .optional(),
    productImages: z
      .lazy(() => ProductImageCreateNestedManyWithoutProductInputSchema)
      .optional(),
    productVariants: z
      .lazy(() => ProductVariantCreateNestedManyWithoutProductInputSchema)
      .optional(),
  })
  .strict() as z.ZodType<Prisma.ProductCreateInput>;

export const ProductUncheckedCreateInputSchema: z.ZodType<Prisma.ProductUncheckedCreateInput> =
  z
    .object({
      id: z.string().uuid().optional(),
      vendorID: z.string(),
      name: z.string(),
      slug: z.string(),
      description: z.string().optional().nullable(),
      sku: z.string().optional().nullable(),
      price: z
        .union([
          z.number(),
          z.string(),
          z.instanceof(Decimal),
          z.instanceof(Prisma.Decimal),
          DecimalJsLikeSchema,
        ])
        .refine((v) => isValidDecimalInput(v), {
          message: 'Must be a Decimal',
        }),
      stockQuantity: z.number().int().optional(),
      status: z.lazy(() => ProductStatusSchema).optional(),
      createdAt: z.coerce.date().optional(),
      createdBy: z.string().optional().nullable(),
      updatedAt: z.coerce.date().optional(),
      deletedAt: z.coerce.date().optional().nullable(),
      productCategories: z
        .lazy(
          () =>
            ProductCategoryUncheckedCreateNestedManyWithoutProductInputSchema,
        )
        .optional(),
      productImages: z
        .lazy(
          () => ProductImageUncheckedCreateNestedManyWithoutProductInputSchema,
        )
        .optional(),
      productVariants: z
        .lazy(
          () =>
            ProductVariantUncheckedCreateNestedManyWithoutProductInputSchema,
        )
        .optional(),
    })
    .strict() as z.ZodType<Prisma.ProductUncheckedCreateInput>;

export const ProductUpdateInputSchema: z.ZodType<Prisma.ProductUpdateInput> = z
  .object({
    id: z
      .union([
        z.string().uuid(),
        z.lazy(() => StringFieldUpdateOperationsInputSchema),
      ])
      .optional(),
    name: z
      .union([z.string(), z.lazy(() => StringFieldUpdateOperationsInputSchema)])
      .optional(),
    slug: z
      .union([z.string(), z.lazy(() => StringFieldUpdateOperationsInputSchema)])
      .optional(),
    description: z
      .union([
        z.string(),
        z.lazy(() => NullableStringFieldUpdateOperationsInputSchema),
      ])
      .optional()
      .nullable(),
    sku: z
      .union([
        z.string(),
        z.lazy(() => NullableStringFieldUpdateOperationsInputSchema),
      ])
      .optional()
      .nullable(),
    price: z
      .union([
        z
          .union([
            z.number(),
            z.string(),
            z.instanceof(Decimal),
            z.instanceof(Prisma.Decimal),
            DecimalJsLikeSchema,
          ])
          .refine((v) => isValidDecimalInput(v), {
            message: 'Must be a Decimal',
          }),
        z.lazy(() => DecimalFieldUpdateOperationsInputSchema),
      ])
      .optional(),
    stockQuantity: z
      .union([
        z.number().int(),
        z.lazy(() => IntFieldUpdateOperationsInputSchema),
      ])
      .optional(),
    status: z
      .union([
        z.lazy(() => ProductStatusSchema),
        z.lazy(() => EnumProductStatusFieldUpdateOperationsInputSchema),
      ])
      .optional(),
    createdAt: z
      .union([
        z.coerce.date(),
        z.lazy(() => DateTimeFieldUpdateOperationsInputSchema),
      ])
      .optional(),
    createdBy: z
      .union([
        z.string(),
        z.lazy(() => NullableStringFieldUpdateOperationsInputSchema),
      ])
      .optional()
      .nullable(),
    updatedAt: z
      .union([
        z.coerce.date(),
        z.lazy(() => DateTimeFieldUpdateOperationsInputSchema),
      ])
      .optional(),
    deletedAt: z
      .union([
        z.coerce.date(),
        z.lazy(() => NullableDateTimeFieldUpdateOperationsInputSchema),
      ])
      .optional()
      .nullable(),
    vendor: z
      .lazy(() => VendorUpdateOneRequiredWithoutProductsNestedInputSchema)
      .optional(),
    productCategories: z
      .lazy(() => ProductCategoryUpdateManyWithoutProductNestedInputSchema)
      .optional(),
    productImages: z
      .lazy(() => ProductImageUpdateManyWithoutProductNestedInputSchema)
      .optional(),
    productVariants: z
      .lazy(() => ProductVariantUpdateManyWithoutProductNestedInputSchema)
      .optional(),
  })
  .strict() as z.ZodType<Prisma.ProductUpdateInput>;

export const ProductUncheckedUpdateInputSchema: z.ZodType<Prisma.ProductUncheckedUpdateInput> =
  z
    .object({
      id: z
        .union([
          z.string().uuid(),
          z.lazy(() => StringFieldUpdateOperationsInputSchema),
        ])
        .optional(),
      vendorID: z
        .union([
          z.string(),
          z.lazy(() => StringFieldUpdateOperationsInputSchema),
        ])
        .optional(),
      name: z
        .union([
          z.string(),
          z.lazy(() => StringFieldUpdateOperationsInputSchema),
        ])
        .optional(),
      slug: z
        .union([
          z.string(),
          z.lazy(() => StringFieldUpdateOperationsInputSchema),
        ])
        .optional(),
      description: z
        .union([
          z.string(),
          z.lazy(() => NullableStringFieldUpdateOperationsInputSchema),
        ])
        .optional()
        .nullable(),
      sku: z
        .union([
          z.string(),
          z.lazy(() => NullableStringFieldUpdateOperationsInputSchema),
        ])
        .optional()
        .nullable(),
      price: z
        .union([
          z
            .union([
              z.number(),
              z.string(),
              z.instanceof(Decimal),
              z.instanceof(Prisma.Decimal),
              DecimalJsLikeSchema,
            ])
            .refine((v) => isValidDecimalInput(v), {
              message: 'Must be a Decimal',
            }),
          z.lazy(() => DecimalFieldUpdateOperationsInputSchema),
        ])
        .optional(),
      stockQuantity: z
        .union([
          z.number().int(),
          z.lazy(() => IntFieldUpdateOperationsInputSchema),
        ])
        .optional(),
      status: z
        .union([
          z.lazy(() => ProductStatusSchema),
          z.lazy(() => EnumProductStatusFieldUpdateOperationsInputSchema),
        ])
        .optional(),
      createdAt: z
        .union([
          z.coerce.date(),
          z.lazy(() => DateTimeFieldUpdateOperationsInputSchema),
        ])
        .optional(),
      createdBy: z
        .union([
          z.string(),
          z.lazy(() => NullableStringFieldUpdateOperationsInputSchema),
        ])
        .optional()
        .nullable(),
      updatedAt: z
        .union([
          z.coerce.date(),
          z.lazy(() => DateTimeFieldUpdateOperationsInputSchema),
        ])
        .optional(),
      deletedAt: z
        .union([
          z.coerce.date(),
          z.lazy(() => NullableDateTimeFieldUpdateOperationsInputSchema),
        ])
        .optional()
        .nullable(),
      productCategories: z
        .lazy(
          () =>
            ProductCategoryUncheckedUpdateManyWithoutProductNestedInputSchema,
        )
        .optional(),
      productImages: z
        .lazy(
          () => ProductImageUncheckedUpdateManyWithoutProductNestedInputSchema,
        )
        .optional(),
      productVariants: z
        .lazy(
          () =>
            ProductVariantUncheckedUpdateManyWithoutProductNestedInputSchema,
        )
        .optional(),
    })
    .strict() as z.ZodType<Prisma.ProductUncheckedUpdateInput>;

export const ProductCreateManyInputSchema: z.ZodType<Prisma.ProductCreateManyInput> =
  z
    .object({
      id: z.string().uuid().optional(),
      vendorID: z.string(),
      name: z.string(),
      slug: z.string(),
      description: z.string().optional().nullable(),
      sku: z.string().optional().nullable(),
      price: z
        .union([
          z.number(),
          z.string(),
          z.instanceof(Decimal),
          z.instanceof(Prisma.Decimal),
          DecimalJsLikeSchema,
        ])
        .refine((v) => isValidDecimalInput(v), {
          message: 'Must be a Decimal',
        }),
      stockQuantity: z.number().int().optional(),
      status: z.lazy(() => ProductStatusSchema).optional(),
      createdAt: z.coerce.date().optional(),
      createdBy: z.string().optional().nullable(),
      updatedAt: z.coerce.date().optional(),
      deletedAt: z.coerce.date().optional().nullable(),
    })
    .strict() as z.ZodType<Prisma.ProductCreateManyInput>;

export const ProductUpdateManyMutationInputSchema: z.ZodType<Prisma.ProductUpdateManyMutationInput> =
  z
    .object({
      id: z
        .union([
          z.string().uuid(),
          z.lazy(() => StringFieldUpdateOperationsInputSchema),
        ])
        .optional(),
      name: z
        .union([
          z.string(),
          z.lazy(() => StringFieldUpdateOperationsInputSchema),
        ])
        .optional(),
      slug: z
        .union([
          z.string(),
          z.lazy(() => StringFieldUpdateOperationsInputSchema),
        ])
        .optional(),
      description: z
        .union([
          z.string(),
          z.lazy(() => NullableStringFieldUpdateOperationsInputSchema),
        ])
        .optional()
        .nullable(),
      sku: z
        .union([
          z.string(),
          z.lazy(() => NullableStringFieldUpdateOperationsInputSchema),
        ])
        .optional()
        .nullable(),
      price: z
        .union([
          z
            .union([
              z.number(),
              z.string(),
              z.instanceof(Decimal),
              z.instanceof(Prisma.Decimal),
              DecimalJsLikeSchema,
            ])
            .refine((v) => isValidDecimalInput(v), {
              message: 'Must be a Decimal',
            }),
          z.lazy(() => DecimalFieldUpdateOperationsInputSchema),
        ])
        .optional(),
      stockQuantity: z
        .union([
          z.number().int(),
          z.lazy(() => IntFieldUpdateOperationsInputSchema),
        ])
        .optional(),
      status: z
        .union([
          z.lazy(() => ProductStatusSchema),
          z.lazy(() => EnumProductStatusFieldUpdateOperationsInputSchema),
        ])
        .optional(),
      createdAt: z
        .union([
          z.coerce.date(),
          z.lazy(() => DateTimeFieldUpdateOperationsInputSchema),
        ])
        .optional(),
      createdBy: z
        .union([
          z.string(),
          z.lazy(() => NullableStringFieldUpdateOperationsInputSchema),
        ])
        .optional()
        .nullable(),
      updatedAt: z
        .union([
          z.coerce.date(),
          z.lazy(() => DateTimeFieldUpdateOperationsInputSchema),
        ])
        .optional(),
      deletedAt: z
        .union([
          z.coerce.date(),
          z.lazy(() => NullableDateTimeFieldUpdateOperationsInputSchema),
        ])
        .optional()
        .nullable(),
    })
    .strict() as z.ZodType<Prisma.ProductUpdateManyMutationInput>;

export const ProductUncheckedUpdateManyInputSchema: z.ZodType<Prisma.ProductUncheckedUpdateManyInput> =
  z
    .object({
      id: z
        .union([
          z.string().uuid(),
          z.lazy(() => StringFieldUpdateOperationsInputSchema),
        ])
        .optional(),
      vendorID: z
        .union([
          z.string(),
          z.lazy(() => StringFieldUpdateOperationsInputSchema),
        ])
        .optional(),
      name: z
        .union([
          z.string(),
          z.lazy(() => StringFieldUpdateOperationsInputSchema),
        ])
        .optional(),
      slug: z
        .union([
          z.string(),
          z.lazy(() => StringFieldUpdateOperationsInputSchema),
        ])
        .optional(),
      description: z
        .union([
          z.string(),
          z.lazy(() => NullableStringFieldUpdateOperationsInputSchema),
        ])
        .optional()
        .nullable(),
      sku: z
        .union([
          z.string(),
          z.lazy(() => NullableStringFieldUpdateOperationsInputSchema),
        ])
        .optional()
        .nullable(),
      price: z
        .union([
          z
            .union([
              z.number(),
              z.string(),
              z.instanceof(Decimal),
              z.instanceof(Prisma.Decimal),
              DecimalJsLikeSchema,
            ])
            .refine((v) => isValidDecimalInput(v), {
              message: 'Must be a Decimal',
            }),
          z.lazy(() => DecimalFieldUpdateOperationsInputSchema),
        ])
        .optional(),
      stockQuantity: z
        .union([
          z.number().int(),
          z.lazy(() => IntFieldUpdateOperationsInputSchema),
        ])
        .optional(),
      status: z
        .union([
          z.lazy(() => ProductStatusSchema),
          z.lazy(() => EnumProductStatusFieldUpdateOperationsInputSchema),
        ])
        .optional(),
      createdAt: z
        .union([
          z.coerce.date(),
          z.lazy(() => DateTimeFieldUpdateOperationsInputSchema),
        ])
        .optional(),
      createdBy: z
        .union([
          z.string(),
          z.lazy(() => NullableStringFieldUpdateOperationsInputSchema),
        ])
        .optional()
        .nullable(),
      updatedAt: z
        .union([
          z.coerce.date(),
          z.lazy(() => DateTimeFieldUpdateOperationsInputSchema),
        ])
        .optional(),
      deletedAt: z
        .union([
          z.coerce.date(),
          z.lazy(() => NullableDateTimeFieldUpdateOperationsInputSchema),
        ])
        .optional()
        .nullable(),
    })
    .strict() as z.ZodType<Prisma.ProductUncheckedUpdateManyInput>;

export const ProductVariantCreateInputSchema: z.ZodType<Prisma.ProductVariantCreateInput> =
  z
    .object({
      id: z.string().uuid().optional(),
      name: z.string().optional().nullable(),
      sku: z.string().optional().nullable(),
      price: z
        .union([
          z.number(),
          z.string(),
          z.instanceof(Decimal),
          z.instanceof(Prisma.Decimal),
          DecimalJsLikeSchema,
        ])
        .refine((v) => isValidDecimalInput(v), {
          message: 'Must be a Decimal',
        }),
      stockQuantity: z.number().int().optional(),
      attributes: z
        .union([
          z.lazy(() => NullableJsonNullValueInputSchema),
          InputJsonValueSchema,
        ])
        .optional(),
      createdAt: z.coerce.date().optional(),
      createdBy: z.string().optional().nullable(),
      updatedAt: z.coerce.date().optional(),
      deletedAt: z.coerce.date().optional().nullable(),
      product: z.lazy(
        () => ProductCreateNestedOneWithoutProductVariantsInputSchema,
      ),
      productImages: z
        .lazy(
          () => ProductImageCreateNestedManyWithoutProductVariantInputSchema,
        )
        .optional(),
      orderItems: z
        .lazy(() => OrderItemCreateNestedManyWithoutProductVariantInputSchema)
        .optional(),
      cartItems: z
        .lazy(() => CartItemCreateNestedManyWithoutProductVariantInputSchema)
        .optional(),
    })
    .strict() as z.ZodType<Prisma.ProductVariantCreateInput>;

export const ProductVariantUncheckedCreateInputSchema: z.ZodType<Prisma.ProductVariantUncheckedCreateInput> =
  z
    .object({
      id: z.string().uuid().optional(),
      productID: z.string(),
      name: z.string().optional().nullable(),
      sku: z.string().optional().nullable(),
      price: z
        .union([
          z.number(),
          z.string(),
          z.instanceof(Decimal),
          z.instanceof(Prisma.Decimal),
          DecimalJsLikeSchema,
        ])
        .refine((v) => isValidDecimalInput(v), {
          message: 'Must be a Decimal',
        }),
      stockQuantity: z.number().int().optional(),
      attributes: z
        .union([
          z.lazy(() => NullableJsonNullValueInputSchema),
          InputJsonValueSchema,
        ])
        .optional(),
      createdAt: z.coerce.date().optional(),
      createdBy: z.string().optional().nullable(),
      updatedAt: z.coerce.date().optional(),
      deletedAt: z.coerce.date().optional().nullable(),
      productImages: z
        .lazy(
          () =>
            ProductImageUncheckedCreateNestedManyWithoutProductVariantInputSchema,
        )
        .optional(),
      orderItems: z
        .lazy(
          () =>
            OrderItemUncheckedCreateNestedManyWithoutProductVariantInputSchema,
        )
        .optional(),
      cartItems: z
        .lazy(
          () =>
            CartItemUncheckedCreateNestedManyWithoutProductVariantInputSchema,
        )
        .optional(),
    })
    .strict() as z.ZodType<Prisma.ProductVariantUncheckedCreateInput>;

export const ProductVariantUpdateInputSchema: z.ZodType<Prisma.ProductVariantUpdateInput> =
  z
    .object({
      id: z
        .union([
          z.string().uuid(),
          z.lazy(() => StringFieldUpdateOperationsInputSchema),
        ])
        .optional(),
      name: z
        .union([
          z.string(),
          z.lazy(() => NullableStringFieldUpdateOperationsInputSchema),
        ])
        .optional()
        .nullable(),
      sku: z
        .union([
          z.string(),
          z.lazy(() => NullableStringFieldUpdateOperationsInputSchema),
        ])
        .optional()
        .nullable(),
      price: z
        .union([
          z
            .union([
              z.number(),
              z.string(),
              z.instanceof(Decimal),
              z.instanceof(Prisma.Decimal),
              DecimalJsLikeSchema,
            ])
            .refine((v) => isValidDecimalInput(v), {
              message: 'Must be a Decimal',
            }),
          z.lazy(() => DecimalFieldUpdateOperationsInputSchema),
        ])
        .optional(),
      stockQuantity: z
        .union([
          z.number().int(),
          z.lazy(() => IntFieldUpdateOperationsInputSchema),
        ])
        .optional(),
      attributes: z
        .union([
          z.lazy(() => NullableJsonNullValueInputSchema),
          InputJsonValueSchema,
        ])
        .optional(),
      createdAt: z
        .union([
          z.coerce.date(),
          z.lazy(() => DateTimeFieldUpdateOperationsInputSchema),
        ])
        .optional(),
      createdBy: z
        .union([
          z.string(),
          z.lazy(() => NullableStringFieldUpdateOperationsInputSchema),
        ])
        .optional()
        .nullable(),
      updatedAt: z
        .union([
          z.coerce.date(),
          z.lazy(() => DateTimeFieldUpdateOperationsInputSchema),
        ])
        .optional(),
      deletedAt: z
        .union([
          z.coerce.date(),
          z.lazy(() => NullableDateTimeFieldUpdateOperationsInputSchema),
        ])
        .optional()
        .nullable(),
      product: z
        .lazy(
          () => ProductUpdateOneRequiredWithoutProductVariantsNestedInputSchema,
        )
        .optional(),
      productImages: z
        .lazy(
          () => ProductImageUpdateManyWithoutProductVariantNestedInputSchema,
        )
        .optional(),
      orderItems: z
        .lazy(() => OrderItemUpdateManyWithoutProductVariantNestedInputSchema)
        .optional(),
      cartItems: z
        .lazy(() => CartItemUpdateManyWithoutProductVariantNestedInputSchema)
        .optional(),
    })
    .strict() as z.ZodType<Prisma.ProductVariantUpdateInput>;

export const ProductVariantUncheckedUpdateInputSchema: z.ZodType<Prisma.ProductVariantUncheckedUpdateInput> =
  z
    .object({
      id: z
        .union([
          z.string().uuid(),
          z.lazy(() => StringFieldUpdateOperationsInputSchema),
        ])
        .optional(),
      productID: z
        .union([
          z.string(),
          z.lazy(() => StringFieldUpdateOperationsInputSchema),
        ])
        .optional(),
      name: z
        .union([
          z.string(),
          z.lazy(() => NullableStringFieldUpdateOperationsInputSchema),
        ])
        .optional()
        .nullable(),
      sku: z
        .union([
          z.string(),
          z.lazy(() => NullableStringFieldUpdateOperationsInputSchema),
        ])
        .optional()
        .nullable(),
      price: z
        .union([
          z
            .union([
              z.number(),
              z.string(),
              z.instanceof(Decimal),
              z.instanceof(Prisma.Decimal),
              DecimalJsLikeSchema,
            ])
            .refine((v) => isValidDecimalInput(v), {
              message: 'Must be a Decimal',
            }),
          z.lazy(() => DecimalFieldUpdateOperationsInputSchema),
        ])
        .optional(),
      stockQuantity: z
        .union([
          z.number().int(),
          z.lazy(() => IntFieldUpdateOperationsInputSchema),
        ])
        .optional(),
      attributes: z
        .union([
          z.lazy(() => NullableJsonNullValueInputSchema),
          InputJsonValueSchema,
        ])
        .optional(),
      createdAt: z
        .union([
          z.coerce.date(),
          z.lazy(() => DateTimeFieldUpdateOperationsInputSchema),
        ])
        .optional(),
      createdBy: z
        .union([
          z.string(),
          z.lazy(() => NullableStringFieldUpdateOperationsInputSchema),
        ])
        .optional()
        .nullable(),
      updatedAt: z
        .union([
          z.coerce.date(),
          z.lazy(() => DateTimeFieldUpdateOperationsInputSchema),
        ])
        .optional(),
      deletedAt: z
        .union([
          z.coerce.date(),
          z.lazy(() => NullableDateTimeFieldUpdateOperationsInputSchema),
        ])
        .optional()
        .nullable(),
      productImages: z
        .lazy(
          () =>
            ProductImageUncheckedUpdateManyWithoutProductVariantNestedInputSchema,
        )
        .optional(),
      orderItems: z
        .lazy(
          () =>
            OrderItemUncheckedUpdateManyWithoutProductVariantNestedInputSchema,
        )
        .optional(),
      cartItems: z
        .lazy(
          () =>
            CartItemUncheckedUpdateManyWithoutProductVariantNestedInputSchema,
        )
        .optional(),
    })
    .strict() as z.ZodType<Prisma.ProductVariantUncheckedUpdateInput>;

export const ProductVariantCreateManyInputSchema: z.ZodType<Prisma.ProductVariantCreateManyInput> =
  z
    .object({
      id: z.string().uuid().optional(),
      productID: z.string(),
      name: z.string().optional().nullable(),
      sku: z.string().optional().nullable(),
      price: z
        .union([
          z.number(),
          z.string(),
          z.instanceof(Decimal),
          z.instanceof(Prisma.Decimal),
          DecimalJsLikeSchema,
        ])
        .refine((v) => isValidDecimalInput(v), {
          message: 'Must be a Decimal',
        }),
      stockQuantity: z.number().int().optional(),
      attributes: z
        .union([
          z.lazy(() => NullableJsonNullValueInputSchema),
          InputJsonValueSchema,
        ])
        .optional(),
      createdAt: z.coerce.date().optional(),
      createdBy: z.string().optional().nullable(),
      updatedAt: z.coerce.date().optional(),
      deletedAt: z.coerce.date().optional().nullable(),
    })
    .strict() as z.ZodType<Prisma.ProductVariantCreateManyInput>;

export const ProductVariantUpdateManyMutationInputSchema: z.ZodType<Prisma.ProductVariantUpdateManyMutationInput> =
  z
    .object({
      id: z
        .union([
          z.string().uuid(),
          z.lazy(() => StringFieldUpdateOperationsInputSchema),
        ])
        .optional(),
      name: z
        .union([
          z.string(),
          z.lazy(() => NullableStringFieldUpdateOperationsInputSchema),
        ])
        .optional()
        .nullable(),
      sku: z
        .union([
          z.string(),
          z.lazy(() => NullableStringFieldUpdateOperationsInputSchema),
        ])
        .optional()
        .nullable(),
      price: z
        .union([
          z
            .union([
              z.number(),
              z.string(),
              z.instanceof(Decimal),
              z.instanceof(Prisma.Decimal),
              DecimalJsLikeSchema,
            ])
            .refine((v) => isValidDecimalInput(v), {
              message: 'Must be a Decimal',
            }),
          z.lazy(() => DecimalFieldUpdateOperationsInputSchema),
        ])
        .optional(),
      stockQuantity: z
        .union([
          z.number().int(),
          z.lazy(() => IntFieldUpdateOperationsInputSchema),
        ])
        .optional(),
      attributes: z
        .union([
          z.lazy(() => NullableJsonNullValueInputSchema),
          InputJsonValueSchema,
        ])
        .optional(),
      createdAt: z
        .union([
          z.coerce.date(),
          z.lazy(() => DateTimeFieldUpdateOperationsInputSchema),
        ])
        .optional(),
      createdBy: z
        .union([
          z.string(),
          z.lazy(() => NullableStringFieldUpdateOperationsInputSchema),
        ])
        .optional()
        .nullable(),
      updatedAt: z
        .union([
          z.coerce.date(),
          z.lazy(() => DateTimeFieldUpdateOperationsInputSchema),
        ])
        .optional(),
      deletedAt: z
        .union([
          z.coerce.date(),
          z.lazy(() => NullableDateTimeFieldUpdateOperationsInputSchema),
        ])
        .optional()
        .nullable(),
    })
    .strict() as z.ZodType<Prisma.ProductVariantUpdateManyMutationInput>;

export const ProductVariantUncheckedUpdateManyInputSchema: z.ZodType<Prisma.ProductVariantUncheckedUpdateManyInput> =
  z
    .object({
      id: z
        .union([
          z.string().uuid(),
          z.lazy(() => StringFieldUpdateOperationsInputSchema),
        ])
        .optional(),
      productID: z
        .union([
          z.string(),
          z.lazy(() => StringFieldUpdateOperationsInputSchema),
        ])
        .optional(),
      name: z
        .union([
          z.string(),
          z.lazy(() => NullableStringFieldUpdateOperationsInputSchema),
        ])
        .optional()
        .nullable(),
      sku: z
        .union([
          z.string(),
          z.lazy(() => NullableStringFieldUpdateOperationsInputSchema),
        ])
        .optional()
        .nullable(),
      price: z
        .union([
          z
            .union([
              z.number(),
              z.string(),
              z.instanceof(Decimal),
              z.instanceof(Prisma.Decimal),
              DecimalJsLikeSchema,
            ])
            .refine((v) => isValidDecimalInput(v), {
              message: 'Must be a Decimal',
            }),
          z.lazy(() => DecimalFieldUpdateOperationsInputSchema),
        ])
        .optional(),
      stockQuantity: z
        .union([
          z.number().int(),
          z.lazy(() => IntFieldUpdateOperationsInputSchema),
        ])
        .optional(),
      attributes: z
        .union([
          z.lazy(() => NullableJsonNullValueInputSchema),
          InputJsonValueSchema,
        ])
        .optional(),
      createdAt: z
        .union([
          z.coerce.date(),
          z.lazy(() => DateTimeFieldUpdateOperationsInputSchema),
        ])
        .optional(),
      createdBy: z
        .union([
          z.string(),
          z.lazy(() => NullableStringFieldUpdateOperationsInputSchema),
        ])
        .optional()
        .nullable(),
      updatedAt: z
        .union([
          z.coerce.date(),
          z.lazy(() => DateTimeFieldUpdateOperationsInputSchema),
        ])
        .optional(),
      deletedAt: z
        .union([
          z.coerce.date(),
          z.lazy(() => NullableDateTimeFieldUpdateOperationsInputSchema),
        ])
        .optional()
        .nullable(),
    })
    .strict() as z.ZodType<Prisma.ProductVariantUncheckedUpdateManyInput>;

export const ProductCategoryCreateInputSchema: z.ZodType<Prisma.ProductCategoryCreateInput> =
  z
    .object({
      product: z.lazy(
        () => ProductCreateNestedOneWithoutProductCategoriesInputSchema,
      ),
      category: z.lazy(
        () => CategoryCreateNestedOneWithoutProductCategoriesInputSchema,
      ),
    })
    .strict() as z.ZodType<Prisma.ProductCategoryCreateInput>;

export const ProductCategoryUncheckedCreateInputSchema: z.ZodType<Prisma.ProductCategoryUncheckedCreateInput> =
  z
    .object({
      productID: z.string(),
      categoryID: z.string(),
    })
    .strict() as z.ZodType<Prisma.ProductCategoryUncheckedCreateInput>;

export const ProductCategoryUpdateInputSchema: z.ZodType<Prisma.ProductCategoryUpdateInput> =
  z
    .object({
      product: z
        .lazy(
          () =>
            ProductUpdateOneRequiredWithoutProductCategoriesNestedInputSchema,
        )
        .optional(),
      category: z
        .lazy(
          () =>
            CategoryUpdateOneRequiredWithoutProductCategoriesNestedInputSchema,
        )
        .optional(),
    })
    .strict() as z.ZodType<Prisma.ProductCategoryUpdateInput>;

export const ProductCategoryUncheckedUpdateInputSchema: z.ZodType<Prisma.ProductCategoryUncheckedUpdateInput> =
  z
    .object({
      productID: z
        .union([
          z.string(),
          z.lazy(() => StringFieldUpdateOperationsInputSchema),
        ])
        .optional(),
      categoryID: z
        .union([
          z.string(),
          z.lazy(() => StringFieldUpdateOperationsInputSchema),
        ])
        .optional(),
    })
    .strict() as z.ZodType<Prisma.ProductCategoryUncheckedUpdateInput>;

export const ProductCategoryCreateManyInputSchema: z.ZodType<Prisma.ProductCategoryCreateManyInput> =
  z
    .object({
      productID: z.string(),
      categoryID: z.string(),
    })
    .strict() as z.ZodType<Prisma.ProductCategoryCreateManyInput>;

export const ProductCategoryUpdateManyMutationInputSchema: z.ZodType<Prisma.ProductCategoryUpdateManyMutationInput> =
  z
    .object({})
    .strict() as z.ZodType<Prisma.ProductCategoryUpdateManyMutationInput>;

export const ProductCategoryUncheckedUpdateManyInputSchema: z.ZodType<Prisma.ProductCategoryUncheckedUpdateManyInput> =
  z
    .object({
      productID: z
        .union([
          z.string(),
          z.lazy(() => StringFieldUpdateOperationsInputSchema),
        ])
        .optional(),
      categoryID: z
        .union([
          z.string(),
          z.lazy(() => StringFieldUpdateOperationsInputSchema),
        ])
        .optional(),
    })
    .strict() as z.ZodType<Prisma.ProductCategoryUncheckedUpdateManyInput>;

export const ProductImageCreateInputSchema: z.ZodType<Prisma.ProductImageCreateInput> =
  z
    .object({
      id: z.string().uuid().optional(),
      name: z.string(),
      description: z.string().optional().nullable(),
      imageUrl: z.string(),
      sortOrder: z.number().int().optional(),
      createdAt: z.coerce.date().optional(),
      createdBy: z.string().optional().nullable(),
      updatedAt: z.coerce.date().optional(),
      deletedAt: z.coerce.date().optional().nullable(),
      product: z
        .lazy(() => ProductCreateNestedOneWithoutProductImagesInputSchema)
        .optional(),
      productVariant: z
        .lazy(
          () => ProductVariantCreateNestedOneWithoutProductImagesInputSchema,
        )
        .optional(),
    })
    .strict() as z.ZodType<Prisma.ProductImageCreateInput>;

export const ProductImageUncheckedCreateInputSchema: z.ZodType<Prisma.ProductImageUncheckedCreateInput> =
  z
    .object({
      id: z.string().uuid().optional(),
      name: z.string(),
      description: z.string().optional().nullable(),
      productID: z.string().optional().nullable(),
      productVariantID: z.string().optional().nullable(),
      imageUrl: z.string(),
      sortOrder: z.number().int().optional(),
      createdAt: z.coerce.date().optional(),
      createdBy: z.string().optional().nullable(),
      updatedAt: z.coerce.date().optional(),
      deletedAt: z.coerce.date().optional().nullable(),
    })
    .strict() as z.ZodType<Prisma.ProductImageUncheckedCreateInput>;

export const ProductImageUpdateInputSchema: z.ZodType<Prisma.ProductImageUpdateInput> =
  z
    .object({
      id: z
        .union([
          z.string().uuid(),
          z.lazy(() => StringFieldUpdateOperationsInputSchema),
        ])
        .optional(),
      name: z
        .union([
          z.string(),
          z.lazy(() => StringFieldUpdateOperationsInputSchema),
        ])
        .optional(),
      description: z
        .union([
          z.string(),
          z.lazy(() => NullableStringFieldUpdateOperationsInputSchema),
        ])
        .optional()
        .nullable(),
      imageUrl: z
        .union([
          z.string(),
          z.lazy(() => StringFieldUpdateOperationsInputSchema),
        ])
        .optional(),
      sortOrder: z
        .union([
          z.number().int(),
          z.lazy(() => IntFieldUpdateOperationsInputSchema),
        ])
        .optional(),
      createdAt: z
        .union([
          z.coerce.date(),
          z.lazy(() => DateTimeFieldUpdateOperationsInputSchema),
        ])
        .optional(),
      createdBy: z
        .union([
          z.string(),
          z.lazy(() => NullableStringFieldUpdateOperationsInputSchema),
        ])
        .optional()
        .nullable(),
      updatedAt: z
        .union([
          z.coerce.date(),
          z.lazy(() => DateTimeFieldUpdateOperationsInputSchema),
        ])
        .optional(),
      deletedAt: z
        .union([
          z.coerce.date(),
          z.lazy(() => NullableDateTimeFieldUpdateOperationsInputSchema),
        ])
        .optional()
        .nullable(),
      product: z
        .lazy(() => ProductUpdateOneWithoutProductImagesNestedInputSchema)
        .optional(),
      productVariant: z
        .lazy(
          () => ProductVariantUpdateOneWithoutProductImagesNestedInputSchema,
        )
        .optional(),
    })
    .strict() as z.ZodType<Prisma.ProductImageUpdateInput>;

export const ProductImageUncheckedUpdateInputSchema: z.ZodType<Prisma.ProductImageUncheckedUpdateInput> =
  z
    .object({
      id: z
        .union([
          z.string().uuid(),
          z.lazy(() => StringFieldUpdateOperationsInputSchema),
        ])
        .optional(),
      name: z
        .union([
          z.string(),
          z.lazy(() => StringFieldUpdateOperationsInputSchema),
        ])
        .optional(),
      description: z
        .union([
          z.string(),
          z.lazy(() => NullableStringFieldUpdateOperationsInputSchema),
        ])
        .optional()
        .nullable(),
      productID: z
        .union([
          z.string(),
          z.lazy(() => NullableStringFieldUpdateOperationsInputSchema),
        ])
        .optional()
        .nullable(),
      productVariantID: z
        .union([
          z.string(),
          z.lazy(() => NullableStringFieldUpdateOperationsInputSchema),
        ])
        .optional()
        .nullable(),
      imageUrl: z
        .union([
          z.string(),
          z.lazy(() => StringFieldUpdateOperationsInputSchema),
        ])
        .optional(),
      sortOrder: z
        .union([
          z.number().int(),
          z.lazy(() => IntFieldUpdateOperationsInputSchema),
        ])
        .optional(),
      createdAt: z
        .union([
          z.coerce.date(),
          z.lazy(() => DateTimeFieldUpdateOperationsInputSchema),
        ])
        .optional(),
      createdBy: z
        .union([
          z.string(),
          z.lazy(() => NullableStringFieldUpdateOperationsInputSchema),
        ])
        .optional()
        .nullable(),
      updatedAt: z
        .union([
          z.coerce.date(),
          z.lazy(() => DateTimeFieldUpdateOperationsInputSchema),
        ])
        .optional(),
      deletedAt: z
        .union([
          z.coerce.date(),
          z.lazy(() => NullableDateTimeFieldUpdateOperationsInputSchema),
        ])
        .optional()
        .nullable(),
    })
    .strict() as z.ZodType<Prisma.ProductImageUncheckedUpdateInput>;

export const ProductImageCreateManyInputSchema: z.ZodType<Prisma.ProductImageCreateManyInput> =
  z
    .object({
      id: z.string().uuid().optional(),
      name: z.string(),
      description: z.string().optional().nullable(),
      productID: z.string().optional().nullable(),
      productVariantID: z.string().optional().nullable(),
      imageUrl: z.string(),
      sortOrder: z.number().int().optional(),
      createdAt: z.coerce.date().optional(),
      createdBy: z.string().optional().nullable(),
      updatedAt: z.coerce.date().optional(),
      deletedAt: z.coerce.date().optional().nullable(),
    })
    .strict() as z.ZodType<Prisma.ProductImageCreateManyInput>;

export const ProductImageUpdateManyMutationInputSchema: z.ZodType<Prisma.ProductImageUpdateManyMutationInput> =
  z
    .object({
      id: z
        .union([
          z.string().uuid(),
          z.lazy(() => StringFieldUpdateOperationsInputSchema),
        ])
        .optional(),
      name: z
        .union([
          z.string(),
          z.lazy(() => StringFieldUpdateOperationsInputSchema),
        ])
        .optional(),
      description: z
        .union([
          z.string(),
          z.lazy(() => NullableStringFieldUpdateOperationsInputSchema),
        ])
        .optional()
        .nullable(),
      imageUrl: z
        .union([
          z.string(),
          z.lazy(() => StringFieldUpdateOperationsInputSchema),
        ])
        .optional(),
      sortOrder: z
        .union([
          z.number().int(),
          z.lazy(() => IntFieldUpdateOperationsInputSchema),
        ])
        .optional(),
      createdAt: z
        .union([
          z.coerce.date(),
          z.lazy(() => DateTimeFieldUpdateOperationsInputSchema),
        ])
        .optional(),
      createdBy: z
        .union([
          z.string(),
          z.lazy(() => NullableStringFieldUpdateOperationsInputSchema),
        ])
        .optional()
        .nullable(),
      updatedAt: z
        .union([
          z.coerce.date(),
          z.lazy(() => DateTimeFieldUpdateOperationsInputSchema),
        ])
        .optional(),
      deletedAt: z
        .union([
          z.coerce.date(),
          z.lazy(() => NullableDateTimeFieldUpdateOperationsInputSchema),
        ])
        .optional()
        .nullable(),
    })
    .strict() as z.ZodType<Prisma.ProductImageUpdateManyMutationInput>;

export const ProductImageUncheckedUpdateManyInputSchema: z.ZodType<Prisma.ProductImageUncheckedUpdateManyInput> =
  z
    .object({
      id: z
        .union([
          z.string().uuid(),
          z.lazy(() => StringFieldUpdateOperationsInputSchema),
        ])
        .optional(),
      name: z
        .union([
          z.string(),
          z.lazy(() => StringFieldUpdateOperationsInputSchema),
        ])
        .optional(),
      description: z
        .union([
          z.string(),
          z.lazy(() => NullableStringFieldUpdateOperationsInputSchema),
        ])
        .optional()
        .nullable(),
      productID: z
        .union([
          z.string(),
          z.lazy(() => NullableStringFieldUpdateOperationsInputSchema),
        ])
        .optional()
        .nullable(),
      productVariantID: z
        .union([
          z.string(),
          z.lazy(() => NullableStringFieldUpdateOperationsInputSchema),
        ])
        .optional()
        .nullable(),
      imageUrl: z
        .union([
          z.string(),
          z.lazy(() => StringFieldUpdateOperationsInputSchema),
        ])
        .optional(),
      sortOrder: z
        .union([
          z.number().int(),
          z.lazy(() => IntFieldUpdateOperationsInputSchema),
        ])
        .optional(),
      createdAt: z
        .union([
          z.coerce.date(),
          z.lazy(() => DateTimeFieldUpdateOperationsInputSchema),
        ])
        .optional(),
      createdBy: z
        .union([
          z.string(),
          z.lazy(() => NullableStringFieldUpdateOperationsInputSchema),
        ])
        .optional()
        .nullable(),
      updatedAt: z
        .union([
          z.coerce.date(),
          z.lazy(() => DateTimeFieldUpdateOperationsInputSchema),
        ])
        .optional(),
      deletedAt: z
        .union([
          z.coerce.date(),
          z.lazy(() => NullableDateTimeFieldUpdateOperationsInputSchema),
        ])
        .optional()
        .nullable(),
    })
    .strict() as z.ZodType<Prisma.ProductImageUncheckedUpdateManyInput>;

export const OrderCreateInputSchema: z.ZodType<Prisma.OrderCreateInput> = z
  .object({
    id: z.string().uuid().optional(),
    orderNumber: z.string(),
    status: z.lazy(() => OrderStatusSchema).optional(),
    subtotal: z
      .union([
        z.number(),
        z.string(),
        z.instanceof(Decimal),
        z.instanceof(Prisma.Decimal),
        DecimalJsLikeSchema,
      ])
      .refine((v) => isValidDecimalInput(v), { message: 'Must be a Decimal' }),
    taxAmount: z
      .union([
        z.number(),
        z.string(),
        z.instanceof(Decimal),
        z.instanceof(Prisma.Decimal),
        DecimalJsLikeSchema,
      ])
      .refine((v) => isValidDecimalInput(v), { message: 'Must be a Decimal' })
      .optional(),
    shippingAmount: z
      .union([
        z.number(),
        z.string(),
        z.instanceof(Decimal),
        z.instanceof(Prisma.Decimal),
        DecimalJsLikeSchema,
      ])
      .refine((v) => isValidDecimalInput(v), { message: 'Must be a Decimal' })
      .optional(),
    discountAmount: z
      .union([
        z.number(),
        z.string(),
        z.instanceof(Decimal),
        z.instanceof(Prisma.Decimal),
        DecimalJsLikeSchema,
      ])
      .refine((v) => isValidDecimalInput(v), { message: 'Must be a Decimal' })
      .optional(),
    totalAmount: z
      .union([
        z.number(),
        z.string(),
        z.instanceof(Decimal),
        z.instanceof(Prisma.Decimal),
        DecimalJsLikeSchema,
      ])
      .refine((v) => isValidDecimalInput(v), { message: 'Must be a Decimal' }),
    currency: z.string().optional(),
    notes: z.string().optional().nullable(),
    shippedAt: z.coerce.date().optional().nullable(),
    deliveredAt: z.coerce.date().optional().nullable(),
    createdAt: z.coerce.date().optional(),
    createdBy: z.string().optional().nullable(),
    updatedAt: z.coerce.date().optional(),
    deletedAt: z.coerce.date().optional().nullable(),
    user: z.lazy(() => UserCreateNestedOneWithoutOrdersInputSchema),
    orderItems: z
      .lazy(() => OrderItemCreateNestedManyWithoutOrderInputSchema)
      .optional(),
    orderAddresses: z
      .lazy(() => OrderAddressCreateNestedManyWithoutOrderInputSchema)
      .optional(),
    orderPromotions: z
      .lazy(() => OrderPromotionCreateNestedManyWithoutOrderInputSchema)
      .optional(),
    payments: z
      .lazy(() => PaymentCreateNestedManyWithoutOrderInputSchema)
      .optional(),
  })
  .strict() as z.ZodType<Prisma.OrderCreateInput>;

export const OrderUncheckedCreateInputSchema: z.ZodType<Prisma.OrderUncheckedCreateInput> =
  z
    .object({
      id: z.string().uuid().optional(),
      orderNumber: z.string(),
      userID: z.string(),
      status: z.lazy(() => OrderStatusSchema).optional(),
      subtotal: z
        .union([
          z.number(),
          z.string(),
          z.instanceof(Decimal),
          z.instanceof(Prisma.Decimal),
          DecimalJsLikeSchema,
        ])
        .refine((v) => isValidDecimalInput(v), {
          message: 'Must be a Decimal',
        }),
      taxAmount: z
        .union([
          z.number(),
          z.string(),
          z.instanceof(Decimal),
          z.instanceof(Prisma.Decimal),
          DecimalJsLikeSchema,
        ])
        .refine((v) => isValidDecimalInput(v), { message: 'Must be a Decimal' })
        .optional(),
      shippingAmount: z
        .union([
          z.number(),
          z.string(),
          z.instanceof(Decimal),
          z.instanceof(Prisma.Decimal),
          DecimalJsLikeSchema,
        ])
        .refine((v) => isValidDecimalInput(v), { message: 'Must be a Decimal' })
        .optional(),
      discountAmount: z
        .union([
          z.number(),
          z.string(),
          z.instanceof(Decimal),
          z.instanceof(Prisma.Decimal),
          DecimalJsLikeSchema,
        ])
        .refine((v) => isValidDecimalInput(v), { message: 'Must be a Decimal' })
        .optional(),
      totalAmount: z
        .union([
          z.number(),
          z.string(),
          z.instanceof(Decimal),
          z.instanceof(Prisma.Decimal),
          DecimalJsLikeSchema,
        ])
        .refine((v) => isValidDecimalInput(v), {
          message: 'Must be a Decimal',
        }),
      currency: z.string().optional(),
      notes: z.string().optional().nullable(),
      shippedAt: z.coerce.date().optional().nullable(),
      deliveredAt: z.coerce.date().optional().nullable(),
      createdAt: z.coerce.date().optional(),
      createdBy: z.string().optional().nullable(),
      updatedAt: z.coerce.date().optional(),
      deletedAt: z.coerce.date().optional().nullable(),
      orderItems: z
        .lazy(() => OrderItemUncheckedCreateNestedManyWithoutOrderInputSchema)
        .optional(),
      orderAddresses: z
        .lazy(
          () => OrderAddressUncheckedCreateNestedManyWithoutOrderInputSchema,
        )
        .optional(),
      orderPromotions: z
        .lazy(
          () => OrderPromotionUncheckedCreateNestedManyWithoutOrderInputSchema,
        )
        .optional(),
      payments: z
        .lazy(() => PaymentUncheckedCreateNestedManyWithoutOrderInputSchema)
        .optional(),
    })
    .strict() as z.ZodType<Prisma.OrderUncheckedCreateInput>;

export const OrderUpdateInputSchema: z.ZodType<Prisma.OrderUpdateInput> = z
  .object({
    id: z
      .union([
        z.string().uuid(),
        z.lazy(() => StringFieldUpdateOperationsInputSchema),
      ])
      .optional(),
    orderNumber: z
      .union([z.string(), z.lazy(() => StringFieldUpdateOperationsInputSchema)])
      .optional(),
    status: z
      .union([
        z.lazy(() => OrderStatusSchema),
        z.lazy(() => EnumOrderStatusFieldUpdateOperationsInputSchema),
      ])
      .optional(),
    subtotal: z
      .union([
        z
          .union([
            z.number(),
            z.string(),
            z.instanceof(Decimal),
            z.instanceof(Prisma.Decimal),
            DecimalJsLikeSchema,
          ])
          .refine((v) => isValidDecimalInput(v), {
            message: 'Must be a Decimal',
          }),
        z.lazy(() => DecimalFieldUpdateOperationsInputSchema),
      ])
      .optional(),
    taxAmount: z
      .union([
        z
          .union([
            z.number(),
            z.string(),
            z.instanceof(Decimal),
            z.instanceof(Prisma.Decimal),
            DecimalJsLikeSchema,
          ])
          .refine((v) => isValidDecimalInput(v), {
            message: 'Must be a Decimal',
          }),
        z.lazy(() => DecimalFieldUpdateOperationsInputSchema),
      ])
      .optional(),
    shippingAmount: z
      .union([
        z
          .union([
            z.number(),
            z.string(),
            z.instanceof(Decimal),
            z.instanceof(Prisma.Decimal),
            DecimalJsLikeSchema,
          ])
          .refine((v) => isValidDecimalInput(v), {
            message: 'Must be a Decimal',
          }),
        z.lazy(() => DecimalFieldUpdateOperationsInputSchema),
      ])
      .optional(),
    discountAmount: z
      .union([
        z
          .union([
            z.number(),
            z.string(),
            z.instanceof(Decimal),
            z.instanceof(Prisma.Decimal),
            DecimalJsLikeSchema,
          ])
          .refine((v) => isValidDecimalInput(v), {
            message: 'Must be a Decimal',
          }),
        z.lazy(() => DecimalFieldUpdateOperationsInputSchema),
      ])
      .optional(),
    totalAmount: z
      .union([
        z
          .union([
            z.number(),
            z.string(),
            z.instanceof(Decimal),
            z.instanceof(Prisma.Decimal),
            DecimalJsLikeSchema,
          ])
          .refine((v) => isValidDecimalInput(v), {
            message: 'Must be a Decimal',
          }),
        z.lazy(() => DecimalFieldUpdateOperationsInputSchema),
      ])
      .optional(),
    currency: z
      .union([z.string(), z.lazy(() => StringFieldUpdateOperationsInputSchema)])
      .optional(),
    notes: z
      .union([
        z.string(),
        z.lazy(() => NullableStringFieldUpdateOperationsInputSchema),
      ])
      .optional()
      .nullable(),
    shippedAt: z
      .union([
        z.coerce.date(),
        z.lazy(() => NullableDateTimeFieldUpdateOperationsInputSchema),
      ])
      .optional()
      .nullable(),
    deliveredAt: z
      .union([
        z.coerce.date(),
        z.lazy(() => NullableDateTimeFieldUpdateOperationsInputSchema),
      ])
      .optional()
      .nullable(),
    createdAt: z
      .union([
        z.coerce.date(),
        z.lazy(() => DateTimeFieldUpdateOperationsInputSchema),
      ])
      .optional(),
    createdBy: z
      .union([
        z.string(),
        z.lazy(() => NullableStringFieldUpdateOperationsInputSchema),
      ])
      .optional()
      .nullable(),
    updatedAt: z
      .union([
        z.coerce.date(),
        z.lazy(() => DateTimeFieldUpdateOperationsInputSchema),
      ])
      .optional(),
    deletedAt: z
      .union([
        z.coerce.date(),
        z.lazy(() => NullableDateTimeFieldUpdateOperationsInputSchema),
      ])
      .optional()
      .nullable(),
    user: z
      .lazy(() => UserUpdateOneRequiredWithoutOrdersNestedInputSchema)
      .optional(),
    orderItems: z
      .lazy(() => OrderItemUpdateManyWithoutOrderNestedInputSchema)
      .optional(),
    orderAddresses: z
      .lazy(() => OrderAddressUpdateManyWithoutOrderNestedInputSchema)
      .optional(),
    orderPromotions: z
      .lazy(() => OrderPromotionUpdateManyWithoutOrderNestedInputSchema)
      .optional(),
    payments: z
      .lazy(() => PaymentUpdateManyWithoutOrderNestedInputSchema)
      .optional(),
  })
  .strict() as z.ZodType<Prisma.OrderUpdateInput>;

export const OrderUncheckedUpdateInputSchema: z.ZodType<Prisma.OrderUncheckedUpdateInput> =
  z
    .object({
      id: z
        .union([
          z.string().uuid(),
          z.lazy(() => StringFieldUpdateOperationsInputSchema),
        ])
        .optional(),
      orderNumber: z
        .union([
          z.string(),
          z.lazy(() => StringFieldUpdateOperationsInputSchema),
        ])
        .optional(),
      userID: z
        .union([
          z.string(),
          z.lazy(() => StringFieldUpdateOperationsInputSchema),
        ])
        .optional(),
      status: z
        .union([
          z.lazy(() => OrderStatusSchema),
          z.lazy(() => EnumOrderStatusFieldUpdateOperationsInputSchema),
        ])
        .optional(),
      subtotal: z
        .union([
          z
            .union([
              z.number(),
              z.string(),
              z.instanceof(Decimal),
              z.instanceof(Prisma.Decimal),
              DecimalJsLikeSchema,
            ])
            .refine((v) => isValidDecimalInput(v), {
              message: 'Must be a Decimal',
            }),
          z.lazy(() => DecimalFieldUpdateOperationsInputSchema),
        ])
        .optional(),
      taxAmount: z
        .union([
          z
            .union([
              z.number(),
              z.string(),
              z.instanceof(Decimal),
              z.instanceof(Prisma.Decimal),
              DecimalJsLikeSchema,
            ])
            .refine((v) => isValidDecimalInput(v), {
              message: 'Must be a Decimal',
            }),
          z.lazy(() => DecimalFieldUpdateOperationsInputSchema),
        ])
        .optional(),
      shippingAmount: z
        .union([
          z
            .union([
              z.number(),
              z.string(),
              z.instanceof(Decimal),
              z.instanceof(Prisma.Decimal),
              DecimalJsLikeSchema,
            ])
            .refine((v) => isValidDecimalInput(v), {
              message: 'Must be a Decimal',
            }),
          z.lazy(() => DecimalFieldUpdateOperationsInputSchema),
        ])
        .optional(),
      discountAmount: z
        .union([
          z
            .union([
              z.number(),
              z.string(),
              z.instanceof(Decimal),
              z.instanceof(Prisma.Decimal),
              DecimalJsLikeSchema,
            ])
            .refine((v) => isValidDecimalInput(v), {
              message: 'Must be a Decimal',
            }),
          z.lazy(() => DecimalFieldUpdateOperationsInputSchema),
        ])
        .optional(),
      totalAmount: z
        .union([
          z
            .union([
              z.number(),
              z.string(),
              z.instanceof(Decimal),
              z.instanceof(Prisma.Decimal),
              DecimalJsLikeSchema,
            ])
            .refine((v) => isValidDecimalInput(v), {
              message: 'Must be a Decimal',
            }),
          z.lazy(() => DecimalFieldUpdateOperationsInputSchema),
        ])
        .optional(),
      currency: z
        .union([
          z.string(),
          z.lazy(() => StringFieldUpdateOperationsInputSchema),
        ])
        .optional(),
      notes: z
        .union([
          z.string(),
          z.lazy(() => NullableStringFieldUpdateOperationsInputSchema),
        ])
        .optional()
        .nullable(),
      shippedAt: z
        .union([
          z.coerce.date(),
          z.lazy(() => NullableDateTimeFieldUpdateOperationsInputSchema),
        ])
        .optional()
        .nullable(),
      deliveredAt: z
        .union([
          z.coerce.date(),
          z.lazy(() => NullableDateTimeFieldUpdateOperationsInputSchema),
        ])
        .optional()
        .nullable(),
      createdAt: z
        .union([
          z.coerce.date(),
          z.lazy(() => DateTimeFieldUpdateOperationsInputSchema),
        ])
        .optional(),
      createdBy: z
        .union([
          z.string(),
          z.lazy(() => NullableStringFieldUpdateOperationsInputSchema),
        ])
        .optional()
        .nullable(),
      updatedAt: z
        .union([
          z.coerce.date(),
          z.lazy(() => DateTimeFieldUpdateOperationsInputSchema),
        ])
        .optional(),
      deletedAt: z
        .union([
          z.coerce.date(),
          z.lazy(() => NullableDateTimeFieldUpdateOperationsInputSchema),
        ])
        .optional()
        .nullable(),
      orderItems: z
        .lazy(() => OrderItemUncheckedUpdateManyWithoutOrderNestedInputSchema)
        .optional(),
      orderAddresses: z
        .lazy(
          () => OrderAddressUncheckedUpdateManyWithoutOrderNestedInputSchema,
        )
        .optional(),
      orderPromotions: z
        .lazy(
          () => OrderPromotionUncheckedUpdateManyWithoutOrderNestedInputSchema,
        )
        .optional(),
      payments: z
        .lazy(() => PaymentUncheckedUpdateManyWithoutOrderNestedInputSchema)
        .optional(),
    })
    .strict() as z.ZodType<Prisma.OrderUncheckedUpdateInput>;

export const OrderCreateManyInputSchema: z.ZodType<Prisma.OrderCreateManyInput> =
  z
    .object({
      id: z.string().uuid().optional(),
      orderNumber: z.string(),
      userID: z.string(),
      status: z.lazy(() => OrderStatusSchema).optional(),
      subtotal: z
        .union([
          z.number(),
          z.string(),
          z.instanceof(Decimal),
          z.instanceof(Prisma.Decimal),
          DecimalJsLikeSchema,
        ])
        .refine((v) => isValidDecimalInput(v), {
          message: 'Must be a Decimal',
        }),
      taxAmount: z
        .union([
          z.number(),
          z.string(),
          z.instanceof(Decimal),
          z.instanceof(Prisma.Decimal),
          DecimalJsLikeSchema,
        ])
        .refine((v) => isValidDecimalInput(v), { message: 'Must be a Decimal' })
        .optional(),
      shippingAmount: z
        .union([
          z.number(),
          z.string(),
          z.instanceof(Decimal),
          z.instanceof(Prisma.Decimal),
          DecimalJsLikeSchema,
        ])
        .refine((v) => isValidDecimalInput(v), { message: 'Must be a Decimal' })
        .optional(),
      discountAmount: z
        .union([
          z.number(),
          z.string(),
          z.instanceof(Decimal),
          z.instanceof(Prisma.Decimal),
          DecimalJsLikeSchema,
        ])
        .refine((v) => isValidDecimalInput(v), { message: 'Must be a Decimal' })
        .optional(),
      totalAmount: z
        .union([
          z.number(),
          z.string(),
          z.instanceof(Decimal),
          z.instanceof(Prisma.Decimal),
          DecimalJsLikeSchema,
        ])
        .refine((v) => isValidDecimalInput(v), {
          message: 'Must be a Decimal',
        }),
      currency: z.string().optional(),
      notes: z.string().optional().nullable(),
      shippedAt: z.coerce.date().optional().nullable(),
      deliveredAt: z.coerce.date().optional().nullable(),
      createdAt: z.coerce.date().optional(),
      createdBy: z.string().optional().nullable(),
      updatedAt: z.coerce.date().optional(),
      deletedAt: z.coerce.date().optional().nullable(),
    })
    .strict() as z.ZodType<Prisma.OrderCreateManyInput>;

export const OrderUpdateManyMutationInputSchema: z.ZodType<Prisma.OrderUpdateManyMutationInput> =
  z
    .object({
      id: z
        .union([
          z.string().uuid(),
          z.lazy(() => StringFieldUpdateOperationsInputSchema),
        ])
        .optional(),
      orderNumber: z
        .union([
          z.string(),
          z.lazy(() => StringFieldUpdateOperationsInputSchema),
        ])
        .optional(),
      status: z
        .union([
          z.lazy(() => OrderStatusSchema),
          z.lazy(() => EnumOrderStatusFieldUpdateOperationsInputSchema),
        ])
        .optional(),
      subtotal: z
        .union([
          z
            .union([
              z.number(),
              z.string(),
              z.instanceof(Decimal),
              z.instanceof(Prisma.Decimal),
              DecimalJsLikeSchema,
            ])
            .refine((v) => isValidDecimalInput(v), {
              message: 'Must be a Decimal',
            }),
          z.lazy(() => DecimalFieldUpdateOperationsInputSchema),
        ])
        .optional(),
      taxAmount: z
        .union([
          z
            .union([
              z.number(),
              z.string(),
              z.instanceof(Decimal),
              z.instanceof(Prisma.Decimal),
              DecimalJsLikeSchema,
            ])
            .refine((v) => isValidDecimalInput(v), {
              message: 'Must be a Decimal',
            }),
          z.lazy(() => DecimalFieldUpdateOperationsInputSchema),
        ])
        .optional(),
      shippingAmount: z
        .union([
          z
            .union([
              z.number(),
              z.string(),
              z.instanceof(Decimal),
              z.instanceof(Prisma.Decimal),
              DecimalJsLikeSchema,
            ])
            .refine((v) => isValidDecimalInput(v), {
              message: 'Must be a Decimal',
            }),
          z.lazy(() => DecimalFieldUpdateOperationsInputSchema),
        ])
        .optional(),
      discountAmount: z
        .union([
          z
            .union([
              z.number(),
              z.string(),
              z.instanceof(Decimal),
              z.instanceof(Prisma.Decimal),
              DecimalJsLikeSchema,
            ])
            .refine((v) => isValidDecimalInput(v), {
              message: 'Must be a Decimal',
            }),
          z.lazy(() => DecimalFieldUpdateOperationsInputSchema),
        ])
        .optional(),
      totalAmount: z
        .union([
          z
            .union([
              z.number(),
              z.string(),
              z.instanceof(Decimal),
              z.instanceof(Prisma.Decimal),
              DecimalJsLikeSchema,
            ])
            .refine((v) => isValidDecimalInput(v), {
              message: 'Must be a Decimal',
            }),
          z.lazy(() => DecimalFieldUpdateOperationsInputSchema),
        ])
        .optional(),
      currency: z
        .union([
          z.string(),
          z.lazy(() => StringFieldUpdateOperationsInputSchema),
        ])
        .optional(),
      notes: z
        .union([
          z.string(),
          z.lazy(() => NullableStringFieldUpdateOperationsInputSchema),
        ])
        .optional()
        .nullable(),
      shippedAt: z
        .union([
          z.coerce.date(),
          z.lazy(() => NullableDateTimeFieldUpdateOperationsInputSchema),
        ])
        .optional()
        .nullable(),
      deliveredAt: z
        .union([
          z.coerce.date(),
          z.lazy(() => NullableDateTimeFieldUpdateOperationsInputSchema),
        ])
        .optional()
        .nullable(),
      createdAt: z
        .union([
          z.coerce.date(),
          z.lazy(() => DateTimeFieldUpdateOperationsInputSchema),
        ])
        .optional(),
      createdBy: z
        .union([
          z.string(),
          z.lazy(() => NullableStringFieldUpdateOperationsInputSchema),
        ])
        .optional()
        .nullable(),
      updatedAt: z
        .union([
          z.coerce.date(),
          z.lazy(() => DateTimeFieldUpdateOperationsInputSchema),
        ])
        .optional(),
      deletedAt: z
        .union([
          z.coerce.date(),
          z.lazy(() => NullableDateTimeFieldUpdateOperationsInputSchema),
        ])
        .optional()
        .nullable(),
    })
    .strict() as z.ZodType<Prisma.OrderUpdateManyMutationInput>;

export const OrderUncheckedUpdateManyInputSchema: z.ZodType<Prisma.OrderUncheckedUpdateManyInput> =
  z
    .object({
      id: z
        .union([
          z.string().uuid(),
          z.lazy(() => StringFieldUpdateOperationsInputSchema),
        ])
        .optional(),
      orderNumber: z
        .union([
          z.string(),
          z.lazy(() => StringFieldUpdateOperationsInputSchema),
        ])
        .optional(),
      userID: z
        .union([
          z.string(),
          z.lazy(() => StringFieldUpdateOperationsInputSchema),
        ])
        .optional(),
      status: z
        .union([
          z.lazy(() => OrderStatusSchema),
          z.lazy(() => EnumOrderStatusFieldUpdateOperationsInputSchema),
        ])
        .optional(),
      subtotal: z
        .union([
          z
            .union([
              z.number(),
              z.string(),
              z.instanceof(Decimal),
              z.instanceof(Prisma.Decimal),
              DecimalJsLikeSchema,
            ])
            .refine((v) => isValidDecimalInput(v), {
              message: 'Must be a Decimal',
            }),
          z.lazy(() => DecimalFieldUpdateOperationsInputSchema),
        ])
        .optional(),
      taxAmount: z
        .union([
          z
            .union([
              z.number(),
              z.string(),
              z.instanceof(Decimal),
              z.instanceof(Prisma.Decimal),
              DecimalJsLikeSchema,
            ])
            .refine((v) => isValidDecimalInput(v), {
              message: 'Must be a Decimal',
            }),
          z.lazy(() => DecimalFieldUpdateOperationsInputSchema),
        ])
        .optional(),
      shippingAmount: z
        .union([
          z
            .union([
              z.number(),
              z.string(),
              z.instanceof(Decimal),
              z.instanceof(Prisma.Decimal),
              DecimalJsLikeSchema,
            ])
            .refine((v) => isValidDecimalInput(v), {
              message: 'Must be a Decimal',
            }),
          z.lazy(() => DecimalFieldUpdateOperationsInputSchema),
        ])
        .optional(),
      discountAmount: z
        .union([
          z
            .union([
              z.number(),
              z.string(),
              z.instanceof(Decimal),
              z.instanceof(Prisma.Decimal),
              DecimalJsLikeSchema,
            ])
            .refine((v) => isValidDecimalInput(v), {
              message: 'Must be a Decimal',
            }),
          z.lazy(() => DecimalFieldUpdateOperationsInputSchema),
        ])
        .optional(),
      totalAmount: z
        .union([
          z
            .union([
              z.number(),
              z.string(),
              z.instanceof(Decimal),
              z.instanceof(Prisma.Decimal),
              DecimalJsLikeSchema,
            ])
            .refine((v) => isValidDecimalInput(v), {
              message: 'Must be a Decimal',
            }),
          z.lazy(() => DecimalFieldUpdateOperationsInputSchema),
        ])
        .optional(),
      currency: z
        .union([
          z.string(),
          z.lazy(() => StringFieldUpdateOperationsInputSchema),
        ])
        .optional(),
      notes: z
        .union([
          z.string(),
          z.lazy(() => NullableStringFieldUpdateOperationsInputSchema),
        ])
        .optional()
        .nullable(),
      shippedAt: z
        .union([
          z.coerce.date(),
          z.lazy(() => NullableDateTimeFieldUpdateOperationsInputSchema),
        ])
        .optional()
        .nullable(),
      deliveredAt: z
        .union([
          z.coerce.date(),
          z.lazy(() => NullableDateTimeFieldUpdateOperationsInputSchema),
        ])
        .optional()
        .nullable(),
      createdAt: z
        .union([
          z.coerce.date(),
          z.lazy(() => DateTimeFieldUpdateOperationsInputSchema),
        ])
        .optional(),
      createdBy: z
        .union([
          z.string(),
          z.lazy(() => NullableStringFieldUpdateOperationsInputSchema),
        ])
        .optional()
        .nullable(),
      updatedAt: z
        .union([
          z.coerce.date(),
          z.lazy(() => DateTimeFieldUpdateOperationsInputSchema),
        ])
        .optional(),
      deletedAt: z
        .union([
          z.coerce.date(),
          z.lazy(() => NullableDateTimeFieldUpdateOperationsInputSchema),
        ])
        .optional()
        .nullable(),
    })
    .strict() as z.ZodType<Prisma.OrderUncheckedUpdateManyInput>;

export const OrderItemCreateInputSchema: z.ZodType<Prisma.OrderItemCreateInput> =
  z
    .object({
      id: z.string().uuid().optional(),
      quantity: z.number().int().optional(),
      unitPrice: z
        .union([
          z.number(),
          z.string(),
          z.instanceof(Decimal),
          z.instanceof(Prisma.Decimal),
          DecimalJsLikeSchema,
        ])
        .refine((v) => isValidDecimalInput(v), {
          message: 'Must be a Decimal',
        }),
      totalPrice: z
        .union([
          z.number(),
          z.string(),
          z.instanceof(Decimal),
          z.instanceof(Prisma.Decimal),
          DecimalJsLikeSchema,
        ])
        .refine((v) => isValidDecimalInput(v), {
          message: 'Must be a Decimal',
        }),
      productVariantSnapshot: z
        .union([
          z.lazy(() => NullableJsonNullValueInputSchema),
          InputJsonValueSchema,
        ])
        .optional(),
      productVariant: z.lazy(
        () => ProductVariantCreateNestedOneWithoutOrderItemsInputSchema,
      ),
      order: z.lazy(() => OrderCreateNestedOneWithoutOrderItemsInputSchema),
    })
    .strict() as z.ZodType<Prisma.OrderItemCreateInput>;

export const OrderItemUncheckedCreateInputSchema: z.ZodType<Prisma.OrderItemUncheckedCreateInput> =
  z
    .object({
      id: z.string().uuid().optional(),
      orderID: z.string(),
      productVariantID: z.string(),
      quantity: z.number().int().optional(),
      unitPrice: z
        .union([
          z.number(),
          z.string(),
          z.instanceof(Decimal),
          z.instanceof(Prisma.Decimal),
          DecimalJsLikeSchema,
        ])
        .refine((v) => isValidDecimalInput(v), {
          message: 'Must be a Decimal',
        }),
      totalPrice: z
        .union([
          z.number(),
          z.string(),
          z.instanceof(Decimal),
          z.instanceof(Prisma.Decimal),
          DecimalJsLikeSchema,
        ])
        .refine((v) => isValidDecimalInput(v), {
          message: 'Must be a Decimal',
        }),
      productVariantSnapshot: z
        .union([
          z.lazy(() => NullableJsonNullValueInputSchema),
          InputJsonValueSchema,
        ])
        .optional(),
    })
    .strict() as z.ZodType<Prisma.OrderItemUncheckedCreateInput>;

export const OrderItemUpdateInputSchema: z.ZodType<Prisma.OrderItemUpdateInput> =
  z
    .object({
      id: z
        .union([
          z.string().uuid(),
          z.lazy(() => StringFieldUpdateOperationsInputSchema),
        ])
        .optional(),
      quantity: z
        .union([
          z.number().int(),
          z.lazy(() => IntFieldUpdateOperationsInputSchema),
        ])
        .optional(),
      unitPrice: z
        .union([
          z
            .union([
              z.number(),
              z.string(),
              z.instanceof(Decimal),
              z.instanceof(Prisma.Decimal),
              DecimalJsLikeSchema,
            ])
            .refine((v) => isValidDecimalInput(v), {
              message: 'Must be a Decimal',
            }),
          z.lazy(() => DecimalFieldUpdateOperationsInputSchema),
        ])
        .optional(),
      totalPrice: z
        .union([
          z
            .union([
              z.number(),
              z.string(),
              z.instanceof(Decimal),
              z.instanceof(Prisma.Decimal),
              DecimalJsLikeSchema,
            ])
            .refine((v) => isValidDecimalInput(v), {
              message: 'Must be a Decimal',
            }),
          z.lazy(() => DecimalFieldUpdateOperationsInputSchema),
        ])
        .optional(),
      productVariantSnapshot: z
        .union([
          z.lazy(() => NullableJsonNullValueInputSchema),
          InputJsonValueSchema,
        ])
        .optional(),
      productVariant: z
        .lazy(
          () =>
            ProductVariantUpdateOneRequiredWithoutOrderItemsNestedInputSchema,
        )
        .optional(),
      order: z
        .lazy(() => OrderUpdateOneRequiredWithoutOrderItemsNestedInputSchema)
        .optional(),
    })
    .strict() as z.ZodType<Prisma.OrderItemUpdateInput>;

export const OrderItemUncheckedUpdateInputSchema: z.ZodType<Prisma.OrderItemUncheckedUpdateInput> =
  z
    .object({
      id: z
        .union([
          z.string().uuid(),
          z.lazy(() => StringFieldUpdateOperationsInputSchema),
        ])
        .optional(),
      orderID: z
        .union([
          z.string(),
          z.lazy(() => StringFieldUpdateOperationsInputSchema),
        ])
        .optional(),
      productVariantID: z
        .union([
          z.string(),
          z.lazy(() => StringFieldUpdateOperationsInputSchema),
        ])
        .optional(),
      quantity: z
        .union([
          z.number().int(),
          z.lazy(() => IntFieldUpdateOperationsInputSchema),
        ])
        .optional(),
      unitPrice: z
        .union([
          z
            .union([
              z.number(),
              z.string(),
              z.instanceof(Decimal),
              z.instanceof(Prisma.Decimal),
              DecimalJsLikeSchema,
            ])
            .refine((v) => isValidDecimalInput(v), {
              message: 'Must be a Decimal',
            }),
          z.lazy(() => DecimalFieldUpdateOperationsInputSchema),
        ])
        .optional(),
      totalPrice: z
        .union([
          z
            .union([
              z.number(),
              z.string(),
              z.instanceof(Decimal),
              z.instanceof(Prisma.Decimal),
              DecimalJsLikeSchema,
            ])
            .refine((v) => isValidDecimalInput(v), {
              message: 'Must be a Decimal',
            }),
          z.lazy(() => DecimalFieldUpdateOperationsInputSchema),
        ])
        .optional(),
      productVariantSnapshot: z
        .union([
          z.lazy(() => NullableJsonNullValueInputSchema),
          InputJsonValueSchema,
        ])
        .optional(),
    })
    .strict() as z.ZodType<Prisma.OrderItemUncheckedUpdateInput>;

export const OrderItemCreateManyInputSchema: z.ZodType<Prisma.OrderItemCreateManyInput> =
  z
    .object({
      id: z.string().uuid().optional(),
      orderID: z.string(),
      productVariantID: z.string(),
      quantity: z.number().int().optional(),
      unitPrice: z
        .union([
          z.number(),
          z.string(),
          z.instanceof(Decimal),
          z.instanceof(Prisma.Decimal),
          DecimalJsLikeSchema,
        ])
        .refine((v) => isValidDecimalInput(v), {
          message: 'Must be a Decimal',
        }),
      totalPrice: z
        .union([
          z.number(),
          z.string(),
          z.instanceof(Decimal),
          z.instanceof(Prisma.Decimal),
          DecimalJsLikeSchema,
        ])
        .refine((v) => isValidDecimalInput(v), {
          message: 'Must be a Decimal',
        }),
      productVariantSnapshot: z
        .union([
          z.lazy(() => NullableJsonNullValueInputSchema),
          InputJsonValueSchema,
        ])
        .optional(),
    })
    .strict() as z.ZodType<Prisma.OrderItemCreateManyInput>;

export const OrderItemUpdateManyMutationInputSchema: z.ZodType<Prisma.OrderItemUpdateManyMutationInput> =
  z
    .object({
      id: z
        .union([
          z.string().uuid(),
          z.lazy(() => StringFieldUpdateOperationsInputSchema),
        ])
        .optional(),
      quantity: z
        .union([
          z.number().int(),
          z.lazy(() => IntFieldUpdateOperationsInputSchema),
        ])
        .optional(),
      unitPrice: z
        .union([
          z
            .union([
              z.number(),
              z.string(),
              z.instanceof(Decimal),
              z.instanceof(Prisma.Decimal),
              DecimalJsLikeSchema,
            ])
            .refine((v) => isValidDecimalInput(v), {
              message: 'Must be a Decimal',
            }),
          z.lazy(() => DecimalFieldUpdateOperationsInputSchema),
        ])
        .optional(),
      totalPrice: z
        .union([
          z
            .union([
              z.number(),
              z.string(),
              z.instanceof(Decimal),
              z.instanceof(Prisma.Decimal),
              DecimalJsLikeSchema,
            ])
            .refine((v) => isValidDecimalInput(v), {
              message: 'Must be a Decimal',
            }),
          z.lazy(() => DecimalFieldUpdateOperationsInputSchema),
        ])
        .optional(),
      productVariantSnapshot: z
        .union([
          z.lazy(() => NullableJsonNullValueInputSchema),
          InputJsonValueSchema,
        ])
        .optional(),
    })
    .strict() as z.ZodType<Prisma.OrderItemUpdateManyMutationInput>;

export const OrderItemUncheckedUpdateManyInputSchema: z.ZodType<Prisma.OrderItemUncheckedUpdateManyInput> =
  z
    .object({
      id: z
        .union([
          z.string().uuid(),
          z.lazy(() => StringFieldUpdateOperationsInputSchema),
        ])
        .optional(),
      orderID: z
        .union([
          z.string(),
          z.lazy(() => StringFieldUpdateOperationsInputSchema),
        ])
        .optional(),
      productVariantID: z
        .union([
          z.string(),
          z.lazy(() => StringFieldUpdateOperationsInputSchema),
        ])
        .optional(),
      quantity: z
        .union([
          z.number().int(),
          z.lazy(() => IntFieldUpdateOperationsInputSchema),
        ])
        .optional(),
      unitPrice: z
        .union([
          z
            .union([
              z.number(),
              z.string(),
              z.instanceof(Decimal),
              z.instanceof(Prisma.Decimal),
              DecimalJsLikeSchema,
            ])
            .refine((v) => isValidDecimalInput(v), {
              message: 'Must be a Decimal',
            }),
          z.lazy(() => DecimalFieldUpdateOperationsInputSchema),
        ])
        .optional(),
      totalPrice: z
        .union([
          z
            .union([
              z.number(),
              z.string(),
              z.instanceof(Decimal),
              z.instanceof(Prisma.Decimal),
              DecimalJsLikeSchema,
            ])
            .refine((v) => isValidDecimalInput(v), {
              message: 'Must be a Decimal',
            }),
          z.lazy(() => DecimalFieldUpdateOperationsInputSchema),
        ])
        .optional(),
      productVariantSnapshot: z
        .union([
          z.lazy(() => NullableJsonNullValueInputSchema),
          InputJsonValueSchema,
        ])
        .optional(),
    })
    .strict() as z.ZodType<Prisma.OrderItemUncheckedUpdateManyInput>;

export const OrderAddressCreateInputSchema: z.ZodType<Prisma.OrderAddressCreateInput> =
  z
    .object({
      id: z.string().uuid().optional(),
      type: z.lazy(() => AddressTypeSchema).optional(),
      firstName: z.string(),
      lastName: z.string().optional().nullable(),
      company: z.string().optional().nullable(),
      fullAddress: z.string(),
      city: z.string().optional().nullable(),
      province: z.string().optional().nullable(),
      country: z.string().optional().nullable(),
      phone: z.string(),
      order: z.lazy(() => OrderCreateNestedOneWithoutOrderAddressesInputSchema),
    })
    .strict() as z.ZodType<Prisma.OrderAddressCreateInput>;

export const OrderAddressUncheckedCreateInputSchema: z.ZodType<Prisma.OrderAddressUncheckedCreateInput> =
  z
    .object({
      id: z.string().uuid().optional(),
      orderID: z.string(),
      type: z.lazy(() => AddressTypeSchema).optional(),
      firstName: z.string(),
      lastName: z.string().optional().nullable(),
      company: z.string().optional().nullable(),
      fullAddress: z.string(),
      city: z.string().optional().nullable(),
      province: z.string().optional().nullable(),
      country: z.string().optional().nullable(),
      phone: z.string(),
    })
    .strict() as z.ZodType<Prisma.OrderAddressUncheckedCreateInput>;

export const OrderAddressUpdateInputSchema: z.ZodType<Prisma.OrderAddressUpdateInput> =
  z
    .object({
      id: z
        .union([
          z.string().uuid(),
          z.lazy(() => StringFieldUpdateOperationsInputSchema),
        ])
        .optional(),
      type: z
        .union([
          z.lazy(() => AddressTypeSchema),
          z.lazy(() => EnumAddressTypeFieldUpdateOperationsInputSchema),
        ])
        .optional(),
      firstName: z
        .union([
          z.string(),
          z.lazy(() => StringFieldUpdateOperationsInputSchema),
        ])
        .optional(),
      lastName: z
        .union([
          z.string(),
          z.lazy(() => NullableStringFieldUpdateOperationsInputSchema),
        ])
        .optional()
        .nullable(),
      company: z
        .union([
          z.string(),
          z.lazy(() => NullableStringFieldUpdateOperationsInputSchema),
        ])
        .optional()
        .nullable(),
      fullAddress: z
        .union([
          z.string(),
          z.lazy(() => StringFieldUpdateOperationsInputSchema),
        ])
        .optional(),
      city: z
        .union([
          z.string(),
          z.lazy(() => NullableStringFieldUpdateOperationsInputSchema),
        ])
        .optional()
        .nullable(),
      province: z
        .union([
          z.string(),
          z.lazy(() => NullableStringFieldUpdateOperationsInputSchema),
        ])
        .optional()
        .nullable(),
      country: z
        .union([
          z.string(),
          z.lazy(() => NullableStringFieldUpdateOperationsInputSchema),
        ])
        .optional()
        .nullable(),
      phone: z
        .union([
          z.string(),
          z.lazy(() => StringFieldUpdateOperationsInputSchema),
        ])
        .optional(),
      order: z
        .lazy(
          () => OrderUpdateOneRequiredWithoutOrderAddressesNestedInputSchema,
        )
        .optional(),
    })
    .strict() as z.ZodType<Prisma.OrderAddressUpdateInput>;

export const OrderAddressUncheckedUpdateInputSchema: z.ZodType<Prisma.OrderAddressUncheckedUpdateInput> =
  z
    .object({
      id: z
        .union([
          z.string().uuid(),
          z.lazy(() => StringFieldUpdateOperationsInputSchema),
        ])
        .optional(),
      orderID: z
        .union([
          z.string(),
          z.lazy(() => StringFieldUpdateOperationsInputSchema),
        ])
        .optional(),
      type: z
        .union([
          z.lazy(() => AddressTypeSchema),
          z.lazy(() => EnumAddressTypeFieldUpdateOperationsInputSchema),
        ])
        .optional(),
      firstName: z
        .union([
          z.string(),
          z.lazy(() => StringFieldUpdateOperationsInputSchema),
        ])
        .optional(),
      lastName: z
        .union([
          z.string(),
          z.lazy(() => NullableStringFieldUpdateOperationsInputSchema),
        ])
        .optional()
        .nullable(),
      company: z
        .union([
          z.string(),
          z.lazy(() => NullableStringFieldUpdateOperationsInputSchema),
        ])
        .optional()
        .nullable(),
      fullAddress: z
        .union([
          z.string(),
          z.lazy(() => StringFieldUpdateOperationsInputSchema),
        ])
        .optional(),
      city: z
        .union([
          z.string(),
          z.lazy(() => NullableStringFieldUpdateOperationsInputSchema),
        ])
        .optional()
        .nullable(),
      province: z
        .union([
          z.string(),
          z.lazy(() => NullableStringFieldUpdateOperationsInputSchema),
        ])
        .optional()
        .nullable(),
      country: z
        .union([
          z.string(),
          z.lazy(() => NullableStringFieldUpdateOperationsInputSchema),
        ])
        .optional()
        .nullable(),
      phone: z
        .union([
          z.string(),
          z.lazy(() => StringFieldUpdateOperationsInputSchema),
        ])
        .optional(),
    })
    .strict() as z.ZodType<Prisma.OrderAddressUncheckedUpdateInput>;

export const OrderAddressCreateManyInputSchema: z.ZodType<Prisma.OrderAddressCreateManyInput> =
  z
    .object({
      id: z.string().uuid().optional(),
      orderID: z.string(),
      type: z.lazy(() => AddressTypeSchema).optional(),
      firstName: z.string(),
      lastName: z.string().optional().nullable(),
      company: z.string().optional().nullable(),
      fullAddress: z.string(),
      city: z.string().optional().nullable(),
      province: z.string().optional().nullable(),
      country: z.string().optional().nullable(),
      phone: z.string(),
    })
    .strict() as z.ZodType<Prisma.OrderAddressCreateManyInput>;

export const OrderAddressUpdateManyMutationInputSchema: z.ZodType<Prisma.OrderAddressUpdateManyMutationInput> =
  z
    .object({
      id: z
        .union([
          z.string().uuid(),
          z.lazy(() => StringFieldUpdateOperationsInputSchema),
        ])
        .optional(),
      type: z
        .union([
          z.lazy(() => AddressTypeSchema),
          z.lazy(() => EnumAddressTypeFieldUpdateOperationsInputSchema),
        ])
        .optional(),
      firstName: z
        .union([
          z.string(),
          z.lazy(() => StringFieldUpdateOperationsInputSchema),
        ])
        .optional(),
      lastName: z
        .union([
          z.string(),
          z.lazy(() => NullableStringFieldUpdateOperationsInputSchema),
        ])
        .optional()
        .nullable(),
      company: z
        .union([
          z.string(),
          z.lazy(() => NullableStringFieldUpdateOperationsInputSchema),
        ])
        .optional()
        .nullable(),
      fullAddress: z
        .union([
          z.string(),
          z.lazy(() => StringFieldUpdateOperationsInputSchema),
        ])
        .optional(),
      city: z
        .union([
          z.string(),
          z.lazy(() => NullableStringFieldUpdateOperationsInputSchema),
        ])
        .optional()
        .nullable(),
      province: z
        .union([
          z.string(),
          z.lazy(() => NullableStringFieldUpdateOperationsInputSchema),
        ])
        .optional()
        .nullable(),
      country: z
        .union([
          z.string(),
          z.lazy(() => NullableStringFieldUpdateOperationsInputSchema),
        ])
        .optional()
        .nullable(),
      phone: z
        .union([
          z.string(),
          z.lazy(() => StringFieldUpdateOperationsInputSchema),
        ])
        .optional(),
    })
    .strict() as z.ZodType<Prisma.OrderAddressUpdateManyMutationInput>;

export const OrderAddressUncheckedUpdateManyInputSchema: z.ZodType<Prisma.OrderAddressUncheckedUpdateManyInput> =
  z
    .object({
      id: z
        .union([
          z.string().uuid(),
          z.lazy(() => StringFieldUpdateOperationsInputSchema),
        ])
        .optional(),
      orderID: z
        .union([
          z.string(),
          z.lazy(() => StringFieldUpdateOperationsInputSchema),
        ])
        .optional(),
      type: z
        .union([
          z.lazy(() => AddressTypeSchema),
          z.lazy(() => EnumAddressTypeFieldUpdateOperationsInputSchema),
        ])
        .optional(),
      firstName: z
        .union([
          z.string(),
          z.lazy(() => StringFieldUpdateOperationsInputSchema),
        ])
        .optional(),
      lastName: z
        .union([
          z.string(),
          z.lazy(() => NullableStringFieldUpdateOperationsInputSchema),
        ])
        .optional()
        .nullable(),
      company: z
        .union([
          z.string(),
          z.lazy(() => NullableStringFieldUpdateOperationsInputSchema),
        ])
        .optional()
        .nullable(),
      fullAddress: z
        .union([
          z.string(),
          z.lazy(() => StringFieldUpdateOperationsInputSchema),
        ])
        .optional(),
      city: z
        .union([
          z.string(),
          z.lazy(() => NullableStringFieldUpdateOperationsInputSchema),
        ])
        .optional()
        .nullable(),
      province: z
        .union([
          z.string(),
          z.lazy(() => NullableStringFieldUpdateOperationsInputSchema),
        ])
        .optional()
        .nullable(),
      country: z
        .union([
          z.string(),
          z.lazy(() => NullableStringFieldUpdateOperationsInputSchema),
        ])
        .optional()
        .nullable(),
      phone: z
        .union([
          z.string(),
          z.lazy(() => StringFieldUpdateOperationsInputSchema),
        ])
        .optional(),
    })
    .strict() as z.ZodType<Prisma.OrderAddressUncheckedUpdateManyInput>;

export const PromotionCreateInputSchema: z.ZodType<Prisma.PromotionCreateInput> =
  z
    .object({
      id: z.string().uuid().optional(),
      code: z.string(),
      name: z.string(),
      description: z.string().optional().nullable(),
      type: z.lazy(() => PromotionTypeSchema).optional(),
      value: z
        .union([
          z.number(),
          z.string(),
          z.instanceof(Decimal),
          z.instanceof(Prisma.Decimal),
          DecimalJsLikeSchema,
        ])
        .refine((v) => isValidDecimalInput(v), {
          message: 'Must be a Decimal',
        }),
      usageLimit: z.number().int().optional().nullable(),
      startDate: z.coerce.date().optional(),
      endDate: z.coerce.date().optional().nullable(),
      status: z.lazy(() => PromotionStatusSchema).optional(),
      createdAt: z.coerce.date().optional(),
      createdBy: z.string().optional().nullable(),
      updatedAt: z.coerce.date().optional(),
      deletedAt: z.coerce.date().optional().nullable(),
      orderPromotions: z
        .lazy(() => OrderPromotionCreateNestedManyWithoutPromotionInputSchema)
        .optional(),
    })
    .strict() as z.ZodType<Prisma.PromotionCreateInput>;

export const PromotionUncheckedCreateInputSchema: z.ZodType<Prisma.PromotionUncheckedCreateInput> =
  z
    .object({
      id: z.string().uuid().optional(),
      code: z.string(),
      name: z.string(),
      description: z.string().optional().nullable(),
      type: z.lazy(() => PromotionTypeSchema).optional(),
      value: z
        .union([
          z.number(),
          z.string(),
          z.instanceof(Decimal),
          z.instanceof(Prisma.Decimal),
          DecimalJsLikeSchema,
        ])
        .refine((v) => isValidDecimalInput(v), {
          message: 'Must be a Decimal',
        }),
      usageLimit: z.number().int().optional().nullable(),
      startDate: z.coerce.date().optional(),
      endDate: z.coerce.date().optional().nullable(),
      status: z.lazy(() => PromotionStatusSchema).optional(),
      createdAt: z.coerce.date().optional(),
      createdBy: z.string().optional().nullable(),
      updatedAt: z.coerce.date().optional(),
      deletedAt: z.coerce.date().optional().nullable(),
      orderPromotions: z
        .lazy(
          () =>
            OrderPromotionUncheckedCreateNestedManyWithoutPromotionInputSchema,
        )
        .optional(),
    })
    .strict() as z.ZodType<Prisma.PromotionUncheckedCreateInput>;

export const PromotionUpdateInputSchema: z.ZodType<Prisma.PromotionUpdateInput> =
  z
    .object({
      id: z
        .union([
          z.string().uuid(),
          z.lazy(() => StringFieldUpdateOperationsInputSchema),
        ])
        .optional(),
      code: z
        .union([
          z.string(),
          z.lazy(() => StringFieldUpdateOperationsInputSchema),
        ])
        .optional(),
      name: z
        .union([
          z.string(),
          z.lazy(() => StringFieldUpdateOperationsInputSchema),
        ])
        .optional(),
      description: z
        .union([
          z.string(),
          z.lazy(() => NullableStringFieldUpdateOperationsInputSchema),
        ])
        .optional()
        .nullable(),
      type: z
        .union([
          z.lazy(() => PromotionTypeSchema),
          z.lazy(() => EnumPromotionTypeFieldUpdateOperationsInputSchema),
        ])
        .optional(),
      value: z
        .union([
          z
            .union([
              z.number(),
              z.string(),
              z.instanceof(Decimal),
              z.instanceof(Prisma.Decimal),
              DecimalJsLikeSchema,
            ])
            .refine((v) => isValidDecimalInput(v), {
              message: 'Must be a Decimal',
            }),
          z.lazy(() => DecimalFieldUpdateOperationsInputSchema),
        ])
        .optional(),
      usageLimit: z
        .union([
          z.number().int(),
          z.lazy(() => NullableIntFieldUpdateOperationsInputSchema),
        ])
        .optional()
        .nullable(),
      startDate: z
        .union([
          z.coerce.date(),
          z.lazy(() => DateTimeFieldUpdateOperationsInputSchema),
        ])
        .optional(),
      endDate: z
        .union([
          z.coerce.date(),
          z.lazy(() => NullableDateTimeFieldUpdateOperationsInputSchema),
        ])
        .optional()
        .nullable(),
      status: z
        .union([
          z.lazy(() => PromotionStatusSchema),
          z.lazy(() => EnumPromotionStatusFieldUpdateOperationsInputSchema),
        ])
        .optional(),
      createdAt: z
        .union([
          z.coerce.date(),
          z.lazy(() => DateTimeFieldUpdateOperationsInputSchema),
        ])
        .optional(),
      createdBy: z
        .union([
          z.string(),
          z.lazy(() => NullableStringFieldUpdateOperationsInputSchema),
        ])
        .optional()
        .nullable(),
      updatedAt: z
        .union([
          z.coerce.date(),
          z.lazy(() => DateTimeFieldUpdateOperationsInputSchema),
        ])
        .optional(),
      deletedAt: z
        .union([
          z.coerce.date(),
          z.lazy(() => NullableDateTimeFieldUpdateOperationsInputSchema),
        ])
        .optional()
        .nullable(),
      orderPromotions: z
        .lazy(() => OrderPromotionUpdateManyWithoutPromotionNestedInputSchema)
        .optional(),
    })
    .strict() as z.ZodType<Prisma.PromotionUpdateInput>;

export const PromotionUncheckedUpdateInputSchema: z.ZodType<Prisma.PromotionUncheckedUpdateInput> =
  z
    .object({
      id: z
        .union([
          z.string().uuid(),
          z.lazy(() => StringFieldUpdateOperationsInputSchema),
        ])
        .optional(),
      code: z
        .union([
          z.string(),
          z.lazy(() => StringFieldUpdateOperationsInputSchema),
        ])
        .optional(),
      name: z
        .union([
          z.string(),
          z.lazy(() => StringFieldUpdateOperationsInputSchema),
        ])
        .optional(),
      description: z
        .union([
          z.string(),
          z.lazy(() => NullableStringFieldUpdateOperationsInputSchema),
        ])
        .optional()
        .nullable(),
      type: z
        .union([
          z.lazy(() => PromotionTypeSchema),
          z.lazy(() => EnumPromotionTypeFieldUpdateOperationsInputSchema),
        ])
        .optional(),
      value: z
        .union([
          z
            .union([
              z.number(),
              z.string(),
              z.instanceof(Decimal),
              z.instanceof(Prisma.Decimal),
              DecimalJsLikeSchema,
            ])
            .refine((v) => isValidDecimalInput(v), {
              message: 'Must be a Decimal',
            }),
          z.lazy(() => DecimalFieldUpdateOperationsInputSchema),
        ])
        .optional(),
      usageLimit: z
        .union([
          z.number().int(),
          z.lazy(() => NullableIntFieldUpdateOperationsInputSchema),
        ])
        .optional()
        .nullable(),
      startDate: z
        .union([
          z.coerce.date(),
          z.lazy(() => DateTimeFieldUpdateOperationsInputSchema),
        ])
        .optional(),
      endDate: z
        .union([
          z.coerce.date(),
          z.lazy(() => NullableDateTimeFieldUpdateOperationsInputSchema),
        ])
        .optional()
        .nullable(),
      status: z
        .union([
          z.lazy(() => PromotionStatusSchema),
          z.lazy(() => EnumPromotionStatusFieldUpdateOperationsInputSchema),
        ])
        .optional(),
      createdAt: z
        .union([
          z.coerce.date(),
          z.lazy(() => DateTimeFieldUpdateOperationsInputSchema),
        ])
        .optional(),
      createdBy: z
        .union([
          z.string(),
          z.lazy(() => NullableStringFieldUpdateOperationsInputSchema),
        ])
        .optional()
        .nullable(),
      updatedAt: z
        .union([
          z.coerce.date(),
          z.lazy(() => DateTimeFieldUpdateOperationsInputSchema),
        ])
        .optional(),
      deletedAt: z
        .union([
          z.coerce.date(),
          z.lazy(() => NullableDateTimeFieldUpdateOperationsInputSchema),
        ])
        .optional()
        .nullable(),
      orderPromotions: z
        .lazy(
          () =>
            OrderPromotionUncheckedUpdateManyWithoutPromotionNestedInputSchema,
        )
        .optional(),
    })
    .strict() as z.ZodType<Prisma.PromotionUncheckedUpdateInput>;

export const PromotionCreateManyInputSchema: z.ZodType<Prisma.PromotionCreateManyInput> =
  z
    .object({
      id: z.string().uuid().optional(),
      code: z.string(),
      name: z.string(),
      description: z.string().optional().nullable(),
      type: z.lazy(() => PromotionTypeSchema).optional(),
      value: z
        .union([
          z.number(),
          z.string(),
          z.instanceof(Decimal),
          z.instanceof(Prisma.Decimal),
          DecimalJsLikeSchema,
        ])
        .refine((v) => isValidDecimalInput(v), {
          message: 'Must be a Decimal',
        }),
      usageLimit: z.number().int().optional().nullable(),
      startDate: z.coerce.date().optional(),
      endDate: z.coerce.date().optional().nullable(),
      status: z.lazy(() => PromotionStatusSchema).optional(),
      createdAt: z.coerce.date().optional(),
      createdBy: z.string().optional().nullable(),
      updatedAt: z.coerce.date().optional(),
      deletedAt: z.coerce.date().optional().nullable(),
    })
    .strict() as z.ZodType<Prisma.PromotionCreateManyInput>;

export const PromotionUpdateManyMutationInputSchema: z.ZodType<Prisma.PromotionUpdateManyMutationInput> =
  z
    .object({
      id: z
        .union([
          z.string().uuid(),
          z.lazy(() => StringFieldUpdateOperationsInputSchema),
        ])
        .optional(),
      code: z
        .union([
          z.string(),
          z.lazy(() => StringFieldUpdateOperationsInputSchema),
        ])
        .optional(),
      name: z
        .union([
          z.string(),
          z.lazy(() => StringFieldUpdateOperationsInputSchema),
        ])
        .optional(),
      description: z
        .union([
          z.string(),
          z.lazy(() => NullableStringFieldUpdateOperationsInputSchema),
        ])
        .optional()
        .nullable(),
      type: z
        .union([
          z.lazy(() => PromotionTypeSchema),
          z.lazy(() => EnumPromotionTypeFieldUpdateOperationsInputSchema),
        ])
        .optional(),
      value: z
        .union([
          z
            .union([
              z.number(),
              z.string(),
              z.instanceof(Decimal),
              z.instanceof(Prisma.Decimal),
              DecimalJsLikeSchema,
            ])
            .refine((v) => isValidDecimalInput(v), {
              message: 'Must be a Decimal',
            }),
          z.lazy(() => DecimalFieldUpdateOperationsInputSchema),
        ])
        .optional(),
      usageLimit: z
        .union([
          z.number().int(),
          z.lazy(() => NullableIntFieldUpdateOperationsInputSchema),
        ])
        .optional()
        .nullable(),
      startDate: z
        .union([
          z.coerce.date(),
          z.lazy(() => DateTimeFieldUpdateOperationsInputSchema),
        ])
        .optional(),
      endDate: z
        .union([
          z.coerce.date(),
          z.lazy(() => NullableDateTimeFieldUpdateOperationsInputSchema),
        ])
        .optional()
        .nullable(),
      status: z
        .union([
          z.lazy(() => PromotionStatusSchema),
          z.lazy(() => EnumPromotionStatusFieldUpdateOperationsInputSchema),
        ])
        .optional(),
      createdAt: z
        .union([
          z.coerce.date(),
          z.lazy(() => DateTimeFieldUpdateOperationsInputSchema),
        ])
        .optional(),
      createdBy: z
        .union([
          z.string(),
          z.lazy(() => NullableStringFieldUpdateOperationsInputSchema),
        ])
        .optional()
        .nullable(),
      updatedAt: z
        .union([
          z.coerce.date(),
          z.lazy(() => DateTimeFieldUpdateOperationsInputSchema),
        ])
        .optional(),
      deletedAt: z
        .union([
          z.coerce.date(),
          z.lazy(() => NullableDateTimeFieldUpdateOperationsInputSchema),
        ])
        .optional()
        .nullable(),
    })
    .strict() as z.ZodType<Prisma.PromotionUpdateManyMutationInput>;

export const PromotionUncheckedUpdateManyInputSchema: z.ZodType<Prisma.PromotionUncheckedUpdateManyInput> =
  z
    .object({
      id: z
        .union([
          z.string().uuid(),
          z.lazy(() => StringFieldUpdateOperationsInputSchema),
        ])
        .optional(),
      code: z
        .union([
          z.string(),
          z.lazy(() => StringFieldUpdateOperationsInputSchema),
        ])
        .optional(),
      name: z
        .union([
          z.string(),
          z.lazy(() => StringFieldUpdateOperationsInputSchema),
        ])
        .optional(),
      description: z
        .union([
          z.string(),
          z.lazy(() => NullableStringFieldUpdateOperationsInputSchema),
        ])
        .optional()
        .nullable(),
      type: z
        .union([
          z.lazy(() => PromotionTypeSchema),
          z.lazy(() => EnumPromotionTypeFieldUpdateOperationsInputSchema),
        ])
        .optional(),
      value: z
        .union([
          z
            .union([
              z.number(),
              z.string(),
              z.instanceof(Decimal),
              z.instanceof(Prisma.Decimal),
              DecimalJsLikeSchema,
            ])
            .refine((v) => isValidDecimalInput(v), {
              message: 'Must be a Decimal',
            }),
          z.lazy(() => DecimalFieldUpdateOperationsInputSchema),
        ])
        .optional(),
      usageLimit: z
        .union([
          z.number().int(),
          z.lazy(() => NullableIntFieldUpdateOperationsInputSchema),
        ])
        .optional()
        .nullable(),
      startDate: z
        .union([
          z.coerce.date(),
          z.lazy(() => DateTimeFieldUpdateOperationsInputSchema),
        ])
        .optional(),
      endDate: z
        .union([
          z.coerce.date(),
          z.lazy(() => NullableDateTimeFieldUpdateOperationsInputSchema),
        ])
        .optional()
        .nullable(),
      status: z
        .union([
          z.lazy(() => PromotionStatusSchema),
          z.lazy(() => EnumPromotionStatusFieldUpdateOperationsInputSchema),
        ])
        .optional(),
      createdAt: z
        .union([
          z.coerce.date(),
          z.lazy(() => DateTimeFieldUpdateOperationsInputSchema),
        ])
        .optional(),
      createdBy: z
        .union([
          z.string(),
          z.lazy(() => NullableStringFieldUpdateOperationsInputSchema),
        ])
        .optional()
        .nullable(),
      updatedAt: z
        .union([
          z.coerce.date(),
          z.lazy(() => DateTimeFieldUpdateOperationsInputSchema),
        ])
        .optional(),
      deletedAt: z
        .union([
          z.coerce.date(),
          z.lazy(() => NullableDateTimeFieldUpdateOperationsInputSchema),
        ])
        .optional()
        .nullable(),
    })
    .strict() as z.ZodType<Prisma.PromotionUncheckedUpdateManyInput>;

export const OrderPromotionCreateInputSchema: z.ZodType<Prisma.OrderPromotionCreateInput> =
  z
    .object({
      id: z.string().uuid().optional(),
      discountAmount: z
        .union([
          z.number(),
          z.string(),
          z.instanceof(Decimal),
          z.instanceof(Prisma.Decimal),
          DecimalJsLikeSchema,
        ])
        .refine((v) => isValidDecimalInput(v), { message: 'Must be a Decimal' })
        .optional(),
      order: z.lazy(
        () => OrderCreateNestedOneWithoutOrderPromotionsInputSchema,
      ),
      promotion: z.lazy(
        () => PromotionCreateNestedOneWithoutOrderPromotionsInputSchema,
      ),
    })
    .strict() as z.ZodType<Prisma.OrderPromotionCreateInput>;

export const OrderPromotionUncheckedCreateInputSchema: z.ZodType<Prisma.OrderPromotionUncheckedCreateInput> =
  z
    .object({
      id: z.string().uuid().optional(),
      orderID: z.string(),
      promotionID: z.string(),
      discountAmount: z
        .union([
          z.number(),
          z.string(),
          z.instanceof(Decimal),
          z.instanceof(Prisma.Decimal),
          DecimalJsLikeSchema,
        ])
        .refine((v) => isValidDecimalInput(v), { message: 'Must be a Decimal' })
        .optional(),
    })
    .strict() as z.ZodType<Prisma.OrderPromotionUncheckedCreateInput>;

export const OrderPromotionUpdateInputSchema: z.ZodType<Prisma.OrderPromotionUpdateInput> =
  z
    .object({
      id: z
        .union([
          z.string().uuid(),
          z.lazy(() => StringFieldUpdateOperationsInputSchema),
        ])
        .optional(),
      discountAmount: z
        .union([
          z
            .union([
              z.number(),
              z.string(),
              z.instanceof(Decimal),
              z.instanceof(Prisma.Decimal),
              DecimalJsLikeSchema,
            ])
            .refine((v) => isValidDecimalInput(v), {
              message: 'Must be a Decimal',
            }),
          z.lazy(() => DecimalFieldUpdateOperationsInputSchema),
        ])
        .optional(),
      order: z
        .lazy(
          () => OrderUpdateOneRequiredWithoutOrderPromotionsNestedInputSchema,
        )
        .optional(),
      promotion: z
        .lazy(
          () =>
            PromotionUpdateOneRequiredWithoutOrderPromotionsNestedInputSchema,
        )
        .optional(),
    })
    .strict() as z.ZodType<Prisma.OrderPromotionUpdateInput>;

export const OrderPromotionUncheckedUpdateInputSchema: z.ZodType<Prisma.OrderPromotionUncheckedUpdateInput> =
  z
    .object({
      id: z
        .union([
          z.string().uuid(),
          z.lazy(() => StringFieldUpdateOperationsInputSchema),
        ])
        .optional(),
      orderID: z
        .union([
          z.string(),
          z.lazy(() => StringFieldUpdateOperationsInputSchema),
        ])
        .optional(),
      promotionID: z
        .union([
          z.string(),
          z.lazy(() => StringFieldUpdateOperationsInputSchema),
        ])
        .optional(),
      discountAmount: z
        .union([
          z
            .union([
              z.number(),
              z.string(),
              z.instanceof(Decimal),
              z.instanceof(Prisma.Decimal),
              DecimalJsLikeSchema,
            ])
            .refine((v) => isValidDecimalInput(v), {
              message: 'Must be a Decimal',
            }),
          z.lazy(() => DecimalFieldUpdateOperationsInputSchema),
        ])
        .optional(),
    })
    .strict() as z.ZodType<Prisma.OrderPromotionUncheckedUpdateInput>;

export const OrderPromotionCreateManyInputSchema: z.ZodType<Prisma.OrderPromotionCreateManyInput> =
  z
    .object({
      id: z.string().uuid().optional(),
      orderID: z.string(),
      promotionID: z.string(),
      discountAmount: z
        .union([
          z.number(),
          z.string(),
          z.instanceof(Decimal),
          z.instanceof(Prisma.Decimal),
          DecimalJsLikeSchema,
        ])
        .refine((v) => isValidDecimalInput(v), { message: 'Must be a Decimal' })
        .optional(),
    })
    .strict() as z.ZodType<Prisma.OrderPromotionCreateManyInput>;

export const OrderPromotionUpdateManyMutationInputSchema: z.ZodType<Prisma.OrderPromotionUpdateManyMutationInput> =
  z
    .object({
      id: z
        .union([
          z.string().uuid(),
          z.lazy(() => StringFieldUpdateOperationsInputSchema),
        ])
        .optional(),
      discountAmount: z
        .union([
          z
            .union([
              z.number(),
              z.string(),
              z.instanceof(Decimal),
              z.instanceof(Prisma.Decimal),
              DecimalJsLikeSchema,
            ])
            .refine((v) => isValidDecimalInput(v), {
              message: 'Must be a Decimal',
            }),
          z.lazy(() => DecimalFieldUpdateOperationsInputSchema),
        ])
        .optional(),
    })
    .strict() as z.ZodType<Prisma.OrderPromotionUpdateManyMutationInput>;

export const OrderPromotionUncheckedUpdateManyInputSchema: z.ZodType<Prisma.OrderPromotionUncheckedUpdateManyInput> =
  z
    .object({
      id: z
        .union([
          z.string().uuid(),
          z.lazy(() => StringFieldUpdateOperationsInputSchema),
        ])
        .optional(),
      orderID: z
        .union([
          z.string(),
          z.lazy(() => StringFieldUpdateOperationsInputSchema),
        ])
        .optional(),
      promotionID: z
        .union([
          z.string(),
          z.lazy(() => StringFieldUpdateOperationsInputSchema),
        ])
        .optional(),
      discountAmount: z
        .union([
          z
            .union([
              z.number(),
              z.string(),
              z.instanceof(Decimal),
              z.instanceof(Prisma.Decimal),
              DecimalJsLikeSchema,
            ])
            .refine((v) => isValidDecimalInput(v), {
              message: 'Must be a Decimal',
            }),
          z.lazy(() => DecimalFieldUpdateOperationsInputSchema),
        ])
        .optional(),
    })
    .strict() as z.ZodType<Prisma.OrderPromotionUncheckedUpdateManyInput>;

export const CartCreateInputSchema: z.ZodType<Prisma.CartCreateInput> = z
  .object({
    id: z.string().uuid().optional(),
    createdAt: z.coerce.date().optional(),
    updatedAt: z.coerce.date().optional(),
    user: z.lazy(() => UserCreateNestedOneWithoutCartInputSchema),
    cartItems: z
      .lazy(() => CartItemCreateNestedManyWithoutCartInputSchema)
      .optional(),
  })
  .strict() as z.ZodType<Prisma.CartCreateInput>;

export const CartUncheckedCreateInputSchema: z.ZodType<Prisma.CartUncheckedCreateInput> =
  z
    .object({
      id: z.string().uuid().optional(),
      userID: z.string(),
      createdAt: z.coerce.date().optional(),
      updatedAt: z.coerce.date().optional(),
      cartItems: z
        .lazy(() => CartItemUncheckedCreateNestedManyWithoutCartInputSchema)
        .optional(),
    })
    .strict() as z.ZodType<Prisma.CartUncheckedCreateInput>;

export const CartUpdateInputSchema: z.ZodType<Prisma.CartUpdateInput> = z
  .object({
    id: z
      .union([
        z.string().uuid(),
        z.lazy(() => StringFieldUpdateOperationsInputSchema),
      ])
      .optional(),
    createdAt: z
      .union([
        z.coerce.date(),
        z.lazy(() => DateTimeFieldUpdateOperationsInputSchema),
      ])
      .optional(),
    updatedAt: z
      .union([
        z.coerce.date(),
        z.lazy(() => DateTimeFieldUpdateOperationsInputSchema),
      ])
      .optional(),
    user: z
      .lazy(() => UserUpdateOneRequiredWithoutCartNestedInputSchema)
      .optional(),
    cartItems: z
      .lazy(() => CartItemUpdateManyWithoutCartNestedInputSchema)
      .optional(),
  })
  .strict() as z.ZodType<Prisma.CartUpdateInput>;

export const CartUncheckedUpdateInputSchema: z.ZodType<Prisma.CartUncheckedUpdateInput> =
  z
    .object({
      id: z
        .union([
          z.string().uuid(),
          z.lazy(() => StringFieldUpdateOperationsInputSchema),
        ])
        .optional(),
      userID: z
        .union([
          z.string(),
          z.lazy(() => StringFieldUpdateOperationsInputSchema),
        ])
        .optional(),
      createdAt: z
        .union([
          z.coerce.date(),
          z.lazy(() => DateTimeFieldUpdateOperationsInputSchema),
        ])
        .optional(),
      updatedAt: z
        .union([
          z.coerce.date(),
          z.lazy(() => DateTimeFieldUpdateOperationsInputSchema),
        ])
        .optional(),
      cartItems: z
        .lazy(() => CartItemUncheckedUpdateManyWithoutCartNestedInputSchema)
        .optional(),
    })
    .strict() as z.ZodType<Prisma.CartUncheckedUpdateInput>;

export const CartCreateManyInputSchema: z.ZodType<Prisma.CartCreateManyInput> =
  z
    .object({
      id: z.string().uuid().optional(),
      userID: z.string(),
      createdAt: z.coerce.date().optional(),
      updatedAt: z.coerce.date().optional(),
    })
    .strict() as z.ZodType<Prisma.CartCreateManyInput>;

export const CartUpdateManyMutationInputSchema: z.ZodType<Prisma.CartUpdateManyMutationInput> =
  z
    .object({
      id: z
        .union([
          z.string().uuid(),
          z.lazy(() => StringFieldUpdateOperationsInputSchema),
        ])
        .optional(),
      createdAt: z
        .union([
          z.coerce.date(),
          z.lazy(() => DateTimeFieldUpdateOperationsInputSchema),
        ])
        .optional(),
      updatedAt: z
        .union([
          z.coerce.date(),
          z.lazy(() => DateTimeFieldUpdateOperationsInputSchema),
        ])
        .optional(),
    })
    .strict() as z.ZodType<Prisma.CartUpdateManyMutationInput>;

export const CartUncheckedUpdateManyInputSchema: z.ZodType<Prisma.CartUncheckedUpdateManyInput> =
  z
    .object({
      id: z
        .union([
          z.string().uuid(),
          z.lazy(() => StringFieldUpdateOperationsInputSchema),
        ])
        .optional(),
      userID: z
        .union([
          z.string(),
          z.lazy(() => StringFieldUpdateOperationsInputSchema),
        ])
        .optional(),
      createdAt: z
        .union([
          z.coerce.date(),
          z.lazy(() => DateTimeFieldUpdateOperationsInputSchema),
        ])
        .optional(),
      updatedAt: z
        .union([
          z.coerce.date(),
          z.lazy(() => DateTimeFieldUpdateOperationsInputSchema),
        ])
        .optional(),
    })
    .strict() as z.ZodType<Prisma.CartUncheckedUpdateManyInput>;

export const CartItemCreateInputSchema: z.ZodType<Prisma.CartItemCreateInput> =
  z
    .object({
      id: z.string().uuid().optional(),
      quantity: z.number().int().optional(),
      createdAt: z.coerce.date().optional(),
      updatedAt: z.coerce.date().optional(),
      cart: z.lazy(() => CartCreateNestedOneWithoutCartItemsInputSchema),
      productVariant: z.lazy(
        () => ProductVariantCreateNestedOneWithoutCartItemsInputSchema,
      ),
    })
    .strict() as z.ZodType<Prisma.CartItemCreateInput>;

export const CartItemUncheckedCreateInputSchema: z.ZodType<Prisma.CartItemUncheckedCreateInput> =
  z
    .object({
      id: z.string().uuid().optional(),
      cartID: z.string(),
      productVariantID: z.string(),
      quantity: z.number().int().optional(),
      createdAt: z.coerce.date().optional(),
      updatedAt: z.coerce.date().optional(),
    })
    .strict() as z.ZodType<Prisma.CartItemUncheckedCreateInput>;

export const CartItemUpdateInputSchema: z.ZodType<Prisma.CartItemUpdateInput> =
  z
    .object({
      id: z
        .union([
          z.string().uuid(),
          z.lazy(() => StringFieldUpdateOperationsInputSchema),
        ])
        .optional(),
      quantity: z
        .union([
          z.number().int(),
          z.lazy(() => IntFieldUpdateOperationsInputSchema),
        ])
        .optional(),
      createdAt: z
        .union([
          z.coerce.date(),
          z.lazy(() => DateTimeFieldUpdateOperationsInputSchema),
        ])
        .optional(),
      updatedAt: z
        .union([
          z.coerce.date(),
          z.lazy(() => DateTimeFieldUpdateOperationsInputSchema),
        ])
        .optional(),
      cart: z
        .lazy(() => CartUpdateOneRequiredWithoutCartItemsNestedInputSchema)
        .optional(),
      productVariant: z
        .lazy(
          () =>
            ProductVariantUpdateOneRequiredWithoutCartItemsNestedInputSchema,
        )
        .optional(),
    })
    .strict() as z.ZodType<Prisma.CartItemUpdateInput>;

export const CartItemUncheckedUpdateInputSchema: z.ZodType<Prisma.CartItemUncheckedUpdateInput> =
  z
    .object({
      id: z
        .union([
          z.string().uuid(),
          z.lazy(() => StringFieldUpdateOperationsInputSchema),
        ])
        .optional(),
      cartID: z
        .union([
          z.string(),
          z.lazy(() => StringFieldUpdateOperationsInputSchema),
        ])
        .optional(),
      productVariantID: z
        .union([
          z.string(),
          z.lazy(() => StringFieldUpdateOperationsInputSchema),
        ])
        .optional(),
      quantity: z
        .union([
          z.number().int(),
          z.lazy(() => IntFieldUpdateOperationsInputSchema),
        ])
        .optional(),
      createdAt: z
        .union([
          z.coerce.date(),
          z.lazy(() => DateTimeFieldUpdateOperationsInputSchema),
        ])
        .optional(),
      updatedAt: z
        .union([
          z.coerce.date(),
          z.lazy(() => DateTimeFieldUpdateOperationsInputSchema),
        ])
        .optional(),
    })
    .strict() as z.ZodType<Prisma.CartItemUncheckedUpdateInput>;

export const CartItemCreateManyInputSchema: z.ZodType<Prisma.CartItemCreateManyInput> =
  z
    .object({
      id: z.string().uuid().optional(),
      cartID: z.string(),
      productVariantID: z.string(),
      quantity: z.number().int().optional(),
      createdAt: z.coerce.date().optional(),
      updatedAt: z.coerce.date().optional(),
    })
    .strict() as z.ZodType<Prisma.CartItemCreateManyInput>;

export const CartItemUpdateManyMutationInputSchema: z.ZodType<Prisma.CartItemUpdateManyMutationInput> =
  z
    .object({
      id: z
        .union([
          z.string().uuid(),
          z.lazy(() => StringFieldUpdateOperationsInputSchema),
        ])
        .optional(),
      quantity: z
        .union([
          z.number().int(),
          z.lazy(() => IntFieldUpdateOperationsInputSchema),
        ])
        .optional(),
      createdAt: z
        .union([
          z.coerce.date(),
          z.lazy(() => DateTimeFieldUpdateOperationsInputSchema),
        ])
        .optional(),
      updatedAt: z
        .union([
          z.coerce.date(),
          z.lazy(() => DateTimeFieldUpdateOperationsInputSchema),
        ])
        .optional(),
    })
    .strict() as z.ZodType<Prisma.CartItemUpdateManyMutationInput>;

export const CartItemUncheckedUpdateManyInputSchema: z.ZodType<Prisma.CartItemUncheckedUpdateManyInput> =
  z
    .object({
      id: z
        .union([
          z.string().uuid(),
          z.lazy(() => StringFieldUpdateOperationsInputSchema),
        ])
        .optional(),
      cartID: z
        .union([
          z.string(),
          z.lazy(() => StringFieldUpdateOperationsInputSchema),
        ])
        .optional(),
      productVariantID: z
        .union([
          z.string(),
          z.lazy(() => StringFieldUpdateOperationsInputSchema),
        ])
        .optional(),
      quantity: z
        .union([
          z.number().int(),
          z.lazy(() => IntFieldUpdateOperationsInputSchema),
        ])
        .optional(),
      createdAt: z
        .union([
          z.coerce.date(),
          z.lazy(() => DateTimeFieldUpdateOperationsInputSchema),
        ])
        .optional(),
      updatedAt: z
        .union([
          z.coerce.date(),
          z.lazy(() => DateTimeFieldUpdateOperationsInputSchema),
        ])
        .optional(),
    })
    .strict() as z.ZodType<Prisma.CartItemUncheckedUpdateManyInput>;

export const NotificationCreateInputSchema: z.ZodType<Prisma.NotificationCreateInput> =
  z
    .object({
      id: z.string().uuid().optional(),
      title: z.string(),
      message: z.string(),
      isRead: z.boolean().optional(),
      User: z
        .lazy(() => UserCreateNestedOneWithoutNotificationsInputSchema)
        .optional(),
    })
    .strict() as z.ZodType<Prisma.NotificationCreateInput>;

export const NotificationUncheckedCreateInputSchema: z.ZodType<Prisma.NotificationUncheckedCreateInput> =
  z
    .object({
      id: z.string().uuid().optional(),
      userID: z.string(),
      title: z.string(),
      message: z.string(),
      isRead: z.boolean().optional(),
    })
    .strict() as z.ZodType<Prisma.NotificationUncheckedCreateInput>;

export const NotificationUpdateInputSchema: z.ZodType<Prisma.NotificationUpdateInput> =
  z
    .object({
      id: z
        .union([
          z.string().uuid(),
          z.lazy(() => StringFieldUpdateOperationsInputSchema),
        ])
        .optional(),
      title: z
        .union([
          z.string(),
          z.lazy(() => StringFieldUpdateOperationsInputSchema),
        ])
        .optional(),
      message: z
        .union([
          z.string(),
          z.lazy(() => StringFieldUpdateOperationsInputSchema),
        ])
        .optional(),
      isRead: z
        .union([
          z.boolean(),
          z.lazy(() => BoolFieldUpdateOperationsInputSchema),
        ])
        .optional(),
      User: z
        .lazy(() => UserUpdateOneWithoutNotificationsNestedInputSchema)
        .optional(),
    })
    .strict() as z.ZodType<Prisma.NotificationUpdateInput>;

export const NotificationUncheckedUpdateInputSchema: z.ZodType<Prisma.NotificationUncheckedUpdateInput> =
  z
    .object({
      id: z
        .union([
          z.string().uuid(),
          z.lazy(() => StringFieldUpdateOperationsInputSchema),
        ])
        .optional(),
      userID: z
        .union([
          z.string(),
          z.lazy(() => StringFieldUpdateOperationsInputSchema),
        ])
        .optional(),
      title: z
        .union([
          z.string(),
          z.lazy(() => StringFieldUpdateOperationsInputSchema),
        ])
        .optional(),
      message: z
        .union([
          z.string(),
          z.lazy(() => StringFieldUpdateOperationsInputSchema),
        ])
        .optional(),
      isRead: z
        .union([
          z.boolean(),
          z.lazy(() => BoolFieldUpdateOperationsInputSchema),
        ])
        .optional(),
    })
    .strict() as z.ZodType<Prisma.NotificationUncheckedUpdateInput>;

export const NotificationCreateManyInputSchema: z.ZodType<Prisma.NotificationCreateManyInput> =
  z
    .object({
      id: z.string().uuid().optional(),
      userID: z.string(),
      title: z.string(),
      message: z.string(),
      isRead: z.boolean().optional(),
    })
    .strict() as z.ZodType<Prisma.NotificationCreateManyInput>;

export const NotificationUpdateManyMutationInputSchema: z.ZodType<Prisma.NotificationUpdateManyMutationInput> =
  z
    .object({
      id: z
        .union([
          z.string().uuid(),
          z.lazy(() => StringFieldUpdateOperationsInputSchema),
        ])
        .optional(),
      title: z
        .union([
          z.string(),
          z.lazy(() => StringFieldUpdateOperationsInputSchema),
        ])
        .optional(),
      message: z
        .union([
          z.string(),
          z.lazy(() => StringFieldUpdateOperationsInputSchema),
        ])
        .optional(),
      isRead: z
        .union([
          z.boolean(),
          z.lazy(() => BoolFieldUpdateOperationsInputSchema),
        ])
        .optional(),
    })
    .strict() as z.ZodType<Prisma.NotificationUpdateManyMutationInput>;

export const NotificationUncheckedUpdateManyInputSchema: z.ZodType<Prisma.NotificationUncheckedUpdateManyInput> =
  z
    .object({
      id: z
        .union([
          z.string().uuid(),
          z.lazy(() => StringFieldUpdateOperationsInputSchema),
        ])
        .optional(),
      userID: z
        .union([
          z.string(),
          z.lazy(() => StringFieldUpdateOperationsInputSchema),
        ])
        .optional(),
      title: z
        .union([
          z.string(),
          z.lazy(() => StringFieldUpdateOperationsInputSchema),
        ])
        .optional(),
      message: z
        .union([
          z.string(),
          z.lazy(() => StringFieldUpdateOperationsInputSchema),
        ])
        .optional(),
      isRead: z
        .union([
          z.boolean(),
          z.lazy(() => BoolFieldUpdateOperationsInputSchema),
        ])
        .optional(),
    })
    .strict() as z.ZodType<Prisma.NotificationUncheckedUpdateManyInput>;

export const PaymentCreateInputSchema: z.ZodType<Prisma.PaymentCreateInput> = z
  .object({
    id: z.string().uuid().optional(),
    type: z.lazy(() => PaymentTypeSchema),
    status: z.lazy(() => PaymentStatusSchema),
    amount: z
      .union([
        z.number(),
        z.string(),
        z.instanceof(Decimal),
        z.instanceof(Prisma.Decimal),
        DecimalJsLikeSchema,
      ])
      .refine((v) => isValidDecimalInput(v), { message: 'Must be a Decimal' }),
    transactionID: z.string().optional().nullable(),
    createdAt: z.coerce.date().optional(),
    createdBy: z.string().optional().nullable(),
    updatedAt: z.coerce.date().optional(),
    deletedAt: z.coerce.date().optional().nullable(),
    order: z.lazy(() => OrderCreateNestedOneWithoutPaymentsInputSchema),
  })
  .strict() as z.ZodType<Prisma.PaymentCreateInput>;

export const PaymentUncheckedCreateInputSchema: z.ZodType<Prisma.PaymentUncheckedCreateInput> =
  z
    .object({
      id: z.string().uuid().optional(),
      orderID: z.string(),
      type: z.lazy(() => PaymentTypeSchema),
      status: z.lazy(() => PaymentStatusSchema),
      amount: z
        .union([
          z.number(),
          z.string(),
          z.instanceof(Decimal),
          z.instanceof(Prisma.Decimal),
          DecimalJsLikeSchema,
        ])
        .refine((v) => isValidDecimalInput(v), {
          message: 'Must be a Decimal',
        }),
      transactionID: z.string().optional().nullable(),
      createdAt: z.coerce.date().optional(),
      createdBy: z.string().optional().nullable(),
      updatedAt: z.coerce.date().optional(),
      deletedAt: z.coerce.date().optional().nullable(),
    })
    .strict() as z.ZodType<Prisma.PaymentUncheckedCreateInput>;

export const PaymentUpdateInputSchema: z.ZodType<Prisma.PaymentUpdateInput> = z
  .object({
    id: z
      .union([
        z.string().uuid(),
        z.lazy(() => StringFieldUpdateOperationsInputSchema),
      ])
      .optional(),
    type: z
      .union([
        z.lazy(() => PaymentTypeSchema),
        z.lazy(() => EnumPaymentTypeFieldUpdateOperationsInputSchema),
      ])
      .optional(),
    status: z
      .union([
        z.lazy(() => PaymentStatusSchema),
        z.lazy(() => EnumPaymentStatusFieldUpdateOperationsInputSchema),
      ])
      .optional(),
    amount: z
      .union([
        z
          .union([
            z.number(),
            z.string(),
            z.instanceof(Decimal),
            z.instanceof(Prisma.Decimal),
            DecimalJsLikeSchema,
          ])
          .refine((v) => isValidDecimalInput(v), {
            message: 'Must be a Decimal',
          }),
        z.lazy(() => DecimalFieldUpdateOperationsInputSchema),
      ])
      .optional(),
    transactionID: z
      .union([
        z.string(),
        z.lazy(() => NullableStringFieldUpdateOperationsInputSchema),
      ])
      .optional()
      .nullable(),
    createdAt: z
      .union([
        z.coerce.date(),
        z.lazy(() => DateTimeFieldUpdateOperationsInputSchema),
      ])
      .optional(),
    createdBy: z
      .union([
        z.string(),
        z.lazy(() => NullableStringFieldUpdateOperationsInputSchema),
      ])
      .optional()
      .nullable(),
    updatedAt: z
      .union([
        z.coerce.date(),
        z.lazy(() => DateTimeFieldUpdateOperationsInputSchema),
      ])
      .optional(),
    deletedAt: z
      .union([
        z.coerce.date(),
        z.lazy(() => NullableDateTimeFieldUpdateOperationsInputSchema),
      ])
      .optional()
      .nullable(),
    order: z
      .lazy(() => OrderUpdateOneRequiredWithoutPaymentsNestedInputSchema)
      .optional(),
  })
  .strict() as z.ZodType<Prisma.PaymentUpdateInput>;

export const PaymentUncheckedUpdateInputSchema: z.ZodType<Prisma.PaymentUncheckedUpdateInput> =
  z
    .object({
      id: z
        .union([
          z.string().uuid(),
          z.lazy(() => StringFieldUpdateOperationsInputSchema),
        ])
        .optional(),
      orderID: z
        .union([
          z.string(),
          z.lazy(() => StringFieldUpdateOperationsInputSchema),
        ])
        .optional(),
      type: z
        .union([
          z.lazy(() => PaymentTypeSchema),
          z.lazy(() => EnumPaymentTypeFieldUpdateOperationsInputSchema),
        ])
        .optional(),
      status: z
        .union([
          z.lazy(() => PaymentStatusSchema),
          z.lazy(() => EnumPaymentStatusFieldUpdateOperationsInputSchema),
        ])
        .optional(),
      amount: z
        .union([
          z
            .union([
              z.number(),
              z.string(),
              z.instanceof(Decimal),
              z.instanceof(Prisma.Decimal),
              DecimalJsLikeSchema,
            ])
            .refine((v) => isValidDecimalInput(v), {
              message: 'Must be a Decimal',
            }),
          z.lazy(() => DecimalFieldUpdateOperationsInputSchema),
        ])
        .optional(),
      transactionID: z
        .union([
          z.string(),
          z.lazy(() => NullableStringFieldUpdateOperationsInputSchema),
        ])
        .optional()
        .nullable(),
      createdAt: z
        .union([
          z.coerce.date(),
          z.lazy(() => DateTimeFieldUpdateOperationsInputSchema),
        ])
        .optional(),
      createdBy: z
        .union([
          z.string(),
          z.lazy(() => NullableStringFieldUpdateOperationsInputSchema),
        ])
        .optional()
        .nullable(),
      updatedAt: z
        .union([
          z.coerce.date(),
          z.lazy(() => DateTimeFieldUpdateOperationsInputSchema),
        ])
        .optional(),
      deletedAt: z
        .union([
          z.coerce.date(),
          z.lazy(() => NullableDateTimeFieldUpdateOperationsInputSchema),
        ])
        .optional()
        .nullable(),
    })
    .strict() as z.ZodType<Prisma.PaymentUncheckedUpdateInput>;

export const PaymentCreateManyInputSchema: z.ZodType<Prisma.PaymentCreateManyInput> =
  z
    .object({
      id: z.string().uuid().optional(),
      orderID: z.string(),
      type: z.lazy(() => PaymentTypeSchema),
      status: z.lazy(() => PaymentStatusSchema),
      amount: z
        .union([
          z.number(),
          z.string(),
          z.instanceof(Decimal),
          z.instanceof(Prisma.Decimal),
          DecimalJsLikeSchema,
        ])
        .refine((v) => isValidDecimalInput(v), {
          message: 'Must be a Decimal',
        }),
      transactionID: z.string().optional().nullable(),
      createdAt: z.coerce.date().optional(),
      createdBy: z.string().optional().nullable(),
      updatedAt: z.coerce.date().optional(),
      deletedAt: z.coerce.date().optional().nullable(),
    })
    .strict() as z.ZodType<Prisma.PaymentCreateManyInput>;

export const PaymentUpdateManyMutationInputSchema: z.ZodType<Prisma.PaymentUpdateManyMutationInput> =
  z
    .object({
      id: z
        .union([
          z.string().uuid(),
          z.lazy(() => StringFieldUpdateOperationsInputSchema),
        ])
        .optional(),
      type: z
        .union([
          z.lazy(() => PaymentTypeSchema),
          z.lazy(() => EnumPaymentTypeFieldUpdateOperationsInputSchema),
        ])
        .optional(),
      status: z
        .union([
          z.lazy(() => PaymentStatusSchema),
          z.lazy(() => EnumPaymentStatusFieldUpdateOperationsInputSchema),
        ])
        .optional(),
      amount: z
        .union([
          z
            .union([
              z.number(),
              z.string(),
              z.instanceof(Decimal),
              z.instanceof(Prisma.Decimal),
              DecimalJsLikeSchema,
            ])
            .refine((v) => isValidDecimalInput(v), {
              message: 'Must be a Decimal',
            }),
          z.lazy(() => DecimalFieldUpdateOperationsInputSchema),
        ])
        .optional(),
      transactionID: z
        .union([
          z.string(),
          z.lazy(() => NullableStringFieldUpdateOperationsInputSchema),
        ])
        .optional()
        .nullable(),
      createdAt: z
        .union([
          z.coerce.date(),
          z.lazy(() => DateTimeFieldUpdateOperationsInputSchema),
        ])
        .optional(),
      createdBy: z
        .union([
          z.string(),
          z.lazy(() => NullableStringFieldUpdateOperationsInputSchema),
        ])
        .optional()
        .nullable(),
      updatedAt: z
        .union([
          z.coerce.date(),
          z.lazy(() => DateTimeFieldUpdateOperationsInputSchema),
        ])
        .optional(),
      deletedAt: z
        .union([
          z.coerce.date(),
          z.lazy(() => NullableDateTimeFieldUpdateOperationsInputSchema),
        ])
        .optional()
        .nullable(),
    })
    .strict() as z.ZodType<Prisma.PaymentUpdateManyMutationInput>;

export const PaymentUncheckedUpdateManyInputSchema: z.ZodType<Prisma.PaymentUncheckedUpdateManyInput> =
  z
    .object({
      id: z
        .union([
          z.string().uuid(),
          z.lazy(() => StringFieldUpdateOperationsInputSchema),
        ])
        .optional(),
      orderID: z
        .union([
          z.string(),
          z.lazy(() => StringFieldUpdateOperationsInputSchema),
        ])
        .optional(),
      type: z
        .union([
          z.lazy(() => PaymentTypeSchema),
          z.lazy(() => EnumPaymentTypeFieldUpdateOperationsInputSchema),
        ])
        .optional(),
      status: z
        .union([
          z.lazy(() => PaymentStatusSchema),
          z.lazy(() => EnumPaymentStatusFieldUpdateOperationsInputSchema),
        ])
        .optional(),
      amount: z
        .union([
          z
            .union([
              z.number(),
              z.string(),
              z.instanceof(Decimal),
              z.instanceof(Prisma.Decimal),
              DecimalJsLikeSchema,
            ])
            .refine((v) => isValidDecimalInput(v), {
              message: 'Must be a Decimal',
            }),
          z.lazy(() => DecimalFieldUpdateOperationsInputSchema),
        ])
        .optional(),
      transactionID: z
        .union([
          z.string(),
          z.lazy(() => NullableStringFieldUpdateOperationsInputSchema),
        ])
        .optional()
        .nullable(),
      createdAt: z
        .union([
          z.coerce.date(),
          z.lazy(() => DateTimeFieldUpdateOperationsInputSchema),
        ])
        .optional(),
      createdBy: z
        .union([
          z.string(),
          z.lazy(() => NullableStringFieldUpdateOperationsInputSchema),
        ])
        .optional()
        .nullable(),
      updatedAt: z
        .union([
          z.coerce.date(),
          z.lazy(() => DateTimeFieldUpdateOperationsInputSchema),
        ])
        .optional(),
      deletedAt: z
        .union([
          z.coerce.date(),
          z.lazy(() => NullableDateTimeFieldUpdateOperationsInputSchema),
        ])
        .optional()
        .nullable(),
    })
    .strict() as z.ZodType<Prisma.PaymentUncheckedUpdateManyInput>;

export const StringFilterSchema: z.ZodType<Prisma.StringFilter> = z
  .object({
    equals: z.string().optional(),
    in: z.string().array().optional(),
    notIn: z.string().array().optional(),
    lt: z.string().optional(),
    lte: z.string().optional(),
    gt: z.string().optional(),
    gte: z.string().optional(),
    contains: z.string().optional(),
    startsWith: z.string().optional(),
    endsWith: z.string().optional(),
    mode: z.lazy(() => QueryModeSchema).optional(),
    not: z
      .union([z.string(), z.lazy(() => NestedStringFilterSchema)])
      .optional(),
  })
  .strict() as z.ZodType<Prisma.StringFilter>;

export const StringNullableFilterSchema: z.ZodType<Prisma.StringNullableFilter> =
  z
    .object({
      equals: z.string().optional().nullable(),
      in: z.string().array().optional().nullable(),
      notIn: z.string().array().optional().nullable(),
      lt: z.string().optional(),
      lte: z.string().optional(),
      gt: z.string().optional(),
      gte: z.string().optional(),
      contains: z.string().optional(),
      startsWith: z.string().optional(),
      endsWith: z.string().optional(),
      mode: z.lazy(() => QueryModeSchema).optional(),
      not: z
        .union([z.string(), z.lazy(() => NestedStringNullableFilterSchema)])
        .optional()
        .nullable(),
    })
    .strict() as z.ZodType<Prisma.StringNullableFilter>;

export const EnumUserStatusFilterSchema: z.ZodType<Prisma.EnumUserStatusFilter> =
  z
    .object({
      equals: z.lazy(() => UserStatusSchema).optional(),
      in: z
        .lazy(() => UserStatusSchema)
        .array()
        .optional(),
      notIn: z
        .lazy(() => UserStatusSchema)
        .array()
        .optional(),
      not: z
        .union([
          z.lazy(() => UserStatusSchema),
          z.lazy(() => NestedEnumUserStatusFilterSchema),
        ])
        .optional(),
    })
    .strict() as z.ZodType<Prisma.EnumUserStatusFilter>;

export const DateTimeFilterSchema: z.ZodType<Prisma.DateTimeFilter> = z
  .object({
    equals: z.coerce.date().optional(),
    in: z.coerce.date().array().optional(),
    notIn: z.coerce.date().array().optional(),
    lt: z.coerce.date().optional(),
    lte: z.coerce.date().optional(),
    gt: z.coerce.date().optional(),
    gte: z.coerce.date().optional(),
    not: z
      .union([z.coerce.date(), z.lazy(() => NestedDateTimeFilterSchema)])
      .optional(),
  })
  .strict() as z.ZodType<Prisma.DateTimeFilter>;

export const DateTimeNullableFilterSchema: z.ZodType<Prisma.DateTimeNullableFilter> =
  z
    .object({
      equals: z.coerce.date().optional().nullable(),
      in: z.coerce.date().array().optional().nullable(),
      notIn: z.coerce.date().array().optional().nullable(),
      lt: z.coerce.date().optional(),
      lte: z.coerce.date().optional(),
      gt: z.coerce.date().optional(),
      gte: z.coerce.date().optional(),
      not: z
        .union([
          z.coerce.date(),
          z.lazy(() => NestedDateTimeNullableFilterSchema),
        ])
        .optional()
        .nullable(),
    })
    .strict() as z.ZodType<Prisma.DateTimeNullableFilter>;

export const VendorListRelationFilterSchema: z.ZodType<Prisma.VendorListRelationFilter> =
  z
    .object({
      every: z.lazy(() => VendorWhereInputSchema).optional(),
      some: z.lazy(() => VendorWhereInputSchema).optional(),
      none: z.lazy(() => VendorWhereInputSchema).optional(),
    })
    .strict() as z.ZodType<Prisma.VendorListRelationFilter>;

export const UserVendorRoleListRelationFilterSchema: z.ZodType<Prisma.UserVendorRoleListRelationFilter> =
  z
    .object({
      every: z.lazy(() => UserVendorRoleWhereInputSchema).optional(),
      some: z.lazy(() => UserVendorRoleWhereInputSchema).optional(),
      none: z.lazy(() => UserVendorRoleWhereInputSchema).optional(),
    })
    .strict() as z.ZodType<Prisma.UserVendorRoleListRelationFilter>;

export const OrderListRelationFilterSchema: z.ZodType<Prisma.OrderListRelationFilter> =
  z
    .object({
      every: z.lazy(() => OrderWhereInputSchema).optional(),
      some: z.lazy(() => OrderWhereInputSchema).optional(),
      none: z.lazy(() => OrderWhereInputSchema).optional(),
    })
    .strict() as z.ZodType<Prisma.OrderListRelationFilter>;

export const CartNullableScalarRelationFilterSchema: z.ZodType<Prisma.CartNullableScalarRelationFilter> =
  z
    .object({
      is: z
        .lazy(() => CartWhereInputSchema)
        .optional()
        .nullable(),
      isNot: z
        .lazy(() => CartWhereInputSchema)
        .optional()
        .nullable(),
    })
    .strict() as z.ZodType<Prisma.CartNullableScalarRelationFilter>;

export const NotificationListRelationFilterSchema: z.ZodType<Prisma.NotificationListRelationFilter> =
  z
    .object({
      every: z.lazy(() => NotificationWhereInputSchema).optional(),
      some: z.lazy(() => NotificationWhereInputSchema).optional(),
      none: z.lazy(() => NotificationWhereInputSchema).optional(),
    })
    .strict() as z.ZodType<Prisma.NotificationListRelationFilter>;

export const SortOrderInputSchema: z.ZodType<Prisma.SortOrderInput> = z
  .object({
    sort: z.lazy(() => SortOrderSchema),
    nulls: z.lazy(() => NullsOrderSchema).optional(),
  })
  .strict() as z.ZodType<Prisma.SortOrderInput>;

export const VendorOrderByRelationAggregateInputSchema: z.ZodType<Prisma.VendorOrderByRelationAggregateInput> =
  z
    .object({
      _count: z.lazy(() => SortOrderSchema).optional(),
    })
    .strict() as z.ZodType<Prisma.VendorOrderByRelationAggregateInput>;

export const UserVendorRoleOrderByRelationAggregateInputSchema: z.ZodType<Prisma.UserVendorRoleOrderByRelationAggregateInput> =
  z
    .object({
      _count: z.lazy(() => SortOrderSchema).optional(),
    })
    .strict() as z.ZodType<Prisma.UserVendorRoleOrderByRelationAggregateInput>;

export const OrderOrderByRelationAggregateInputSchema: z.ZodType<Prisma.OrderOrderByRelationAggregateInput> =
  z
    .object({
      _count: z.lazy(() => SortOrderSchema).optional(),
    })
    .strict() as z.ZodType<Prisma.OrderOrderByRelationAggregateInput>;

export const NotificationOrderByRelationAggregateInputSchema: z.ZodType<Prisma.NotificationOrderByRelationAggregateInput> =
  z
    .object({
      _count: z.lazy(() => SortOrderSchema).optional(),
    })
    .strict() as z.ZodType<Prisma.NotificationOrderByRelationAggregateInput>;

export const UserCountOrderByAggregateInputSchema: z.ZodType<Prisma.UserCountOrderByAggregateInput> =
  z
    .object({
      id: z.lazy(() => SortOrderSchema).optional(),
      email: z.lazy(() => SortOrderSchema).optional(),
      password: z.lazy(() => SortOrderSchema).optional(),
      firstName: z.lazy(() => SortOrderSchema).optional(),
      lastName: z.lazy(() => SortOrderSchema).optional(),
      fullAddress: z.lazy(() => SortOrderSchema).optional(),
      city: z.lazy(() => SortOrderSchema).optional(),
      province: z.lazy(() => SortOrderSchema).optional(),
      country: z.lazy(() => SortOrderSchema).optional(),
      phone: z.lazy(() => SortOrderSchema).optional(),
      status: z.lazy(() => SortOrderSchema).optional(),
      createdAt: z.lazy(() => SortOrderSchema).optional(),
      createdBy: z.lazy(() => SortOrderSchema).optional(),
      updatedAt: z.lazy(() => SortOrderSchema).optional(),
      deletedAt: z.lazy(() => SortOrderSchema).optional(),
    })
    .strict() as z.ZodType<Prisma.UserCountOrderByAggregateInput>;

export const UserMaxOrderByAggregateInputSchema: z.ZodType<Prisma.UserMaxOrderByAggregateInput> =
  z
    .object({
      id: z.lazy(() => SortOrderSchema).optional(),
      email: z.lazy(() => SortOrderSchema).optional(),
      password: z.lazy(() => SortOrderSchema).optional(),
      firstName: z.lazy(() => SortOrderSchema).optional(),
      lastName: z.lazy(() => SortOrderSchema).optional(),
      fullAddress: z.lazy(() => SortOrderSchema).optional(),
      city: z.lazy(() => SortOrderSchema).optional(),
      province: z.lazy(() => SortOrderSchema).optional(),
      country: z.lazy(() => SortOrderSchema).optional(),
      phone: z.lazy(() => SortOrderSchema).optional(),
      status: z.lazy(() => SortOrderSchema).optional(),
      createdAt: z.lazy(() => SortOrderSchema).optional(),
      createdBy: z.lazy(() => SortOrderSchema).optional(),
      updatedAt: z.lazy(() => SortOrderSchema).optional(),
      deletedAt: z.lazy(() => SortOrderSchema).optional(),
    })
    .strict() as z.ZodType<Prisma.UserMaxOrderByAggregateInput>;

export const UserMinOrderByAggregateInputSchema: z.ZodType<Prisma.UserMinOrderByAggregateInput> =
  z
    .object({
      id: z.lazy(() => SortOrderSchema).optional(),
      email: z.lazy(() => SortOrderSchema).optional(),
      password: z.lazy(() => SortOrderSchema).optional(),
      firstName: z.lazy(() => SortOrderSchema).optional(),
      lastName: z.lazy(() => SortOrderSchema).optional(),
      fullAddress: z.lazy(() => SortOrderSchema).optional(),
      city: z.lazy(() => SortOrderSchema).optional(),
      province: z.lazy(() => SortOrderSchema).optional(),
      country: z.lazy(() => SortOrderSchema).optional(),
      phone: z.lazy(() => SortOrderSchema).optional(),
      status: z.lazy(() => SortOrderSchema).optional(),
      createdAt: z.lazy(() => SortOrderSchema).optional(),
      createdBy: z.lazy(() => SortOrderSchema).optional(),
      updatedAt: z.lazy(() => SortOrderSchema).optional(),
      deletedAt: z.lazy(() => SortOrderSchema).optional(),
    })
    .strict() as z.ZodType<Prisma.UserMinOrderByAggregateInput>;

export const StringWithAggregatesFilterSchema: z.ZodType<Prisma.StringWithAggregatesFilter> =
  z
    .object({
      equals: z.string().optional(),
      in: z.string().array().optional(),
      notIn: z.string().array().optional(),
      lt: z.string().optional(),
      lte: z.string().optional(),
      gt: z.string().optional(),
      gte: z.string().optional(),
      contains: z.string().optional(),
      startsWith: z.string().optional(),
      endsWith: z.string().optional(),
      mode: z.lazy(() => QueryModeSchema).optional(),
      not: z
        .union([
          z.string(),
          z.lazy(() => NestedStringWithAggregatesFilterSchema),
        ])
        .optional(),
      _count: z.lazy(() => NestedIntFilterSchema).optional(),
      _min: z.lazy(() => NestedStringFilterSchema).optional(),
      _max: z.lazy(() => NestedStringFilterSchema).optional(),
    })
    .strict() as z.ZodType<Prisma.StringWithAggregatesFilter>;

export const StringNullableWithAggregatesFilterSchema: z.ZodType<Prisma.StringNullableWithAggregatesFilter> =
  z
    .object({
      equals: z.string().optional().nullable(),
      in: z.string().array().optional().nullable(),
      notIn: z.string().array().optional().nullable(),
      lt: z.string().optional(),
      lte: z.string().optional(),
      gt: z.string().optional(),
      gte: z.string().optional(),
      contains: z.string().optional(),
      startsWith: z.string().optional(),
      endsWith: z.string().optional(),
      mode: z.lazy(() => QueryModeSchema).optional(),
      not: z
        .union([
          z.string(),
          z.lazy(() => NestedStringNullableWithAggregatesFilterSchema),
        ])
        .optional()
        .nullable(),
      _count: z.lazy(() => NestedIntNullableFilterSchema).optional(),
      _min: z.lazy(() => NestedStringNullableFilterSchema).optional(),
      _max: z.lazy(() => NestedStringNullableFilterSchema).optional(),
    })
    .strict() as z.ZodType<Prisma.StringNullableWithAggregatesFilter>;

export const EnumUserStatusWithAggregatesFilterSchema: z.ZodType<Prisma.EnumUserStatusWithAggregatesFilter> =
  z
    .object({
      equals: z.lazy(() => UserStatusSchema).optional(),
      in: z
        .lazy(() => UserStatusSchema)
        .array()
        .optional(),
      notIn: z
        .lazy(() => UserStatusSchema)
        .array()
        .optional(),
      not: z
        .union([
          z.lazy(() => UserStatusSchema),
          z.lazy(() => NestedEnumUserStatusWithAggregatesFilterSchema),
        ])
        .optional(),
      _count: z.lazy(() => NestedIntFilterSchema).optional(),
      _min: z.lazy(() => NestedEnumUserStatusFilterSchema).optional(),
      _max: z.lazy(() => NestedEnumUserStatusFilterSchema).optional(),
    })
    .strict() as z.ZodType<Prisma.EnumUserStatusWithAggregatesFilter>;

export const DateTimeWithAggregatesFilterSchema: z.ZodType<Prisma.DateTimeWithAggregatesFilter> =
  z
    .object({
      equals: z.coerce.date().optional(),
      in: z.coerce.date().array().optional(),
      notIn: z.coerce.date().array().optional(),
      lt: z.coerce.date().optional(),
      lte: z.coerce.date().optional(),
      gt: z.coerce.date().optional(),
      gte: z.coerce.date().optional(),
      not: z
        .union([
          z.coerce.date(),
          z.lazy(() => NestedDateTimeWithAggregatesFilterSchema),
        ])
        .optional(),
      _count: z.lazy(() => NestedIntFilterSchema).optional(),
      _min: z.lazy(() => NestedDateTimeFilterSchema).optional(),
      _max: z.lazy(() => NestedDateTimeFilterSchema).optional(),
    })
    .strict() as z.ZodType<Prisma.DateTimeWithAggregatesFilter>;

export const DateTimeNullableWithAggregatesFilterSchema: z.ZodType<Prisma.DateTimeNullableWithAggregatesFilter> =
  z
    .object({
      equals: z.coerce.date().optional().nullable(),
      in: z.coerce.date().array().optional().nullable(),
      notIn: z.coerce.date().array().optional().nullable(),
      lt: z.coerce.date().optional(),
      lte: z.coerce.date().optional(),
      gt: z.coerce.date().optional(),
      gte: z.coerce.date().optional(),
      not: z
        .union([
          z.coerce.date(),
          z.lazy(() => NestedDateTimeNullableWithAggregatesFilterSchema),
        ])
        .optional()
        .nullable(),
      _count: z.lazy(() => NestedIntNullableFilterSchema).optional(),
      _min: z.lazy(() => NestedDateTimeNullableFilterSchema).optional(),
      _max: z.lazy(() => NestedDateTimeNullableFilterSchema).optional(),
    })
    .strict() as z.ZodType<Prisma.DateTimeNullableWithAggregatesFilter>;

export const IntFilterSchema: z.ZodType<Prisma.IntFilter> = z
  .object({
    equals: z.number().optional(),
    in: z.number().array().optional(),
    notIn: z.number().array().optional(),
    lt: z.number().optional(),
    lte: z.number().optional(),
    gt: z.number().optional(),
    gte: z.number().optional(),
    not: z.union([z.number(), z.lazy(() => NestedIntFilterSchema)]).optional(),
  })
  .strict() as z.ZodType<Prisma.IntFilter>;

export const EnumVendorStatusFilterSchema: z.ZodType<Prisma.EnumVendorStatusFilter> =
  z
    .object({
      equals: z.lazy(() => VendorStatusSchema).optional(),
      in: z
        .lazy(() => VendorStatusSchema)
        .array()
        .optional(),
      notIn: z
        .lazy(() => VendorStatusSchema)
        .array()
        .optional(),
      not: z
        .union([
          z.lazy(() => VendorStatusSchema),
          z.lazy(() => NestedEnumVendorStatusFilterSchema),
        ])
        .optional(),
    })
    .strict() as z.ZodType<Prisma.EnumVendorStatusFilter>;

export const UserScalarRelationFilterSchema: z.ZodType<Prisma.UserScalarRelationFilter> =
  z
    .object({
      is: z.lazy(() => UserWhereInputSchema).optional(),
      isNot: z.lazy(() => UserWhereInputSchema).optional(),
    })
    .strict() as z.ZodType<Prisma.UserScalarRelationFilter>;

export const ProductListRelationFilterSchema: z.ZodType<Prisma.ProductListRelationFilter> =
  z
    .object({
      every: z.lazy(() => ProductWhereInputSchema).optional(),
      some: z.lazy(() => ProductWhereInputSchema).optional(),
      none: z.lazy(() => ProductWhereInputSchema).optional(),
    })
    .strict() as z.ZodType<Prisma.ProductListRelationFilter>;

export const ProductOrderByRelationAggregateInputSchema: z.ZodType<Prisma.ProductOrderByRelationAggregateInput> =
  z
    .object({
      _count: z.lazy(() => SortOrderSchema).optional(),
    })
    .strict() as z.ZodType<Prisma.ProductOrderByRelationAggregateInput>;

export const VendorCountOrderByAggregateInputSchema: z.ZodType<Prisma.VendorCountOrderByAggregateInput> =
  z
    .object({
      id: z.lazy(() => SortOrderSchema).optional(),
      userID: z.lazy(() => SortOrderSchema).optional(),
      name: z.lazy(() => SortOrderSchema).optional(),
      slug: z.lazy(() => SortOrderSchema).optional(),
      description: z.lazy(() => SortOrderSchema).optional(),
      logoUrl: z.lazy(() => SortOrderSchema).optional(),
      taxCode: z.lazy(() => SortOrderSchema).optional(),
      totalProducts: z.lazy(() => SortOrderSchema).optional(),
      totalOrders: z.lazy(() => SortOrderSchema).optional(),
      status: z.lazy(() => SortOrderSchema).optional(),
      createdAt: z.lazy(() => SortOrderSchema).optional(),
      createdBy: z.lazy(() => SortOrderSchema).optional(),
      updatedAt: z.lazy(() => SortOrderSchema).optional(),
      deletedAt: z.lazy(() => SortOrderSchema).optional(),
    })
    .strict() as z.ZodType<Prisma.VendorCountOrderByAggregateInput>;

export const VendorAvgOrderByAggregateInputSchema: z.ZodType<Prisma.VendorAvgOrderByAggregateInput> =
  z
    .object({
      totalProducts: z.lazy(() => SortOrderSchema).optional(),
      totalOrders: z.lazy(() => SortOrderSchema).optional(),
    })
    .strict() as z.ZodType<Prisma.VendorAvgOrderByAggregateInput>;

export const VendorMaxOrderByAggregateInputSchema: z.ZodType<Prisma.VendorMaxOrderByAggregateInput> =
  z
    .object({
      id: z.lazy(() => SortOrderSchema).optional(),
      userID: z.lazy(() => SortOrderSchema).optional(),
      name: z.lazy(() => SortOrderSchema).optional(),
      slug: z.lazy(() => SortOrderSchema).optional(),
      description: z.lazy(() => SortOrderSchema).optional(),
      logoUrl: z.lazy(() => SortOrderSchema).optional(),
      taxCode: z.lazy(() => SortOrderSchema).optional(),
      totalProducts: z.lazy(() => SortOrderSchema).optional(),
      totalOrders: z.lazy(() => SortOrderSchema).optional(),
      status: z.lazy(() => SortOrderSchema).optional(),
      createdAt: z.lazy(() => SortOrderSchema).optional(),
      createdBy: z.lazy(() => SortOrderSchema).optional(),
      updatedAt: z.lazy(() => SortOrderSchema).optional(),
      deletedAt: z.lazy(() => SortOrderSchema).optional(),
    })
    .strict() as z.ZodType<Prisma.VendorMaxOrderByAggregateInput>;

export const VendorMinOrderByAggregateInputSchema: z.ZodType<Prisma.VendorMinOrderByAggregateInput> =
  z
    .object({
      id: z.lazy(() => SortOrderSchema).optional(),
      userID: z.lazy(() => SortOrderSchema).optional(),
      name: z.lazy(() => SortOrderSchema).optional(),
      slug: z.lazy(() => SortOrderSchema).optional(),
      description: z.lazy(() => SortOrderSchema).optional(),
      logoUrl: z.lazy(() => SortOrderSchema).optional(),
      taxCode: z.lazy(() => SortOrderSchema).optional(),
      totalProducts: z.lazy(() => SortOrderSchema).optional(),
      totalOrders: z.lazy(() => SortOrderSchema).optional(),
      status: z.lazy(() => SortOrderSchema).optional(),
      createdAt: z.lazy(() => SortOrderSchema).optional(),
      createdBy: z.lazy(() => SortOrderSchema).optional(),
      updatedAt: z.lazy(() => SortOrderSchema).optional(),
      deletedAt: z.lazy(() => SortOrderSchema).optional(),
    })
    .strict() as z.ZodType<Prisma.VendorMinOrderByAggregateInput>;

export const VendorSumOrderByAggregateInputSchema: z.ZodType<Prisma.VendorSumOrderByAggregateInput> =
  z
    .object({
      totalProducts: z.lazy(() => SortOrderSchema).optional(),
      totalOrders: z.lazy(() => SortOrderSchema).optional(),
    })
    .strict() as z.ZodType<Prisma.VendorSumOrderByAggregateInput>;

export const IntWithAggregatesFilterSchema: z.ZodType<Prisma.IntWithAggregatesFilter> =
  z
    .object({
      equals: z.number().optional(),
      in: z.number().array().optional(),
      notIn: z.number().array().optional(),
      lt: z.number().optional(),
      lte: z.number().optional(),
      gt: z.number().optional(),
      gte: z.number().optional(),
      not: z
        .union([z.number(), z.lazy(() => NestedIntWithAggregatesFilterSchema)])
        .optional(),
      _count: z.lazy(() => NestedIntFilterSchema).optional(),
      _avg: z.lazy(() => NestedFloatFilterSchema).optional(),
      _sum: z.lazy(() => NestedIntFilterSchema).optional(),
      _min: z.lazy(() => NestedIntFilterSchema).optional(),
      _max: z.lazy(() => NestedIntFilterSchema).optional(),
    })
    .strict() as z.ZodType<Prisma.IntWithAggregatesFilter>;

export const EnumVendorStatusWithAggregatesFilterSchema: z.ZodType<Prisma.EnumVendorStatusWithAggregatesFilter> =
  z
    .object({
      equals: z.lazy(() => VendorStatusSchema).optional(),
      in: z
        .lazy(() => VendorStatusSchema)
        .array()
        .optional(),
      notIn: z
        .lazy(() => VendorStatusSchema)
        .array()
        .optional(),
      not: z
        .union([
          z.lazy(() => VendorStatusSchema),
          z.lazy(() => NestedEnumVendorStatusWithAggregatesFilterSchema),
        ])
        .optional(),
      _count: z.lazy(() => NestedIntFilterSchema).optional(),
      _min: z.lazy(() => NestedEnumVendorStatusFilterSchema).optional(),
      _max: z.lazy(() => NestedEnumVendorStatusFilterSchema).optional(),
    })
    .strict() as z.ZodType<Prisma.EnumVendorStatusWithAggregatesFilter>;

export const BoolFilterSchema: z.ZodType<Prisma.BoolFilter> = z
  .object({
    equals: z.boolean().optional(),
    not: z
      .union([z.boolean(), z.lazy(() => NestedBoolFilterSchema)])
      .optional(),
  })
  .strict() as z.ZodType<Prisma.BoolFilter>;

export const RolePermissionListRelationFilterSchema: z.ZodType<Prisma.RolePermissionListRelationFilter> =
  z
    .object({
      every: z.lazy(() => RolePermissionWhereInputSchema).optional(),
      some: z.lazy(() => RolePermissionWhereInputSchema).optional(),
      none: z.lazy(() => RolePermissionWhereInputSchema).optional(),
    })
    .strict() as z.ZodType<Prisma.RolePermissionListRelationFilter>;

export const RolePermissionOrderByRelationAggregateInputSchema: z.ZodType<Prisma.RolePermissionOrderByRelationAggregateInput> =
  z
    .object({
      _count: z.lazy(() => SortOrderSchema).optional(),
    })
    .strict() as z.ZodType<Prisma.RolePermissionOrderByRelationAggregateInput>;

export const RoleCountOrderByAggregateInputSchema: z.ZodType<Prisma.RoleCountOrderByAggregateInput> =
  z
    .object({
      id: z.lazy(() => SortOrderSchema).optional(),
      name: z.lazy(() => SortOrderSchema).optional(),
      description: z.lazy(() => SortOrderSchema).optional(),
      isSystemRole: z.lazy(() => SortOrderSchema).optional(),
      createdAt: z.lazy(() => SortOrderSchema).optional(),
      createdBy: z.lazy(() => SortOrderSchema).optional(),
      updatedAt: z.lazy(() => SortOrderSchema).optional(),
      deletedAt: z.lazy(() => SortOrderSchema).optional(),
    })
    .strict() as z.ZodType<Prisma.RoleCountOrderByAggregateInput>;

export const RoleMaxOrderByAggregateInputSchema: z.ZodType<Prisma.RoleMaxOrderByAggregateInput> =
  z
    .object({
      id: z.lazy(() => SortOrderSchema).optional(),
      name: z.lazy(() => SortOrderSchema).optional(),
      description: z.lazy(() => SortOrderSchema).optional(),
      isSystemRole: z.lazy(() => SortOrderSchema).optional(),
      createdAt: z.lazy(() => SortOrderSchema).optional(),
      createdBy: z.lazy(() => SortOrderSchema).optional(),
      updatedAt: z.lazy(() => SortOrderSchema).optional(),
      deletedAt: z.lazy(() => SortOrderSchema).optional(),
    })
    .strict() as z.ZodType<Prisma.RoleMaxOrderByAggregateInput>;

export const RoleMinOrderByAggregateInputSchema: z.ZodType<Prisma.RoleMinOrderByAggregateInput> =
  z
    .object({
      id: z.lazy(() => SortOrderSchema).optional(),
      name: z.lazy(() => SortOrderSchema).optional(),
      description: z.lazy(() => SortOrderSchema).optional(),
      isSystemRole: z.lazy(() => SortOrderSchema).optional(),
      createdAt: z.lazy(() => SortOrderSchema).optional(),
      createdBy: z.lazy(() => SortOrderSchema).optional(),
      updatedAt: z.lazy(() => SortOrderSchema).optional(),
      deletedAt: z.lazy(() => SortOrderSchema).optional(),
    })
    .strict() as z.ZodType<Prisma.RoleMinOrderByAggregateInput>;

export const BoolWithAggregatesFilterSchema: z.ZodType<Prisma.BoolWithAggregatesFilter> =
  z
    .object({
      equals: z.boolean().optional(),
      not: z
        .union([
          z.boolean(),
          z.lazy(() => NestedBoolWithAggregatesFilterSchema),
        ])
        .optional(),
      _count: z.lazy(() => NestedIntFilterSchema).optional(),
      _min: z.lazy(() => NestedBoolFilterSchema).optional(),
      _max: z.lazy(() => NestedBoolFilterSchema).optional(),
    })
    .strict() as z.ZodType<Prisma.BoolWithAggregatesFilter>;

export const PermissionNameKeyCompoundUniqueInputSchema: z.ZodType<Prisma.PermissionNameKeyCompoundUniqueInput> =
  z
    .object({
      name: z.string(),
      key: z.string(),
    })
    .strict() as z.ZodType<Prisma.PermissionNameKeyCompoundUniqueInput>;

export const PermissionCountOrderByAggregateInputSchema: z.ZodType<Prisma.PermissionCountOrderByAggregateInput> =
  z
    .object({
      id: z.lazy(() => SortOrderSchema).optional(),
      name: z.lazy(() => SortOrderSchema).optional(),
      description: z.lazy(() => SortOrderSchema).optional(),
      key: z.lazy(() => SortOrderSchema).optional(),
      isSystemPermission: z.lazy(() => SortOrderSchema).optional(),
      createdAt: z.lazy(() => SortOrderSchema).optional(),
      createdBy: z.lazy(() => SortOrderSchema).optional(),
      updatedAt: z.lazy(() => SortOrderSchema).optional(),
      deletedAt: z.lazy(() => SortOrderSchema).optional(),
    })
    .strict() as z.ZodType<Prisma.PermissionCountOrderByAggregateInput>;

export const PermissionMaxOrderByAggregateInputSchema: z.ZodType<Prisma.PermissionMaxOrderByAggregateInput> =
  z
    .object({
      id: z.lazy(() => SortOrderSchema).optional(),
      name: z.lazy(() => SortOrderSchema).optional(),
      description: z.lazy(() => SortOrderSchema).optional(),
      key: z.lazy(() => SortOrderSchema).optional(),
      isSystemPermission: z.lazy(() => SortOrderSchema).optional(),
      createdAt: z.lazy(() => SortOrderSchema).optional(),
      createdBy: z.lazy(() => SortOrderSchema).optional(),
      updatedAt: z.lazy(() => SortOrderSchema).optional(),
      deletedAt: z.lazy(() => SortOrderSchema).optional(),
    })
    .strict() as z.ZodType<Prisma.PermissionMaxOrderByAggregateInput>;

export const PermissionMinOrderByAggregateInputSchema: z.ZodType<Prisma.PermissionMinOrderByAggregateInput> =
  z
    .object({
      id: z.lazy(() => SortOrderSchema).optional(),
      name: z.lazy(() => SortOrderSchema).optional(),
      description: z.lazy(() => SortOrderSchema).optional(),
      key: z.lazy(() => SortOrderSchema).optional(),
      isSystemPermission: z.lazy(() => SortOrderSchema).optional(),
      createdAt: z.lazy(() => SortOrderSchema).optional(),
      createdBy: z.lazy(() => SortOrderSchema).optional(),
      updatedAt: z.lazy(() => SortOrderSchema).optional(),
      deletedAt: z.lazy(() => SortOrderSchema).optional(),
    })
    .strict() as z.ZodType<Prisma.PermissionMinOrderByAggregateInput>;

export const RoleScalarRelationFilterSchema: z.ZodType<Prisma.RoleScalarRelationFilter> =
  z
    .object({
      is: z.lazy(() => RoleWhereInputSchema).optional(),
      isNot: z.lazy(() => RoleWhereInputSchema).optional(),
    })
    .strict() as z.ZodType<Prisma.RoleScalarRelationFilter>;

export const PermissionScalarRelationFilterSchema: z.ZodType<Prisma.PermissionScalarRelationFilter> =
  z
    .object({
      is: z.lazy(() => PermissionWhereInputSchema).optional(),
      isNot: z.lazy(() => PermissionWhereInputSchema).optional(),
    })
    .strict() as z.ZodType<Prisma.PermissionScalarRelationFilter>;

export const RolePermissionRoleIDPermissionIDCompoundUniqueInputSchema: z.ZodType<Prisma.RolePermissionRoleIDPermissionIDCompoundUniqueInput> =
  z
    .object({
      roleID: z.string(),
      permissionID: z.string(),
    })
    .strict() as z.ZodType<Prisma.RolePermissionRoleIDPermissionIDCompoundUniqueInput>;

export const RolePermissionCountOrderByAggregateInputSchema: z.ZodType<Prisma.RolePermissionCountOrderByAggregateInput> =
  z
    .object({
      roleID: z.lazy(() => SortOrderSchema).optional(),
      permissionID: z.lazy(() => SortOrderSchema).optional(),
      createdAt: z.lazy(() => SortOrderSchema).optional(),
      createdBy: z.lazy(() => SortOrderSchema).optional(),
    })
    .strict() as z.ZodType<Prisma.RolePermissionCountOrderByAggregateInput>;

export const RolePermissionMaxOrderByAggregateInputSchema: z.ZodType<Prisma.RolePermissionMaxOrderByAggregateInput> =
  z
    .object({
      roleID: z.lazy(() => SortOrderSchema).optional(),
      permissionID: z.lazy(() => SortOrderSchema).optional(),
      createdAt: z.lazy(() => SortOrderSchema).optional(),
      createdBy: z.lazy(() => SortOrderSchema).optional(),
    })
    .strict() as z.ZodType<Prisma.RolePermissionMaxOrderByAggregateInput>;

export const RolePermissionMinOrderByAggregateInputSchema: z.ZodType<Prisma.RolePermissionMinOrderByAggregateInput> =
  z
    .object({
      roleID: z.lazy(() => SortOrderSchema).optional(),
      permissionID: z.lazy(() => SortOrderSchema).optional(),
      createdAt: z.lazy(() => SortOrderSchema).optional(),
      createdBy: z.lazy(() => SortOrderSchema).optional(),
    })
    .strict() as z.ZodType<Prisma.RolePermissionMinOrderByAggregateInput>;

export const EnumUserVendorRoleStatusFilterSchema: z.ZodType<Prisma.EnumUserVendorRoleStatusFilter> =
  z
    .object({
      equals: z.lazy(() => UserVendorRoleStatusSchema).optional(),
      in: z
        .lazy(() => UserVendorRoleStatusSchema)
        .array()
        .optional(),
      notIn: z
        .lazy(() => UserVendorRoleStatusSchema)
        .array()
        .optional(),
      not: z
        .union([
          z.lazy(() => UserVendorRoleStatusSchema),
          z.lazy(() => NestedEnumUserVendorRoleStatusFilterSchema),
        ])
        .optional(),
    })
    .strict() as z.ZodType<Prisma.EnumUserVendorRoleStatusFilter>;

export const VendorScalarRelationFilterSchema: z.ZodType<Prisma.VendorScalarRelationFilter> =
  z
    .object({
      is: z.lazy(() => VendorWhereInputSchema).optional(),
      isNot: z.lazy(() => VendorWhereInputSchema).optional(),
    })
    .strict() as z.ZodType<Prisma.VendorScalarRelationFilter>;

export const UserVendorRoleUserIDVendorIDCompoundUniqueInputSchema: z.ZodType<Prisma.UserVendorRoleUserIDVendorIDCompoundUniqueInput> =
  z
    .object({
      userID: z.string(),
      vendorID: z.string(),
    })
    .strict() as z.ZodType<Prisma.UserVendorRoleUserIDVendorIDCompoundUniqueInput>;

export const UserVendorRoleCountOrderByAggregateInputSchema: z.ZodType<Prisma.UserVendorRoleCountOrderByAggregateInput> =
  z
    .object({
      id: z.lazy(() => SortOrderSchema).optional(),
      userID: z.lazy(() => SortOrderSchema).optional(),
      vendorID: z.lazy(() => SortOrderSchema).optional(),
      roleID: z.lazy(() => SortOrderSchema).optional(),
      status: z.lazy(() => SortOrderSchema).optional(),
      createdAt: z.lazy(() => SortOrderSchema).optional(),
      createdBy: z.lazy(() => SortOrderSchema).optional(),
    })
    .strict() as z.ZodType<Prisma.UserVendorRoleCountOrderByAggregateInput>;

export const UserVendorRoleMaxOrderByAggregateInputSchema: z.ZodType<Prisma.UserVendorRoleMaxOrderByAggregateInput> =
  z
    .object({
      id: z.lazy(() => SortOrderSchema).optional(),
      userID: z.lazy(() => SortOrderSchema).optional(),
      vendorID: z.lazy(() => SortOrderSchema).optional(),
      roleID: z.lazy(() => SortOrderSchema).optional(),
      status: z.lazy(() => SortOrderSchema).optional(),
      createdAt: z.lazy(() => SortOrderSchema).optional(),
      createdBy: z.lazy(() => SortOrderSchema).optional(),
    })
    .strict() as z.ZodType<Prisma.UserVendorRoleMaxOrderByAggregateInput>;

export const UserVendorRoleMinOrderByAggregateInputSchema: z.ZodType<Prisma.UserVendorRoleMinOrderByAggregateInput> =
  z
    .object({
      id: z.lazy(() => SortOrderSchema).optional(),
      userID: z.lazy(() => SortOrderSchema).optional(),
      vendorID: z.lazy(() => SortOrderSchema).optional(),
      roleID: z.lazy(() => SortOrderSchema).optional(),
      status: z.lazy(() => SortOrderSchema).optional(),
      createdAt: z.lazy(() => SortOrderSchema).optional(),
      createdBy: z.lazy(() => SortOrderSchema).optional(),
    })
    .strict() as z.ZodType<Prisma.UserVendorRoleMinOrderByAggregateInput>;

export const EnumUserVendorRoleStatusWithAggregatesFilterSchema: z.ZodType<Prisma.EnumUserVendorRoleStatusWithAggregatesFilter> =
  z
    .object({
      equals: z.lazy(() => UserVendorRoleStatusSchema).optional(),
      in: z
        .lazy(() => UserVendorRoleStatusSchema)
        .array()
        .optional(),
      notIn: z
        .lazy(() => UserVendorRoleStatusSchema)
        .array()
        .optional(),
      not: z
        .union([
          z.lazy(() => UserVendorRoleStatusSchema),
          z.lazy(
            () => NestedEnumUserVendorRoleStatusWithAggregatesFilterSchema,
          ),
        ])
        .optional(),
      _count: z.lazy(() => NestedIntFilterSchema).optional(),
      _min: z.lazy(() => NestedEnumUserVendorRoleStatusFilterSchema).optional(),
      _max: z.lazy(() => NestedEnumUserVendorRoleStatusFilterSchema).optional(),
    })
    .strict() as z.ZodType<Prisma.EnumUserVendorRoleStatusWithAggregatesFilter>;

export const CategoryNullableScalarRelationFilterSchema: z.ZodType<Prisma.CategoryNullableScalarRelationFilter> =
  z
    .object({
      is: z
        .lazy(() => CategoryWhereInputSchema)
        .optional()
        .nullable(),
      isNot: z
        .lazy(() => CategoryWhereInputSchema)
        .optional()
        .nullable(),
    })
    .strict() as z.ZodType<Prisma.CategoryNullableScalarRelationFilter>;

export const CategoryListRelationFilterSchema: z.ZodType<Prisma.CategoryListRelationFilter> =
  z
    .object({
      every: z.lazy(() => CategoryWhereInputSchema).optional(),
      some: z.lazy(() => CategoryWhereInputSchema).optional(),
      none: z.lazy(() => CategoryWhereInputSchema).optional(),
    })
    .strict() as z.ZodType<Prisma.CategoryListRelationFilter>;

export const ProductCategoryListRelationFilterSchema: z.ZodType<Prisma.ProductCategoryListRelationFilter> =
  z
    .object({
      every: z.lazy(() => ProductCategoryWhereInputSchema).optional(),
      some: z.lazy(() => ProductCategoryWhereInputSchema).optional(),
      none: z.lazy(() => ProductCategoryWhereInputSchema).optional(),
    })
    .strict() as z.ZodType<Prisma.ProductCategoryListRelationFilter>;

export const CategoryOrderByRelationAggregateInputSchema: z.ZodType<Prisma.CategoryOrderByRelationAggregateInput> =
  z
    .object({
      _count: z.lazy(() => SortOrderSchema).optional(),
    })
    .strict() as z.ZodType<Prisma.CategoryOrderByRelationAggregateInput>;

export const ProductCategoryOrderByRelationAggregateInputSchema: z.ZodType<Prisma.ProductCategoryOrderByRelationAggregateInput> =
  z
    .object({
      _count: z.lazy(() => SortOrderSchema).optional(),
    })
    .strict() as z.ZodType<Prisma.ProductCategoryOrderByRelationAggregateInput>;

export const CategoryCountOrderByAggregateInputSchema: z.ZodType<Prisma.CategoryCountOrderByAggregateInput> =
  z
    .object({
      id: z.lazy(() => SortOrderSchema).optional(),
      name: z.lazy(() => SortOrderSchema).optional(),
      slug: z.lazy(() => SortOrderSchema).optional(),
      description: z.lazy(() => SortOrderSchema).optional(),
      parentID: z.lazy(() => SortOrderSchema).optional(),
      imageUrl: z.lazy(() => SortOrderSchema).optional(),
      createdAt: z.lazy(() => SortOrderSchema).optional(),
      createdBy: z.lazy(() => SortOrderSchema).optional(),
      updatedAt: z.lazy(() => SortOrderSchema).optional(),
      deletedAt: z.lazy(() => SortOrderSchema).optional(),
    })
    .strict() as z.ZodType<Prisma.CategoryCountOrderByAggregateInput>;

export const CategoryMaxOrderByAggregateInputSchema: z.ZodType<Prisma.CategoryMaxOrderByAggregateInput> =
  z
    .object({
      id: z.lazy(() => SortOrderSchema).optional(),
      name: z.lazy(() => SortOrderSchema).optional(),
      slug: z.lazy(() => SortOrderSchema).optional(),
      description: z.lazy(() => SortOrderSchema).optional(),
      parentID: z.lazy(() => SortOrderSchema).optional(),
      imageUrl: z.lazy(() => SortOrderSchema).optional(),
      createdAt: z.lazy(() => SortOrderSchema).optional(),
      createdBy: z.lazy(() => SortOrderSchema).optional(),
      updatedAt: z.lazy(() => SortOrderSchema).optional(),
      deletedAt: z.lazy(() => SortOrderSchema).optional(),
    })
    .strict() as z.ZodType<Prisma.CategoryMaxOrderByAggregateInput>;

export const CategoryMinOrderByAggregateInputSchema: z.ZodType<Prisma.CategoryMinOrderByAggregateInput> =
  z
    .object({
      id: z.lazy(() => SortOrderSchema).optional(),
      name: z.lazy(() => SortOrderSchema).optional(),
      slug: z.lazy(() => SortOrderSchema).optional(),
      description: z.lazy(() => SortOrderSchema).optional(),
      parentID: z.lazy(() => SortOrderSchema).optional(),
      imageUrl: z.lazy(() => SortOrderSchema).optional(),
      createdAt: z.lazy(() => SortOrderSchema).optional(),
      createdBy: z.lazy(() => SortOrderSchema).optional(),
      updatedAt: z.lazy(() => SortOrderSchema).optional(),
      deletedAt: z.lazy(() => SortOrderSchema).optional(),
    })
    .strict() as z.ZodType<Prisma.CategoryMinOrderByAggregateInput>;

export const DecimalFilterSchema: z.ZodType<Prisma.DecimalFilter> = z
  .object({
    equals: z
      .union([
        z.number(),
        z.string(),
        z.instanceof(Decimal),
        z.instanceof(Prisma.Decimal),
        DecimalJsLikeSchema,
      ])
      .refine((v) => isValidDecimalInput(v), { message: 'Must be a Decimal' })
      .optional(),
    in: z
      .union([
        z.number().array(),
        z.string().array(),
        z.instanceof(Decimal).array(),
        z.instanceof(Prisma.Decimal).array(),
        DecimalJsLikeSchema.array(),
      ])
      .refine(
        (v) =>
          Array.isArray(v) && (v as any[]).every((v) => isValidDecimalInput(v)),
        { message: 'Must be a Decimal' },
      )
      .optional(),
    notIn: z
      .union([
        z.number().array(),
        z.string().array(),
        z.instanceof(Decimal).array(),
        z.instanceof(Prisma.Decimal).array(),
        DecimalJsLikeSchema.array(),
      ])
      .refine(
        (v) =>
          Array.isArray(v) && (v as any[]).every((v) => isValidDecimalInput(v)),
        { message: 'Must be a Decimal' },
      )
      .optional(),
    lt: z
      .union([
        z.number(),
        z.string(),
        z.instanceof(Decimal),
        z.instanceof(Prisma.Decimal),
        DecimalJsLikeSchema,
      ])
      .refine((v) => isValidDecimalInput(v), { message: 'Must be a Decimal' })
      .optional(),
    lte: z
      .union([
        z.number(),
        z.string(),
        z.instanceof(Decimal),
        z.instanceof(Prisma.Decimal),
        DecimalJsLikeSchema,
      ])
      .refine((v) => isValidDecimalInput(v), { message: 'Must be a Decimal' })
      .optional(),
    gt: z
      .union([
        z.number(),
        z.string(),
        z.instanceof(Decimal),
        z.instanceof(Prisma.Decimal),
        DecimalJsLikeSchema,
      ])
      .refine((v) => isValidDecimalInput(v), { message: 'Must be a Decimal' })
      .optional(),
    gte: z
      .union([
        z.number(),
        z.string(),
        z.instanceof(Decimal),
        z.instanceof(Prisma.Decimal),
        DecimalJsLikeSchema,
      ])
      .refine((v) => isValidDecimalInput(v), { message: 'Must be a Decimal' })
      .optional(),
    not: z
      .union([
        z
          .union([
            z.number(),
            z.string(),
            z.instanceof(Decimal),
            z.instanceof(Prisma.Decimal),
            DecimalJsLikeSchema,
          ])
          .refine((v) => isValidDecimalInput(v), {
            message: 'Must be a Decimal',
          }),
        z.lazy(() => NestedDecimalFilterSchema),
      ])
      .optional(),
  })
  .strict() as z.ZodType<Prisma.DecimalFilter>;

export const EnumProductStatusFilterSchema: z.ZodType<Prisma.EnumProductStatusFilter> =
  z
    .object({
      equals: z.lazy(() => ProductStatusSchema).optional(),
      in: z
        .lazy(() => ProductStatusSchema)
        .array()
        .optional(),
      notIn: z
        .lazy(() => ProductStatusSchema)
        .array()
        .optional(),
      not: z
        .union([
          z.lazy(() => ProductStatusSchema),
          z.lazy(() => NestedEnumProductStatusFilterSchema),
        ])
        .optional(),
    })
    .strict() as z.ZodType<Prisma.EnumProductStatusFilter>;

export const ProductImageListRelationFilterSchema: z.ZodType<Prisma.ProductImageListRelationFilter> =
  z
    .object({
      every: z.lazy(() => ProductImageWhereInputSchema).optional(),
      some: z.lazy(() => ProductImageWhereInputSchema).optional(),
      none: z.lazy(() => ProductImageWhereInputSchema).optional(),
    })
    .strict() as z.ZodType<Prisma.ProductImageListRelationFilter>;

export const ProductVariantListRelationFilterSchema: z.ZodType<Prisma.ProductVariantListRelationFilter> =
  z
    .object({
      every: z.lazy(() => ProductVariantWhereInputSchema).optional(),
      some: z.lazy(() => ProductVariantWhereInputSchema).optional(),
      none: z.lazy(() => ProductVariantWhereInputSchema).optional(),
    })
    .strict() as z.ZodType<Prisma.ProductVariantListRelationFilter>;

export const ProductImageOrderByRelationAggregateInputSchema: z.ZodType<Prisma.ProductImageOrderByRelationAggregateInput> =
  z
    .object({
      _count: z.lazy(() => SortOrderSchema).optional(),
    })
    .strict() as z.ZodType<Prisma.ProductImageOrderByRelationAggregateInput>;

export const ProductVariantOrderByRelationAggregateInputSchema: z.ZodType<Prisma.ProductVariantOrderByRelationAggregateInput> =
  z
    .object({
      _count: z.lazy(() => SortOrderSchema).optional(),
    })
    .strict() as z.ZodType<Prisma.ProductVariantOrderByRelationAggregateInput>;

export const ProductCountOrderByAggregateInputSchema: z.ZodType<Prisma.ProductCountOrderByAggregateInput> =
  z
    .object({
      id: z.lazy(() => SortOrderSchema).optional(),
      vendorID: z.lazy(() => SortOrderSchema).optional(),
      name: z.lazy(() => SortOrderSchema).optional(),
      slug: z.lazy(() => SortOrderSchema).optional(),
      description: z.lazy(() => SortOrderSchema).optional(),
      sku: z.lazy(() => SortOrderSchema).optional(),
      price: z.lazy(() => SortOrderSchema).optional(),
      stockQuantity: z.lazy(() => SortOrderSchema).optional(),
      status: z.lazy(() => SortOrderSchema).optional(),
      createdAt: z.lazy(() => SortOrderSchema).optional(),
      createdBy: z.lazy(() => SortOrderSchema).optional(),
      updatedAt: z.lazy(() => SortOrderSchema).optional(),
      deletedAt: z.lazy(() => SortOrderSchema).optional(),
    })
    .strict() as z.ZodType<Prisma.ProductCountOrderByAggregateInput>;

export const ProductAvgOrderByAggregateInputSchema: z.ZodType<Prisma.ProductAvgOrderByAggregateInput> =
  z
    .object({
      price: z.lazy(() => SortOrderSchema).optional(),
      stockQuantity: z.lazy(() => SortOrderSchema).optional(),
    })
    .strict() as z.ZodType<Prisma.ProductAvgOrderByAggregateInput>;

export const ProductMaxOrderByAggregateInputSchema: z.ZodType<Prisma.ProductMaxOrderByAggregateInput> =
  z
    .object({
      id: z.lazy(() => SortOrderSchema).optional(),
      vendorID: z.lazy(() => SortOrderSchema).optional(),
      name: z.lazy(() => SortOrderSchema).optional(),
      slug: z.lazy(() => SortOrderSchema).optional(),
      description: z.lazy(() => SortOrderSchema).optional(),
      sku: z.lazy(() => SortOrderSchema).optional(),
      price: z.lazy(() => SortOrderSchema).optional(),
      stockQuantity: z.lazy(() => SortOrderSchema).optional(),
      status: z.lazy(() => SortOrderSchema).optional(),
      createdAt: z.lazy(() => SortOrderSchema).optional(),
      createdBy: z.lazy(() => SortOrderSchema).optional(),
      updatedAt: z.lazy(() => SortOrderSchema).optional(),
      deletedAt: z.lazy(() => SortOrderSchema).optional(),
    })
    .strict() as z.ZodType<Prisma.ProductMaxOrderByAggregateInput>;

export const ProductMinOrderByAggregateInputSchema: z.ZodType<Prisma.ProductMinOrderByAggregateInput> =
  z
    .object({
      id: z.lazy(() => SortOrderSchema).optional(),
      vendorID: z.lazy(() => SortOrderSchema).optional(),
      name: z.lazy(() => SortOrderSchema).optional(),
      slug: z.lazy(() => SortOrderSchema).optional(),
      description: z.lazy(() => SortOrderSchema).optional(),
      sku: z.lazy(() => SortOrderSchema).optional(),
      price: z.lazy(() => SortOrderSchema).optional(),
      stockQuantity: z.lazy(() => SortOrderSchema).optional(),
      status: z.lazy(() => SortOrderSchema).optional(),
      createdAt: z.lazy(() => SortOrderSchema).optional(),
      createdBy: z.lazy(() => SortOrderSchema).optional(),
      updatedAt: z.lazy(() => SortOrderSchema).optional(),
      deletedAt: z.lazy(() => SortOrderSchema).optional(),
    })
    .strict() as z.ZodType<Prisma.ProductMinOrderByAggregateInput>;

export const ProductSumOrderByAggregateInputSchema: z.ZodType<Prisma.ProductSumOrderByAggregateInput> =
  z
    .object({
      price: z.lazy(() => SortOrderSchema).optional(),
      stockQuantity: z.lazy(() => SortOrderSchema).optional(),
    })
    .strict() as z.ZodType<Prisma.ProductSumOrderByAggregateInput>;

export const DecimalWithAggregatesFilterSchema: z.ZodType<Prisma.DecimalWithAggregatesFilter> =
  z
    .object({
      equals: z
        .union([
          z.number(),
          z.string(),
          z.instanceof(Decimal),
          z.instanceof(Prisma.Decimal),
          DecimalJsLikeSchema,
        ])
        .refine((v) => isValidDecimalInput(v), { message: 'Must be a Decimal' })
        .optional(),
      in: z
        .union([
          z.number().array(),
          z.string().array(),
          z.instanceof(Decimal).array(),
          z.instanceof(Prisma.Decimal).array(),
          DecimalJsLikeSchema.array(),
        ])
        .refine(
          (v) =>
            Array.isArray(v) &&
            (v as any[]).every((v) => isValidDecimalInput(v)),
          { message: 'Must be a Decimal' },
        )
        .optional(),
      notIn: z
        .union([
          z.number().array(),
          z.string().array(),
          z.instanceof(Decimal).array(),
          z.instanceof(Prisma.Decimal).array(),
          DecimalJsLikeSchema.array(),
        ])
        .refine(
          (v) =>
            Array.isArray(v) &&
            (v as any[]).every((v) => isValidDecimalInput(v)),
          { message: 'Must be a Decimal' },
        )
        .optional(),
      lt: z
        .union([
          z.number(),
          z.string(),
          z.instanceof(Decimal),
          z.instanceof(Prisma.Decimal),
          DecimalJsLikeSchema,
        ])
        .refine((v) => isValidDecimalInput(v), { message: 'Must be a Decimal' })
        .optional(),
      lte: z
        .union([
          z.number(),
          z.string(),
          z.instanceof(Decimal),
          z.instanceof(Prisma.Decimal),
          DecimalJsLikeSchema,
        ])
        .refine((v) => isValidDecimalInput(v), { message: 'Must be a Decimal' })
        .optional(),
      gt: z
        .union([
          z.number(),
          z.string(),
          z.instanceof(Decimal),
          z.instanceof(Prisma.Decimal),
          DecimalJsLikeSchema,
        ])
        .refine((v) => isValidDecimalInput(v), { message: 'Must be a Decimal' })
        .optional(),
      gte: z
        .union([
          z.number(),
          z.string(),
          z.instanceof(Decimal),
          z.instanceof(Prisma.Decimal),
          DecimalJsLikeSchema,
        ])
        .refine((v) => isValidDecimalInput(v), { message: 'Must be a Decimal' })
        .optional(),
      not: z
        .union([
          z
            .union([
              z.number(),
              z.string(),
              z.instanceof(Decimal),
              z.instanceof(Prisma.Decimal),
              DecimalJsLikeSchema,
            ])
            .refine((v) => isValidDecimalInput(v), {
              message: 'Must be a Decimal',
            }),
          z.lazy(() => NestedDecimalWithAggregatesFilterSchema),
        ])
        .optional(),
      _count: z.lazy(() => NestedIntFilterSchema).optional(),
      _avg: z.lazy(() => NestedDecimalFilterSchema).optional(),
      _sum: z.lazy(() => NestedDecimalFilterSchema).optional(),
      _min: z.lazy(() => NestedDecimalFilterSchema).optional(),
      _max: z.lazy(() => NestedDecimalFilterSchema).optional(),
    })
    .strict() as z.ZodType<Prisma.DecimalWithAggregatesFilter>;

export const EnumProductStatusWithAggregatesFilterSchema: z.ZodType<Prisma.EnumProductStatusWithAggregatesFilter> =
  z
    .object({
      equals: z.lazy(() => ProductStatusSchema).optional(),
      in: z
        .lazy(() => ProductStatusSchema)
        .array()
        .optional(),
      notIn: z
        .lazy(() => ProductStatusSchema)
        .array()
        .optional(),
      not: z
        .union([
          z.lazy(() => ProductStatusSchema),
          z.lazy(() => NestedEnumProductStatusWithAggregatesFilterSchema),
        ])
        .optional(),
      _count: z.lazy(() => NestedIntFilterSchema).optional(),
      _min: z.lazy(() => NestedEnumProductStatusFilterSchema).optional(),
      _max: z.lazy(() => NestedEnumProductStatusFilterSchema).optional(),
    })
    .strict() as z.ZodType<Prisma.EnumProductStatusWithAggregatesFilter>;

export const JsonNullableFilterSchema: z.ZodType<Prisma.JsonNullableFilter> = z
  .object({
    equals: InputJsonValueSchema.optional(),
    path: z.string().array().optional(),
    mode: z.lazy(() => QueryModeSchema).optional(),
    string_contains: z.string().optional(),
    string_starts_with: z.string().optional(),
    string_ends_with: z.string().optional(),
    array_starts_with: InputJsonValueSchema.optional().nullable(),
    array_ends_with: InputJsonValueSchema.optional().nullable(),
    array_contains: InputJsonValueSchema.optional().nullable(),
    lt: InputJsonValueSchema.optional(),
    lte: InputJsonValueSchema.optional(),
    gt: InputJsonValueSchema.optional(),
    gte: InputJsonValueSchema.optional(),
    not: InputJsonValueSchema.optional(),
  })
  .strict() as z.ZodType<Prisma.JsonNullableFilter>;

export const ProductScalarRelationFilterSchema: z.ZodType<Prisma.ProductScalarRelationFilter> =
  z
    .object({
      is: z.lazy(() => ProductWhereInputSchema).optional(),
      isNot: z.lazy(() => ProductWhereInputSchema).optional(),
    })
    .strict() as z.ZodType<Prisma.ProductScalarRelationFilter>;

export const OrderItemListRelationFilterSchema: z.ZodType<Prisma.OrderItemListRelationFilter> =
  z
    .object({
      every: z.lazy(() => OrderItemWhereInputSchema).optional(),
      some: z.lazy(() => OrderItemWhereInputSchema).optional(),
      none: z.lazy(() => OrderItemWhereInputSchema).optional(),
    })
    .strict() as z.ZodType<Prisma.OrderItemListRelationFilter>;

export const CartItemListRelationFilterSchema: z.ZodType<Prisma.CartItemListRelationFilter> =
  z
    .object({
      every: z.lazy(() => CartItemWhereInputSchema).optional(),
      some: z.lazy(() => CartItemWhereInputSchema).optional(),
      none: z.lazy(() => CartItemWhereInputSchema).optional(),
    })
    .strict() as z.ZodType<Prisma.CartItemListRelationFilter>;

export const OrderItemOrderByRelationAggregateInputSchema: z.ZodType<Prisma.OrderItemOrderByRelationAggregateInput> =
  z
    .object({
      _count: z.lazy(() => SortOrderSchema).optional(),
    })
    .strict() as z.ZodType<Prisma.OrderItemOrderByRelationAggregateInput>;

export const CartItemOrderByRelationAggregateInputSchema: z.ZodType<Prisma.CartItemOrderByRelationAggregateInput> =
  z
    .object({
      _count: z.lazy(() => SortOrderSchema).optional(),
    })
    .strict() as z.ZodType<Prisma.CartItemOrderByRelationAggregateInput>;

export const ProductVariantCountOrderByAggregateInputSchema: z.ZodType<Prisma.ProductVariantCountOrderByAggregateInput> =
  z
    .object({
      id: z.lazy(() => SortOrderSchema).optional(),
      productID: z.lazy(() => SortOrderSchema).optional(),
      name: z.lazy(() => SortOrderSchema).optional(),
      sku: z.lazy(() => SortOrderSchema).optional(),
      price: z.lazy(() => SortOrderSchema).optional(),
      stockQuantity: z.lazy(() => SortOrderSchema).optional(),
      attributes: z.lazy(() => SortOrderSchema).optional(),
      createdAt: z.lazy(() => SortOrderSchema).optional(),
      createdBy: z.lazy(() => SortOrderSchema).optional(),
      updatedAt: z.lazy(() => SortOrderSchema).optional(),
      deletedAt: z.lazy(() => SortOrderSchema).optional(),
    })
    .strict() as z.ZodType<Prisma.ProductVariantCountOrderByAggregateInput>;

export const ProductVariantAvgOrderByAggregateInputSchema: z.ZodType<Prisma.ProductVariantAvgOrderByAggregateInput> =
  z
    .object({
      price: z.lazy(() => SortOrderSchema).optional(),
      stockQuantity: z.lazy(() => SortOrderSchema).optional(),
    })
    .strict() as z.ZodType<Prisma.ProductVariantAvgOrderByAggregateInput>;

export const ProductVariantMaxOrderByAggregateInputSchema: z.ZodType<Prisma.ProductVariantMaxOrderByAggregateInput> =
  z
    .object({
      id: z.lazy(() => SortOrderSchema).optional(),
      productID: z.lazy(() => SortOrderSchema).optional(),
      name: z.lazy(() => SortOrderSchema).optional(),
      sku: z.lazy(() => SortOrderSchema).optional(),
      price: z.lazy(() => SortOrderSchema).optional(),
      stockQuantity: z.lazy(() => SortOrderSchema).optional(),
      createdAt: z.lazy(() => SortOrderSchema).optional(),
      createdBy: z.lazy(() => SortOrderSchema).optional(),
      updatedAt: z.lazy(() => SortOrderSchema).optional(),
      deletedAt: z.lazy(() => SortOrderSchema).optional(),
    })
    .strict() as z.ZodType<Prisma.ProductVariantMaxOrderByAggregateInput>;

export const ProductVariantMinOrderByAggregateInputSchema: z.ZodType<Prisma.ProductVariantMinOrderByAggregateInput> =
  z
    .object({
      id: z.lazy(() => SortOrderSchema).optional(),
      productID: z.lazy(() => SortOrderSchema).optional(),
      name: z.lazy(() => SortOrderSchema).optional(),
      sku: z.lazy(() => SortOrderSchema).optional(),
      price: z.lazy(() => SortOrderSchema).optional(),
      stockQuantity: z.lazy(() => SortOrderSchema).optional(),
      createdAt: z.lazy(() => SortOrderSchema).optional(),
      createdBy: z.lazy(() => SortOrderSchema).optional(),
      updatedAt: z.lazy(() => SortOrderSchema).optional(),
      deletedAt: z.lazy(() => SortOrderSchema).optional(),
    })
    .strict() as z.ZodType<Prisma.ProductVariantMinOrderByAggregateInput>;

export const ProductVariantSumOrderByAggregateInputSchema: z.ZodType<Prisma.ProductVariantSumOrderByAggregateInput> =
  z
    .object({
      price: z.lazy(() => SortOrderSchema).optional(),
      stockQuantity: z.lazy(() => SortOrderSchema).optional(),
    })
    .strict() as z.ZodType<Prisma.ProductVariantSumOrderByAggregateInput>;

export const JsonNullableWithAggregatesFilterSchema: z.ZodType<Prisma.JsonNullableWithAggregatesFilter> =
  z
    .object({
      equals: InputJsonValueSchema.optional(),
      path: z.string().array().optional(),
      mode: z.lazy(() => QueryModeSchema).optional(),
      string_contains: z.string().optional(),
      string_starts_with: z.string().optional(),
      string_ends_with: z.string().optional(),
      array_starts_with: InputJsonValueSchema.optional().nullable(),
      array_ends_with: InputJsonValueSchema.optional().nullable(),
      array_contains: InputJsonValueSchema.optional().nullable(),
      lt: InputJsonValueSchema.optional(),
      lte: InputJsonValueSchema.optional(),
      gt: InputJsonValueSchema.optional(),
      gte: InputJsonValueSchema.optional(),
      not: InputJsonValueSchema.optional(),
      _count: z.lazy(() => NestedIntNullableFilterSchema).optional(),
      _min: z.lazy(() => NestedJsonNullableFilterSchema).optional(),
      _max: z.lazy(() => NestedJsonNullableFilterSchema).optional(),
    })
    .strict() as z.ZodType<Prisma.JsonNullableWithAggregatesFilter>;

export const CategoryScalarRelationFilterSchema: z.ZodType<Prisma.CategoryScalarRelationFilter> =
  z
    .object({
      is: z.lazy(() => CategoryWhereInputSchema).optional(),
      isNot: z.lazy(() => CategoryWhereInputSchema).optional(),
    })
    .strict() as z.ZodType<Prisma.CategoryScalarRelationFilter>;

export const ProductCategoryProductIDCategoryIDCompoundUniqueInputSchema: z.ZodType<Prisma.ProductCategoryProductIDCategoryIDCompoundUniqueInput> =
  z
    .object({
      productID: z.string(),
      categoryID: z.string(),
    })
    .strict() as z.ZodType<Prisma.ProductCategoryProductIDCategoryIDCompoundUniqueInput>;

export const ProductCategoryCountOrderByAggregateInputSchema: z.ZodType<Prisma.ProductCategoryCountOrderByAggregateInput> =
  z
    .object({
      productID: z.lazy(() => SortOrderSchema).optional(),
      categoryID: z.lazy(() => SortOrderSchema).optional(),
    })
    .strict() as z.ZodType<Prisma.ProductCategoryCountOrderByAggregateInput>;

export const ProductCategoryMaxOrderByAggregateInputSchema: z.ZodType<Prisma.ProductCategoryMaxOrderByAggregateInput> =
  z
    .object({
      productID: z.lazy(() => SortOrderSchema).optional(),
      categoryID: z.lazy(() => SortOrderSchema).optional(),
    })
    .strict() as z.ZodType<Prisma.ProductCategoryMaxOrderByAggregateInput>;

export const ProductCategoryMinOrderByAggregateInputSchema: z.ZodType<Prisma.ProductCategoryMinOrderByAggregateInput> =
  z
    .object({
      productID: z.lazy(() => SortOrderSchema).optional(),
      categoryID: z.lazy(() => SortOrderSchema).optional(),
    })
    .strict() as z.ZodType<Prisma.ProductCategoryMinOrderByAggregateInput>;

export const ProductNullableScalarRelationFilterSchema: z.ZodType<Prisma.ProductNullableScalarRelationFilter> =
  z
    .object({
      is: z
        .lazy(() => ProductWhereInputSchema)
        .optional()
        .nullable(),
      isNot: z
        .lazy(() => ProductWhereInputSchema)
        .optional()
        .nullable(),
    })
    .strict() as z.ZodType<Prisma.ProductNullableScalarRelationFilter>;

export const ProductVariantNullableScalarRelationFilterSchema: z.ZodType<Prisma.ProductVariantNullableScalarRelationFilter> =
  z
    .object({
      is: z
        .lazy(() => ProductVariantWhereInputSchema)
        .optional()
        .nullable(),
      isNot: z
        .lazy(() => ProductVariantWhereInputSchema)
        .optional()
        .nullable(),
    })
    .strict() as z.ZodType<Prisma.ProductVariantNullableScalarRelationFilter>;

export const ProductImageCountOrderByAggregateInputSchema: z.ZodType<Prisma.ProductImageCountOrderByAggregateInput> =
  z
    .object({
      id: z.lazy(() => SortOrderSchema).optional(),
      name: z.lazy(() => SortOrderSchema).optional(),
      description: z.lazy(() => SortOrderSchema).optional(),
      productID: z.lazy(() => SortOrderSchema).optional(),
      productVariantID: z.lazy(() => SortOrderSchema).optional(),
      imageUrl: z.lazy(() => SortOrderSchema).optional(),
      sortOrder: z.lazy(() => SortOrderSchema).optional(),
      createdAt: z.lazy(() => SortOrderSchema).optional(),
      createdBy: z.lazy(() => SortOrderSchema).optional(),
      updatedAt: z.lazy(() => SortOrderSchema).optional(),
      deletedAt: z.lazy(() => SortOrderSchema).optional(),
    })
    .strict() as z.ZodType<Prisma.ProductImageCountOrderByAggregateInput>;

export const ProductImageAvgOrderByAggregateInputSchema: z.ZodType<Prisma.ProductImageAvgOrderByAggregateInput> =
  z
    .object({
      sortOrder: z.lazy(() => SortOrderSchema).optional(),
    })
    .strict() as z.ZodType<Prisma.ProductImageAvgOrderByAggregateInput>;

export const ProductImageMaxOrderByAggregateInputSchema: z.ZodType<Prisma.ProductImageMaxOrderByAggregateInput> =
  z
    .object({
      id: z.lazy(() => SortOrderSchema).optional(),
      name: z.lazy(() => SortOrderSchema).optional(),
      description: z.lazy(() => SortOrderSchema).optional(),
      productID: z.lazy(() => SortOrderSchema).optional(),
      productVariantID: z.lazy(() => SortOrderSchema).optional(),
      imageUrl: z.lazy(() => SortOrderSchema).optional(),
      sortOrder: z.lazy(() => SortOrderSchema).optional(),
      createdAt: z.lazy(() => SortOrderSchema).optional(),
      createdBy: z.lazy(() => SortOrderSchema).optional(),
      updatedAt: z.lazy(() => SortOrderSchema).optional(),
      deletedAt: z.lazy(() => SortOrderSchema).optional(),
    })
    .strict() as z.ZodType<Prisma.ProductImageMaxOrderByAggregateInput>;

export const ProductImageMinOrderByAggregateInputSchema: z.ZodType<Prisma.ProductImageMinOrderByAggregateInput> =
  z
    .object({
      id: z.lazy(() => SortOrderSchema).optional(),
      name: z.lazy(() => SortOrderSchema).optional(),
      description: z.lazy(() => SortOrderSchema).optional(),
      productID: z.lazy(() => SortOrderSchema).optional(),
      productVariantID: z.lazy(() => SortOrderSchema).optional(),
      imageUrl: z.lazy(() => SortOrderSchema).optional(),
      sortOrder: z.lazy(() => SortOrderSchema).optional(),
      createdAt: z.lazy(() => SortOrderSchema).optional(),
      createdBy: z.lazy(() => SortOrderSchema).optional(),
      updatedAt: z.lazy(() => SortOrderSchema).optional(),
      deletedAt: z.lazy(() => SortOrderSchema).optional(),
    })
    .strict() as z.ZodType<Prisma.ProductImageMinOrderByAggregateInput>;

export const ProductImageSumOrderByAggregateInputSchema: z.ZodType<Prisma.ProductImageSumOrderByAggregateInput> =
  z
    .object({
      sortOrder: z.lazy(() => SortOrderSchema).optional(),
    })
    .strict() as z.ZodType<Prisma.ProductImageSumOrderByAggregateInput>;

export const EnumOrderStatusFilterSchema: z.ZodType<Prisma.EnumOrderStatusFilter> =
  z
    .object({
      equals: z.lazy(() => OrderStatusSchema).optional(),
      in: z
        .lazy(() => OrderStatusSchema)
        .array()
        .optional(),
      notIn: z
        .lazy(() => OrderStatusSchema)
        .array()
        .optional(),
      not: z
        .union([
          z.lazy(() => OrderStatusSchema),
          z.lazy(() => NestedEnumOrderStatusFilterSchema),
        ])
        .optional(),
    })
    .strict() as z.ZodType<Prisma.EnumOrderStatusFilter>;

export const OrderAddressListRelationFilterSchema: z.ZodType<Prisma.OrderAddressListRelationFilter> =
  z
    .object({
      every: z.lazy(() => OrderAddressWhereInputSchema).optional(),
      some: z.lazy(() => OrderAddressWhereInputSchema).optional(),
      none: z.lazy(() => OrderAddressWhereInputSchema).optional(),
    })
    .strict() as z.ZodType<Prisma.OrderAddressListRelationFilter>;

export const OrderPromotionListRelationFilterSchema: z.ZodType<Prisma.OrderPromotionListRelationFilter> =
  z
    .object({
      every: z.lazy(() => OrderPromotionWhereInputSchema).optional(),
      some: z.lazy(() => OrderPromotionWhereInputSchema).optional(),
      none: z.lazy(() => OrderPromotionWhereInputSchema).optional(),
    })
    .strict() as z.ZodType<Prisma.OrderPromotionListRelationFilter>;

export const PaymentListRelationFilterSchema: z.ZodType<Prisma.PaymentListRelationFilter> =
  z
    .object({
      every: z.lazy(() => PaymentWhereInputSchema).optional(),
      some: z.lazy(() => PaymentWhereInputSchema).optional(),
      none: z.lazy(() => PaymentWhereInputSchema).optional(),
    })
    .strict() as z.ZodType<Prisma.PaymentListRelationFilter>;

export const OrderAddressOrderByRelationAggregateInputSchema: z.ZodType<Prisma.OrderAddressOrderByRelationAggregateInput> =
  z
    .object({
      _count: z.lazy(() => SortOrderSchema).optional(),
    })
    .strict() as z.ZodType<Prisma.OrderAddressOrderByRelationAggregateInput>;

export const OrderPromotionOrderByRelationAggregateInputSchema: z.ZodType<Prisma.OrderPromotionOrderByRelationAggregateInput> =
  z
    .object({
      _count: z.lazy(() => SortOrderSchema).optional(),
    })
    .strict() as z.ZodType<Prisma.OrderPromotionOrderByRelationAggregateInput>;

export const PaymentOrderByRelationAggregateInputSchema: z.ZodType<Prisma.PaymentOrderByRelationAggregateInput> =
  z
    .object({
      _count: z.lazy(() => SortOrderSchema).optional(),
    })
    .strict() as z.ZodType<Prisma.PaymentOrderByRelationAggregateInput>;

export const OrderCountOrderByAggregateInputSchema: z.ZodType<Prisma.OrderCountOrderByAggregateInput> =
  z
    .object({
      id: z.lazy(() => SortOrderSchema).optional(),
      orderNumber: z.lazy(() => SortOrderSchema).optional(),
      userID: z.lazy(() => SortOrderSchema).optional(),
      status: z.lazy(() => SortOrderSchema).optional(),
      subtotal: z.lazy(() => SortOrderSchema).optional(),
      taxAmount: z.lazy(() => SortOrderSchema).optional(),
      shippingAmount: z.lazy(() => SortOrderSchema).optional(),
      discountAmount: z.lazy(() => SortOrderSchema).optional(),
      totalAmount: z.lazy(() => SortOrderSchema).optional(),
      currency: z.lazy(() => SortOrderSchema).optional(),
      notes: z.lazy(() => SortOrderSchema).optional(),
      shippedAt: z.lazy(() => SortOrderSchema).optional(),
      deliveredAt: z.lazy(() => SortOrderSchema).optional(),
      createdAt: z.lazy(() => SortOrderSchema).optional(),
      createdBy: z.lazy(() => SortOrderSchema).optional(),
      updatedAt: z.lazy(() => SortOrderSchema).optional(),
      deletedAt: z.lazy(() => SortOrderSchema).optional(),
    })
    .strict() as z.ZodType<Prisma.OrderCountOrderByAggregateInput>;

export const OrderAvgOrderByAggregateInputSchema: z.ZodType<Prisma.OrderAvgOrderByAggregateInput> =
  z
    .object({
      subtotal: z.lazy(() => SortOrderSchema).optional(),
      taxAmount: z.lazy(() => SortOrderSchema).optional(),
      shippingAmount: z.lazy(() => SortOrderSchema).optional(),
      discountAmount: z.lazy(() => SortOrderSchema).optional(),
      totalAmount: z.lazy(() => SortOrderSchema).optional(),
    })
    .strict() as z.ZodType<Prisma.OrderAvgOrderByAggregateInput>;

export const OrderMaxOrderByAggregateInputSchema: z.ZodType<Prisma.OrderMaxOrderByAggregateInput> =
  z
    .object({
      id: z.lazy(() => SortOrderSchema).optional(),
      orderNumber: z.lazy(() => SortOrderSchema).optional(),
      userID: z.lazy(() => SortOrderSchema).optional(),
      status: z.lazy(() => SortOrderSchema).optional(),
      subtotal: z.lazy(() => SortOrderSchema).optional(),
      taxAmount: z.lazy(() => SortOrderSchema).optional(),
      shippingAmount: z.lazy(() => SortOrderSchema).optional(),
      discountAmount: z.lazy(() => SortOrderSchema).optional(),
      totalAmount: z.lazy(() => SortOrderSchema).optional(),
      currency: z.lazy(() => SortOrderSchema).optional(),
      notes: z.lazy(() => SortOrderSchema).optional(),
      shippedAt: z.lazy(() => SortOrderSchema).optional(),
      deliveredAt: z.lazy(() => SortOrderSchema).optional(),
      createdAt: z.lazy(() => SortOrderSchema).optional(),
      createdBy: z.lazy(() => SortOrderSchema).optional(),
      updatedAt: z.lazy(() => SortOrderSchema).optional(),
      deletedAt: z.lazy(() => SortOrderSchema).optional(),
    })
    .strict() as z.ZodType<Prisma.OrderMaxOrderByAggregateInput>;

export const OrderMinOrderByAggregateInputSchema: z.ZodType<Prisma.OrderMinOrderByAggregateInput> =
  z
    .object({
      id: z.lazy(() => SortOrderSchema).optional(),
      orderNumber: z.lazy(() => SortOrderSchema).optional(),
      userID: z.lazy(() => SortOrderSchema).optional(),
      status: z.lazy(() => SortOrderSchema).optional(),
      subtotal: z.lazy(() => SortOrderSchema).optional(),
      taxAmount: z.lazy(() => SortOrderSchema).optional(),
      shippingAmount: z.lazy(() => SortOrderSchema).optional(),
      discountAmount: z.lazy(() => SortOrderSchema).optional(),
      totalAmount: z.lazy(() => SortOrderSchema).optional(),
      currency: z.lazy(() => SortOrderSchema).optional(),
      notes: z.lazy(() => SortOrderSchema).optional(),
      shippedAt: z.lazy(() => SortOrderSchema).optional(),
      deliveredAt: z.lazy(() => SortOrderSchema).optional(),
      createdAt: z.lazy(() => SortOrderSchema).optional(),
      createdBy: z.lazy(() => SortOrderSchema).optional(),
      updatedAt: z.lazy(() => SortOrderSchema).optional(),
      deletedAt: z.lazy(() => SortOrderSchema).optional(),
    })
    .strict() as z.ZodType<Prisma.OrderMinOrderByAggregateInput>;

export const OrderSumOrderByAggregateInputSchema: z.ZodType<Prisma.OrderSumOrderByAggregateInput> =
  z
    .object({
      subtotal: z.lazy(() => SortOrderSchema).optional(),
      taxAmount: z.lazy(() => SortOrderSchema).optional(),
      shippingAmount: z.lazy(() => SortOrderSchema).optional(),
      discountAmount: z.lazy(() => SortOrderSchema).optional(),
      totalAmount: z.lazy(() => SortOrderSchema).optional(),
    })
    .strict() as z.ZodType<Prisma.OrderSumOrderByAggregateInput>;

export const EnumOrderStatusWithAggregatesFilterSchema: z.ZodType<Prisma.EnumOrderStatusWithAggregatesFilter> =
  z
    .object({
      equals: z.lazy(() => OrderStatusSchema).optional(),
      in: z
        .lazy(() => OrderStatusSchema)
        .array()
        .optional(),
      notIn: z
        .lazy(() => OrderStatusSchema)
        .array()
        .optional(),
      not: z
        .union([
          z.lazy(() => OrderStatusSchema),
          z.lazy(() => NestedEnumOrderStatusWithAggregatesFilterSchema),
        ])
        .optional(),
      _count: z.lazy(() => NestedIntFilterSchema).optional(),
      _min: z.lazy(() => NestedEnumOrderStatusFilterSchema).optional(),
      _max: z.lazy(() => NestedEnumOrderStatusFilterSchema).optional(),
    })
    .strict() as z.ZodType<Prisma.EnumOrderStatusWithAggregatesFilter>;

export const ProductVariantScalarRelationFilterSchema: z.ZodType<Prisma.ProductVariantScalarRelationFilter> =
  z
    .object({
      is: z.lazy(() => ProductVariantWhereInputSchema).optional(),
      isNot: z.lazy(() => ProductVariantWhereInputSchema).optional(),
    })
    .strict() as z.ZodType<Prisma.ProductVariantScalarRelationFilter>;

export const OrderScalarRelationFilterSchema: z.ZodType<Prisma.OrderScalarRelationFilter> =
  z
    .object({
      is: z.lazy(() => OrderWhereInputSchema).optional(),
      isNot: z.lazy(() => OrderWhereInputSchema).optional(),
    })
    .strict() as z.ZodType<Prisma.OrderScalarRelationFilter>;

export const OrderItemCountOrderByAggregateInputSchema: z.ZodType<Prisma.OrderItemCountOrderByAggregateInput> =
  z
    .object({
      id: z.lazy(() => SortOrderSchema).optional(),
      orderID: z.lazy(() => SortOrderSchema).optional(),
      productVariantID: z.lazy(() => SortOrderSchema).optional(),
      quantity: z.lazy(() => SortOrderSchema).optional(),
      unitPrice: z.lazy(() => SortOrderSchema).optional(),
      totalPrice: z.lazy(() => SortOrderSchema).optional(),
      productVariantSnapshot: z.lazy(() => SortOrderSchema).optional(),
    })
    .strict() as z.ZodType<Prisma.OrderItemCountOrderByAggregateInput>;

export const OrderItemAvgOrderByAggregateInputSchema: z.ZodType<Prisma.OrderItemAvgOrderByAggregateInput> =
  z
    .object({
      quantity: z.lazy(() => SortOrderSchema).optional(),
      unitPrice: z.lazy(() => SortOrderSchema).optional(),
      totalPrice: z.lazy(() => SortOrderSchema).optional(),
    })
    .strict() as z.ZodType<Prisma.OrderItemAvgOrderByAggregateInput>;

export const OrderItemMaxOrderByAggregateInputSchema: z.ZodType<Prisma.OrderItemMaxOrderByAggregateInput> =
  z
    .object({
      id: z.lazy(() => SortOrderSchema).optional(),
      orderID: z.lazy(() => SortOrderSchema).optional(),
      productVariantID: z.lazy(() => SortOrderSchema).optional(),
      quantity: z.lazy(() => SortOrderSchema).optional(),
      unitPrice: z.lazy(() => SortOrderSchema).optional(),
      totalPrice: z.lazy(() => SortOrderSchema).optional(),
    })
    .strict() as z.ZodType<Prisma.OrderItemMaxOrderByAggregateInput>;

export const OrderItemMinOrderByAggregateInputSchema: z.ZodType<Prisma.OrderItemMinOrderByAggregateInput> =
  z
    .object({
      id: z.lazy(() => SortOrderSchema).optional(),
      orderID: z.lazy(() => SortOrderSchema).optional(),
      productVariantID: z.lazy(() => SortOrderSchema).optional(),
      quantity: z.lazy(() => SortOrderSchema).optional(),
      unitPrice: z.lazy(() => SortOrderSchema).optional(),
      totalPrice: z.lazy(() => SortOrderSchema).optional(),
    })
    .strict() as z.ZodType<Prisma.OrderItemMinOrderByAggregateInput>;

export const OrderItemSumOrderByAggregateInputSchema: z.ZodType<Prisma.OrderItemSumOrderByAggregateInput> =
  z
    .object({
      quantity: z.lazy(() => SortOrderSchema).optional(),
      unitPrice: z.lazy(() => SortOrderSchema).optional(),
      totalPrice: z.lazy(() => SortOrderSchema).optional(),
    })
    .strict() as z.ZodType<Prisma.OrderItemSumOrderByAggregateInput>;

export const EnumAddressTypeFilterSchema: z.ZodType<Prisma.EnumAddressTypeFilter> =
  z
    .object({
      equals: z.lazy(() => AddressTypeSchema).optional(),
      in: z
        .lazy(() => AddressTypeSchema)
        .array()
        .optional(),
      notIn: z
        .lazy(() => AddressTypeSchema)
        .array()
        .optional(),
      not: z
        .union([
          z.lazy(() => AddressTypeSchema),
          z.lazy(() => NestedEnumAddressTypeFilterSchema),
        ])
        .optional(),
    })
    .strict() as z.ZodType<Prisma.EnumAddressTypeFilter>;

export const OrderAddressCountOrderByAggregateInputSchema: z.ZodType<Prisma.OrderAddressCountOrderByAggregateInput> =
  z
    .object({
      id: z.lazy(() => SortOrderSchema).optional(),
      orderID: z.lazy(() => SortOrderSchema).optional(),
      type: z.lazy(() => SortOrderSchema).optional(),
      firstName: z.lazy(() => SortOrderSchema).optional(),
      lastName: z.lazy(() => SortOrderSchema).optional(),
      company: z.lazy(() => SortOrderSchema).optional(),
      fullAddress: z.lazy(() => SortOrderSchema).optional(),
      city: z.lazy(() => SortOrderSchema).optional(),
      province: z.lazy(() => SortOrderSchema).optional(),
      country: z.lazy(() => SortOrderSchema).optional(),
      phone: z.lazy(() => SortOrderSchema).optional(),
    })
    .strict() as z.ZodType<Prisma.OrderAddressCountOrderByAggregateInput>;

export const OrderAddressMaxOrderByAggregateInputSchema: z.ZodType<Prisma.OrderAddressMaxOrderByAggregateInput> =
  z
    .object({
      id: z.lazy(() => SortOrderSchema).optional(),
      orderID: z.lazy(() => SortOrderSchema).optional(),
      type: z.lazy(() => SortOrderSchema).optional(),
      firstName: z.lazy(() => SortOrderSchema).optional(),
      lastName: z.lazy(() => SortOrderSchema).optional(),
      company: z.lazy(() => SortOrderSchema).optional(),
      fullAddress: z.lazy(() => SortOrderSchema).optional(),
      city: z.lazy(() => SortOrderSchema).optional(),
      province: z.lazy(() => SortOrderSchema).optional(),
      country: z.lazy(() => SortOrderSchema).optional(),
      phone: z.lazy(() => SortOrderSchema).optional(),
    })
    .strict() as z.ZodType<Prisma.OrderAddressMaxOrderByAggregateInput>;

export const OrderAddressMinOrderByAggregateInputSchema: z.ZodType<Prisma.OrderAddressMinOrderByAggregateInput> =
  z
    .object({
      id: z.lazy(() => SortOrderSchema).optional(),
      orderID: z.lazy(() => SortOrderSchema).optional(),
      type: z.lazy(() => SortOrderSchema).optional(),
      firstName: z.lazy(() => SortOrderSchema).optional(),
      lastName: z.lazy(() => SortOrderSchema).optional(),
      company: z.lazy(() => SortOrderSchema).optional(),
      fullAddress: z.lazy(() => SortOrderSchema).optional(),
      city: z.lazy(() => SortOrderSchema).optional(),
      province: z.lazy(() => SortOrderSchema).optional(),
      country: z.lazy(() => SortOrderSchema).optional(),
      phone: z.lazy(() => SortOrderSchema).optional(),
    })
    .strict() as z.ZodType<Prisma.OrderAddressMinOrderByAggregateInput>;

export const EnumAddressTypeWithAggregatesFilterSchema: z.ZodType<Prisma.EnumAddressTypeWithAggregatesFilter> =
  z
    .object({
      equals: z.lazy(() => AddressTypeSchema).optional(),
      in: z
        .lazy(() => AddressTypeSchema)
        .array()
        .optional(),
      notIn: z
        .lazy(() => AddressTypeSchema)
        .array()
        .optional(),
      not: z
        .union([
          z.lazy(() => AddressTypeSchema),
          z.lazy(() => NestedEnumAddressTypeWithAggregatesFilterSchema),
        ])
        .optional(),
      _count: z.lazy(() => NestedIntFilterSchema).optional(),
      _min: z.lazy(() => NestedEnumAddressTypeFilterSchema).optional(),
      _max: z.lazy(() => NestedEnumAddressTypeFilterSchema).optional(),
    })
    .strict() as z.ZodType<Prisma.EnumAddressTypeWithAggregatesFilter>;

export const EnumPromotionTypeFilterSchema: z.ZodType<Prisma.EnumPromotionTypeFilter> =
  z
    .object({
      equals: z.lazy(() => PromotionTypeSchema).optional(),
      in: z
        .lazy(() => PromotionTypeSchema)
        .array()
        .optional(),
      notIn: z
        .lazy(() => PromotionTypeSchema)
        .array()
        .optional(),
      not: z
        .union([
          z.lazy(() => PromotionTypeSchema),
          z.lazy(() => NestedEnumPromotionTypeFilterSchema),
        ])
        .optional(),
    })
    .strict() as z.ZodType<Prisma.EnumPromotionTypeFilter>;

export const IntNullableFilterSchema: z.ZodType<Prisma.IntNullableFilter> = z
  .object({
    equals: z.number().optional().nullable(),
    in: z.number().array().optional().nullable(),
    notIn: z.number().array().optional().nullable(),
    lt: z.number().optional(),
    lte: z.number().optional(),
    gt: z.number().optional(),
    gte: z.number().optional(),
    not: z
      .union([z.number(), z.lazy(() => NestedIntNullableFilterSchema)])
      .optional()
      .nullable(),
  })
  .strict() as z.ZodType<Prisma.IntNullableFilter>;

export const EnumPromotionStatusFilterSchema: z.ZodType<Prisma.EnumPromotionStatusFilter> =
  z
    .object({
      equals: z.lazy(() => PromotionStatusSchema).optional(),
      in: z
        .lazy(() => PromotionStatusSchema)
        .array()
        .optional(),
      notIn: z
        .lazy(() => PromotionStatusSchema)
        .array()
        .optional(),
      not: z
        .union([
          z.lazy(() => PromotionStatusSchema),
          z.lazy(() => NestedEnumPromotionStatusFilterSchema),
        ])
        .optional(),
    })
    .strict() as z.ZodType<Prisma.EnumPromotionStatusFilter>;

export const PromotionCountOrderByAggregateInputSchema: z.ZodType<Prisma.PromotionCountOrderByAggregateInput> =
  z
    .object({
      id: z.lazy(() => SortOrderSchema).optional(),
      code: z.lazy(() => SortOrderSchema).optional(),
      name: z.lazy(() => SortOrderSchema).optional(),
      description: z.lazy(() => SortOrderSchema).optional(),
      type: z.lazy(() => SortOrderSchema).optional(),
      value: z.lazy(() => SortOrderSchema).optional(),
      usageLimit: z.lazy(() => SortOrderSchema).optional(),
      startDate: z.lazy(() => SortOrderSchema).optional(),
      endDate: z.lazy(() => SortOrderSchema).optional(),
      status: z.lazy(() => SortOrderSchema).optional(),
      createdAt: z.lazy(() => SortOrderSchema).optional(),
      createdBy: z.lazy(() => SortOrderSchema).optional(),
      updatedAt: z.lazy(() => SortOrderSchema).optional(),
      deletedAt: z.lazy(() => SortOrderSchema).optional(),
    })
    .strict() as z.ZodType<Prisma.PromotionCountOrderByAggregateInput>;

export const PromotionAvgOrderByAggregateInputSchema: z.ZodType<Prisma.PromotionAvgOrderByAggregateInput> =
  z
    .object({
      value: z.lazy(() => SortOrderSchema).optional(),
      usageLimit: z.lazy(() => SortOrderSchema).optional(),
    })
    .strict() as z.ZodType<Prisma.PromotionAvgOrderByAggregateInput>;

export const PromotionMaxOrderByAggregateInputSchema: z.ZodType<Prisma.PromotionMaxOrderByAggregateInput> =
  z
    .object({
      id: z.lazy(() => SortOrderSchema).optional(),
      code: z.lazy(() => SortOrderSchema).optional(),
      name: z.lazy(() => SortOrderSchema).optional(),
      description: z.lazy(() => SortOrderSchema).optional(),
      type: z.lazy(() => SortOrderSchema).optional(),
      value: z.lazy(() => SortOrderSchema).optional(),
      usageLimit: z.lazy(() => SortOrderSchema).optional(),
      startDate: z.lazy(() => SortOrderSchema).optional(),
      endDate: z.lazy(() => SortOrderSchema).optional(),
      status: z.lazy(() => SortOrderSchema).optional(),
      createdAt: z.lazy(() => SortOrderSchema).optional(),
      createdBy: z.lazy(() => SortOrderSchema).optional(),
      updatedAt: z.lazy(() => SortOrderSchema).optional(),
      deletedAt: z.lazy(() => SortOrderSchema).optional(),
    })
    .strict() as z.ZodType<Prisma.PromotionMaxOrderByAggregateInput>;

export const PromotionMinOrderByAggregateInputSchema: z.ZodType<Prisma.PromotionMinOrderByAggregateInput> =
  z
    .object({
      id: z.lazy(() => SortOrderSchema).optional(),
      code: z.lazy(() => SortOrderSchema).optional(),
      name: z.lazy(() => SortOrderSchema).optional(),
      description: z.lazy(() => SortOrderSchema).optional(),
      type: z.lazy(() => SortOrderSchema).optional(),
      value: z.lazy(() => SortOrderSchema).optional(),
      usageLimit: z.lazy(() => SortOrderSchema).optional(),
      startDate: z.lazy(() => SortOrderSchema).optional(),
      endDate: z.lazy(() => SortOrderSchema).optional(),
      status: z.lazy(() => SortOrderSchema).optional(),
      createdAt: z.lazy(() => SortOrderSchema).optional(),
      createdBy: z.lazy(() => SortOrderSchema).optional(),
      updatedAt: z.lazy(() => SortOrderSchema).optional(),
      deletedAt: z.lazy(() => SortOrderSchema).optional(),
    })
    .strict() as z.ZodType<Prisma.PromotionMinOrderByAggregateInput>;

export const PromotionSumOrderByAggregateInputSchema: z.ZodType<Prisma.PromotionSumOrderByAggregateInput> =
  z
    .object({
      value: z.lazy(() => SortOrderSchema).optional(),
      usageLimit: z.lazy(() => SortOrderSchema).optional(),
    })
    .strict() as z.ZodType<Prisma.PromotionSumOrderByAggregateInput>;

export const EnumPromotionTypeWithAggregatesFilterSchema: z.ZodType<Prisma.EnumPromotionTypeWithAggregatesFilter> =
  z
    .object({
      equals: z.lazy(() => PromotionTypeSchema).optional(),
      in: z
        .lazy(() => PromotionTypeSchema)
        .array()
        .optional(),
      notIn: z
        .lazy(() => PromotionTypeSchema)
        .array()
        .optional(),
      not: z
        .union([
          z.lazy(() => PromotionTypeSchema),
          z.lazy(() => NestedEnumPromotionTypeWithAggregatesFilterSchema),
        ])
        .optional(),
      _count: z.lazy(() => NestedIntFilterSchema).optional(),
      _min: z.lazy(() => NestedEnumPromotionTypeFilterSchema).optional(),
      _max: z.lazy(() => NestedEnumPromotionTypeFilterSchema).optional(),
    })
    .strict() as z.ZodType<Prisma.EnumPromotionTypeWithAggregatesFilter>;

export const IntNullableWithAggregatesFilterSchema: z.ZodType<Prisma.IntNullableWithAggregatesFilter> =
  z
    .object({
      equals: z.number().optional().nullable(),
      in: z.number().array().optional().nullable(),
      notIn: z.number().array().optional().nullable(),
      lt: z.number().optional(),
      lte: z.number().optional(),
      gt: z.number().optional(),
      gte: z.number().optional(),
      not: z
        .union([
          z.number(),
          z.lazy(() => NestedIntNullableWithAggregatesFilterSchema),
        ])
        .optional()
        .nullable(),
      _count: z.lazy(() => NestedIntNullableFilterSchema).optional(),
      _avg: z.lazy(() => NestedFloatNullableFilterSchema).optional(),
      _sum: z.lazy(() => NestedIntNullableFilterSchema).optional(),
      _min: z.lazy(() => NestedIntNullableFilterSchema).optional(),
      _max: z.lazy(() => NestedIntNullableFilterSchema).optional(),
    })
    .strict() as z.ZodType<Prisma.IntNullableWithAggregatesFilter>;

export const EnumPromotionStatusWithAggregatesFilterSchema: z.ZodType<Prisma.EnumPromotionStatusWithAggregatesFilter> =
  z
    .object({
      equals: z.lazy(() => PromotionStatusSchema).optional(),
      in: z
        .lazy(() => PromotionStatusSchema)
        .array()
        .optional(),
      notIn: z
        .lazy(() => PromotionStatusSchema)
        .array()
        .optional(),
      not: z
        .union([
          z.lazy(() => PromotionStatusSchema),
          z.lazy(() => NestedEnumPromotionStatusWithAggregatesFilterSchema),
        ])
        .optional(),
      _count: z.lazy(() => NestedIntFilterSchema).optional(),
      _min: z.lazy(() => NestedEnumPromotionStatusFilterSchema).optional(),
      _max: z.lazy(() => NestedEnumPromotionStatusFilterSchema).optional(),
    })
    .strict() as z.ZodType<Prisma.EnumPromotionStatusWithAggregatesFilter>;

export const PromotionScalarRelationFilterSchema: z.ZodType<Prisma.PromotionScalarRelationFilter> =
  z
    .object({
      is: z.lazy(() => PromotionWhereInputSchema).optional(),
      isNot: z.lazy(() => PromotionWhereInputSchema).optional(),
    })
    .strict() as z.ZodType<Prisma.PromotionScalarRelationFilter>;

export const OrderPromotionOrderIDPromotionIDCompoundUniqueInputSchema: z.ZodType<Prisma.OrderPromotionOrderIDPromotionIDCompoundUniqueInput> =
  z
    .object({
      orderID: z.string(),
      promotionID: z.string(),
    })
    .strict() as z.ZodType<Prisma.OrderPromotionOrderIDPromotionIDCompoundUniqueInput>;

export const OrderPromotionCountOrderByAggregateInputSchema: z.ZodType<Prisma.OrderPromotionCountOrderByAggregateInput> =
  z
    .object({
      id: z.lazy(() => SortOrderSchema).optional(),
      orderID: z.lazy(() => SortOrderSchema).optional(),
      promotionID: z.lazy(() => SortOrderSchema).optional(),
      discountAmount: z.lazy(() => SortOrderSchema).optional(),
    })
    .strict() as z.ZodType<Prisma.OrderPromotionCountOrderByAggregateInput>;

export const OrderPromotionAvgOrderByAggregateInputSchema: z.ZodType<Prisma.OrderPromotionAvgOrderByAggregateInput> =
  z
    .object({
      discountAmount: z.lazy(() => SortOrderSchema).optional(),
    })
    .strict() as z.ZodType<Prisma.OrderPromotionAvgOrderByAggregateInput>;

export const OrderPromotionMaxOrderByAggregateInputSchema: z.ZodType<Prisma.OrderPromotionMaxOrderByAggregateInput> =
  z
    .object({
      id: z.lazy(() => SortOrderSchema).optional(),
      orderID: z.lazy(() => SortOrderSchema).optional(),
      promotionID: z.lazy(() => SortOrderSchema).optional(),
      discountAmount: z.lazy(() => SortOrderSchema).optional(),
    })
    .strict() as z.ZodType<Prisma.OrderPromotionMaxOrderByAggregateInput>;

export const OrderPromotionMinOrderByAggregateInputSchema: z.ZodType<Prisma.OrderPromotionMinOrderByAggregateInput> =
  z
    .object({
      id: z.lazy(() => SortOrderSchema).optional(),
      orderID: z.lazy(() => SortOrderSchema).optional(),
      promotionID: z.lazy(() => SortOrderSchema).optional(),
      discountAmount: z.lazy(() => SortOrderSchema).optional(),
    })
    .strict() as z.ZodType<Prisma.OrderPromotionMinOrderByAggregateInput>;

export const OrderPromotionSumOrderByAggregateInputSchema: z.ZodType<Prisma.OrderPromotionSumOrderByAggregateInput> =
  z
    .object({
      discountAmount: z.lazy(() => SortOrderSchema).optional(),
    })
    .strict() as z.ZodType<Prisma.OrderPromotionSumOrderByAggregateInput>;

export const CartCountOrderByAggregateInputSchema: z.ZodType<Prisma.CartCountOrderByAggregateInput> =
  z
    .object({
      id: z.lazy(() => SortOrderSchema).optional(),
      userID: z.lazy(() => SortOrderSchema).optional(),
      createdAt: z.lazy(() => SortOrderSchema).optional(),
      updatedAt: z.lazy(() => SortOrderSchema).optional(),
    })
    .strict() as z.ZodType<Prisma.CartCountOrderByAggregateInput>;

export const CartMaxOrderByAggregateInputSchema: z.ZodType<Prisma.CartMaxOrderByAggregateInput> =
  z
    .object({
      id: z.lazy(() => SortOrderSchema).optional(),
      userID: z.lazy(() => SortOrderSchema).optional(),
      createdAt: z.lazy(() => SortOrderSchema).optional(),
      updatedAt: z.lazy(() => SortOrderSchema).optional(),
    })
    .strict() as z.ZodType<Prisma.CartMaxOrderByAggregateInput>;

export const CartMinOrderByAggregateInputSchema: z.ZodType<Prisma.CartMinOrderByAggregateInput> =
  z
    .object({
      id: z.lazy(() => SortOrderSchema).optional(),
      userID: z.lazy(() => SortOrderSchema).optional(),
      createdAt: z.lazy(() => SortOrderSchema).optional(),
      updatedAt: z.lazy(() => SortOrderSchema).optional(),
    })
    .strict() as z.ZodType<Prisma.CartMinOrderByAggregateInput>;

export const CartScalarRelationFilterSchema: z.ZodType<Prisma.CartScalarRelationFilter> =
  z
    .object({
      is: z.lazy(() => CartWhereInputSchema).optional(),
      isNot: z.lazy(() => CartWhereInputSchema).optional(),
    })
    .strict() as z.ZodType<Prisma.CartScalarRelationFilter>;

export const CartItemCartIDProductVariantIDCompoundUniqueInputSchema: z.ZodType<Prisma.CartItemCartIDProductVariantIDCompoundUniqueInput> =
  z
    .object({
      cartID: z.string(),
      productVariantID: z.string(),
    })
    .strict() as z.ZodType<Prisma.CartItemCartIDProductVariantIDCompoundUniqueInput>;

export const CartItemCountOrderByAggregateInputSchema: z.ZodType<Prisma.CartItemCountOrderByAggregateInput> =
  z
    .object({
      id: z.lazy(() => SortOrderSchema).optional(),
      cartID: z.lazy(() => SortOrderSchema).optional(),
      productVariantID: z.lazy(() => SortOrderSchema).optional(),
      quantity: z.lazy(() => SortOrderSchema).optional(),
      createdAt: z.lazy(() => SortOrderSchema).optional(),
      updatedAt: z.lazy(() => SortOrderSchema).optional(),
    })
    .strict() as z.ZodType<Prisma.CartItemCountOrderByAggregateInput>;

export const CartItemAvgOrderByAggregateInputSchema: z.ZodType<Prisma.CartItemAvgOrderByAggregateInput> =
  z
    .object({
      quantity: z.lazy(() => SortOrderSchema).optional(),
    })
    .strict() as z.ZodType<Prisma.CartItemAvgOrderByAggregateInput>;

export const CartItemMaxOrderByAggregateInputSchema: z.ZodType<Prisma.CartItemMaxOrderByAggregateInput> =
  z
    .object({
      id: z.lazy(() => SortOrderSchema).optional(),
      cartID: z.lazy(() => SortOrderSchema).optional(),
      productVariantID: z.lazy(() => SortOrderSchema).optional(),
      quantity: z.lazy(() => SortOrderSchema).optional(),
      createdAt: z.lazy(() => SortOrderSchema).optional(),
      updatedAt: z.lazy(() => SortOrderSchema).optional(),
    })
    .strict() as z.ZodType<Prisma.CartItemMaxOrderByAggregateInput>;

export const CartItemMinOrderByAggregateInputSchema: z.ZodType<Prisma.CartItemMinOrderByAggregateInput> =
  z
    .object({
      id: z.lazy(() => SortOrderSchema).optional(),
      cartID: z.lazy(() => SortOrderSchema).optional(),
      productVariantID: z.lazy(() => SortOrderSchema).optional(),
      quantity: z.lazy(() => SortOrderSchema).optional(),
      createdAt: z.lazy(() => SortOrderSchema).optional(),
      updatedAt: z.lazy(() => SortOrderSchema).optional(),
    })
    .strict() as z.ZodType<Prisma.CartItemMinOrderByAggregateInput>;

export const CartItemSumOrderByAggregateInputSchema: z.ZodType<Prisma.CartItemSumOrderByAggregateInput> =
  z
    .object({
      quantity: z.lazy(() => SortOrderSchema).optional(),
    })
    .strict() as z.ZodType<Prisma.CartItemSumOrderByAggregateInput>;

export const UserNullableScalarRelationFilterSchema: z.ZodType<Prisma.UserNullableScalarRelationFilter> =
  z
    .object({
      is: z
        .lazy(() => UserWhereInputSchema)
        .optional()
        .nullable(),
      isNot: z
        .lazy(() => UserWhereInputSchema)
        .optional()
        .nullable(),
    })
    .strict() as z.ZodType<Prisma.UserNullableScalarRelationFilter>;

export const NotificationCountOrderByAggregateInputSchema: z.ZodType<Prisma.NotificationCountOrderByAggregateInput> =
  z
    .object({
      id: z.lazy(() => SortOrderSchema).optional(),
      userID: z.lazy(() => SortOrderSchema).optional(),
      title: z.lazy(() => SortOrderSchema).optional(),
      message: z.lazy(() => SortOrderSchema).optional(),
      isRead: z.lazy(() => SortOrderSchema).optional(),
    })
    .strict() as z.ZodType<Prisma.NotificationCountOrderByAggregateInput>;

export const NotificationMaxOrderByAggregateInputSchema: z.ZodType<Prisma.NotificationMaxOrderByAggregateInput> =
  z
    .object({
      id: z.lazy(() => SortOrderSchema).optional(),
      userID: z.lazy(() => SortOrderSchema).optional(),
      title: z.lazy(() => SortOrderSchema).optional(),
      message: z.lazy(() => SortOrderSchema).optional(),
      isRead: z.lazy(() => SortOrderSchema).optional(),
    })
    .strict() as z.ZodType<Prisma.NotificationMaxOrderByAggregateInput>;

export const NotificationMinOrderByAggregateInputSchema: z.ZodType<Prisma.NotificationMinOrderByAggregateInput> =
  z
    .object({
      id: z.lazy(() => SortOrderSchema).optional(),
      userID: z.lazy(() => SortOrderSchema).optional(),
      title: z.lazy(() => SortOrderSchema).optional(),
      message: z.lazy(() => SortOrderSchema).optional(),
      isRead: z.lazy(() => SortOrderSchema).optional(),
    })
    .strict() as z.ZodType<Prisma.NotificationMinOrderByAggregateInput>;

export const EnumPaymentTypeFilterSchema: z.ZodType<Prisma.EnumPaymentTypeFilter> =
  z
    .object({
      equals: z.lazy(() => PaymentTypeSchema).optional(),
      in: z
        .lazy(() => PaymentTypeSchema)
        .array()
        .optional(),
      notIn: z
        .lazy(() => PaymentTypeSchema)
        .array()
        .optional(),
      not: z
        .union([
          z.lazy(() => PaymentTypeSchema),
          z.lazy(() => NestedEnumPaymentTypeFilterSchema),
        ])
        .optional(),
    })
    .strict() as z.ZodType<Prisma.EnumPaymentTypeFilter>;

export const EnumPaymentStatusFilterSchema: z.ZodType<Prisma.EnumPaymentStatusFilter> =
  z
    .object({
      equals: z.lazy(() => PaymentStatusSchema).optional(),
      in: z
        .lazy(() => PaymentStatusSchema)
        .array()
        .optional(),
      notIn: z
        .lazy(() => PaymentStatusSchema)
        .array()
        .optional(),
      not: z
        .union([
          z.lazy(() => PaymentStatusSchema),
          z.lazy(() => NestedEnumPaymentStatusFilterSchema),
        ])
        .optional(),
    })
    .strict() as z.ZodType<Prisma.EnumPaymentStatusFilter>;

export const PaymentCountOrderByAggregateInputSchema: z.ZodType<Prisma.PaymentCountOrderByAggregateInput> =
  z
    .object({
      id: z.lazy(() => SortOrderSchema).optional(),
      orderID: z.lazy(() => SortOrderSchema).optional(),
      type: z.lazy(() => SortOrderSchema).optional(),
      status: z.lazy(() => SortOrderSchema).optional(),
      amount: z.lazy(() => SortOrderSchema).optional(),
      transactionID: z.lazy(() => SortOrderSchema).optional(),
      createdAt: z.lazy(() => SortOrderSchema).optional(),
      createdBy: z.lazy(() => SortOrderSchema).optional(),
      updatedAt: z.lazy(() => SortOrderSchema).optional(),
      deletedAt: z.lazy(() => SortOrderSchema).optional(),
    })
    .strict() as z.ZodType<Prisma.PaymentCountOrderByAggregateInput>;

export const PaymentAvgOrderByAggregateInputSchema: z.ZodType<Prisma.PaymentAvgOrderByAggregateInput> =
  z
    .object({
      amount: z.lazy(() => SortOrderSchema).optional(),
    })
    .strict() as z.ZodType<Prisma.PaymentAvgOrderByAggregateInput>;

export const PaymentMaxOrderByAggregateInputSchema: z.ZodType<Prisma.PaymentMaxOrderByAggregateInput> =
  z
    .object({
      id: z.lazy(() => SortOrderSchema).optional(),
      orderID: z.lazy(() => SortOrderSchema).optional(),
      type: z.lazy(() => SortOrderSchema).optional(),
      status: z.lazy(() => SortOrderSchema).optional(),
      amount: z.lazy(() => SortOrderSchema).optional(),
      transactionID: z.lazy(() => SortOrderSchema).optional(),
      createdAt: z.lazy(() => SortOrderSchema).optional(),
      createdBy: z.lazy(() => SortOrderSchema).optional(),
      updatedAt: z.lazy(() => SortOrderSchema).optional(),
      deletedAt: z.lazy(() => SortOrderSchema).optional(),
    })
    .strict() as z.ZodType<Prisma.PaymentMaxOrderByAggregateInput>;

export const PaymentMinOrderByAggregateInputSchema: z.ZodType<Prisma.PaymentMinOrderByAggregateInput> =
  z
    .object({
      id: z.lazy(() => SortOrderSchema).optional(),
      orderID: z.lazy(() => SortOrderSchema).optional(),
      type: z.lazy(() => SortOrderSchema).optional(),
      status: z.lazy(() => SortOrderSchema).optional(),
      amount: z.lazy(() => SortOrderSchema).optional(),
      transactionID: z.lazy(() => SortOrderSchema).optional(),
      createdAt: z.lazy(() => SortOrderSchema).optional(),
      createdBy: z.lazy(() => SortOrderSchema).optional(),
      updatedAt: z.lazy(() => SortOrderSchema).optional(),
      deletedAt: z.lazy(() => SortOrderSchema).optional(),
    })
    .strict() as z.ZodType<Prisma.PaymentMinOrderByAggregateInput>;

export const PaymentSumOrderByAggregateInputSchema: z.ZodType<Prisma.PaymentSumOrderByAggregateInput> =
  z
    .object({
      amount: z.lazy(() => SortOrderSchema).optional(),
    })
    .strict() as z.ZodType<Prisma.PaymentSumOrderByAggregateInput>;

export const EnumPaymentTypeWithAggregatesFilterSchema: z.ZodType<Prisma.EnumPaymentTypeWithAggregatesFilter> =
  z
    .object({
      equals: z.lazy(() => PaymentTypeSchema).optional(),
      in: z
        .lazy(() => PaymentTypeSchema)
        .array()
        .optional(),
      notIn: z
        .lazy(() => PaymentTypeSchema)
        .array()
        .optional(),
      not: z
        .union([
          z.lazy(() => PaymentTypeSchema),
          z.lazy(() => NestedEnumPaymentTypeWithAggregatesFilterSchema),
        ])
        .optional(),
      _count: z.lazy(() => NestedIntFilterSchema).optional(),
      _min: z.lazy(() => NestedEnumPaymentTypeFilterSchema).optional(),
      _max: z.lazy(() => NestedEnumPaymentTypeFilterSchema).optional(),
    })
    .strict() as z.ZodType<Prisma.EnumPaymentTypeWithAggregatesFilter>;

export const EnumPaymentStatusWithAggregatesFilterSchema: z.ZodType<Prisma.EnumPaymentStatusWithAggregatesFilter> =
  z
    .object({
      equals: z.lazy(() => PaymentStatusSchema).optional(),
      in: z
        .lazy(() => PaymentStatusSchema)
        .array()
        .optional(),
      notIn: z
        .lazy(() => PaymentStatusSchema)
        .array()
        .optional(),
      not: z
        .union([
          z.lazy(() => PaymentStatusSchema),
          z.lazy(() => NestedEnumPaymentStatusWithAggregatesFilterSchema),
        ])
        .optional(),
      _count: z.lazy(() => NestedIntFilterSchema).optional(),
      _min: z.lazy(() => NestedEnumPaymentStatusFilterSchema).optional(),
      _max: z.lazy(() => NestedEnumPaymentStatusFilterSchema).optional(),
    })
    .strict() as z.ZodType<Prisma.EnumPaymentStatusWithAggregatesFilter>;

export const VendorCreateNestedManyWithoutUserInputSchema: z.ZodType<Prisma.VendorCreateNestedManyWithoutUserInput> =
  z
    .object({
      create: z
        .union([
          z.lazy(() => VendorCreateWithoutUserInputSchema),
          z.lazy(() => VendorCreateWithoutUserInputSchema).array(),
          z.lazy(() => VendorUncheckedCreateWithoutUserInputSchema),
          z.lazy(() => VendorUncheckedCreateWithoutUserInputSchema).array(),
        ])
        .optional(),
      connectOrCreate: z
        .union([
          z.lazy(() => VendorCreateOrConnectWithoutUserInputSchema),
          z.lazy(() => VendorCreateOrConnectWithoutUserInputSchema).array(),
        ])
        .optional(),
      createMany: z
        .lazy(() => VendorCreateManyUserInputEnvelopeSchema)
        .optional(),
      connect: z
        .union([
          z.lazy(() => VendorWhereUniqueInputSchema),
          z.lazy(() => VendorWhereUniqueInputSchema).array(),
        ])
        .optional(),
    })
    .strict() as z.ZodType<Prisma.VendorCreateNestedManyWithoutUserInput>;

export const UserVendorRoleCreateNestedManyWithoutUserInputSchema: z.ZodType<Prisma.UserVendorRoleCreateNestedManyWithoutUserInput> =
  z
    .object({
      create: z
        .union([
          z.lazy(() => UserVendorRoleCreateWithoutUserInputSchema),
          z.lazy(() => UserVendorRoleCreateWithoutUserInputSchema).array(),
          z.lazy(() => UserVendorRoleUncheckedCreateWithoutUserInputSchema),
          z
            .lazy(() => UserVendorRoleUncheckedCreateWithoutUserInputSchema)
            .array(),
        ])
        .optional(),
      connectOrCreate: z
        .union([
          z.lazy(() => UserVendorRoleCreateOrConnectWithoutUserInputSchema),
          z
            .lazy(() => UserVendorRoleCreateOrConnectWithoutUserInputSchema)
            .array(),
        ])
        .optional(),
      createMany: z
        .lazy(() => UserVendorRoleCreateManyUserInputEnvelopeSchema)
        .optional(),
      connect: z
        .union([
          z.lazy(() => UserVendorRoleWhereUniqueInputSchema),
          z.lazy(() => UserVendorRoleWhereUniqueInputSchema).array(),
        ])
        .optional(),
    })
    .strict() as z.ZodType<Prisma.UserVendorRoleCreateNestedManyWithoutUserInput>;

export const OrderCreateNestedManyWithoutUserInputSchema: z.ZodType<Prisma.OrderCreateNestedManyWithoutUserInput> =
  z
    .object({
      create: z
        .union([
          z.lazy(() => OrderCreateWithoutUserInputSchema),
          z.lazy(() => OrderCreateWithoutUserInputSchema).array(),
          z.lazy(() => OrderUncheckedCreateWithoutUserInputSchema),
          z.lazy(() => OrderUncheckedCreateWithoutUserInputSchema).array(),
        ])
        .optional(),
      connectOrCreate: z
        .union([
          z.lazy(() => OrderCreateOrConnectWithoutUserInputSchema),
          z.lazy(() => OrderCreateOrConnectWithoutUserInputSchema).array(),
        ])
        .optional(),
      createMany: z
        .lazy(() => OrderCreateManyUserInputEnvelopeSchema)
        .optional(),
      connect: z
        .union([
          z.lazy(() => OrderWhereUniqueInputSchema),
          z.lazy(() => OrderWhereUniqueInputSchema).array(),
        ])
        .optional(),
    })
    .strict() as z.ZodType<Prisma.OrderCreateNestedManyWithoutUserInput>;

export const CartCreateNestedOneWithoutUserInputSchema: z.ZodType<Prisma.CartCreateNestedOneWithoutUserInput> =
  z
    .object({
      create: z
        .union([
          z.lazy(() => CartCreateWithoutUserInputSchema),
          z.lazy(() => CartUncheckedCreateWithoutUserInputSchema),
        ])
        .optional(),
      connectOrCreate: z
        .lazy(() => CartCreateOrConnectWithoutUserInputSchema)
        .optional(),
      connect: z.lazy(() => CartWhereUniqueInputSchema).optional(),
    })
    .strict() as z.ZodType<Prisma.CartCreateNestedOneWithoutUserInput>;

export const NotificationCreateNestedManyWithoutUserInputSchema: z.ZodType<Prisma.NotificationCreateNestedManyWithoutUserInput> =
  z
    .object({
      create: z
        .union([
          z.lazy(() => NotificationCreateWithoutUserInputSchema),
          z.lazy(() => NotificationCreateWithoutUserInputSchema).array(),
          z.lazy(() => NotificationUncheckedCreateWithoutUserInputSchema),
          z
            .lazy(() => NotificationUncheckedCreateWithoutUserInputSchema)
            .array(),
        ])
        .optional(),
      connectOrCreate: z
        .union([
          z.lazy(() => NotificationCreateOrConnectWithoutUserInputSchema),
          z
            .lazy(() => NotificationCreateOrConnectWithoutUserInputSchema)
            .array(),
        ])
        .optional(),
      createMany: z
        .lazy(() => NotificationCreateManyUserInputEnvelopeSchema)
        .optional(),
      connect: z
        .union([
          z.lazy(() => NotificationWhereUniqueInputSchema),
          z.lazy(() => NotificationWhereUniqueInputSchema).array(),
        ])
        .optional(),
    })
    .strict() as z.ZodType<Prisma.NotificationCreateNestedManyWithoutUserInput>;

export const VendorUncheckedCreateNestedManyWithoutUserInputSchema: z.ZodType<Prisma.VendorUncheckedCreateNestedManyWithoutUserInput> =
  z
    .object({
      create: z
        .union([
          z.lazy(() => VendorCreateWithoutUserInputSchema),
          z.lazy(() => VendorCreateWithoutUserInputSchema).array(),
          z.lazy(() => VendorUncheckedCreateWithoutUserInputSchema),
          z.lazy(() => VendorUncheckedCreateWithoutUserInputSchema).array(),
        ])
        .optional(),
      connectOrCreate: z
        .union([
          z.lazy(() => VendorCreateOrConnectWithoutUserInputSchema),
          z.lazy(() => VendorCreateOrConnectWithoutUserInputSchema).array(),
        ])
        .optional(),
      createMany: z
        .lazy(() => VendorCreateManyUserInputEnvelopeSchema)
        .optional(),
      connect: z
        .union([
          z.lazy(() => VendorWhereUniqueInputSchema),
          z.lazy(() => VendorWhereUniqueInputSchema).array(),
        ])
        .optional(),
    })
    .strict() as z.ZodType<Prisma.VendorUncheckedCreateNestedManyWithoutUserInput>;

export const UserVendorRoleUncheckedCreateNestedManyWithoutUserInputSchema: z.ZodType<Prisma.UserVendorRoleUncheckedCreateNestedManyWithoutUserInput> =
  z
    .object({
      create: z
        .union([
          z.lazy(() => UserVendorRoleCreateWithoutUserInputSchema),
          z.lazy(() => UserVendorRoleCreateWithoutUserInputSchema).array(),
          z.lazy(() => UserVendorRoleUncheckedCreateWithoutUserInputSchema),
          z
            .lazy(() => UserVendorRoleUncheckedCreateWithoutUserInputSchema)
            .array(),
        ])
        .optional(),
      connectOrCreate: z
        .union([
          z.lazy(() => UserVendorRoleCreateOrConnectWithoutUserInputSchema),
          z
            .lazy(() => UserVendorRoleCreateOrConnectWithoutUserInputSchema)
            .array(),
        ])
        .optional(),
      createMany: z
        .lazy(() => UserVendorRoleCreateManyUserInputEnvelopeSchema)
        .optional(),
      connect: z
        .union([
          z.lazy(() => UserVendorRoleWhereUniqueInputSchema),
          z.lazy(() => UserVendorRoleWhereUniqueInputSchema).array(),
        ])
        .optional(),
    })
    .strict() as z.ZodType<Prisma.UserVendorRoleUncheckedCreateNestedManyWithoutUserInput>;

export const OrderUncheckedCreateNestedManyWithoutUserInputSchema: z.ZodType<Prisma.OrderUncheckedCreateNestedManyWithoutUserInput> =
  z
    .object({
      create: z
        .union([
          z.lazy(() => OrderCreateWithoutUserInputSchema),
          z.lazy(() => OrderCreateWithoutUserInputSchema).array(),
          z.lazy(() => OrderUncheckedCreateWithoutUserInputSchema),
          z.lazy(() => OrderUncheckedCreateWithoutUserInputSchema).array(),
        ])
        .optional(),
      connectOrCreate: z
        .union([
          z.lazy(() => OrderCreateOrConnectWithoutUserInputSchema),
          z.lazy(() => OrderCreateOrConnectWithoutUserInputSchema).array(),
        ])
        .optional(),
      createMany: z
        .lazy(() => OrderCreateManyUserInputEnvelopeSchema)
        .optional(),
      connect: z
        .union([
          z.lazy(() => OrderWhereUniqueInputSchema),
          z.lazy(() => OrderWhereUniqueInputSchema).array(),
        ])
        .optional(),
    })
    .strict() as z.ZodType<Prisma.OrderUncheckedCreateNestedManyWithoutUserInput>;

export const CartUncheckedCreateNestedOneWithoutUserInputSchema: z.ZodType<Prisma.CartUncheckedCreateNestedOneWithoutUserInput> =
  z
    .object({
      create: z
        .union([
          z.lazy(() => CartCreateWithoutUserInputSchema),
          z.lazy(() => CartUncheckedCreateWithoutUserInputSchema),
        ])
        .optional(),
      connectOrCreate: z
        .lazy(() => CartCreateOrConnectWithoutUserInputSchema)
        .optional(),
      connect: z.lazy(() => CartWhereUniqueInputSchema).optional(),
    })
    .strict() as z.ZodType<Prisma.CartUncheckedCreateNestedOneWithoutUserInput>;

export const NotificationUncheckedCreateNestedManyWithoutUserInputSchema: z.ZodType<Prisma.NotificationUncheckedCreateNestedManyWithoutUserInput> =
  z
    .object({
      create: z
        .union([
          z.lazy(() => NotificationCreateWithoutUserInputSchema),
          z.lazy(() => NotificationCreateWithoutUserInputSchema).array(),
          z.lazy(() => NotificationUncheckedCreateWithoutUserInputSchema),
          z
            .lazy(() => NotificationUncheckedCreateWithoutUserInputSchema)
            .array(),
        ])
        .optional(),
      connectOrCreate: z
        .union([
          z.lazy(() => NotificationCreateOrConnectWithoutUserInputSchema),
          z
            .lazy(() => NotificationCreateOrConnectWithoutUserInputSchema)
            .array(),
        ])
        .optional(),
      createMany: z
        .lazy(() => NotificationCreateManyUserInputEnvelopeSchema)
        .optional(),
      connect: z
        .union([
          z.lazy(() => NotificationWhereUniqueInputSchema),
          z.lazy(() => NotificationWhereUniqueInputSchema).array(),
        ])
        .optional(),
    })
    .strict() as z.ZodType<Prisma.NotificationUncheckedCreateNestedManyWithoutUserInput>;

export const StringFieldUpdateOperationsInputSchema: z.ZodType<Prisma.StringFieldUpdateOperationsInput> =
  z
    .object({
      set: z.string().optional(),
    })
    .strict() as z.ZodType<Prisma.StringFieldUpdateOperationsInput>;

export const NullableStringFieldUpdateOperationsInputSchema: z.ZodType<Prisma.NullableStringFieldUpdateOperationsInput> =
  z
    .object({
      set: z.string().optional().nullable(),
    })
    .strict() as z.ZodType<Prisma.NullableStringFieldUpdateOperationsInput>;

export const EnumUserStatusFieldUpdateOperationsInputSchema: z.ZodType<Prisma.EnumUserStatusFieldUpdateOperationsInput> =
  z
    .object({
      set: z.lazy(() => UserStatusSchema).optional(),
    })
    .strict() as z.ZodType<Prisma.EnumUserStatusFieldUpdateOperationsInput>;

export const DateTimeFieldUpdateOperationsInputSchema: z.ZodType<Prisma.DateTimeFieldUpdateOperationsInput> =
  z
    .object({
      set: z.coerce.date().optional(),
    })
    .strict() as z.ZodType<Prisma.DateTimeFieldUpdateOperationsInput>;

export const NullableDateTimeFieldUpdateOperationsInputSchema: z.ZodType<Prisma.NullableDateTimeFieldUpdateOperationsInput> =
  z
    .object({
      set: z.coerce.date().optional().nullable(),
    })
    .strict() as z.ZodType<Prisma.NullableDateTimeFieldUpdateOperationsInput>;

export const VendorUpdateManyWithoutUserNestedInputSchema: z.ZodType<Prisma.VendorUpdateManyWithoutUserNestedInput> =
  z
    .object({
      create: z
        .union([
          z.lazy(() => VendorCreateWithoutUserInputSchema),
          z.lazy(() => VendorCreateWithoutUserInputSchema).array(),
          z.lazy(() => VendorUncheckedCreateWithoutUserInputSchema),
          z.lazy(() => VendorUncheckedCreateWithoutUserInputSchema).array(),
        ])
        .optional(),
      connectOrCreate: z
        .union([
          z.lazy(() => VendorCreateOrConnectWithoutUserInputSchema),
          z.lazy(() => VendorCreateOrConnectWithoutUserInputSchema).array(),
        ])
        .optional(),
      upsert: z
        .union([
          z.lazy(() => VendorUpsertWithWhereUniqueWithoutUserInputSchema),
          z
            .lazy(() => VendorUpsertWithWhereUniqueWithoutUserInputSchema)
            .array(),
        ])
        .optional(),
      createMany: z
        .lazy(() => VendorCreateManyUserInputEnvelopeSchema)
        .optional(),
      set: z
        .union([
          z.lazy(() => VendorWhereUniqueInputSchema),
          z.lazy(() => VendorWhereUniqueInputSchema).array(),
        ])
        .optional(),
      disconnect: z
        .union([
          z.lazy(() => VendorWhereUniqueInputSchema),
          z.lazy(() => VendorWhereUniqueInputSchema).array(),
        ])
        .optional(),
      delete: z
        .union([
          z.lazy(() => VendorWhereUniqueInputSchema),
          z.lazy(() => VendorWhereUniqueInputSchema).array(),
        ])
        .optional(),
      connect: z
        .union([
          z.lazy(() => VendorWhereUniqueInputSchema),
          z.lazy(() => VendorWhereUniqueInputSchema).array(),
        ])
        .optional(),
      update: z
        .union([
          z.lazy(() => VendorUpdateWithWhereUniqueWithoutUserInputSchema),
          z
            .lazy(() => VendorUpdateWithWhereUniqueWithoutUserInputSchema)
            .array(),
        ])
        .optional(),
      updateMany: z
        .union([
          z.lazy(() => VendorUpdateManyWithWhereWithoutUserInputSchema),
          z.lazy(() => VendorUpdateManyWithWhereWithoutUserInputSchema).array(),
        ])
        .optional(),
      deleteMany: z
        .union([
          z.lazy(() => VendorScalarWhereInputSchema),
          z.lazy(() => VendorScalarWhereInputSchema).array(),
        ])
        .optional(),
    })
    .strict() as z.ZodType<Prisma.VendorUpdateManyWithoutUserNestedInput>;

export const UserVendorRoleUpdateManyWithoutUserNestedInputSchema: z.ZodType<Prisma.UserVendorRoleUpdateManyWithoutUserNestedInput> =
  z
    .object({
      create: z
        .union([
          z.lazy(() => UserVendorRoleCreateWithoutUserInputSchema),
          z.lazy(() => UserVendorRoleCreateWithoutUserInputSchema).array(),
          z.lazy(() => UserVendorRoleUncheckedCreateWithoutUserInputSchema),
          z
            .lazy(() => UserVendorRoleUncheckedCreateWithoutUserInputSchema)
            .array(),
        ])
        .optional(),
      connectOrCreate: z
        .union([
          z.lazy(() => UserVendorRoleCreateOrConnectWithoutUserInputSchema),
          z
            .lazy(() => UserVendorRoleCreateOrConnectWithoutUserInputSchema)
            .array(),
        ])
        .optional(),
      upsert: z
        .union([
          z.lazy(
            () => UserVendorRoleUpsertWithWhereUniqueWithoutUserInputSchema,
          ),
          z
            .lazy(
              () => UserVendorRoleUpsertWithWhereUniqueWithoutUserInputSchema,
            )
            .array(),
        ])
        .optional(),
      createMany: z
        .lazy(() => UserVendorRoleCreateManyUserInputEnvelopeSchema)
        .optional(),
      set: z
        .union([
          z.lazy(() => UserVendorRoleWhereUniqueInputSchema),
          z.lazy(() => UserVendorRoleWhereUniqueInputSchema).array(),
        ])
        .optional(),
      disconnect: z
        .union([
          z.lazy(() => UserVendorRoleWhereUniqueInputSchema),
          z.lazy(() => UserVendorRoleWhereUniqueInputSchema).array(),
        ])
        .optional(),
      delete: z
        .union([
          z.lazy(() => UserVendorRoleWhereUniqueInputSchema),
          z.lazy(() => UserVendorRoleWhereUniqueInputSchema).array(),
        ])
        .optional(),
      connect: z
        .union([
          z.lazy(() => UserVendorRoleWhereUniqueInputSchema),
          z.lazy(() => UserVendorRoleWhereUniqueInputSchema).array(),
        ])
        .optional(),
      update: z
        .union([
          z.lazy(
            () => UserVendorRoleUpdateWithWhereUniqueWithoutUserInputSchema,
          ),
          z
            .lazy(
              () => UserVendorRoleUpdateWithWhereUniqueWithoutUserInputSchema,
            )
            .array(),
        ])
        .optional(),
      updateMany: z
        .union([
          z.lazy(() => UserVendorRoleUpdateManyWithWhereWithoutUserInputSchema),
          z
            .lazy(() => UserVendorRoleUpdateManyWithWhereWithoutUserInputSchema)
            .array(),
        ])
        .optional(),
      deleteMany: z
        .union([
          z.lazy(() => UserVendorRoleScalarWhereInputSchema),
          z.lazy(() => UserVendorRoleScalarWhereInputSchema).array(),
        ])
        .optional(),
    })
    .strict() as z.ZodType<Prisma.UserVendorRoleUpdateManyWithoutUserNestedInput>;

export const OrderUpdateManyWithoutUserNestedInputSchema: z.ZodType<Prisma.OrderUpdateManyWithoutUserNestedInput> =
  z
    .object({
      create: z
        .union([
          z.lazy(() => OrderCreateWithoutUserInputSchema),
          z.lazy(() => OrderCreateWithoutUserInputSchema).array(),
          z.lazy(() => OrderUncheckedCreateWithoutUserInputSchema),
          z.lazy(() => OrderUncheckedCreateWithoutUserInputSchema).array(),
        ])
        .optional(),
      connectOrCreate: z
        .union([
          z.lazy(() => OrderCreateOrConnectWithoutUserInputSchema),
          z.lazy(() => OrderCreateOrConnectWithoutUserInputSchema).array(),
        ])
        .optional(),
      upsert: z
        .union([
          z.lazy(() => OrderUpsertWithWhereUniqueWithoutUserInputSchema),
          z
            .lazy(() => OrderUpsertWithWhereUniqueWithoutUserInputSchema)
            .array(),
        ])
        .optional(),
      createMany: z
        .lazy(() => OrderCreateManyUserInputEnvelopeSchema)
        .optional(),
      set: z
        .union([
          z.lazy(() => OrderWhereUniqueInputSchema),
          z.lazy(() => OrderWhereUniqueInputSchema).array(),
        ])
        .optional(),
      disconnect: z
        .union([
          z.lazy(() => OrderWhereUniqueInputSchema),
          z.lazy(() => OrderWhereUniqueInputSchema).array(),
        ])
        .optional(),
      delete: z
        .union([
          z.lazy(() => OrderWhereUniqueInputSchema),
          z.lazy(() => OrderWhereUniqueInputSchema).array(),
        ])
        .optional(),
      connect: z
        .union([
          z.lazy(() => OrderWhereUniqueInputSchema),
          z.lazy(() => OrderWhereUniqueInputSchema).array(),
        ])
        .optional(),
      update: z
        .union([
          z.lazy(() => OrderUpdateWithWhereUniqueWithoutUserInputSchema),
          z
            .lazy(() => OrderUpdateWithWhereUniqueWithoutUserInputSchema)
            .array(),
        ])
        .optional(),
      updateMany: z
        .union([
          z.lazy(() => OrderUpdateManyWithWhereWithoutUserInputSchema),
          z.lazy(() => OrderUpdateManyWithWhereWithoutUserInputSchema).array(),
        ])
        .optional(),
      deleteMany: z
        .union([
          z.lazy(() => OrderScalarWhereInputSchema),
          z.lazy(() => OrderScalarWhereInputSchema).array(),
        ])
        .optional(),
    })
    .strict() as z.ZodType<Prisma.OrderUpdateManyWithoutUserNestedInput>;

export const CartUpdateOneWithoutUserNestedInputSchema: z.ZodType<Prisma.CartUpdateOneWithoutUserNestedInput> =
  z
    .object({
      create: z
        .union([
          z.lazy(() => CartCreateWithoutUserInputSchema),
          z.lazy(() => CartUncheckedCreateWithoutUserInputSchema),
        ])
        .optional(),
      connectOrCreate: z
        .lazy(() => CartCreateOrConnectWithoutUserInputSchema)
        .optional(),
      upsert: z.lazy(() => CartUpsertWithoutUserInputSchema).optional(),
      disconnect: z
        .union([z.boolean(), z.lazy(() => CartWhereInputSchema)])
        .optional(),
      delete: z
        .union([z.boolean(), z.lazy(() => CartWhereInputSchema)])
        .optional(),
      connect: z.lazy(() => CartWhereUniqueInputSchema).optional(),
      update: z
        .union([
          z.lazy(() => CartUpdateToOneWithWhereWithoutUserInputSchema),
          z.lazy(() => CartUpdateWithoutUserInputSchema),
          z.lazy(() => CartUncheckedUpdateWithoutUserInputSchema),
        ])
        .optional(),
    })
    .strict() as z.ZodType<Prisma.CartUpdateOneWithoutUserNestedInput>;

export const NotificationUpdateManyWithoutUserNestedInputSchema: z.ZodType<Prisma.NotificationUpdateManyWithoutUserNestedInput> =
  z
    .object({
      create: z
        .union([
          z.lazy(() => NotificationCreateWithoutUserInputSchema),
          z.lazy(() => NotificationCreateWithoutUserInputSchema).array(),
          z.lazy(() => NotificationUncheckedCreateWithoutUserInputSchema),
          z
            .lazy(() => NotificationUncheckedCreateWithoutUserInputSchema)
            .array(),
        ])
        .optional(),
      connectOrCreate: z
        .union([
          z.lazy(() => NotificationCreateOrConnectWithoutUserInputSchema),
          z
            .lazy(() => NotificationCreateOrConnectWithoutUserInputSchema)
            .array(),
        ])
        .optional(),
      upsert: z
        .union([
          z.lazy(() => NotificationUpsertWithWhereUniqueWithoutUserInputSchema),
          z
            .lazy(() => NotificationUpsertWithWhereUniqueWithoutUserInputSchema)
            .array(),
        ])
        .optional(),
      createMany: z
        .lazy(() => NotificationCreateManyUserInputEnvelopeSchema)
        .optional(),
      set: z
        .union([
          z.lazy(() => NotificationWhereUniqueInputSchema),
          z.lazy(() => NotificationWhereUniqueInputSchema).array(),
        ])
        .optional(),
      disconnect: z
        .union([
          z.lazy(() => NotificationWhereUniqueInputSchema),
          z.lazy(() => NotificationWhereUniqueInputSchema).array(),
        ])
        .optional(),
      delete: z
        .union([
          z.lazy(() => NotificationWhereUniqueInputSchema),
          z.lazy(() => NotificationWhereUniqueInputSchema).array(),
        ])
        .optional(),
      connect: z
        .union([
          z.lazy(() => NotificationWhereUniqueInputSchema),
          z.lazy(() => NotificationWhereUniqueInputSchema).array(),
        ])
        .optional(),
      update: z
        .union([
          z.lazy(() => NotificationUpdateWithWhereUniqueWithoutUserInputSchema),
          z
            .lazy(() => NotificationUpdateWithWhereUniqueWithoutUserInputSchema)
            .array(),
        ])
        .optional(),
      updateMany: z
        .union([
          z.lazy(() => NotificationUpdateManyWithWhereWithoutUserInputSchema),
          z
            .lazy(() => NotificationUpdateManyWithWhereWithoutUserInputSchema)
            .array(),
        ])
        .optional(),
      deleteMany: z
        .union([
          z.lazy(() => NotificationScalarWhereInputSchema),
          z.lazy(() => NotificationScalarWhereInputSchema).array(),
        ])
        .optional(),
    })
    .strict() as z.ZodType<Prisma.NotificationUpdateManyWithoutUserNestedInput>;

export const VendorUncheckedUpdateManyWithoutUserNestedInputSchema: z.ZodType<Prisma.VendorUncheckedUpdateManyWithoutUserNestedInput> =
  z
    .object({
      create: z
        .union([
          z.lazy(() => VendorCreateWithoutUserInputSchema),
          z.lazy(() => VendorCreateWithoutUserInputSchema).array(),
          z.lazy(() => VendorUncheckedCreateWithoutUserInputSchema),
          z.lazy(() => VendorUncheckedCreateWithoutUserInputSchema).array(),
        ])
        .optional(),
      connectOrCreate: z
        .union([
          z.lazy(() => VendorCreateOrConnectWithoutUserInputSchema),
          z.lazy(() => VendorCreateOrConnectWithoutUserInputSchema).array(),
        ])
        .optional(),
      upsert: z
        .union([
          z.lazy(() => VendorUpsertWithWhereUniqueWithoutUserInputSchema),
          z
            .lazy(() => VendorUpsertWithWhereUniqueWithoutUserInputSchema)
            .array(),
        ])
        .optional(),
      createMany: z
        .lazy(() => VendorCreateManyUserInputEnvelopeSchema)
        .optional(),
      set: z
        .union([
          z.lazy(() => VendorWhereUniqueInputSchema),
          z.lazy(() => VendorWhereUniqueInputSchema).array(),
        ])
        .optional(),
      disconnect: z
        .union([
          z.lazy(() => VendorWhereUniqueInputSchema),
          z.lazy(() => VendorWhereUniqueInputSchema).array(),
        ])
        .optional(),
      delete: z
        .union([
          z.lazy(() => VendorWhereUniqueInputSchema),
          z.lazy(() => VendorWhereUniqueInputSchema).array(),
        ])
        .optional(),
      connect: z
        .union([
          z.lazy(() => VendorWhereUniqueInputSchema),
          z.lazy(() => VendorWhereUniqueInputSchema).array(),
        ])
        .optional(),
      update: z
        .union([
          z.lazy(() => VendorUpdateWithWhereUniqueWithoutUserInputSchema),
          z
            .lazy(() => VendorUpdateWithWhereUniqueWithoutUserInputSchema)
            .array(),
        ])
        .optional(),
      updateMany: z
        .union([
          z.lazy(() => VendorUpdateManyWithWhereWithoutUserInputSchema),
          z.lazy(() => VendorUpdateManyWithWhereWithoutUserInputSchema).array(),
        ])
        .optional(),
      deleteMany: z
        .union([
          z.lazy(() => VendorScalarWhereInputSchema),
          z.lazy(() => VendorScalarWhereInputSchema).array(),
        ])
        .optional(),
    })
    .strict() as z.ZodType<Prisma.VendorUncheckedUpdateManyWithoutUserNestedInput>;

export const UserVendorRoleUncheckedUpdateManyWithoutUserNestedInputSchema: z.ZodType<Prisma.UserVendorRoleUncheckedUpdateManyWithoutUserNestedInput> =
  z
    .object({
      create: z
        .union([
          z.lazy(() => UserVendorRoleCreateWithoutUserInputSchema),
          z.lazy(() => UserVendorRoleCreateWithoutUserInputSchema).array(),
          z.lazy(() => UserVendorRoleUncheckedCreateWithoutUserInputSchema),
          z
            .lazy(() => UserVendorRoleUncheckedCreateWithoutUserInputSchema)
            .array(),
        ])
        .optional(),
      connectOrCreate: z
        .union([
          z.lazy(() => UserVendorRoleCreateOrConnectWithoutUserInputSchema),
          z
            .lazy(() => UserVendorRoleCreateOrConnectWithoutUserInputSchema)
            .array(),
        ])
        .optional(),
      upsert: z
        .union([
          z.lazy(
            () => UserVendorRoleUpsertWithWhereUniqueWithoutUserInputSchema,
          ),
          z
            .lazy(
              () => UserVendorRoleUpsertWithWhereUniqueWithoutUserInputSchema,
            )
            .array(),
        ])
        .optional(),
      createMany: z
        .lazy(() => UserVendorRoleCreateManyUserInputEnvelopeSchema)
        .optional(),
      set: z
        .union([
          z.lazy(() => UserVendorRoleWhereUniqueInputSchema),
          z.lazy(() => UserVendorRoleWhereUniqueInputSchema).array(),
        ])
        .optional(),
      disconnect: z
        .union([
          z.lazy(() => UserVendorRoleWhereUniqueInputSchema),
          z.lazy(() => UserVendorRoleWhereUniqueInputSchema).array(),
        ])
        .optional(),
      delete: z
        .union([
          z.lazy(() => UserVendorRoleWhereUniqueInputSchema),
          z.lazy(() => UserVendorRoleWhereUniqueInputSchema).array(),
        ])
        .optional(),
      connect: z
        .union([
          z.lazy(() => UserVendorRoleWhereUniqueInputSchema),
          z.lazy(() => UserVendorRoleWhereUniqueInputSchema).array(),
        ])
        .optional(),
      update: z
        .union([
          z.lazy(
            () => UserVendorRoleUpdateWithWhereUniqueWithoutUserInputSchema,
          ),
          z
            .lazy(
              () => UserVendorRoleUpdateWithWhereUniqueWithoutUserInputSchema,
            )
            .array(),
        ])
        .optional(),
      updateMany: z
        .union([
          z.lazy(() => UserVendorRoleUpdateManyWithWhereWithoutUserInputSchema),
          z
            .lazy(() => UserVendorRoleUpdateManyWithWhereWithoutUserInputSchema)
            .array(),
        ])
        .optional(),
      deleteMany: z
        .union([
          z.lazy(() => UserVendorRoleScalarWhereInputSchema),
          z.lazy(() => UserVendorRoleScalarWhereInputSchema).array(),
        ])
        .optional(),
    })
    .strict() as z.ZodType<Prisma.UserVendorRoleUncheckedUpdateManyWithoutUserNestedInput>;

export const OrderUncheckedUpdateManyWithoutUserNestedInputSchema: z.ZodType<Prisma.OrderUncheckedUpdateManyWithoutUserNestedInput> =
  z
    .object({
      create: z
        .union([
          z.lazy(() => OrderCreateWithoutUserInputSchema),
          z.lazy(() => OrderCreateWithoutUserInputSchema).array(),
          z.lazy(() => OrderUncheckedCreateWithoutUserInputSchema),
          z.lazy(() => OrderUncheckedCreateWithoutUserInputSchema).array(),
        ])
        .optional(),
      connectOrCreate: z
        .union([
          z.lazy(() => OrderCreateOrConnectWithoutUserInputSchema),
          z.lazy(() => OrderCreateOrConnectWithoutUserInputSchema).array(),
        ])
        .optional(),
      upsert: z
        .union([
          z.lazy(() => OrderUpsertWithWhereUniqueWithoutUserInputSchema),
          z
            .lazy(() => OrderUpsertWithWhereUniqueWithoutUserInputSchema)
            .array(),
        ])
        .optional(),
      createMany: z
        .lazy(() => OrderCreateManyUserInputEnvelopeSchema)
        .optional(),
      set: z
        .union([
          z.lazy(() => OrderWhereUniqueInputSchema),
          z.lazy(() => OrderWhereUniqueInputSchema).array(),
        ])
        .optional(),
      disconnect: z
        .union([
          z.lazy(() => OrderWhereUniqueInputSchema),
          z.lazy(() => OrderWhereUniqueInputSchema).array(),
        ])
        .optional(),
      delete: z
        .union([
          z.lazy(() => OrderWhereUniqueInputSchema),
          z.lazy(() => OrderWhereUniqueInputSchema).array(),
        ])
        .optional(),
      connect: z
        .union([
          z.lazy(() => OrderWhereUniqueInputSchema),
          z.lazy(() => OrderWhereUniqueInputSchema).array(),
        ])
        .optional(),
      update: z
        .union([
          z.lazy(() => OrderUpdateWithWhereUniqueWithoutUserInputSchema),
          z
            .lazy(() => OrderUpdateWithWhereUniqueWithoutUserInputSchema)
            .array(),
        ])
        .optional(),
      updateMany: z
        .union([
          z.lazy(() => OrderUpdateManyWithWhereWithoutUserInputSchema),
          z.lazy(() => OrderUpdateManyWithWhereWithoutUserInputSchema).array(),
        ])
        .optional(),
      deleteMany: z
        .union([
          z.lazy(() => OrderScalarWhereInputSchema),
          z.lazy(() => OrderScalarWhereInputSchema).array(),
        ])
        .optional(),
    })
    .strict() as z.ZodType<Prisma.OrderUncheckedUpdateManyWithoutUserNestedInput>;

export const CartUncheckedUpdateOneWithoutUserNestedInputSchema: z.ZodType<Prisma.CartUncheckedUpdateOneWithoutUserNestedInput> =
  z
    .object({
      create: z
        .union([
          z.lazy(() => CartCreateWithoutUserInputSchema),
          z.lazy(() => CartUncheckedCreateWithoutUserInputSchema),
        ])
        .optional(),
      connectOrCreate: z
        .lazy(() => CartCreateOrConnectWithoutUserInputSchema)
        .optional(),
      upsert: z.lazy(() => CartUpsertWithoutUserInputSchema).optional(),
      disconnect: z
        .union([z.boolean(), z.lazy(() => CartWhereInputSchema)])
        .optional(),
      delete: z
        .union([z.boolean(), z.lazy(() => CartWhereInputSchema)])
        .optional(),
      connect: z.lazy(() => CartWhereUniqueInputSchema).optional(),
      update: z
        .union([
          z.lazy(() => CartUpdateToOneWithWhereWithoutUserInputSchema),
          z.lazy(() => CartUpdateWithoutUserInputSchema),
          z.lazy(() => CartUncheckedUpdateWithoutUserInputSchema),
        ])
        .optional(),
    })
    .strict() as z.ZodType<Prisma.CartUncheckedUpdateOneWithoutUserNestedInput>;

export const NotificationUncheckedUpdateManyWithoutUserNestedInputSchema: z.ZodType<Prisma.NotificationUncheckedUpdateManyWithoutUserNestedInput> =
  z
    .object({
      create: z
        .union([
          z.lazy(() => NotificationCreateWithoutUserInputSchema),
          z.lazy(() => NotificationCreateWithoutUserInputSchema).array(),
          z.lazy(() => NotificationUncheckedCreateWithoutUserInputSchema),
          z
            .lazy(() => NotificationUncheckedCreateWithoutUserInputSchema)
            .array(),
        ])
        .optional(),
      connectOrCreate: z
        .union([
          z.lazy(() => NotificationCreateOrConnectWithoutUserInputSchema),
          z
            .lazy(() => NotificationCreateOrConnectWithoutUserInputSchema)
            .array(),
        ])
        .optional(),
      upsert: z
        .union([
          z.lazy(() => NotificationUpsertWithWhereUniqueWithoutUserInputSchema),
          z
            .lazy(() => NotificationUpsertWithWhereUniqueWithoutUserInputSchema)
            .array(),
        ])
        .optional(),
      createMany: z
        .lazy(() => NotificationCreateManyUserInputEnvelopeSchema)
        .optional(),
      set: z
        .union([
          z.lazy(() => NotificationWhereUniqueInputSchema),
          z.lazy(() => NotificationWhereUniqueInputSchema).array(),
        ])
        .optional(),
      disconnect: z
        .union([
          z.lazy(() => NotificationWhereUniqueInputSchema),
          z.lazy(() => NotificationWhereUniqueInputSchema).array(),
        ])
        .optional(),
      delete: z
        .union([
          z.lazy(() => NotificationWhereUniqueInputSchema),
          z.lazy(() => NotificationWhereUniqueInputSchema).array(),
        ])
        .optional(),
      connect: z
        .union([
          z.lazy(() => NotificationWhereUniqueInputSchema),
          z.lazy(() => NotificationWhereUniqueInputSchema).array(),
        ])
        .optional(),
      update: z
        .union([
          z.lazy(() => NotificationUpdateWithWhereUniqueWithoutUserInputSchema),
          z
            .lazy(() => NotificationUpdateWithWhereUniqueWithoutUserInputSchema)
            .array(),
        ])
        .optional(),
      updateMany: z
        .union([
          z.lazy(() => NotificationUpdateManyWithWhereWithoutUserInputSchema),
          z
            .lazy(() => NotificationUpdateManyWithWhereWithoutUserInputSchema)
            .array(),
        ])
        .optional(),
      deleteMany: z
        .union([
          z.lazy(() => NotificationScalarWhereInputSchema),
          z.lazy(() => NotificationScalarWhereInputSchema).array(),
        ])
        .optional(),
    })
    .strict() as z.ZodType<Prisma.NotificationUncheckedUpdateManyWithoutUserNestedInput>;

export const UserCreateNestedOneWithoutVendorsInputSchema: z.ZodType<Prisma.UserCreateNestedOneWithoutVendorsInput> =
  z
    .object({
      create: z
        .union([
          z.lazy(() => UserCreateWithoutVendorsInputSchema),
          z.lazy(() => UserUncheckedCreateWithoutVendorsInputSchema),
        ])
        .optional(),
      connectOrCreate: z
        .lazy(() => UserCreateOrConnectWithoutVendorsInputSchema)
        .optional(),
      connect: z.lazy(() => UserWhereUniqueInputSchema).optional(),
    })
    .strict() as z.ZodType<Prisma.UserCreateNestedOneWithoutVendorsInput>;

export const ProductCreateNestedManyWithoutVendorInputSchema: z.ZodType<Prisma.ProductCreateNestedManyWithoutVendorInput> =
  z
    .object({
      create: z
        .union([
          z.lazy(() => ProductCreateWithoutVendorInputSchema),
          z.lazy(() => ProductCreateWithoutVendorInputSchema).array(),
          z.lazy(() => ProductUncheckedCreateWithoutVendorInputSchema),
          z.lazy(() => ProductUncheckedCreateWithoutVendorInputSchema).array(),
        ])
        .optional(),
      connectOrCreate: z
        .union([
          z.lazy(() => ProductCreateOrConnectWithoutVendorInputSchema),
          z.lazy(() => ProductCreateOrConnectWithoutVendorInputSchema).array(),
        ])
        .optional(),
      createMany: z
        .lazy(() => ProductCreateManyVendorInputEnvelopeSchema)
        .optional(),
      connect: z
        .union([
          z.lazy(() => ProductWhereUniqueInputSchema),
          z.lazy(() => ProductWhereUniqueInputSchema).array(),
        ])
        .optional(),
    })
    .strict() as z.ZodType<Prisma.ProductCreateNestedManyWithoutVendorInput>;

export const UserVendorRoleCreateNestedManyWithoutVendorInputSchema: z.ZodType<Prisma.UserVendorRoleCreateNestedManyWithoutVendorInput> =
  z
    .object({
      create: z
        .union([
          z.lazy(() => UserVendorRoleCreateWithoutVendorInputSchema),
          z.lazy(() => UserVendorRoleCreateWithoutVendorInputSchema).array(),
          z.lazy(() => UserVendorRoleUncheckedCreateWithoutVendorInputSchema),
          z
            .lazy(() => UserVendorRoleUncheckedCreateWithoutVendorInputSchema)
            .array(),
        ])
        .optional(),
      connectOrCreate: z
        .union([
          z.lazy(() => UserVendorRoleCreateOrConnectWithoutVendorInputSchema),
          z
            .lazy(() => UserVendorRoleCreateOrConnectWithoutVendorInputSchema)
            .array(),
        ])
        .optional(),
      createMany: z
        .lazy(() => UserVendorRoleCreateManyVendorInputEnvelopeSchema)
        .optional(),
      connect: z
        .union([
          z.lazy(() => UserVendorRoleWhereUniqueInputSchema),
          z.lazy(() => UserVendorRoleWhereUniqueInputSchema).array(),
        ])
        .optional(),
    })
    .strict() as z.ZodType<Prisma.UserVendorRoleCreateNestedManyWithoutVendorInput>;

export const ProductUncheckedCreateNestedManyWithoutVendorInputSchema: z.ZodType<Prisma.ProductUncheckedCreateNestedManyWithoutVendorInput> =
  z
    .object({
      create: z
        .union([
          z.lazy(() => ProductCreateWithoutVendorInputSchema),
          z.lazy(() => ProductCreateWithoutVendorInputSchema).array(),
          z.lazy(() => ProductUncheckedCreateWithoutVendorInputSchema),
          z.lazy(() => ProductUncheckedCreateWithoutVendorInputSchema).array(),
        ])
        .optional(),
      connectOrCreate: z
        .union([
          z.lazy(() => ProductCreateOrConnectWithoutVendorInputSchema),
          z.lazy(() => ProductCreateOrConnectWithoutVendorInputSchema).array(),
        ])
        .optional(),
      createMany: z
        .lazy(() => ProductCreateManyVendorInputEnvelopeSchema)
        .optional(),
      connect: z
        .union([
          z.lazy(() => ProductWhereUniqueInputSchema),
          z.lazy(() => ProductWhereUniqueInputSchema).array(),
        ])
        .optional(),
    })
    .strict() as z.ZodType<Prisma.ProductUncheckedCreateNestedManyWithoutVendorInput>;

export const UserVendorRoleUncheckedCreateNestedManyWithoutVendorInputSchema: z.ZodType<Prisma.UserVendorRoleUncheckedCreateNestedManyWithoutVendorInput> =
  z
    .object({
      create: z
        .union([
          z.lazy(() => UserVendorRoleCreateWithoutVendorInputSchema),
          z.lazy(() => UserVendorRoleCreateWithoutVendorInputSchema).array(),
          z.lazy(() => UserVendorRoleUncheckedCreateWithoutVendorInputSchema),
          z
            .lazy(() => UserVendorRoleUncheckedCreateWithoutVendorInputSchema)
            .array(),
        ])
        .optional(),
      connectOrCreate: z
        .union([
          z.lazy(() => UserVendorRoleCreateOrConnectWithoutVendorInputSchema),
          z
            .lazy(() => UserVendorRoleCreateOrConnectWithoutVendorInputSchema)
            .array(),
        ])
        .optional(),
      createMany: z
        .lazy(() => UserVendorRoleCreateManyVendorInputEnvelopeSchema)
        .optional(),
      connect: z
        .union([
          z.lazy(() => UserVendorRoleWhereUniqueInputSchema),
          z.lazy(() => UserVendorRoleWhereUniqueInputSchema).array(),
        ])
        .optional(),
    })
    .strict() as z.ZodType<Prisma.UserVendorRoleUncheckedCreateNestedManyWithoutVendorInput>;

export const IntFieldUpdateOperationsInputSchema: z.ZodType<Prisma.IntFieldUpdateOperationsInput> =
  z
    .object({
      set: z.number().optional(),
      increment: z.number().optional(),
      decrement: z.number().optional(),
      multiply: z.number().optional(),
      divide: z.number().optional(),
    })
    .strict() as z.ZodType<Prisma.IntFieldUpdateOperationsInput>;

export const EnumVendorStatusFieldUpdateOperationsInputSchema: z.ZodType<Prisma.EnumVendorStatusFieldUpdateOperationsInput> =
  z
    .object({
      set: z.lazy(() => VendorStatusSchema).optional(),
    })
    .strict() as z.ZodType<Prisma.EnumVendorStatusFieldUpdateOperationsInput>;

export const UserUpdateOneRequiredWithoutVendorsNestedInputSchema: z.ZodType<Prisma.UserUpdateOneRequiredWithoutVendorsNestedInput> =
  z
    .object({
      create: z
        .union([
          z.lazy(() => UserCreateWithoutVendorsInputSchema),
          z.lazy(() => UserUncheckedCreateWithoutVendorsInputSchema),
        ])
        .optional(),
      connectOrCreate: z
        .lazy(() => UserCreateOrConnectWithoutVendorsInputSchema)
        .optional(),
      upsert: z.lazy(() => UserUpsertWithoutVendorsInputSchema).optional(),
      connect: z.lazy(() => UserWhereUniqueInputSchema).optional(),
      update: z
        .union([
          z.lazy(() => UserUpdateToOneWithWhereWithoutVendorsInputSchema),
          z.lazy(() => UserUpdateWithoutVendorsInputSchema),
          z.lazy(() => UserUncheckedUpdateWithoutVendorsInputSchema),
        ])
        .optional(),
    })
    .strict() as z.ZodType<Prisma.UserUpdateOneRequiredWithoutVendorsNestedInput>;

export const ProductUpdateManyWithoutVendorNestedInputSchema: z.ZodType<Prisma.ProductUpdateManyWithoutVendorNestedInput> =
  z
    .object({
      create: z
        .union([
          z.lazy(() => ProductCreateWithoutVendorInputSchema),
          z.lazy(() => ProductCreateWithoutVendorInputSchema).array(),
          z.lazy(() => ProductUncheckedCreateWithoutVendorInputSchema),
          z.lazy(() => ProductUncheckedCreateWithoutVendorInputSchema).array(),
        ])
        .optional(),
      connectOrCreate: z
        .union([
          z.lazy(() => ProductCreateOrConnectWithoutVendorInputSchema),
          z.lazy(() => ProductCreateOrConnectWithoutVendorInputSchema).array(),
        ])
        .optional(),
      upsert: z
        .union([
          z.lazy(() => ProductUpsertWithWhereUniqueWithoutVendorInputSchema),
          z
            .lazy(() => ProductUpsertWithWhereUniqueWithoutVendorInputSchema)
            .array(),
        ])
        .optional(),
      createMany: z
        .lazy(() => ProductCreateManyVendorInputEnvelopeSchema)
        .optional(),
      set: z
        .union([
          z.lazy(() => ProductWhereUniqueInputSchema),
          z.lazy(() => ProductWhereUniqueInputSchema).array(),
        ])
        .optional(),
      disconnect: z
        .union([
          z.lazy(() => ProductWhereUniqueInputSchema),
          z.lazy(() => ProductWhereUniqueInputSchema).array(),
        ])
        .optional(),
      delete: z
        .union([
          z.lazy(() => ProductWhereUniqueInputSchema),
          z.lazy(() => ProductWhereUniqueInputSchema).array(),
        ])
        .optional(),
      connect: z
        .union([
          z.lazy(() => ProductWhereUniqueInputSchema),
          z.lazy(() => ProductWhereUniqueInputSchema).array(),
        ])
        .optional(),
      update: z
        .union([
          z.lazy(() => ProductUpdateWithWhereUniqueWithoutVendorInputSchema),
          z
            .lazy(() => ProductUpdateWithWhereUniqueWithoutVendorInputSchema)
            .array(),
        ])
        .optional(),
      updateMany: z
        .union([
          z.lazy(() => ProductUpdateManyWithWhereWithoutVendorInputSchema),
          z
            .lazy(() => ProductUpdateManyWithWhereWithoutVendorInputSchema)
            .array(),
        ])
        .optional(),
      deleteMany: z
        .union([
          z.lazy(() => ProductScalarWhereInputSchema),
          z.lazy(() => ProductScalarWhereInputSchema).array(),
        ])
        .optional(),
    })
    .strict() as z.ZodType<Prisma.ProductUpdateManyWithoutVendorNestedInput>;

export const UserVendorRoleUpdateManyWithoutVendorNestedInputSchema: z.ZodType<Prisma.UserVendorRoleUpdateManyWithoutVendorNestedInput> =
  z
    .object({
      create: z
        .union([
          z.lazy(() => UserVendorRoleCreateWithoutVendorInputSchema),
          z.lazy(() => UserVendorRoleCreateWithoutVendorInputSchema).array(),
          z.lazy(() => UserVendorRoleUncheckedCreateWithoutVendorInputSchema),
          z
            .lazy(() => UserVendorRoleUncheckedCreateWithoutVendorInputSchema)
            .array(),
        ])
        .optional(),
      connectOrCreate: z
        .union([
          z.lazy(() => UserVendorRoleCreateOrConnectWithoutVendorInputSchema),
          z
            .lazy(() => UserVendorRoleCreateOrConnectWithoutVendorInputSchema)
            .array(),
        ])
        .optional(),
      upsert: z
        .union([
          z.lazy(
            () => UserVendorRoleUpsertWithWhereUniqueWithoutVendorInputSchema,
          ),
          z
            .lazy(
              () => UserVendorRoleUpsertWithWhereUniqueWithoutVendorInputSchema,
            )
            .array(),
        ])
        .optional(),
      createMany: z
        .lazy(() => UserVendorRoleCreateManyVendorInputEnvelopeSchema)
        .optional(),
      set: z
        .union([
          z.lazy(() => UserVendorRoleWhereUniqueInputSchema),
          z.lazy(() => UserVendorRoleWhereUniqueInputSchema).array(),
        ])
        .optional(),
      disconnect: z
        .union([
          z.lazy(() => UserVendorRoleWhereUniqueInputSchema),
          z.lazy(() => UserVendorRoleWhereUniqueInputSchema).array(),
        ])
        .optional(),
      delete: z
        .union([
          z.lazy(() => UserVendorRoleWhereUniqueInputSchema),
          z.lazy(() => UserVendorRoleWhereUniqueInputSchema).array(),
        ])
        .optional(),
      connect: z
        .union([
          z.lazy(() => UserVendorRoleWhereUniqueInputSchema),
          z.lazy(() => UserVendorRoleWhereUniqueInputSchema).array(),
        ])
        .optional(),
      update: z
        .union([
          z.lazy(
            () => UserVendorRoleUpdateWithWhereUniqueWithoutVendorInputSchema,
          ),
          z
            .lazy(
              () => UserVendorRoleUpdateWithWhereUniqueWithoutVendorInputSchema,
            )
            .array(),
        ])
        .optional(),
      updateMany: z
        .union([
          z.lazy(
            () => UserVendorRoleUpdateManyWithWhereWithoutVendorInputSchema,
          ),
          z
            .lazy(
              () => UserVendorRoleUpdateManyWithWhereWithoutVendorInputSchema,
            )
            .array(),
        ])
        .optional(),
      deleteMany: z
        .union([
          z.lazy(() => UserVendorRoleScalarWhereInputSchema),
          z.lazy(() => UserVendorRoleScalarWhereInputSchema).array(),
        ])
        .optional(),
    })
    .strict() as z.ZodType<Prisma.UserVendorRoleUpdateManyWithoutVendorNestedInput>;

export const ProductUncheckedUpdateManyWithoutVendorNestedInputSchema: z.ZodType<Prisma.ProductUncheckedUpdateManyWithoutVendorNestedInput> =
  z
    .object({
      create: z
        .union([
          z.lazy(() => ProductCreateWithoutVendorInputSchema),
          z.lazy(() => ProductCreateWithoutVendorInputSchema).array(),
          z.lazy(() => ProductUncheckedCreateWithoutVendorInputSchema),
          z.lazy(() => ProductUncheckedCreateWithoutVendorInputSchema).array(),
        ])
        .optional(),
      connectOrCreate: z
        .union([
          z.lazy(() => ProductCreateOrConnectWithoutVendorInputSchema),
          z.lazy(() => ProductCreateOrConnectWithoutVendorInputSchema).array(),
        ])
        .optional(),
      upsert: z
        .union([
          z.lazy(() => ProductUpsertWithWhereUniqueWithoutVendorInputSchema),
          z
            .lazy(() => ProductUpsertWithWhereUniqueWithoutVendorInputSchema)
            .array(),
        ])
        .optional(),
      createMany: z
        .lazy(() => ProductCreateManyVendorInputEnvelopeSchema)
        .optional(),
      set: z
        .union([
          z.lazy(() => ProductWhereUniqueInputSchema),
          z.lazy(() => ProductWhereUniqueInputSchema).array(),
        ])
        .optional(),
      disconnect: z
        .union([
          z.lazy(() => ProductWhereUniqueInputSchema),
          z.lazy(() => ProductWhereUniqueInputSchema).array(),
        ])
        .optional(),
      delete: z
        .union([
          z.lazy(() => ProductWhereUniqueInputSchema),
          z.lazy(() => ProductWhereUniqueInputSchema).array(),
        ])
        .optional(),
      connect: z
        .union([
          z.lazy(() => ProductWhereUniqueInputSchema),
          z.lazy(() => ProductWhereUniqueInputSchema).array(),
        ])
        .optional(),
      update: z
        .union([
          z.lazy(() => ProductUpdateWithWhereUniqueWithoutVendorInputSchema),
          z
            .lazy(() => ProductUpdateWithWhereUniqueWithoutVendorInputSchema)
            .array(),
        ])
        .optional(),
      updateMany: z
        .union([
          z.lazy(() => ProductUpdateManyWithWhereWithoutVendorInputSchema),
          z
            .lazy(() => ProductUpdateManyWithWhereWithoutVendorInputSchema)
            .array(),
        ])
        .optional(),
      deleteMany: z
        .union([
          z.lazy(() => ProductScalarWhereInputSchema),
          z.lazy(() => ProductScalarWhereInputSchema).array(),
        ])
        .optional(),
    })
    .strict() as z.ZodType<Prisma.ProductUncheckedUpdateManyWithoutVendorNestedInput>;

export const UserVendorRoleUncheckedUpdateManyWithoutVendorNestedInputSchema: z.ZodType<Prisma.UserVendorRoleUncheckedUpdateManyWithoutVendorNestedInput> =
  z
    .object({
      create: z
        .union([
          z.lazy(() => UserVendorRoleCreateWithoutVendorInputSchema),
          z.lazy(() => UserVendorRoleCreateWithoutVendorInputSchema).array(),
          z.lazy(() => UserVendorRoleUncheckedCreateWithoutVendorInputSchema),
          z
            .lazy(() => UserVendorRoleUncheckedCreateWithoutVendorInputSchema)
            .array(),
        ])
        .optional(),
      connectOrCreate: z
        .union([
          z.lazy(() => UserVendorRoleCreateOrConnectWithoutVendorInputSchema),
          z
            .lazy(() => UserVendorRoleCreateOrConnectWithoutVendorInputSchema)
            .array(),
        ])
        .optional(),
      upsert: z
        .union([
          z.lazy(
            () => UserVendorRoleUpsertWithWhereUniqueWithoutVendorInputSchema,
          ),
          z
            .lazy(
              () => UserVendorRoleUpsertWithWhereUniqueWithoutVendorInputSchema,
            )
            .array(),
        ])
        .optional(),
      createMany: z
        .lazy(() => UserVendorRoleCreateManyVendorInputEnvelopeSchema)
        .optional(),
      set: z
        .union([
          z.lazy(() => UserVendorRoleWhereUniqueInputSchema),
          z.lazy(() => UserVendorRoleWhereUniqueInputSchema).array(),
        ])
        .optional(),
      disconnect: z
        .union([
          z.lazy(() => UserVendorRoleWhereUniqueInputSchema),
          z.lazy(() => UserVendorRoleWhereUniqueInputSchema).array(),
        ])
        .optional(),
      delete: z
        .union([
          z.lazy(() => UserVendorRoleWhereUniqueInputSchema),
          z.lazy(() => UserVendorRoleWhereUniqueInputSchema).array(),
        ])
        .optional(),
      connect: z
        .union([
          z.lazy(() => UserVendorRoleWhereUniqueInputSchema),
          z.lazy(() => UserVendorRoleWhereUniqueInputSchema).array(),
        ])
        .optional(),
      update: z
        .union([
          z.lazy(
            () => UserVendorRoleUpdateWithWhereUniqueWithoutVendorInputSchema,
          ),
          z
            .lazy(
              () => UserVendorRoleUpdateWithWhereUniqueWithoutVendorInputSchema,
            )
            .array(),
        ])
        .optional(),
      updateMany: z
        .union([
          z.lazy(
            () => UserVendorRoleUpdateManyWithWhereWithoutVendorInputSchema,
          ),
          z
            .lazy(
              () => UserVendorRoleUpdateManyWithWhereWithoutVendorInputSchema,
            )
            .array(),
        ])
        .optional(),
      deleteMany: z
        .union([
          z.lazy(() => UserVendorRoleScalarWhereInputSchema),
          z.lazy(() => UserVendorRoleScalarWhereInputSchema).array(),
        ])
        .optional(),
    })
    .strict() as z.ZodType<Prisma.UserVendorRoleUncheckedUpdateManyWithoutVendorNestedInput>;

export const UserVendorRoleCreateNestedManyWithoutRoleInputSchema: z.ZodType<Prisma.UserVendorRoleCreateNestedManyWithoutRoleInput> =
  z
    .object({
      create: z
        .union([
          z.lazy(() => UserVendorRoleCreateWithoutRoleInputSchema),
          z.lazy(() => UserVendorRoleCreateWithoutRoleInputSchema).array(),
          z.lazy(() => UserVendorRoleUncheckedCreateWithoutRoleInputSchema),
          z
            .lazy(() => UserVendorRoleUncheckedCreateWithoutRoleInputSchema)
            .array(),
        ])
        .optional(),
      connectOrCreate: z
        .union([
          z.lazy(() => UserVendorRoleCreateOrConnectWithoutRoleInputSchema),
          z
            .lazy(() => UserVendorRoleCreateOrConnectWithoutRoleInputSchema)
            .array(),
        ])
        .optional(),
      createMany: z
        .lazy(() => UserVendorRoleCreateManyRoleInputEnvelopeSchema)
        .optional(),
      connect: z
        .union([
          z.lazy(() => UserVendorRoleWhereUniqueInputSchema),
          z.lazy(() => UserVendorRoleWhereUniqueInputSchema).array(),
        ])
        .optional(),
    })
    .strict() as z.ZodType<Prisma.UserVendorRoleCreateNestedManyWithoutRoleInput>;

export const RolePermissionCreateNestedManyWithoutRoleInputSchema: z.ZodType<Prisma.RolePermissionCreateNestedManyWithoutRoleInput> =
  z
    .object({
      create: z
        .union([
          z.lazy(() => RolePermissionCreateWithoutRoleInputSchema),
          z.lazy(() => RolePermissionCreateWithoutRoleInputSchema).array(),
          z.lazy(() => RolePermissionUncheckedCreateWithoutRoleInputSchema),
          z
            .lazy(() => RolePermissionUncheckedCreateWithoutRoleInputSchema)
            .array(),
        ])
        .optional(),
      connectOrCreate: z
        .union([
          z.lazy(() => RolePermissionCreateOrConnectWithoutRoleInputSchema),
          z
            .lazy(() => RolePermissionCreateOrConnectWithoutRoleInputSchema)
            .array(),
        ])
        .optional(),
      createMany: z
        .lazy(() => RolePermissionCreateManyRoleInputEnvelopeSchema)
        .optional(),
      connect: z
        .union([
          z.lazy(() => RolePermissionWhereUniqueInputSchema),
          z.lazy(() => RolePermissionWhereUniqueInputSchema).array(),
        ])
        .optional(),
    })
    .strict() as z.ZodType<Prisma.RolePermissionCreateNestedManyWithoutRoleInput>;

export const UserVendorRoleUncheckedCreateNestedManyWithoutRoleInputSchema: z.ZodType<Prisma.UserVendorRoleUncheckedCreateNestedManyWithoutRoleInput> =
  z
    .object({
      create: z
        .union([
          z.lazy(() => UserVendorRoleCreateWithoutRoleInputSchema),
          z.lazy(() => UserVendorRoleCreateWithoutRoleInputSchema).array(),
          z.lazy(() => UserVendorRoleUncheckedCreateWithoutRoleInputSchema),
          z
            .lazy(() => UserVendorRoleUncheckedCreateWithoutRoleInputSchema)
            .array(),
        ])
        .optional(),
      connectOrCreate: z
        .union([
          z.lazy(() => UserVendorRoleCreateOrConnectWithoutRoleInputSchema),
          z
            .lazy(() => UserVendorRoleCreateOrConnectWithoutRoleInputSchema)
            .array(),
        ])
        .optional(),
      createMany: z
        .lazy(() => UserVendorRoleCreateManyRoleInputEnvelopeSchema)
        .optional(),
      connect: z
        .union([
          z.lazy(() => UserVendorRoleWhereUniqueInputSchema),
          z.lazy(() => UserVendorRoleWhereUniqueInputSchema).array(),
        ])
        .optional(),
    })
    .strict() as z.ZodType<Prisma.UserVendorRoleUncheckedCreateNestedManyWithoutRoleInput>;

export const RolePermissionUncheckedCreateNestedManyWithoutRoleInputSchema: z.ZodType<Prisma.RolePermissionUncheckedCreateNestedManyWithoutRoleInput> =
  z
    .object({
      create: z
        .union([
          z.lazy(() => RolePermissionCreateWithoutRoleInputSchema),
          z.lazy(() => RolePermissionCreateWithoutRoleInputSchema).array(),
          z.lazy(() => RolePermissionUncheckedCreateWithoutRoleInputSchema),
          z
            .lazy(() => RolePermissionUncheckedCreateWithoutRoleInputSchema)
            .array(),
        ])
        .optional(),
      connectOrCreate: z
        .union([
          z.lazy(() => RolePermissionCreateOrConnectWithoutRoleInputSchema),
          z
            .lazy(() => RolePermissionCreateOrConnectWithoutRoleInputSchema)
            .array(),
        ])
        .optional(),
      createMany: z
        .lazy(() => RolePermissionCreateManyRoleInputEnvelopeSchema)
        .optional(),
      connect: z
        .union([
          z.lazy(() => RolePermissionWhereUniqueInputSchema),
          z.lazy(() => RolePermissionWhereUniqueInputSchema).array(),
        ])
        .optional(),
    })
    .strict() as z.ZodType<Prisma.RolePermissionUncheckedCreateNestedManyWithoutRoleInput>;

export const BoolFieldUpdateOperationsInputSchema: z.ZodType<Prisma.BoolFieldUpdateOperationsInput> =
  z
    .object({
      set: z.boolean().optional(),
    })
    .strict() as z.ZodType<Prisma.BoolFieldUpdateOperationsInput>;

export const UserVendorRoleUpdateManyWithoutRoleNestedInputSchema: z.ZodType<Prisma.UserVendorRoleUpdateManyWithoutRoleNestedInput> =
  z
    .object({
      create: z
        .union([
          z.lazy(() => UserVendorRoleCreateWithoutRoleInputSchema),
          z.lazy(() => UserVendorRoleCreateWithoutRoleInputSchema).array(),
          z.lazy(() => UserVendorRoleUncheckedCreateWithoutRoleInputSchema),
          z
            .lazy(() => UserVendorRoleUncheckedCreateWithoutRoleInputSchema)
            .array(),
        ])
        .optional(),
      connectOrCreate: z
        .union([
          z.lazy(() => UserVendorRoleCreateOrConnectWithoutRoleInputSchema),
          z
            .lazy(() => UserVendorRoleCreateOrConnectWithoutRoleInputSchema)
            .array(),
        ])
        .optional(),
      upsert: z
        .union([
          z.lazy(
            () => UserVendorRoleUpsertWithWhereUniqueWithoutRoleInputSchema,
          ),
          z
            .lazy(
              () => UserVendorRoleUpsertWithWhereUniqueWithoutRoleInputSchema,
            )
            .array(),
        ])
        .optional(),
      createMany: z
        .lazy(() => UserVendorRoleCreateManyRoleInputEnvelopeSchema)
        .optional(),
      set: z
        .union([
          z.lazy(() => UserVendorRoleWhereUniqueInputSchema),
          z.lazy(() => UserVendorRoleWhereUniqueInputSchema).array(),
        ])
        .optional(),
      disconnect: z
        .union([
          z.lazy(() => UserVendorRoleWhereUniqueInputSchema),
          z.lazy(() => UserVendorRoleWhereUniqueInputSchema).array(),
        ])
        .optional(),
      delete: z
        .union([
          z.lazy(() => UserVendorRoleWhereUniqueInputSchema),
          z.lazy(() => UserVendorRoleWhereUniqueInputSchema).array(),
        ])
        .optional(),
      connect: z
        .union([
          z.lazy(() => UserVendorRoleWhereUniqueInputSchema),
          z.lazy(() => UserVendorRoleWhereUniqueInputSchema).array(),
        ])
        .optional(),
      update: z
        .union([
          z.lazy(
            () => UserVendorRoleUpdateWithWhereUniqueWithoutRoleInputSchema,
          ),
          z
            .lazy(
              () => UserVendorRoleUpdateWithWhereUniqueWithoutRoleInputSchema,
            )
            .array(),
        ])
        .optional(),
      updateMany: z
        .union([
          z.lazy(() => UserVendorRoleUpdateManyWithWhereWithoutRoleInputSchema),
          z
            .lazy(() => UserVendorRoleUpdateManyWithWhereWithoutRoleInputSchema)
            .array(),
        ])
        .optional(),
      deleteMany: z
        .union([
          z.lazy(() => UserVendorRoleScalarWhereInputSchema),
          z.lazy(() => UserVendorRoleScalarWhereInputSchema).array(),
        ])
        .optional(),
    })
    .strict() as z.ZodType<Prisma.UserVendorRoleUpdateManyWithoutRoleNestedInput>;

export const RolePermissionUpdateManyWithoutRoleNestedInputSchema: z.ZodType<Prisma.RolePermissionUpdateManyWithoutRoleNestedInput> =
  z
    .object({
      create: z
        .union([
          z.lazy(() => RolePermissionCreateWithoutRoleInputSchema),
          z.lazy(() => RolePermissionCreateWithoutRoleInputSchema).array(),
          z.lazy(() => RolePermissionUncheckedCreateWithoutRoleInputSchema),
          z
            .lazy(() => RolePermissionUncheckedCreateWithoutRoleInputSchema)
            .array(),
        ])
        .optional(),
      connectOrCreate: z
        .union([
          z.lazy(() => RolePermissionCreateOrConnectWithoutRoleInputSchema),
          z
            .lazy(() => RolePermissionCreateOrConnectWithoutRoleInputSchema)
            .array(),
        ])
        .optional(),
      upsert: z
        .union([
          z.lazy(
            () => RolePermissionUpsertWithWhereUniqueWithoutRoleInputSchema,
          ),
          z
            .lazy(
              () => RolePermissionUpsertWithWhereUniqueWithoutRoleInputSchema,
            )
            .array(),
        ])
        .optional(),
      createMany: z
        .lazy(() => RolePermissionCreateManyRoleInputEnvelopeSchema)
        .optional(),
      set: z
        .union([
          z.lazy(() => RolePermissionWhereUniqueInputSchema),
          z.lazy(() => RolePermissionWhereUniqueInputSchema).array(),
        ])
        .optional(),
      disconnect: z
        .union([
          z.lazy(() => RolePermissionWhereUniqueInputSchema),
          z.lazy(() => RolePermissionWhereUniqueInputSchema).array(),
        ])
        .optional(),
      delete: z
        .union([
          z.lazy(() => RolePermissionWhereUniqueInputSchema),
          z.lazy(() => RolePermissionWhereUniqueInputSchema).array(),
        ])
        .optional(),
      connect: z
        .union([
          z.lazy(() => RolePermissionWhereUniqueInputSchema),
          z.lazy(() => RolePermissionWhereUniqueInputSchema).array(),
        ])
        .optional(),
      update: z
        .union([
          z.lazy(
            () => RolePermissionUpdateWithWhereUniqueWithoutRoleInputSchema,
          ),
          z
            .lazy(
              () => RolePermissionUpdateWithWhereUniqueWithoutRoleInputSchema,
            )
            .array(),
        ])
        .optional(),
      updateMany: z
        .union([
          z.lazy(() => RolePermissionUpdateManyWithWhereWithoutRoleInputSchema),
          z
            .lazy(() => RolePermissionUpdateManyWithWhereWithoutRoleInputSchema)
            .array(),
        ])
        .optional(),
      deleteMany: z
        .union([
          z.lazy(() => RolePermissionScalarWhereInputSchema),
          z.lazy(() => RolePermissionScalarWhereInputSchema).array(),
        ])
        .optional(),
    })
    .strict() as z.ZodType<Prisma.RolePermissionUpdateManyWithoutRoleNestedInput>;

export const UserVendorRoleUncheckedUpdateManyWithoutRoleNestedInputSchema: z.ZodType<Prisma.UserVendorRoleUncheckedUpdateManyWithoutRoleNestedInput> =
  z
    .object({
      create: z
        .union([
          z.lazy(() => UserVendorRoleCreateWithoutRoleInputSchema),
          z.lazy(() => UserVendorRoleCreateWithoutRoleInputSchema).array(),
          z.lazy(() => UserVendorRoleUncheckedCreateWithoutRoleInputSchema),
          z
            .lazy(() => UserVendorRoleUncheckedCreateWithoutRoleInputSchema)
            .array(),
        ])
        .optional(),
      connectOrCreate: z
        .union([
          z.lazy(() => UserVendorRoleCreateOrConnectWithoutRoleInputSchema),
          z
            .lazy(() => UserVendorRoleCreateOrConnectWithoutRoleInputSchema)
            .array(),
        ])
        .optional(),
      upsert: z
        .union([
          z.lazy(
            () => UserVendorRoleUpsertWithWhereUniqueWithoutRoleInputSchema,
          ),
          z
            .lazy(
              () => UserVendorRoleUpsertWithWhereUniqueWithoutRoleInputSchema,
            )
            .array(),
        ])
        .optional(),
      createMany: z
        .lazy(() => UserVendorRoleCreateManyRoleInputEnvelopeSchema)
        .optional(),
      set: z
        .union([
          z.lazy(() => UserVendorRoleWhereUniqueInputSchema),
          z.lazy(() => UserVendorRoleWhereUniqueInputSchema).array(),
        ])
        .optional(),
      disconnect: z
        .union([
          z.lazy(() => UserVendorRoleWhereUniqueInputSchema),
          z.lazy(() => UserVendorRoleWhereUniqueInputSchema).array(),
        ])
        .optional(),
      delete: z
        .union([
          z.lazy(() => UserVendorRoleWhereUniqueInputSchema),
          z.lazy(() => UserVendorRoleWhereUniqueInputSchema).array(),
        ])
        .optional(),
      connect: z
        .union([
          z.lazy(() => UserVendorRoleWhereUniqueInputSchema),
          z.lazy(() => UserVendorRoleWhereUniqueInputSchema).array(),
        ])
        .optional(),
      update: z
        .union([
          z.lazy(
            () => UserVendorRoleUpdateWithWhereUniqueWithoutRoleInputSchema,
          ),
          z
            .lazy(
              () => UserVendorRoleUpdateWithWhereUniqueWithoutRoleInputSchema,
            )
            .array(),
        ])
        .optional(),
      updateMany: z
        .union([
          z.lazy(() => UserVendorRoleUpdateManyWithWhereWithoutRoleInputSchema),
          z
            .lazy(() => UserVendorRoleUpdateManyWithWhereWithoutRoleInputSchema)
            .array(),
        ])
        .optional(),
      deleteMany: z
        .union([
          z.lazy(() => UserVendorRoleScalarWhereInputSchema),
          z.lazy(() => UserVendorRoleScalarWhereInputSchema).array(),
        ])
        .optional(),
    })
    .strict() as z.ZodType<Prisma.UserVendorRoleUncheckedUpdateManyWithoutRoleNestedInput>;

export const RolePermissionUncheckedUpdateManyWithoutRoleNestedInputSchema: z.ZodType<Prisma.RolePermissionUncheckedUpdateManyWithoutRoleNestedInput> =
  z
    .object({
      create: z
        .union([
          z.lazy(() => RolePermissionCreateWithoutRoleInputSchema),
          z.lazy(() => RolePermissionCreateWithoutRoleInputSchema).array(),
          z.lazy(() => RolePermissionUncheckedCreateWithoutRoleInputSchema),
          z
            .lazy(() => RolePermissionUncheckedCreateWithoutRoleInputSchema)
            .array(),
        ])
        .optional(),
      connectOrCreate: z
        .union([
          z.lazy(() => RolePermissionCreateOrConnectWithoutRoleInputSchema),
          z
            .lazy(() => RolePermissionCreateOrConnectWithoutRoleInputSchema)
            .array(),
        ])
        .optional(),
      upsert: z
        .union([
          z.lazy(
            () => RolePermissionUpsertWithWhereUniqueWithoutRoleInputSchema,
          ),
          z
            .lazy(
              () => RolePermissionUpsertWithWhereUniqueWithoutRoleInputSchema,
            )
            .array(),
        ])
        .optional(),
      createMany: z
        .lazy(() => RolePermissionCreateManyRoleInputEnvelopeSchema)
        .optional(),
      set: z
        .union([
          z.lazy(() => RolePermissionWhereUniqueInputSchema),
          z.lazy(() => RolePermissionWhereUniqueInputSchema).array(),
        ])
        .optional(),
      disconnect: z
        .union([
          z.lazy(() => RolePermissionWhereUniqueInputSchema),
          z.lazy(() => RolePermissionWhereUniqueInputSchema).array(),
        ])
        .optional(),
      delete: z
        .union([
          z.lazy(() => RolePermissionWhereUniqueInputSchema),
          z.lazy(() => RolePermissionWhereUniqueInputSchema).array(),
        ])
        .optional(),
      connect: z
        .union([
          z.lazy(() => RolePermissionWhereUniqueInputSchema),
          z.lazy(() => RolePermissionWhereUniqueInputSchema).array(),
        ])
        .optional(),
      update: z
        .union([
          z.lazy(
            () => RolePermissionUpdateWithWhereUniqueWithoutRoleInputSchema,
          ),
          z
            .lazy(
              () => RolePermissionUpdateWithWhereUniqueWithoutRoleInputSchema,
            )
            .array(),
        ])
        .optional(),
      updateMany: z
        .union([
          z.lazy(() => RolePermissionUpdateManyWithWhereWithoutRoleInputSchema),
          z
            .lazy(() => RolePermissionUpdateManyWithWhereWithoutRoleInputSchema)
            .array(),
        ])
        .optional(),
      deleteMany: z
        .union([
          z.lazy(() => RolePermissionScalarWhereInputSchema),
          z.lazy(() => RolePermissionScalarWhereInputSchema).array(),
        ])
        .optional(),
    })
    .strict() as z.ZodType<Prisma.RolePermissionUncheckedUpdateManyWithoutRoleNestedInput>;

export const RolePermissionCreateNestedManyWithoutPermissionInputSchema: z.ZodType<Prisma.RolePermissionCreateNestedManyWithoutPermissionInput> =
  z
    .object({
      create: z
        .union([
          z.lazy(() => RolePermissionCreateWithoutPermissionInputSchema),
          z
            .lazy(() => RolePermissionCreateWithoutPermissionInputSchema)
            .array(),
          z.lazy(
            () => RolePermissionUncheckedCreateWithoutPermissionInputSchema,
          ),
          z
            .lazy(
              () => RolePermissionUncheckedCreateWithoutPermissionInputSchema,
            )
            .array(),
        ])
        .optional(),
      connectOrCreate: z
        .union([
          z.lazy(
            () => RolePermissionCreateOrConnectWithoutPermissionInputSchema,
          ),
          z
            .lazy(
              () => RolePermissionCreateOrConnectWithoutPermissionInputSchema,
            )
            .array(),
        ])
        .optional(),
      createMany: z
        .lazy(() => RolePermissionCreateManyPermissionInputEnvelopeSchema)
        .optional(),
      connect: z
        .union([
          z.lazy(() => RolePermissionWhereUniqueInputSchema),
          z.lazy(() => RolePermissionWhereUniqueInputSchema).array(),
        ])
        .optional(),
    })
    .strict() as z.ZodType<Prisma.RolePermissionCreateNestedManyWithoutPermissionInput>;

export const RolePermissionUncheckedCreateNestedManyWithoutPermissionInputSchema: z.ZodType<Prisma.RolePermissionUncheckedCreateNestedManyWithoutPermissionInput> =
  z
    .object({
      create: z
        .union([
          z.lazy(() => RolePermissionCreateWithoutPermissionInputSchema),
          z
            .lazy(() => RolePermissionCreateWithoutPermissionInputSchema)
            .array(),
          z.lazy(
            () => RolePermissionUncheckedCreateWithoutPermissionInputSchema,
          ),
          z
            .lazy(
              () => RolePermissionUncheckedCreateWithoutPermissionInputSchema,
            )
            .array(),
        ])
        .optional(),
      connectOrCreate: z
        .union([
          z.lazy(
            () => RolePermissionCreateOrConnectWithoutPermissionInputSchema,
          ),
          z
            .lazy(
              () => RolePermissionCreateOrConnectWithoutPermissionInputSchema,
            )
            .array(),
        ])
        .optional(),
      createMany: z
        .lazy(() => RolePermissionCreateManyPermissionInputEnvelopeSchema)
        .optional(),
      connect: z
        .union([
          z.lazy(() => RolePermissionWhereUniqueInputSchema),
          z.lazy(() => RolePermissionWhereUniqueInputSchema).array(),
        ])
        .optional(),
    })
    .strict() as z.ZodType<Prisma.RolePermissionUncheckedCreateNestedManyWithoutPermissionInput>;

export const RolePermissionUpdateManyWithoutPermissionNestedInputSchema: z.ZodType<Prisma.RolePermissionUpdateManyWithoutPermissionNestedInput> =
  z
    .object({
      create: z
        .union([
          z.lazy(() => RolePermissionCreateWithoutPermissionInputSchema),
          z
            .lazy(() => RolePermissionCreateWithoutPermissionInputSchema)
            .array(),
          z.lazy(
            () => RolePermissionUncheckedCreateWithoutPermissionInputSchema,
          ),
          z
            .lazy(
              () => RolePermissionUncheckedCreateWithoutPermissionInputSchema,
            )
            .array(),
        ])
        .optional(),
      connectOrCreate: z
        .union([
          z.lazy(
            () => RolePermissionCreateOrConnectWithoutPermissionInputSchema,
          ),
          z
            .lazy(
              () => RolePermissionCreateOrConnectWithoutPermissionInputSchema,
            )
            .array(),
        ])
        .optional(),
      upsert: z
        .union([
          z.lazy(
            () =>
              RolePermissionUpsertWithWhereUniqueWithoutPermissionInputSchema,
          ),
          z
            .lazy(
              () =>
                RolePermissionUpsertWithWhereUniqueWithoutPermissionInputSchema,
            )
            .array(),
        ])
        .optional(),
      createMany: z
        .lazy(() => RolePermissionCreateManyPermissionInputEnvelopeSchema)
        .optional(),
      set: z
        .union([
          z.lazy(() => RolePermissionWhereUniqueInputSchema),
          z.lazy(() => RolePermissionWhereUniqueInputSchema).array(),
        ])
        .optional(),
      disconnect: z
        .union([
          z.lazy(() => RolePermissionWhereUniqueInputSchema),
          z.lazy(() => RolePermissionWhereUniqueInputSchema).array(),
        ])
        .optional(),
      delete: z
        .union([
          z.lazy(() => RolePermissionWhereUniqueInputSchema),
          z.lazy(() => RolePermissionWhereUniqueInputSchema).array(),
        ])
        .optional(),
      connect: z
        .union([
          z.lazy(() => RolePermissionWhereUniqueInputSchema),
          z.lazy(() => RolePermissionWhereUniqueInputSchema).array(),
        ])
        .optional(),
      update: z
        .union([
          z.lazy(
            () =>
              RolePermissionUpdateWithWhereUniqueWithoutPermissionInputSchema,
          ),
          z
            .lazy(
              () =>
                RolePermissionUpdateWithWhereUniqueWithoutPermissionInputSchema,
            )
            .array(),
        ])
        .optional(),
      updateMany: z
        .union([
          z.lazy(
            () => RolePermissionUpdateManyWithWhereWithoutPermissionInputSchema,
          ),
          z
            .lazy(
              () =>
                RolePermissionUpdateManyWithWhereWithoutPermissionInputSchema,
            )
            .array(),
        ])
        .optional(),
      deleteMany: z
        .union([
          z.lazy(() => RolePermissionScalarWhereInputSchema),
          z.lazy(() => RolePermissionScalarWhereInputSchema).array(),
        ])
        .optional(),
    })
    .strict() as z.ZodType<Prisma.RolePermissionUpdateManyWithoutPermissionNestedInput>;

export const RolePermissionUncheckedUpdateManyWithoutPermissionNestedInputSchema: z.ZodType<Prisma.RolePermissionUncheckedUpdateManyWithoutPermissionNestedInput> =
  z
    .object({
      create: z
        .union([
          z.lazy(() => RolePermissionCreateWithoutPermissionInputSchema),
          z
            .lazy(() => RolePermissionCreateWithoutPermissionInputSchema)
            .array(),
          z.lazy(
            () => RolePermissionUncheckedCreateWithoutPermissionInputSchema,
          ),
          z
            .lazy(
              () => RolePermissionUncheckedCreateWithoutPermissionInputSchema,
            )
            .array(),
        ])
        .optional(),
      connectOrCreate: z
        .union([
          z.lazy(
            () => RolePermissionCreateOrConnectWithoutPermissionInputSchema,
          ),
          z
            .lazy(
              () => RolePermissionCreateOrConnectWithoutPermissionInputSchema,
            )
            .array(),
        ])
        .optional(),
      upsert: z
        .union([
          z.lazy(
            () =>
              RolePermissionUpsertWithWhereUniqueWithoutPermissionInputSchema,
          ),
          z
            .lazy(
              () =>
                RolePermissionUpsertWithWhereUniqueWithoutPermissionInputSchema,
            )
            .array(),
        ])
        .optional(),
      createMany: z
        .lazy(() => RolePermissionCreateManyPermissionInputEnvelopeSchema)
        .optional(),
      set: z
        .union([
          z.lazy(() => RolePermissionWhereUniqueInputSchema),
          z.lazy(() => RolePermissionWhereUniqueInputSchema).array(),
        ])
        .optional(),
      disconnect: z
        .union([
          z.lazy(() => RolePermissionWhereUniqueInputSchema),
          z.lazy(() => RolePermissionWhereUniqueInputSchema).array(),
        ])
        .optional(),
      delete: z
        .union([
          z.lazy(() => RolePermissionWhereUniqueInputSchema),
          z.lazy(() => RolePermissionWhereUniqueInputSchema).array(),
        ])
        .optional(),
      connect: z
        .union([
          z.lazy(() => RolePermissionWhereUniqueInputSchema),
          z.lazy(() => RolePermissionWhereUniqueInputSchema).array(),
        ])
        .optional(),
      update: z
        .union([
          z.lazy(
            () =>
              RolePermissionUpdateWithWhereUniqueWithoutPermissionInputSchema,
          ),
          z
            .lazy(
              () =>
                RolePermissionUpdateWithWhereUniqueWithoutPermissionInputSchema,
            )
            .array(),
        ])
        .optional(),
      updateMany: z
        .union([
          z.lazy(
            () => RolePermissionUpdateManyWithWhereWithoutPermissionInputSchema,
          ),
          z
            .lazy(
              () =>
                RolePermissionUpdateManyWithWhereWithoutPermissionInputSchema,
            )
            .array(),
        ])
        .optional(),
      deleteMany: z
        .union([
          z.lazy(() => RolePermissionScalarWhereInputSchema),
          z.lazy(() => RolePermissionScalarWhereInputSchema).array(),
        ])
        .optional(),
    })
    .strict() as z.ZodType<Prisma.RolePermissionUncheckedUpdateManyWithoutPermissionNestedInput>;

export const RoleCreateNestedOneWithoutRolePermissionsInputSchema: z.ZodType<Prisma.RoleCreateNestedOneWithoutRolePermissionsInput> =
  z
    .object({
      create: z
        .union([
          z.lazy(() => RoleCreateWithoutRolePermissionsInputSchema),
          z.lazy(() => RoleUncheckedCreateWithoutRolePermissionsInputSchema),
        ])
        .optional(),
      connectOrCreate: z
        .lazy(() => RoleCreateOrConnectWithoutRolePermissionsInputSchema)
        .optional(),
      connect: z.lazy(() => RoleWhereUniqueInputSchema).optional(),
    })
    .strict() as z.ZodType<Prisma.RoleCreateNestedOneWithoutRolePermissionsInput>;

export const PermissionCreateNestedOneWithoutRolePermissionsInputSchema: z.ZodType<Prisma.PermissionCreateNestedOneWithoutRolePermissionsInput> =
  z
    .object({
      create: z
        .union([
          z.lazy(() => PermissionCreateWithoutRolePermissionsInputSchema),
          z.lazy(
            () => PermissionUncheckedCreateWithoutRolePermissionsInputSchema,
          ),
        ])
        .optional(),
      connectOrCreate: z
        .lazy(() => PermissionCreateOrConnectWithoutRolePermissionsInputSchema)
        .optional(),
      connect: z.lazy(() => PermissionWhereUniqueInputSchema).optional(),
    })
    .strict() as z.ZodType<Prisma.PermissionCreateNestedOneWithoutRolePermissionsInput>;

export const RoleUpdateOneRequiredWithoutRolePermissionsNestedInputSchema: z.ZodType<Prisma.RoleUpdateOneRequiredWithoutRolePermissionsNestedInput> =
  z
    .object({
      create: z
        .union([
          z.lazy(() => RoleCreateWithoutRolePermissionsInputSchema),
          z.lazy(() => RoleUncheckedCreateWithoutRolePermissionsInputSchema),
        ])
        .optional(),
      connectOrCreate: z
        .lazy(() => RoleCreateOrConnectWithoutRolePermissionsInputSchema)
        .optional(),
      upsert: z
        .lazy(() => RoleUpsertWithoutRolePermissionsInputSchema)
        .optional(),
      connect: z.lazy(() => RoleWhereUniqueInputSchema).optional(),
      update: z
        .union([
          z.lazy(
            () => RoleUpdateToOneWithWhereWithoutRolePermissionsInputSchema,
          ),
          z.lazy(() => RoleUpdateWithoutRolePermissionsInputSchema),
          z.lazy(() => RoleUncheckedUpdateWithoutRolePermissionsInputSchema),
        ])
        .optional(),
    })
    .strict() as z.ZodType<Prisma.RoleUpdateOneRequiredWithoutRolePermissionsNestedInput>;

export const PermissionUpdateOneRequiredWithoutRolePermissionsNestedInputSchema: z.ZodType<Prisma.PermissionUpdateOneRequiredWithoutRolePermissionsNestedInput> =
  z
    .object({
      create: z
        .union([
          z.lazy(() => PermissionCreateWithoutRolePermissionsInputSchema),
          z.lazy(
            () => PermissionUncheckedCreateWithoutRolePermissionsInputSchema,
          ),
        ])
        .optional(),
      connectOrCreate: z
        .lazy(() => PermissionCreateOrConnectWithoutRolePermissionsInputSchema)
        .optional(),
      upsert: z
        .lazy(() => PermissionUpsertWithoutRolePermissionsInputSchema)
        .optional(),
      connect: z.lazy(() => PermissionWhereUniqueInputSchema).optional(),
      update: z
        .union([
          z.lazy(
            () =>
              PermissionUpdateToOneWithWhereWithoutRolePermissionsInputSchema,
          ),
          z.lazy(() => PermissionUpdateWithoutRolePermissionsInputSchema),
          z.lazy(
            () => PermissionUncheckedUpdateWithoutRolePermissionsInputSchema,
          ),
        ])
        .optional(),
    })
    .strict() as z.ZodType<Prisma.PermissionUpdateOneRequiredWithoutRolePermissionsNestedInput>;

export const UserCreateNestedOneWithoutUserVendorRolesInputSchema: z.ZodType<Prisma.UserCreateNestedOneWithoutUserVendorRolesInput> =
  z
    .object({
      create: z
        .union([
          z.lazy(() => UserCreateWithoutUserVendorRolesInputSchema),
          z.lazy(() => UserUncheckedCreateWithoutUserVendorRolesInputSchema),
        ])
        .optional(),
      connectOrCreate: z
        .lazy(() => UserCreateOrConnectWithoutUserVendorRolesInputSchema)
        .optional(),
      connect: z.lazy(() => UserWhereUniqueInputSchema).optional(),
    })
    .strict() as z.ZodType<Prisma.UserCreateNestedOneWithoutUserVendorRolesInput>;

export const VendorCreateNestedOneWithoutUserVendorRolesInputSchema: z.ZodType<Prisma.VendorCreateNestedOneWithoutUserVendorRolesInput> =
  z
    .object({
      create: z
        .union([
          z.lazy(() => VendorCreateWithoutUserVendorRolesInputSchema),
          z.lazy(() => VendorUncheckedCreateWithoutUserVendorRolesInputSchema),
        ])
        .optional(),
      connectOrCreate: z
        .lazy(() => VendorCreateOrConnectWithoutUserVendorRolesInputSchema)
        .optional(),
      connect: z.lazy(() => VendorWhereUniqueInputSchema).optional(),
    })
    .strict() as z.ZodType<Prisma.VendorCreateNestedOneWithoutUserVendorRolesInput>;

export const RoleCreateNestedOneWithoutUserVendorRolesInputSchema: z.ZodType<Prisma.RoleCreateNestedOneWithoutUserVendorRolesInput> =
  z
    .object({
      create: z
        .union([
          z.lazy(() => RoleCreateWithoutUserVendorRolesInputSchema),
          z.lazy(() => RoleUncheckedCreateWithoutUserVendorRolesInputSchema),
        ])
        .optional(),
      connectOrCreate: z
        .lazy(() => RoleCreateOrConnectWithoutUserVendorRolesInputSchema)
        .optional(),
      connect: z.lazy(() => RoleWhereUniqueInputSchema).optional(),
    })
    .strict() as z.ZodType<Prisma.RoleCreateNestedOneWithoutUserVendorRolesInput>;

export const EnumUserVendorRoleStatusFieldUpdateOperationsInputSchema: z.ZodType<Prisma.EnumUserVendorRoleStatusFieldUpdateOperationsInput> =
  z
    .object({
      set: z.lazy(() => UserVendorRoleStatusSchema).optional(),
    })
    .strict() as z.ZodType<Prisma.EnumUserVendorRoleStatusFieldUpdateOperationsInput>;

export const UserUpdateOneRequiredWithoutUserVendorRolesNestedInputSchema: z.ZodType<Prisma.UserUpdateOneRequiredWithoutUserVendorRolesNestedInput> =
  z
    .object({
      create: z
        .union([
          z.lazy(() => UserCreateWithoutUserVendorRolesInputSchema),
          z.lazy(() => UserUncheckedCreateWithoutUserVendorRolesInputSchema),
        ])
        .optional(),
      connectOrCreate: z
        .lazy(() => UserCreateOrConnectWithoutUserVendorRolesInputSchema)
        .optional(),
      upsert: z
        .lazy(() => UserUpsertWithoutUserVendorRolesInputSchema)
        .optional(),
      connect: z.lazy(() => UserWhereUniqueInputSchema).optional(),
      update: z
        .union([
          z.lazy(
            () => UserUpdateToOneWithWhereWithoutUserVendorRolesInputSchema,
          ),
          z.lazy(() => UserUpdateWithoutUserVendorRolesInputSchema),
          z.lazy(() => UserUncheckedUpdateWithoutUserVendorRolesInputSchema),
        ])
        .optional(),
    })
    .strict() as z.ZodType<Prisma.UserUpdateOneRequiredWithoutUserVendorRolesNestedInput>;

export const VendorUpdateOneRequiredWithoutUserVendorRolesNestedInputSchema: z.ZodType<Prisma.VendorUpdateOneRequiredWithoutUserVendorRolesNestedInput> =
  z
    .object({
      create: z
        .union([
          z.lazy(() => VendorCreateWithoutUserVendorRolesInputSchema),
          z.lazy(() => VendorUncheckedCreateWithoutUserVendorRolesInputSchema),
        ])
        .optional(),
      connectOrCreate: z
        .lazy(() => VendorCreateOrConnectWithoutUserVendorRolesInputSchema)
        .optional(),
      upsert: z
        .lazy(() => VendorUpsertWithoutUserVendorRolesInputSchema)
        .optional(),
      connect: z.lazy(() => VendorWhereUniqueInputSchema).optional(),
      update: z
        .union([
          z.lazy(
            () => VendorUpdateToOneWithWhereWithoutUserVendorRolesInputSchema,
          ),
          z.lazy(() => VendorUpdateWithoutUserVendorRolesInputSchema),
          z.lazy(() => VendorUncheckedUpdateWithoutUserVendorRolesInputSchema),
        ])
        .optional(),
    })
    .strict() as z.ZodType<Prisma.VendorUpdateOneRequiredWithoutUserVendorRolesNestedInput>;

export const RoleUpdateOneRequiredWithoutUserVendorRolesNestedInputSchema: z.ZodType<Prisma.RoleUpdateOneRequiredWithoutUserVendorRolesNestedInput> =
  z
    .object({
      create: z
        .union([
          z.lazy(() => RoleCreateWithoutUserVendorRolesInputSchema),
          z.lazy(() => RoleUncheckedCreateWithoutUserVendorRolesInputSchema),
        ])
        .optional(),
      connectOrCreate: z
        .lazy(() => RoleCreateOrConnectWithoutUserVendorRolesInputSchema)
        .optional(),
      upsert: z
        .lazy(() => RoleUpsertWithoutUserVendorRolesInputSchema)
        .optional(),
      connect: z.lazy(() => RoleWhereUniqueInputSchema).optional(),
      update: z
        .union([
          z.lazy(
            () => RoleUpdateToOneWithWhereWithoutUserVendorRolesInputSchema,
          ),
          z.lazy(() => RoleUpdateWithoutUserVendorRolesInputSchema),
          z.lazy(() => RoleUncheckedUpdateWithoutUserVendorRolesInputSchema),
        ])
        .optional(),
    })
    .strict() as z.ZodType<Prisma.RoleUpdateOneRequiredWithoutUserVendorRolesNestedInput>;

export const CategoryCreateNestedOneWithoutChildrenInputSchema: z.ZodType<Prisma.CategoryCreateNestedOneWithoutChildrenInput> =
  z
    .object({
      create: z
        .union([
          z.lazy(() => CategoryCreateWithoutChildrenInputSchema),
          z.lazy(() => CategoryUncheckedCreateWithoutChildrenInputSchema),
        ])
        .optional(),
      connectOrCreate: z
        .lazy(() => CategoryCreateOrConnectWithoutChildrenInputSchema)
        .optional(),
      connect: z.lazy(() => CategoryWhereUniqueInputSchema).optional(),
    })
    .strict() as z.ZodType<Prisma.CategoryCreateNestedOneWithoutChildrenInput>;

export const CategoryCreateNestedManyWithoutParentInputSchema: z.ZodType<Prisma.CategoryCreateNestedManyWithoutParentInput> =
  z
    .object({
      create: z
        .union([
          z.lazy(() => CategoryCreateWithoutParentInputSchema),
          z.lazy(() => CategoryCreateWithoutParentInputSchema).array(),
          z.lazy(() => CategoryUncheckedCreateWithoutParentInputSchema),
          z.lazy(() => CategoryUncheckedCreateWithoutParentInputSchema).array(),
        ])
        .optional(),
      connectOrCreate: z
        .union([
          z.lazy(() => CategoryCreateOrConnectWithoutParentInputSchema),
          z.lazy(() => CategoryCreateOrConnectWithoutParentInputSchema).array(),
        ])
        .optional(),
      createMany: z
        .lazy(() => CategoryCreateManyParentInputEnvelopeSchema)
        .optional(),
      connect: z
        .union([
          z.lazy(() => CategoryWhereUniqueInputSchema),
          z.lazy(() => CategoryWhereUniqueInputSchema).array(),
        ])
        .optional(),
    })
    .strict() as z.ZodType<Prisma.CategoryCreateNestedManyWithoutParentInput>;

export const ProductCategoryCreateNestedManyWithoutCategoryInputSchema: z.ZodType<Prisma.ProductCategoryCreateNestedManyWithoutCategoryInput> =
  z
    .object({
      create: z
        .union([
          z.lazy(() => ProductCategoryCreateWithoutCategoryInputSchema),
          z.lazy(() => ProductCategoryCreateWithoutCategoryInputSchema).array(),
          z.lazy(
            () => ProductCategoryUncheckedCreateWithoutCategoryInputSchema,
          ),
          z
            .lazy(
              () => ProductCategoryUncheckedCreateWithoutCategoryInputSchema,
            )
            .array(),
        ])
        .optional(),
      connectOrCreate: z
        .union([
          z.lazy(
            () => ProductCategoryCreateOrConnectWithoutCategoryInputSchema,
          ),
          z
            .lazy(
              () => ProductCategoryCreateOrConnectWithoutCategoryInputSchema,
            )
            .array(),
        ])
        .optional(),
      createMany: z
        .lazy(() => ProductCategoryCreateManyCategoryInputEnvelopeSchema)
        .optional(),
      connect: z
        .union([
          z.lazy(() => ProductCategoryWhereUniqueInputSchema),
          z.lazy(() => ProductCategoryWhereUniqueInputSchema).array(),
        ])
        .optional(),
    })
    .strict() as z.ZodType<Prisma.ProductCategoryCreateNestedManyWithoutCategoryInput>;

export const CategoryUncheckedCreateNestedManyWithoutParentInputSchema: z.ZodType<Prisma.CategoryUncheckedCreateNestedManyWithoutParentInput> =
  z
    .object({
      create: z
        .union([
          z.lazy(() => CategoryCreateWithoutParentInputSchema),
          z.lazy(() => CategoryCreateWithoutParentInputSchema).array(),
          z.lazy(() => CategoryUncheckedCreateWithoutParentInputSchema),
          z.lazy(() => CategoryUncheckedCreateWithoutParentInputSchema).array(),
        ])
        .optional(),
      connectOrCreate: z
        .union([
          z.lazy(() => CategoryCreateOrConnectWithoutParentInputSchema),
          z.lazy(() => CategoryCreateOrConnectWithoutParentInputSchema).array(),
        ])
        .optional(),
      createMany: z
        .lazy(() => CategoryCreateManyParentInputEnvelopeSchema)
        .optional(),
      connect: z
        .union([
          z.lazy(() => CategoryWhereUniqueInputSchema),
          z.lazy(() => CategoryWhereUniqueInputSchema).array(),
        ])
        .optional(),
    })
    .strict() as z.ZodType<Prisma.CategoryUncheckedCreateNestedManyWithoutParentInput>;

export const ProductCategoryUncheckedCreateNestedManyWithoutCategoryInputSchema: z.ZodType<Prisma.ProductCategoryUncheckedCreateNestedManyWithoutCategoryInput> =
  z
    .object({
      create: z
        .union([
          z.lazy(() => ProductCategoryCreateWithoutCategoryInputSchema),
          z.lazy(() => ProductCategoryCreateWithoutCategoryInputSchema).array(),
          z.lazy(
            () => ProductCategoryUncheckedCreateWithoutCategoryInputSchema,
          ),
          z
            .lazy(
              () => ProductCategoryUncheckedCreateWithoutCategoryInputSchema,
            )
            .array(),
        ])
        .optional(),
      connectOrCreate: z
        .union([
          z.lazy(
            () => ProductCategoryCreateOrConnectWithoutCategoryInputSchema,
          ),
          z
            .lazy(
              () => ProductCategoryCreateOrConnectWithoutCategoryInputSchema,
            )
            .array(),
        ])
        .optional(),
      createMany: z
        .lazy(() => ProductCategoryCreateManyCategoryInputEnvelopeSchema)
        .optional(),
      connect: z
        .union([
          z.lazy(() => ProductCategoryWhereUniqueInputSchema),
          z.lazy(() => ProductCategoryWhereUniqueInputSchema).array(),
        ])
        .optional(),
    })
    .strict() as z.ZodType<Prisma.ProductCategoryUncheckedCreateNestedManyWithoutCategoryInput>;

export const CategoryUpdateOneWithoutChildrenNestedInputSchema: z.ZodType<Prisma.CategoryUpdateOneWithoutChildrenNestedInput> =
  z
    .object({
      create: z
        .union([
          z.lazy(() => CategoryCreateWithoutChildrenInputSchema),
          z.lazy(() => CategoryUncheckedCreateWithoutChildrenInputSchema),
        ])
        .optional(),
      connectOrCreate: z
        .lazy(() => CategoryCreateOrConnectWithoutChildrenInputSchema)
        .optional(),
      upsert: z.lazy(() => CategoryUpsertWithoutChildrenInputSchema).optional(),
      disconnect: z
        .union([z.boolean(), z.lazy(() => CategoryWhereInputSchema)])
        .optional(),
      delete: z
        .union([z.boolean(), z.lazy(() => CategoryWhereInputSchema)])
        .optional(),
      connect: z.lazy(() => CategoryWhereUniqueInputSchema).optional(),
      update: z
        .union([
          z.lazy(() => CategoryUpdateToOneWithWhereWithoutChildrenInputSchema),
          z.lazy(() => CategoryUpdateWithoutChildrenInputSchema),
          z.lazy(() => CategoryUncheckedUpdateWithoutChildrenInputSchema),
        ])
        .optional(),
    })
    .strict() as z.ZodType<Prisma.CategoryUpdateOneWithoutChildrenNestedInput>;

export const CategoryUpdateManyWithoutParentNestedInputSchema: z.ZodType<Prisma.CategoryUpdateManyWithoutParentNestedInput> =
  z
    .object({
      create: z
        .union([
          z.lazy(() => CategoryCreateWithoutParentInputSchema),
          z.lazy(() => CategoryCreateWithoutParentInputSchema).array(),
          z.lazy(() => CategoryUncheckedCreateWithoutParentInputSchema),
          z.lazy(() => CategoryUncheckedCreateWithoutParentInputSchema).array(),
        ])
        .optional(),
      connectOrCreate: z
        .union([
          z.lazy(() => CategoryCreateOrConnectWithoutParentInputSchema),
          z.lazy(() => CategoryCreateOrConnectWithoutParentInputSchema).array(),
        ])
        .optional(),
      upsert: z
        .union([
          z.lazy(() => CategoryUpsertWithWhereUniqueWithoutParentInputSchema),
          z
            .lazy(() => CategoryUpsertWithWhereUniqueWithoutParentInputSchema)
            .array(),
        ])
        .optional(),
      createMany: z
        .lazy(() => CategoryCreateManyParentInputEnvelopeSchema)
        .optional(),
      set: z
        .union([
          z.lazy(() => CategoryWhereUniqueInputSchema),
          z.lazy(() => CategoryWhereUniqueInputSchema).array(),
        ])
        .optional(),
      disconnect: z
        .union([
          z.lazy(() => CategoryWhereUniqueInputSchema),
          z.lazy(() => CategoryWhereUniqueInputSchema).array(),
        ])
        .optional(),
      delete: z
        .union([
          z.lazy(() => CategoryWhereUniqueInputSchema),
          z.lazy(() => CategoryWhereUniqueInputSchema).array(),
        ])
        .optional(),
      connect: z
        .union([
          z.lazy(() => CategoryWhereUniqueInputSchema),
          z.lazy(() => CategoryWhereUniqueInputSchema).array(),
        ])
        .optional(),
      update: z
        .union([
          z.lazy(() => CategoryUpdateWithWhereUniqueWithoutParentInputSchema),
          z
            .lazy(() => CategoryUpdateWithWhereUniqueWithoutParentInputSchema)
            .array(),
        ])
        .optional(),
      updateMany: z
        .union([
          z.lazy(() => CategoryUpdateManyWithWhereWithoutParentInputSchema),
          z
            .lazy(() => CategoryUpdateManyWithWhereWithoutParentInputSchema)
            .array(),
        ])
        .optional(),
      deleteMany: z
        .union([
          z.lazy(() => CategoryScalarWhereInputSchema),
          z.lazy(() => CategoryScalarWhereInputSchema).array(),
        ])
        .optional(),
    })
    .strict() as z.ZodType<Prisma.CategoryUpdateManyWithoutParentNestedInput>;

export const ProductCategoryUpdateManyWithoutCategoryNestedInputSchema: z.ZodType<Prisma.ProductCategoryUpdateManyWithoutCategoryNestedInput> =
  z
    .object({
      create: z
        .union([
          z.lazy(() => ProductCategoryCreateWithoutCategoryInputSchema),
          z.lazy(() => ProductCategoryCreateWithoutCategoryInputSchema).array(),
          z.lazy(
            () => ProductCategoryUncheckedCreateWithoutCategoryInputSchema,
          ),
          z
            .lazy(
              () => ProductCategoryUncheckedCreateWithoutCategoryInputSchema,
            )
            .array(),
        ])
        .optional(),
      connectOrCreate: z
        .union([
          z.lazy(
            () => ProductCategoryCreateOrConnectWithoutCategoryInputSchema,
          ),
          z
            .lazy(
              () => ProductCategoryCreateOrConnectWithoutCategoryInputSchema,
            )
            .array(),
        ])
        .optional(),
      upsert: z
        .union([
          z.lazy(
            () =>
              ProductCategoryUpsertWithWhereUniqueWithoutCategoryInputSchema,
          ),
          z
            .lazy(
              () =>
                ProductCategoryUpsertWithWhereUniqueWithoutCategoryInputSchema,
            )
            .array(),
        ])
        .optional(),
      createMany: z
        .lazy(() => ProductCategoryCreateManyCategoryInputEnvelopeSchema)
        .optional(),
      set: z
        .union([
          z.lazy(() => ProductCategoryWhereUniqueInputSchema),
          z.lazy(() => ProductCategoryWhereUniqueInputSchema).array(),
        ])
        .optional(),
      disconnect: z
        .union([
          z.lazy(() => ProductCategoryWhereUniqueInputSchema),
          z.lazy(() => ProductCategoryWhereUniqueInputSchema).array(),
        ])
        .optional(),
      delete: z
        .union([
          z.lazy(() => ProductCategoryWhereUniqueInputSchema),
          z.lazy(() => ProductCategoryWhereUniqueInputSchema).array(),
        ])
        .optional(),
      connect: z
        .union([
          z.lazy(() => ProductCategoryWhereUniqueInputSchema),
          z.lazy(() => ProductCategoryWhereUniqueInputSchema).array(),
        ])
        .optional(),
      update: z
        .union([
          z.lazy(
            () =>
              ProductCategoryUpdateWithWhereUniqueWithoutCategoryInputSchema,
          ),
          z
            .lazy(
              () =>
                ProductCategoryUpdateWithWhereUniqueWithoutCategoryInputSchema,
            )
            .array(),
        ])
        .optional(),
      updateMany: z
        .union([
          z.lazy(
            () => ProductCategoryUpdateManyWithWhereWithoutCategoryInputSchema,
          ),
          z
            .lazy(
              () =>
                ProductCategoryUpdateManyWithWhereWithoutCategoryInputSchema,
            )
            .array(),
        ])
        .optional(),
      deleteMany: z
        .union([
          z.lazy(() => ProductCategoryScalarWhereInputSchema),
          z.lazy(() => ProductCategoryScalarWhereInputSchema).array(),
        ])
        .optional(),
    })
    .strict() as z.ZodType<Prisma.ProductCategoryUpdateManyWithoutCategoryNestedInput>;

export const CategoryUncheckedUpdateManyWithoutParentNestedInputSchema: z.ZodType<Prisma.CategoryUncheckedUpdateManyWithoutParentNestedInput> =
  z
    .object({
      create: z
        .union([
          z.lazy(() => CategoryCreateWithoutParentInputSchema),
          z.lazy(() => CategoryCreateWithoutParentInputSchema).array(),
          z.lazy(() => CategoryUncheckedCreateWithoutParentInputSchema),
          z.lazy(() => CategoryUncheckedCreateWithoutParentInputSchema).array(),
        ])
        .optional(),
      connectOrCreate: z
        .union([
          z.lazy(() => CategoryCreateOrConnectWithoutParentInputSchema),
          z.lazy(() => CategoryCreateOrConnectWithoutParentInputSchema).array(),
        ])
        .optional(),
      upsert: z
        .union([
          z.lazy(() => CategoryUpsertWithWhereUniqueWithoutParentInputSchema),
          z
            .lazy(() => CategoryUpsertWithWhereUniqueWithoutParentInputSchema)
            .array(),
        ])
        .optional(),
      createMany: z
        .lazy(() => CategoryCreateManyParentInputEnvelopeSchema)
        .optional(),
      set: z
        .union([
          z.lazy(() => CategoryWhereUniqueInputSchema),
          z.lazy(() => CategoryWhereUniqueInputSchema).array(),
        ])
        .optional(),
      disconnect: z
        .union([
          z.lazy(() => CategoryWhereUniqueInputSchema),
          z.lazy(() => CategoryWhereUniqueInputSchema).array(),
        ])
        .optional(),
      delete: z
        .union([
          z.lazy(() => CategoryWhereUniqueInputSchema),
          z.lazy(() => CategoryWhereUniqueInputSchema).array(),
        ])
        .optional(),
      connect: z
        .union([
          z.lazy(() => CategoryWhereUniqueInputSchema),
          z.lazy(() => CategoryWhereUniqueInputSchema).array(),
        ])
        .optional(),
      update: z
        .union([
          z.lazy(() => CategoryUpdateWithWhereUniqueWithoutParentInputSchema),
          z
            .lazy(() => CategoryUpdateWithWhereUniqueWithoutParentInputSchema)
            .array(),
        ])
        .optional(),
      updateMany: z
        .union([
          z.lazy(() => CategoryUpdateManyWithWhereWithoutParentInputSchema),
          z
            .lazy(() => CategoryUpdateManyWithWhereWithoutParentInputSchema)
            .array(),
        ])
        .optional(),
      deleteMany: z
        .union([
          z.lazy(() => CategoryScalarWhereInputSchema),
          z.lazy(() => CategoryScalarWhereInputSchema).array(),
        ])
        .optional(),
    })
    .strict() as z.ZodType<Prisma.CategoryUncheckedUpdateManyWithoutParentNestedInput>;

export const ProductCategoryUncheckedUpdateManyWithoutCategoryNestedInputSchema: z.ZodType<Prisma.ProductCategoryUncheckedUpdateManyWithoutCategoryNestedInput> =
  z
    .object({
      create: z
        .union([
          z.lazy(() => ProductCategoryCreateWithoutCategoryInputSchema),
          z.lazy(() => ProductCategoryCreateWithoutCategoryInputSchema).array(),
          z.lazy(
            () => ProductCategoryUncheckedCreateWithoutCategoryInputSchema,
          ),
          z
            .lazy(
              () => ProductCategoryUncheckedCreateWithoutCategoryInputSchema,
            )
            .array(),
        ])
        .optional(),
      connectOrCreate: z
        .union([
          z.lazy(
            () => ProductCategoryCreateOrConnectWithoutCategoryInputSchema,
          ),
          z
            .lazy(
              () => ProductCategoryCreateOrConnectWithoutCategoryInputSchema,
            )
            .array(),
        ])
        .optional(),
      upsert: z
        .union([
          z.lazy(
            () =>
              ProductCategoryUpsertWithWhereUniqueWithoutCategoryInputSchema,
          ),
          z
            .lazy(
              () =>
                ProductCategoryUpsertWithWhereUniqueWithoutCategoryInputSchema,
            )
            .array(),
        ])
        .optional(),
      createMany: z
        .lazy(() => ProductCategoryCreateManyCategoryInputEnvelopeSchema)
        .optional(),
      set: z
        .union([
          z.lazy(() => ProductCategoryWhereUniqueInputSchema),
          z.lazy(() => ProductCategoryWhereUniqueInputSchema).array(),
        ])
        .optional(),
      disconnect: z
        .union([
          z.lazy(() => ProductCategoryWhereUniqueInputSchema),
          z.lazy(() => ProductCategoryWhereUniqueInputSchema).array(),
        ])
        .optional(),
      delete: z
        .union([
          z.lazy(() => ProductCategoryWhereUniqueInputSchema),
          z.lazy(() => ProductCategoryWhereUniqueInputSchema).array(),
        ])
        .optional(),
      connect: z
        .union([
          z.lazy(() => ProductCategoryWhereUniqueInputSchema),
          z.lazy(() => ProductCategoryWhereUniqueInputSchema).array(),
        ])
        .optional(),
      update: z
        .union([
          z.lazy(
            () =>
              ProductCategoryUpdateWithWhereUniqueWithoutCategoryInputSchema,
          ),
          z
            .lazy(
              () =>
                ProductCategoryUpdateWithWhereUniqueWithoutCategoryInputSchema,
            )
            .array(),
        ])
        .optional(),
      updateMany: z
        .union([
          z.lazy(
            () => ProductCategoryUpdateManyWithWhereWithoutCategoryInputSchema,
          ),
          z
            .lazy(
              () =>
                ProductCategoryUpdateManyWithWhereWithoutCategoryInputSchema,
            )
            .array(),
        ])
        .optional(),
      deleteMany: z
        .union([
          z.lazy(() => ProductCategoryScalarWhereInputSchema),
          z.lazy(() => ProductCategoryScalarWhereInputSchema).array(),
        ])
        .optional(),
    })
    .strict() as z.ZodType<Prisma.ProductCategoryUncheckedUpdateManyWithoutCategoryNestedInput>;

export const VendorCreateNestedOneWithoutProductsInputSchema: z.ZodType<Prisma.VendorCreateNestedOneWithoutProductsInput> =
  z
    .object({
      create: z
        .union([
          z.lazy(() => VendorCreateWithoutProductsInputSchema),
          z.lazy(() => VendorUncheckedCreateWithoutProductsInputSchema),
        ])
        .optional(),
      connectOrCreate: z
        .lazy(() => VendorCreateOrConnectWithoutProductsInputSchema)
        .optional(),
      connect: z.lazy(() => VendorWhereUniqueInputSchema).optional(),
    })
    .strict() as z.ZodType<Prisma.VendorCreateNestedOneWithoutProductsInput>;

export const ProductCategoryCreateNestedManyWithoutProductInputSchema: z.ZodType<Prisma.ProductCategoryCreateNestedManyWithoutProductInput> =
  z
    .object({
      create: z
        .union([
          z.lazy(() => ProductCategoryCreateWithoutProductInputSchema),
          z.lazy(() => ProductCategoryCreateWithoutProductInputSchema).array(),
          z.lazy(() => ProductCategoryUncheckedCreateWithoutProductInputSchema),
          z
            .lazy(() => ProductCategoryUncheckedCreateWithoutProductInputSchema)
            .array(),
        ])
        .optional(),
      connectOrCreate: z
        .union([
          z.lazy(() => ProductCategoryCreateOrConnectWithoutProductInputSchema),
          z
            .lazy(() => ProductCategoryCreateOrConnectWithoutProductInputSchema)
            .array(),
        ])
        .optional(),
      createMany: z
        .lazy(() => ProductCategoryCreateManyProductInputEnvelopeSchema)
        .optional(),
      connect: z
        .union([
          z.lazy(() => ProductCategoryWhereUniqueInputSchema),
          z.lazy(() => ProductCategoryWhereUniqueInputSchema).array(),
        ])
        .optional(),
    })
    .strict() as z.ZodType<Prisma.ProductCategoryCreateNestedManyWithoutProductInput>;

export const ProductImageCreateNestedManyWithoutProductInputSchema: z.ZodType<Prisma.ProductImageCreateNestedManyWithoutProductInput> =
  z
    .object({
      create: z
        .union([
          z.lazy(() => ProductImageCreateWithoutProductInputSchema),
          z.lazy(() => ProductImageCreateWithoutProductInputSchema).array(),
          z.lazy(() => ProductImageUncheckedCreateWithoutProductInputSchema),
          z
            .lazy(() => ProductImageUncheckedCreateWithoutProductInputSchema)
            .array(),
        ])
        .optional(),
      connectOrCreate: z
        .union([
          z.lazy(() => ProductImageCreateOrConnectWithoutProductInputSchema),
          z
            .lazy(() => ProductImageCreateOrConnectWithoutProductInputSchema)
            .array(),
        ])
        .optional(),
      createMany: z
        .lazy(() => ProductImageCreateManyProductInputEnvelopeSchema)
        .optional(),
      connect: z
        .union([
          z.lazy(() => ProductImageWhereUniqueInputSchema),
          z.lazy(() => ProductImageWhereUniqueInputSchema).array(),
        ])
        .optional(),
    })
    .strict() as z.ZodType<Prisma.ProductImageCreateNestedManyWithoutProductInput>;

export const ProductVariantCreateNestedManyWithoutProductInputSchema: z.ZodType<Prisma.ProductVariantCreateNestedManyWithoutProductInput> =
  z
    .object({
      create: z
        .union([
          z.lazy(() => ProductVariantCreateWithoutProductInputSchema),
          z.lazy(() => ProductVariantCreateWithoutProductInputSchema).array(),
          z.lazy(() => ProductVariantUncheckedCreateWithoutProductInputSchema),
          z
            .lazy(() => ProductVariantUncheckedCreateWithoutProductInputSchema)
            .array(),
        ])
        .optional(),
      connectOrCreate: z
        .union([
          z.lazy(() => ProductVariantCreateOrConnectWithoutProductInputSchema),
          z
            .lazy(() => ProductVariantCreateOrConnectWithoutProductInputSchema)
            .array(),
        ])
        .optional(),
      createMany: z
        .lazy(() => ProductVariantCreateManyProductInputEnvelopeSchema)
        .optional(),
      connect: z
        .union([
          z.lazy(() => ProductVariantWhereUniqueInputSchema),
          z.lazy(() => ProductVariantWhereUniqueInputSchema).array(),
        ])
        .optional(),
    })
    .strict() as z.ZodType<Prisma.ProductVariantCreateNestedManyWithoutProductInput>;

export const ProductCategoryUncheckedCreateNestedManyWithoutProductInputSchema: z.ZodType<Prisma.ProductCategoryUncheckedCreateNestedManyWithoutProductInput> =
  z
    .object({
      create: z
        .union([
          z.lazy(() => ProductCategoryCreateWithoutProductInputSchema),
          z.lazy(() => ProductCategoryCreateWithoutProductInputSchema).array(),
          z.lazy(() => ProductCategoryUncheckedCreateWithoutProductInputSchema),
          z
            .lazy(() => ProductCategoryUncheckedCreateWithoutProductInputSchema)
            .array(),
        ])
        .optional(),
      connectOrCreate: z
        .union([
          z.lazy(() => ProductCategoryCreateOrConnectWithoutProductInputSchema),
          z
            .lazy(() => ProductCategoryCreateOrConnectWithoutProductInputSchema)
            .array(),
        ])
        .optional(),
      createMany: z
        .lazy(() => ProductCategoryCreateManyProductInputEnvelopeSchema)
        .optional(),
      connect: z
        .union([
          z.lazy(() => ProductCategoryWhereUniqueInputSchema),
          z.lazy(() => ProductCategoryWhereUniqueInputSchema).array(),
        ])
        .optional(),
    })
    .strict() as z.ZodType<Prisma.ProductCategoryUncheckedCreateNestedManyWithoutProductInput>;

export const ProductImageUncheckedCreateNestedManyWithoutProductInputSchema: z.ZodType<Prisma.ProductImageUncheckedCreateNestedManyWithoutProductInput> =
  z
    .object({
      create: z
        .union([
          z.lazy(() => ProductImageCreateWithoutProductInputSchema),
          z.lazy(() => ProductImageCreateWithoutProductInputSchema).array(),
          z.lazy(() => ProductImageUncheckedCreateWithoutProductInputSchema),
          z
            .lazy(() => ProductImageUncheckedCreateWithoutProductInputSchema)
            .array(),
        ])
        .optional(),
      connectOrCreate: z
        .union([
          z.lazy(() => ProductImageCreateOrConnectWithoutProductInputSchema),
          z
            .lazy(() => ProductImageCreateOrConnectWithoutProductInputSchema)
            .array(),
        ])
        .optional(),
      createMany: z
        .lazy(() => ProductImageCreateManyProductInputEnvelopeSchema)
        .optional(),
      connect: z
        .union([
          z.lazy(() => ProductImageWhereUniqueInputSchema),
          z.lazy(() => ProductImageWhereUniqueInputSchema).array(),
        ])
        .optional(),
    })
    .strict() as z.ZodType<Prisma.ProductImageUncheckedCreateNestedManyWithoutProductInput>;

export const ProductVariantUncheckedCreateNestedManyWithoutProductInputSchema: z.ZodType<Prisma.ProductVariantUncheckedCreateNestedManyWithoutProductInput> =
  z
    .object({
      create: z
        .union([
          z.lazy(() => ProductVariantCreateWithoutProductInputSchema),
          z.lazy(() => ProductVariantCreateWithoutProductInputSchema).array(),
          z.lazy(() => ProductVariantUncheckedCreateWithoutProductInputSchema),
          z
            .lazy(() => ProductVariantUncheckedCreateWithoutProductInputSchema)
            .array(),
        ])
        .optional(),
      connectOrCreate: z
        .union([
          z.lazy(() => ProductVariantCreateOrConnectWithoutProductInputSchema),
          z
            .lazy(() => ProductVariantCreateOrConnectWithoutProductInputSchema)
            .array(),
        ])
        .optional(),
      createMany: z
        .lazy(() => ProductVariantCreateManyProductInputEnvelopeSchema)
        .optional(),
      connect: z
        .union([
          z.lazy(() => ProductVariantWhereUniqueInputSchema),
          z.lazy(() => ProductVariantWhereUniqueInputSchema).array(),
        ])
        .optional(),
    })
    .strict() as z.ZodType<Prisma.ProductVariantUncheckedCreateNestedManyWithoutProductInput>;

export const DecimalFieldUpdateOperationsInputSchema: z.ZodType<Prisma.DecimalFieldUpdateOperationsInput> =
  z
    .object({
      set: z
        .union([
          z.number(),
          z.string(),
          z.instanceof(Decimal),
          z.instanceof(Prisma.Decimal),
          DecimalJsLikeSchema,
        ])
        .refine((v) => isValidDecimalInput(v), { message: 'Must be a Decimal' })
        .optional(),
      increment: z
        .union([
          z.number(),
          z.string(),
          z.instanceof(Decimal),
          z.instanceof(Prisma.Decimal),
          DecimalJsLikeSchema,
        ])
        .refine((v) => isValidDecimalInput(v), { message: 'Must be a Decimal' })
        .optional(),
      decrement: z
        .union([
          z.number(),
          z.string(),
          z.instanceof(Decimal),
          z.instanceof(Prisma.Decimal),
          DecimalJsLikeSchema,
        ])
        .refine((v) => isValidDecimalInput(v), { message: 'Must be a Decimal' })
        .optional(),
      multiply: z
        .union([
          z.number(),
          z.string(),
          z.instanceof(Decimal),
          z.instanceof(Prisma.Decimal),
          DecimalJsLikeSchema,
        ])
        .refine((v) => isValidDecimalInput(v), { message: 'Must be a Decimal' })
        .optional(),
      divide: z
        .union([
          z.number(),
          z.string(),
          z.instanceof(Decimal),
          z.instanceof(Prisma.Decimal),
          DecimalJsLikeSchema,
        ])
        .refine((v) => isValidDecimalInput(v), { message: 'Must be a Decimal' })
        .optional(),
    })
    .strict() as z.ZodType<Prisma.DecimalFieldUpdateOperationsInput>;

export const EnumProductStatusFieldUpdateOperationsInputSchema: z.ZodType<Prisma.EnumProductStatusFieldUpdateOperationsInput> =
  z
    .object({
      set: z.lazy(() => ProductStatusSchema).optional(),
    })
    .strict() as z.ZodType<Prisma.EnumProductStatusFieldUpdateOperationsInput>;

export const VendorUpdateOneRequiredWithoutProductsNestedInputSchema: z.ZodType<Prisma.VendorUpdateOneRequiredWithoutProductsNestedInput> =
  z
    .object({
      create: z
        .union([
          z.lazy(() => VendorCreateWithoutProductsInputSchema),
          z.lazy(() => VendorUncheckedCreateWithoutProductsInputSchema),
        ])
        .optional(),
      connectOrCreate: z
        .lazy(() => VendorCreateOrConnectWithoutProductsInputSchema)
        .optional(),
      upsert: z.lazy(() => VendorUpsertWithoutProductsInputSchema).optional(),
      connect: z.lazy(() => VendorWhereUniqueInputSchema).optional(),
      update: z
        .union([
          z.lazy(() => VendorUpdateToOneWithWhereWithoutProductsInputSchema),
          z.lazy(() => VendorUpdateWithoutProductsInputSchema),
          z.lazy(() => VendorUncheckedUpdateWithoutProductsInputSchema),
        ])
        .optional(),
    })
    .strict() as z.ZodType<Prisma.VendorUpdateOneRequiredWithoutProductsNestedInput>;

export const ProductCategoryUpdateManyWithoutProductNestedInputSchema: z.ZodType<Prisma.ProductCategoryUpdateManyWithoutProductNestedInput> =
  z
    .object({
      create: z
        .union([
          z.lazy(() => ProductCategoryCreateWithoutProductInputSchema),
          z.lazy(() => ProductCategoryCreateWithoutProductInputSchema).array(),
          z.lazy(() => ProductCategoryUncheckedCreateWithoutProductInputSchema),
          z
            .lazy(() => ProductCategoryUncheckedCreateWithoutProductInputSchema)
            .array(),
        ])
        .optional(),
      connectOrCreate: z
        .union([
          z.lazy(() => ProductCategoryCreateOrConnectWithoutProductInputSchema),
          z
            .lazy(() => ProductCategoryCreateOrConnectWithoutProductInputSchema)
            .array(),
        ])
        .optional(),
      upsert: z
        .union([
          z.lazy(
            () => ProductCategoryUpsertWithWhereUniqueWithoutProductInputSchema,
          ),
          z
            .lazy(
              () =>
                ProductCategoryUpsertWithWhereUniqueWithoutProductInputSchema,
            )
            .array(),
        ])
        .optional(),
      createMany: z
        .lazy(() => ProductCategoryCreateManyProductInputEnvelopeSchema)
        .optional(),
      set: z
        .union([
          z.lazy(() => ProductCategoryWhereUniqueInputSchema),
          z.lazy(() => ProductCategoryWhereUniqueInputSchema).array(),
        ])
        .optional(),
      disconnect: z
        .union([
          z.lazy(() => ProductCategoryWhereUniqueInputSchema),
          z.lazy(() => ProductCategoryWhereUniqueInputSchema).array(),
        ])
        .optional(),
      delete: z
        .union([
          z.lazy(() => ProductCategoryWhereUniqueInputSchema),
          z.lazy(() => ProductCategoryWhereUniqueInputSchema).array(),
        ])
        .optional(),
      connect: z
        .union([
          z.lazy(() => ProductCategoryWhereUniqueInputSchema),
          z.lazy(() => ProductCategoryWhereUniqueInputSchema).array(),
        ])
        .optional(),
      update: z
        .union([
          z.lazy(
            () => ProductCategoryUpdateWithWhereUniqueWithoutProductInputSchema,
          ),
          z
            .lazy(
              () =>
                ProductCategoryUpdateWithWhereUniqueWithoutProductInputSchema,
            )
            .array(),
        ])
        .optional(),
      updateMany: z
        .union([
          z.lazy(
            () => ProductCategoryUpdateManyWithWhereWithoutProductInputSchema,
          ),
          z
            .lazy(
              () => ProductCategoryUpdateManyWithWhereWithoutProductInputSchema,
            )
            .array(),
        ])
        .optional(),
      deleteMany: z
        .union([
          z.lazy(() => ProductCategoryScalarWhereInputSchema),
          z.lazy(() => ProductCategoryScalarWhereInputSchema).array(),
        ])
        .optional(),
    })
    .strict() as z.ZodType<Prisma.ProductCategoryUpdateManyWithoutProductNestedInput>;

export const ProductImageUpdateManyWithoutProductNestedInputSchema: z.ZodType<Prisma.ProductImageUpdateManyWithoutProductNestedInput> =
  z
    .object({
      create: z
        .union([
          z.lazy(() => ProductImageCreateWithoutProductInputSchema),
          z.lazy(() => ProductImageCreateWithoutProductInputSchema).array(),
          z.lazy(() => ProductImageUncheckedCreateWithoutProductInputSchema),
          z
            .lazy(() => ProductImageUncheckedCreateWithoutProductInputSchema)
            .array(),
        ])
        .optional(),
      connectOrCreate: z
        .union([
          z.lazy(() => ProductImageCreateOrConnectWithoutProductInputSchema),
          z
            .lazy(() => ProductImageCreateOrConnectWithoutProductInputSchema)
            .array(),
        ])
        .optional(),
      upsert: z
        .union([
          z.lazy(
            () => ProductImageUpsertWithWhereUniqueWithoutProductInputSchema,
          ),
          z
            .lazy(
              () => ProductImageUpsertWithWhereUniqueWithoutProductInputSchema,
            )
            .array(),
        ])
        .optional(),
      createMany: z
        .lazy(() => ProductImageCreateManyProductInputEnvelopeSchema)
        .optional(),
      set: z
        .union([
          z.lazy(() => ProductImageWhereUniqueInputSchema),
          z.lazy(() => ProductImageWhereUniqueInputSchema).array(),
        ])
        .optional(),
      disconnect: z
        .union([
          z.lazy(() => ProductImageWhereUniqueInputSchema),
          z.lazy(() => ProductImageWhereUniqueInputSchema).array(),
        ])
        .optional(),
      delete: z
        .union([
          z.lazy(() => ProductImageWhereUniqueInputSchema),
          z.lazy(() => ProductImageWhereUniqueInputSchema).array(),
        ])
        .optional(),
      connect: z
        .union([
          z.lazy(() => ProductImageWhereUniqueInputSchema),
          z.lazy(() => ProductImageWhereUniqueInputSchema).array(),
        ])
        .optional(),
      update: z
        .union([
          z.lazy(
            () => ProductImageUpdateWithWhereUniqueWithoutProductInputSchema,
          ),
          z
            .lazy(
              () => ProductImageUpdateWithWhereUniqueWithoutProductInputSchema,
            )
            .array(),
        ])
        .optional(),
      updateMany: z
        .union([
          z.lazy(
            () => ProductImageUpdateManyWithWhereWithoutProductInputSchema,
          ),
          z
            .lazy(
              () => ProductImageUpdateManyWithWhereWithoutProductInputSchema,
            )
            .array(),
        ])
        .optional(),
      deleteMany: z
        .union([
          z.lazy(() => ProductImageScalarWhereInputSchema),
          z.lazy(() => ProductImageScalarWhereInputSchema).array(),
        ])
        .optional(),
    })
    .strict() as z.ZodType<Prisma.ProductImageUpdateManyWithoutProductNestedInput>;

export const ProductVariantUpdateManyWithoutProductNestedInputSchema: z.ZodType<Prisma.ProductVariantUpdateManyWithoutProductNestedInput> =
  z
    .object({
      create: z
        .union([
          z.lazy(() => ProductVariantCreateWithoutProductInputSchema),
          z.lazy(() => ProductVariantCreateWithoutProductInputSchema).array(),
          z.lazy(() => ProductVariantUncheckedCreateWithoutProductInputSchema),
          z
            .lazy(() => ProductVariantUncheckedCreateWithoutProductInputSchema)
            .array(),
        ])
        .optional(),
      connectOrCreate: z
        .union([
          z.lazy(() => ProductVariantCreateOrConnectWithoutProductInputSchema),
          z
            .lazy(() => ProductVariantCreateOrConnectWithoutProductInputSchema)
            .array(),
        ])
        .optional(),
      upsert: z
        .union([
          z.lazy(
            () => ProductVariantUpsertWithWhereUniqueWithoutProductInputSchema,
          ),
          z
            .lazy(
              () =>
                ProductVariantUpsertWithWhereUniqueWithoutProductInputSchema,
            )
            .array(),
        ])
        .optional(),
      createMany: z
        .lazy(() => ProductVariantCreateManyProductInputEnvelopeSchema)
        .optional(),
      set: z
        .union([
          z.lazy(() => ProductVariantWhereUniqueInputSchema),
          z.lazy(() => ProductVariantWhereUniqueInputSchema).array(),
        ])
        .optional(),
      disconnect: z
        .union([
          z.lazy(() => ProductVariantWhereUniqueInputSchema),
          z.lazy(() => ProductVariantWhereUniqueInputSchema).array(),
        ])
        .optional(),
      delete: z
        .union([
          z.lazy(() => ProductVariantWhereUniqueInputSchema),
          z.lazy(() => ProductVariantWhereUniqueInputSchema).array(),
        ])
        .optional(),
      connect: z
        .union([
          z.lazy(() => ProductVariantWhereUniqueInputSchema),
          z.lazy(() => ProductVariantWhereUniqueInputSchema).array(),
        ])
        .optional(),
      update: z
        .union([
          z.lazy(
            () => ProductVariantUpdateWithWhereUniqueWithoutProductInputSchema,
          ),
          z
            .lazy(
              () =>
                ProductVariantUpdateWithWhereUniqueWithoutProductInputSchema,
            )
            .array(),
        ])
        .optional(),
      updateMany: z
        .union([
          z.lazy(
            () => ProductVariantUpdateManyWithWhereWithoutProductInputSchema,
          ),
          z
            .lazy(
              () => ProductVariantUpdateManyWithWhereWithoutProductInputSchema,
            )
            .array(),
        ])
        .optional(),
      deleteMany: z
        .union([
          z.lazy(() => ProductVariantScalarWhereInputSchema),
          z.lazy(() => ProductVariantScalarWhereInputSchema).array(),
        ])
        .optional(),
    })
    .strict() as z.ZodType<Prisma.ProductVariantUpdateManyWithoutProductNestedInput>;

export const ProductCategoryUncheckedUpdateManyWithoutProductNestedInputSchema: z.ZodType<Prisma.ProductCategoryUncheckedUpdateManyWithoutProductNestedInput> =
  z
    .object({
      create: z
        .union([
          z.lazy(() => ProductCategoryCreateWithoutProductInputSchema),
          z.lazy(() => ProductCategoryCreateWithoutProductInputSchema).array(),
          z.lazy(() => ProductCategoryUncheckedCreateWithoutProductInputSchema),
          z
            .lazy(() => ProductCategoryUncheckedCreateWithoutProductInputSchema)
            .array(),
        ])
        .optional(),
      connectOrCreate: z
        .union([
          z.lazy(() => ProductCategoryCreateOrConnectWithoutProductInputSchema),
          z
            .lazy(() => ProductCategoryCreateOrConnectWithoutProductInputSchema)
            .array(),
        ])
        .optional(),
      upsert: z
        .union([
          z.lazy(
            () => ProductCategoryUpsertWithWhereUniqueWithoutProductInputSchema,
          ),
          z
            .lazy(
              () =>
                ProductCategoryUpsertWithWhereUniqueWithoutProductInputSchema,
            )
            .array(),
        ])
        .optional(),
      createMany: z
        .lazy(() => ProductCategoryCreateManyProductInputEnvelopeSchema)
        .optional(),
      set: z
        .union([
          z.lazy(() => ProductCategoryWhereUniqueInputSchema),
          z.lazy(() => ProductCategoryWhereUniqueInputSchema).array(),
        ])
        .optional(),
      disconnect: z
        .union([
          z.lazy(() => ProductCategoryWhereUniqueInputSchema),
          z.lazy(() => ProductCategoryWhereUniqueInputSchema).array(),
        ])
        .optional(),
      delete: z
        .union([
          z.lazy(() => ProductCategoryWhereUniqueInputSchema),
          z.lazy(() => ProductCategoryWhereUniqueInputSchema).array(),
        ])
        .optional(),
      connect: z
        .union([
          z.lazy(() => ProductCategoryWhereUniqueInputSchema),
          z.lazy(() => ProductCategoryWhereUniqueInputSchema).array(),
        ])
        .optional(),
      update: z
        .union([
          z.lazy(
            () => ProductCategoryUpdateWithWhereUniqueWithoutProductInputSchema,
          ),
          z
            .lazy(
              () =>
                ProductCategoryUpdateWithWhereUniqueWithoutProductInputSchema,
            )
            .array(),
        ])
        .optional(),
      updateMany: z
        .union([
          z.lazy(
            () => ProductCategoryUpdateManyWithWhereWithoutProductInputSchema,
          ),
          z
            .lazy(
              () => ProductCategoryUpdateManyWithWhereWithoutProductInputSchema,
            )
            .array(),
        ])
        .optional(),
      deleteMany: z
        .union([
          z.lazy(() => ProductCategoryScalarWhereInputSchema),
          z.lazy(() => ProductCategoryScalarWhereInputSchema).array(),
        ])
        .optional(),
    })
    .strict() as z.ZodType<Prisma.ProductCategoryUncheckedUpdateManyWithoutProductNestedInput>;

export const ProductImageUncheckedUpdateManyWithoutProductNestedInputSchema: z.ZodType<Prisma.ProductImageUncheckedUpdateManyWithoutProductNestedInput> =
  z
    .object({
      create: z
        .union([
          z.lazy(() => ProductImageCreateWithoutProductInputSchema),
          z.lazy(() => ProductImageCreateWithoutProductInputSchema).array(),
          z.lazy(() => ProductImageUncheckedCreateWithoutProductInputSchema),
          z
            .lazy(() => ProductImageUncheckedCreateWithoutProductInputSchema)
            .array(),
        ])
        .optional(),
      connectOrCreate: z
        .union([
          z.lazy(() => ProductImageCreateOrConnectWithoutProductInputSchema),
          z
            .lazy(() => ProductImageCreateOrConnectWithoutProductInputSchema)
            .array(),
        ])
        .optional(),
      upsert: z
        .union([
          z.lazy(
            () => ProductImageUpsertWithWhereUniqueWithoutProductInputSchema,
          ),
          z
            .lazy(
              () => ProductImageUpsertWithWhereUniqueWithoutProductInputSchema,
            )
            .array(),
        ])
        .optional(),
      createMany: z
        .lazy(() => ProductImageCreateManyProductInputEnvelopeSchema)
        .optional(),
      set: z
        .union([
          z.lazy(() => ProductImageWhereUniqueInputSchema),
          z.lazy(() => ProductImageWhereUniqueInputSchema).array(),
        ])
        .optional(),
      disconnect: z
        .union([
          z.lazy(() => ProductImageWhereUniqueInputSchema),
          z.lazy(() => ProductImageWhereUniqueInputSchema).array(),
        ])
        .optional(),
      delete: z
        .union([
          z.lazy(() => ProductImageWhereUniqueInputSchema),
          z.lazy(() => ProductImageWhereUniqueInputSchema).array(),
        ])
        .optional(),
      connect: z
        .union([
          z.lazy(() => ProductImageWhereUniqueInputSchema),
          z.lazy(() => ProductImageWhereUniqueInputSchema).array(),
        ])
        .optional(),
      update: z
        .union([
          z.lazy(
            () => ProductImageUpdateWithWhereUniqueWithoutProductInputSchema,
          ),
          z
            .lazy(
              () => ProductImageUpdateWithWhereUniqueWithoutProductInputSchema,
            )
            .array(),
        ])
        .optional(),
      updateMany: z
        .union([
          z.lazy(
            () => ProductImageUpdateManyWithWhereWithoutProductInputSchema,
          ),
          z
            .lazy(
              () => ProductImageUpdateManyWithWhereWithoutProductInputSchema,
            )
            .array(),
        ])
        .optional(),
      deleteMany: z
        .union([
          z.lazy(() => ProductImageScalarWhereInputSchema),
          z.lazy(() => ProductImageScalarWhereInputSchema).array(),
        ])
        .optional(),
    })
    .strict() as z.ZodType<Prisma.ProductImageUncheckedUpdateManyWithoutProductNestedInput>;

export const ProductVariantUncheckedUpdateManyWithoutProductNestedInputSchema: z.ZodType<Prisma.ProductVariantUncheckedUpdateManyWithoutProductNestedInput> =
  z
    .object({
      create: z
        .union([
          z.lazy(() => ProductVariantCreateWithoutProductInputSchema),
          z.lazy(() => ProductVariantCreateWithoutProductInputSchema).array(),
          z.lazy(() => ProductVariantUncheckedCreateWithoutProductInputSchema),
          z
            .lazy(() => ProductVariantUncheckedCreateWithoutProductInputSchema)
            .array(),
        ])
        .optional(),
      connectOrCreate: z
        .union([
          z.lazy(() => ProductVariantCreateOrConnectWithoutProductInputSchema),
          z
            .lazy(() => ProductVariantCreateOrConnectWithoutProductInputSchema)
            .array(),
        ])
        .optional(),
      upsert: z
        .union([
          z.lazy(
            () => ProductVariantUpsertWithWhereUniqueWithoutProductInputSchema,
          ),
          z
            .lazy(
              () =>
                ProductVariantUpsertWithWhereUniqueWithoutProductInputSchema,
            )
            .array(),
        ])
        .optional(),
      createMany: z
        .lazy(() => ProductVariantCreateManyProductInputEnvelopeSchema)
        .optional(),
      set: z
        .union([
          z.lazy(() => ProductVariantWhereUniqueInputSchema),
          z.lazy(() => ProductVariantWhereUniqueInputSchema).array(),
        ])
        .optional(),
      disconnect: z
        .union([
          z.lazy(() => ProductVariantWhereUniqueInputSchema),
          z.lazy(() => ProductVariantWhereUniqueInputSchema).array(),
        ])
        .optional(),
      delete: z
        .union([
          z.lazy(() => ProductVariantWhereUniqueInputSchema),
          z.lazy(() => ProductVariantWhereUniqueInputSchema).array(),
        ])
        .optional(),
      connect: z
        .union([
          z.lazy(() => ProductVariantWhereUniqueInputSchema),
          z.lazy(() => ProductVariantWhereUniqueInputSchema).array(),
        ])
        .optional(),
      update: z
        .union([
          z.lazy(
            () => ProductVariantUpdateWithWhereUniqueWithoutProductInputSchema,
          ),
          z
            .lazy(
              () =>
                ProductVariantUpdateWithWhereUniqueWithoutProductInputSchema,
            )
            .array(),
        ])
        .optional(),
      updateMany: z
        .union([
          z.lazy(
            () => ProductVariantUpdateManyWithWhereWithoutProductInputSchema,
          ),
          z
            .lazy(
              () => ProductVariantUpdateManyWithWhereWithoutProductInputSchema,
            )
            .array(),
        ])
        .optional(),
      deleteMany: z
        .union([
          z.lazy(() => ProductVariantScalarWhereInputSchema),
          z.lazy(() => ProductVariantScalarWhereInputSchema).array(),
        ])
        .optional(),
    })
    .strict() as z.ZodType<Prisma.ProductVariantUncheckedUpdateManyWithoutProductNestedInput>;

export const ProductCreateNestedOneWithoutProductVariantsInputSchema: z.ZodType<Prisma.ProductCreateNestedOneWithoutProductVariantsInput> =
  z
    .object({
      create: z
        .union([
          z.lazy(() => ProductCreateWithoutProductVariantsInputSchema),
          z.lazy(() => ProductUncheckedCreateWithoutProductVariantsInputSchema),
        ])
        .optional(),
      connectOrCreate: z
        .lazy(() => ProductCreateOrConnectWithoutProductVariantsInputSchema)
        .optional(),
      connect: z.lazy(() => ProductWhereUniqueInputSchema).optional(),
    })
    .strict() as z.ZodType<Prisma.ProductCreateNestedOneWithoutProductVariantsInput>;

export const ProductImageCreateNestedManyWithoutProductVariantInputSchema: z.ZodType<Prisma.ProductImageCreateNestedManyWithoutProductVariantInput> =
  z
    .object({
      create: z
        .union([
          z.lazy(() => ProductImageCreateWithoutProductVariantInputSchema),
          z
            .lazy(() => ProductImageCreateWithoutProductVariantInputSchema)
            .array(),
          z.lazy(
            () => ProductImageUncheckedCreateWithoutProductVariantInputSchema,
          ),
          z
            .lazy(
              () => ProductImageUncheckedCreateWithoutProductVariantInputSchema,
            )
            .array(),
        ])
        .optional(),
      connectOrCreate: z
        .union([
          z.lazy(
            () => ProductImageCreateOrConnectWithoutProductVariantInputSchema,
          ),
          z
            .lazy(
              () => ProductImageCreateOrConnectWithoutProductVariantInputSchema,
            )
            .array(),
        ])
        .optional(),
      createMany: z
        .lazy(() => ProductImageCreateManyProductVariantInputEnvelopeSchema)
        .optional(),
      connect: z
        .union([
          z.lazy(() => ProductImageWhereUniqueInputSchema),
          z.lazy(() => ProductImageWhereUniqueInputSchema).array(),
        ])
        .optional(),
    })
    .strict() as z.ZodType<Prisma.ProductImageCreateNestedManyWithoutProductVariantInput>;

export const OrderItemCreateNestedManyWithoutProductVariantInputSchema: z.ZodType<Prisma.OrderItemCreateNestedManyWithoutProductVariantInput> =
  z
    .object({
      create: z
        .union([
          z.lazy(() => OrderItemCreateWithoutProductVariantInputSchema),
          z.lazy(() => OrderItemCreateWithoutProductVariantInputSchema).array(),
          z.lazy(
            () => OrderItemUncheckedCreateWithoutProductVariantInputSchema,
          ),
          z
            .lazy(
              () => OrderItemUncheckedCreateWithoutProductVariantInputSchema,
            )
            .array(),
        ])
        .optional(),
      connectOrCreate: z
        .union([
          z.lazy(
            () => OrderItemCreateOrConnectWithoutProductVariantInputSchema,
          ),
          z
            .lazy(
              () => OrderItemCreateOrConnectWithoutProductVariantInputSchema,
            )
            .array(),
        ])
        .optional(),
      createMany: z
        .lazy(() => OrderItemCreateManyProductVariantInputEnvelopeSchema)
        .optional(),
      connect: z
        .union([
          z.lazy(() => OrderItemWhereUniqueInputSchema),
          z.lazy(() => OrderItemWhereUniqueInputSchema).array(),
        ])
        .optional(),
    })
    .strict() as z.ZodType<Prisma.OrderItemCreateNestedManyWithoutProductVariantInput>;

export const CartItemCreateNestedManyWithoutProductVariantInputSchema: z.ZodType<Prisma.CartItemCreateNestedManyWithoutProductVariantInput> =
  z
    .object({
      create: z
        .union([
          z.lazy(() => CartItemCreateWithoutProductVariantInputSchema),
          z.lazy(() => CartItemCreateWithoutProductVariantInputSchema).array(),
          z.lazy(() => CartItemUncheckedCreateWithoutProductVariantInputSchema),
          z
            .lazy(() => CartItemUncheckedCreateWithoutProductVariantInputSchema)
            .array(),
        ])
        .optional(),
      connectOrCreate: z
        .union([
          z.lazy(() => CartItemCreateOrConnectWithoutProductVariantInputSchema),
          z
            .lazy(() => CartItemCreateOrConnectWithoutProductVariantInputSchema)
            .array(),
        ])
        .optional(),
      createMany: z
        .lazy(() => CartItemCreateManyProductVariantInputEnvelopeSchema)
        .optional(),
      connect: z
        .union([
          z.lazy(() => CartItemWhereUniqueInputSchema),
          z.lazy(() => CartItemWhereUniqueInputSchema).array(),
        ])
        .optional(),
    })
    .strict() as z.ZodType<Prisma.CartItemCreateNestedManyWithoutProductVariantInput>;

export const ProductImageUncheckedCreateNestedManyWithoutProductVariantInputSchema: z.ZodType<Prisma.ProductImageUncheckedCreateNestedManyWithoutProductVariantInput> =
  z
    .object({
      create: z
        .union([
          z.lazy(() => ProductImageCreateWithoutProductVariantInputSchema),
          z
            .lazy(() => ProductImageCreateWithoutProductVariantInputSchema)
            .array(),
          z.lazy(
            () => ProductImageUncheckedCreateWithoutProductVariantInputSchema,
          ),
          z
            .lazy(
              () => ProductImageUncheckedCreateWithoutProductVariantInputSchema,
            )
            .array(),
        ])
        .optional(),
      connectOrCreate: z
        .union([
          z.lazy(
            () => ProductImageCreateOrConnectWithoutProductVariantInputSchema,
          ),
          z
            .lazy(
              () => ProductImageCreateOrConnectWithoutProductVariantInputSchema,
            )
            .array(),
        ])
        .optional(),
      createMany: z
        .lazy(() => ProductImageCreateManyProductVariantInputEnvelopeSchema)
        .optional(),
      connect: z
        .union([
          z.lazy(() => ProductImageWhereUniqueInputSchema),
          z.lazy(() => ProductImageWhereUniqueInputSchema).array(),
        ])
        .optional(),
    })
    .strict() as z.ZodType<Prisma.ProductImageUncheckedCreateNestedManyWithoutProductVariantInput>;

export const OrderItemUncheckedCreateNestedManyWithoutProductVariantInputSchema: z.ZodType<Prisma.OrderItemUncheckedCreateNestedManyWithoutProductVariantInput> =
  z
    .object({
      create: z
        .union([
          z.lazy(() => OrderItemCreateWithoutProductVariantInputSchema),
          z.lazy(() => OrderItemCreateWithoutProductVariantInputSchema).array(),
          z.lazy(
            () => OrderItemUncheckedCreateWithoutProductVariantInputSchema,
          ),
          z
            .lazy(
              () => OrderItemUncheckedCreateWithoutProductVariantInputSchema,
            )
            .array(),
        ])
        .optional(),
      connectOrCreate: z
        .union([
          z.lazy(
            () => OrderItemCreateOrConnectWithoutProductVariantInputSchema,
          ),
          z
            .lazy(
              () => OrderItemCreateOrConnectWithoutProductVariantInputSchema,
            )
            .array(),
        ])
        .optional(),
      createMany: z
        .lazy(() => OrderItemCreateManyProductVariantInputEnvelopeSchema)
        .optional(),
      connect: z
        .union([
          z.lazy(() => OrderItemWhereUniqueInputSchema),
          z.lazy(() => OrderItemWhereUniqueInputSchema).array(),
        ])
        .optional(),
    })
    .strict() as z.ZodType<Prisma.OrderItemUncheckedCreateNestedManyWithoutProductVariantInput>;

export const CartItemUncheckedCreateNestedManyWithoutProductVariantInputSchema: z.ZodType<Prisma.CartItemUncheckedCreateNestedManyWithoutProductVariantInput> =
  z
    .object({
      create: z
        .union([
          z.lazy(() => CartItemCreateWithoutProductVariantInputSchema),
          z.lazy(() => CartItemCreateWithoutProductVariantInputSchema).array(),
          z.lazy(() => CartItemUncheckedCreateWithoutProductVariantInputSchema),
          z
            .lazy(() => CartItemUncheckedCreateWithoutProductVariantInputSchema)
            .array(),
        ])
        .optional(),
      connectOrCreate: z
        .union([
          z.lazy(() => CartItemCreateOrConnectWithoutProductVariantInputSchema),
          z
            .lazy(() => CartItemCreateOrConnectWithoutProductVariantInputSchema)
            .array(),
        ])
        .optional(),
      createMany: z
        .lazy(() => CartItemCreateManyProductVariantInputEnvelopeSchema)
        .optional(),
      connect: z
        .union([
          z.lazy(() => CartItemWhereUniqueInputSchema),
          z.lazy(() => CartItemWhereUniqueInputSchema).array(),
        ])
        .optional(),
    })
    .strict() as z.ZodType<Prisma.CartItemUncheckedCreateNestedManyWithoutProductVariantInput>;

export const ProductUpdateOneRequiredWithoutProductVariantsNestedInputSchema: z.ZodType<Prisma.ProductUpdateOneRequiredWithoutProductVariantsNestedInput> =
  z
    .object({
      create: z
        .union([
          z.lazy(() => ProductCreateWithoutProductVariantsInputSchema),
          z.lazy(() => ProductUncheckedCreateWithoutProductVariantsInputSchema),
        ])
        .optional(),
      connectOrCreate: z
        .lazy(() => ProductCreateOrConnectWithoutProductVariantsInputSchema)
        .optional(),
      upsert: z
        .lazy(() => ProductUpsertWithoutProductVariantsInputSchema)
        .optional(),
      connect: z.lazy(() => ProductWhereUniqueInputSchema).optional(),
      update: z
        .union([
          z.lazy(
            () => ProductUpdateToOneWithWhereWithoutProductVariantsInputSchema,
          ),
          z.lazy(() => ProductUpdateWithoutProductVariantsInputSchema),
          z.lazy(() => ProductUncheckedUpdateWithoutProductVariantsInputSchema),
        ])
        .optional(),
    })
    .strict() as z.ZodType<Prisma.ProductUpdateOneRequiredWithoutProductVariantsNestedInput>;

export const ProductImageUpdateManyWithoutProductVariantNestedInputSchema: z.ZodType<Prisma.ProductImageUpdateManyWithoutProductVariantNestedInput> =
  z
    .object({
      create: z
        .union([
          z.lazy(() => ProductImageCreateWithoutProductVariantInputSchema),
          z
            .lazy(() => ProductImageCreateWithoutProductVariantInputSchema)
            .array(),
          z.lazy(
            () => ProductImageUncheckedCreateWithoutProductVariantInputSchema,
          ),
          z
            .lazy(
              () => ProductImageUncheckedCreateWithoutProductVariantInputSchema,
            )
            .array(),
        ])
        .optional(),
      connectOrCreate: z
        .union([
          z.lazy(
            () => ProductImageCreateOrConnectWithoutProductVariantInputSchema,
          ),
          z
            .lazy(
              () => ProductImageCreateOrConnectWithoutProductVariantInputSchema,
            )
            .array(),
        ])
        .optional(),
      upsert: z
        .union([
          z.lazy(
            () =>
              ProductImageUpsertWithWhereUniqueWithoutProductVariantInputSchema,
          ),
          z
            .lazy(
              () =>
                ProductImageUpsertWithWhereUniqueWithoutProductVariantInputSchema,
            )
            .array(),
        ])
        .optional(),
      createMany: z
        .lazy(() => ProductImageCreateManyProductVariantInputEnvelopeSchema)
        .optional(),
      set: z
        .union([
          z.lazy(() => ProductImageWhereUniqueInputSchema),
          z.lazy(() => ProductImageWhereUniqueInputSchema).array(),
        ])
        .optional(),
      disconnect: z
        .union([
          z.lazy(() => ProductImageWhereUniqueInputSchema),
          z.lazy(() => ProductImageWhereUniqueInputSchema).array(),
        ])
        .optional(),
      delete: z
        .union([
          z.lazy(() => ProductImageWhereUniqueInputSchema),
          z.lazy(() => ProductImageWhereUniqueInputSchema).array(),
        ])
        .optional(),
      connect: z
        .union([
          z.lazy(() => ProductImageWhereUniqueInputSchema),
          z.lazy(() => ProductImageWhereUniqueInputSchema).array(),
        ])
        .optional(),
      update: z
        .union([
          z.lazy(
            () =>
              ProductImageUpdateWithWhereUniqueWithoutProductVariantInputSchema,
          ),
          z
            .lazy(
              () =>
                ProductImageUpdateWithWhereUniqueWithoutProductVariantInputSchema,
            )
            .array(),
        ])
        .optional(),
      updateMany: z
        .union([
          z.lazy(
            () =>
              ProductImageUpdateManyWithWhereWithoutProductVariantInputSchema,
          ),
          z
            .lazy(
              () =>
                ProductImageUpdateManyWithWhereWithoutProductVariantInputSchema,
            )
            .array(),
        ])
        .optional(),
      deleteMany: z
        .union([
          z.lazy(() => ProductImageScalarWhereInputSchema),
          z.lazy(() => ProductImageScalarWhereInputSchema).array(),
        ])
        .optional(),
    })
    .strict() as z.ZodType<Prisma.ProductImageUpdateManyWithoutProductVariantNestedInput>;

export const OrderItemUpdateManyWithoutProductVariantNestedInputSchema: z.ZodType<Prisma.OrderItemUpdateManyWithoutProductVariantNestedInput> =
  z
    .object({
      create: z
        .union([
          z.lazy(() => OrderItemCreateWithoutProductVariantInputSchema),
          z.lazy(() => OrderItemCreateWithoutProductVariantInputSchema).array(),
          z.lazy(
            () => OrderItemUncheckedCreateWithoutProductVariantInputSchema,
          ),
          z
            .lazy(
              () => OrderItemUncheckedCreateWithoutProductVariantInputSchema,
            )
            .array(),
        ])
        .optional(),
      connectOrCreate: z
        .union([
          z.lazy(
            () => OrderItemCreateOrConnectWithoutProductVariantInputSchema,
          ),
          z
            .lazy(
              () => OrderItemCreateOrConnectWithoutProductVariantInputSchema,
            )
            .array(),
        ])
        .optional(),
      upsert: z
        .union([
          z.lazy(
            () =>
              OrderItemUpsertWithWhereUniqueWithoutProductVariantInputSchema,
          ),
          z
            .lazy(
              () =>
                OrderItemUpsertWithWhereUniqueWithoutProductVariantInputSchema,
            )
            .array(),
        ])
        .optional(),
      createMany: z
        .lazy(() => OrderItemCreateManyProductVariantInputEnvelopeSchema)
        .optional(),
      set: z
        .union([
          z.lazy(() => OrderItemWhereUniqueInputSchema),
          z.lazy(() => OrderItemWhereUniqueInputSchema).array(),
        ])
        .optional(),
      disconnect: z
        .union([
          z.lazy(() => OrderItemWhereUniqueInputSchema),
          z.lazy(() => OrderItemWhereUniqueInputSchema).array(),
        ])
        .optional(),
      delete: z
        .union([
          z.lazy(() => OrderItemWhereUniqueInputSchema),
          z.lazy(() => OrderItemWhereUniqueInputSchema).array(),
        ])
        .optional(),
      connect: z
        .union([
          z.lazy(() => OrderItemWhereUniqueInputSchema),
          z.lazy(() => OrderItemWhereUniqueInputSchema).array(),
        ])
        .optional(),
      update: z
        .union([
          z.lazy(
            () =>
              OrderItemUpdateWithWhereUniqueWithoutProductVariantInputSchema,
          ),
          z
            .lazy(
              () =>
                OrderItemUpdateWithWhereUniqueWithoutProductVariantInputSchema,
            )
            .array(),
        ])
        .optional(),
      updateMany: z
        .union([
          z.lazy(
            () => OrderItemUpdateManyWithWhereWithoutProductVariantInputSchema,
          ),
          z
            .lazy(
              () =>
                OrderItemUpdateManyWithWhereWithoutProductVariantInputSchema,
            )
            .array(),
        ])
        .optional(),
      deleteMany: z
        .union([
          z.lazy(() => OrderItemScalarWhereInputSchema),
          z.lazy(() => OrderItemScalarWhereInputSchema).array(),
        ])
        .optional(),
    })
    .strict() as z.ZodType<Prisma.OrderItemUpdateManyWithoutProductVariantNestedInput>;

export const CartItemUpdateManyWithoutProductVariantNestedInputSchema: z.ZodType<Prisma.CartItemUpdateManyWithoutProductVariantNestedInput> =
  z
    .object({
      create: z
        .union([
          z.lazy(() => CartItemCreateWithoutProductVariantInputSchema),
          z.lazy(() => CartItemCreateWithoutProductVariantInputSchema).array(),
          z.lazy(() => CartItemUncheckedCreateWithoutProductVariantInputSchema),
          z
            .lazy(() => CartItemUncheckedCreateWithoutProductVariantInputSchema)
            .array(),
        ])
        .optional(),
      connectOrCreate: z
        .union([
          z.lazy(() => CartItemCreateOrConnectWithoutProductVariantInputSchema),
          z
            .lazy(() => CartItemCreateOrConnectWithoutProductVariantInputSchema)
            .array(),
        ])
        .optional(),
      upsert: z
        .union([
          z.lazy(
            () => CartItemUpsertWithWhereUniqueWithoutProductVariantInputSchema,
          ),
          z
            .lazy(
              () =>
                CartItemUpsertWithWhereUniqueWithoutProductVariantInputSchema,
            )
            .array(),
        ])
        .optional(),
      createMany: z
        .lazy(() => CartItemCreateManyProductVariantInputEnvelopeSchema)
        .optional(),
      set: z
        .union([
          z.lazy(() => CartItemWhereUniqueInputSchema),
          z.lazy(() => CartItemWhereUniqueInputSchema).array(),
        ])
        .optional(),
      disconnect: z
        .union([
          z.lazy(() => CartItemWhereUniqueInputSchema),
          z.lazy(() => CartItemWhereUniqueInputSchema).array(),
        ])
        .optional(),
      delete: z
        .union([
          z.lazy(() => CartItemWhereUniqueInputSchema),
          z.lazy(() => CartItemWhereUniqueInputSchema).array(),
        ])
        .optional(),
      connect: z
        .union([
          z.lazy(() => CartItemWhereUniqueInputSchema),
          z.lazy(() => CartItemWhereUniqueInputSchema).array(),
        ])
        .optional(),
      update: z
        .union([
          z.lazy(
            () => CartItemUpdateWithWhereUniqueWithoutProductVariantInputSchema,
          ),
          z
            .lazy(
              () =>
                CartItemUpdateWithWhereUniqueWithoutProductVariantInputSchema,
            )
            .array(),
        ])
        .optional(),
      updateMany: z
        .union([
          z.lazy(
            () => CartItemUpdateManyWithWhereWithoutProductVariantInputSchema,
          ),
          z
            .lazy(
              () => CartItemUpdateManyWithWhereWithoutProductVariantInputSchema,
            )
            .array(),
        ])
        .optional(),
      deleteMany: z
        .union([
          z.lazy(() => CartItemScalarWhereInputSchema),
          z.lazy(() => CartItemScalarWhereInputSchema).array(),
        ])
        .optional(),
    })
    .strict() as z.ZodType<Prisma.CartItemUpdateManyWithoutProductVariantNestedInput>;

export const ProductImageUncheckedUpdateManyWithoutProductVariantNestedInputSchema: z.ZodType<Prisma.ProductImageUncheckedUpdateManyWithoutProductVariantNestedInput> =
  z
    .object({
      create: z
        .union([
          z.lazy(() => ProductImageCreateWithoutProductVariantInputSchema),
          z
            .lazy(() => ProductImageCreateWithoutProductVariantInputSchema)
            .array(),
          z.lazy(
            () => ProductImageUncheckedCreateWithoutProductVariantInputSchema,
          ),
          z
            .lazy(
              () => ProductImageUncheckedCreateWithoutProductVariantInputSchema,
            )
            .array(),
        ])
        .optional(),
      connectOrCreate: z
        .union([
          z.lazy(
            () => ProductImageCreateOrConnectWithoutProductVariantInputSchema,
          ),
          z
            .lazy(
              () => ProductImageCreateOrConnectWithoutProductVariantInputSchema,
            )
            .array(),
        ])
        .optional(),
      upsert: z
        .union([
          z.lazy(
            () =>
              ProductImageUpsertWithWhereUniqueWithoutProductVariantInputSchema,
          ),
          z
            .lazy(
              () =>
                ProductImageUpsertWithWhereUniqueWithoutProductVariantInputSchema,
            )
            .array(),
        ])
        .optional(),
      createMany: z
        .lazy(() => ProductImageCreateManyProductVariantInputEnvelopeSchema)
        .optional(),
      set: z
        .union([
          z.lazy(() => ProductImageWhereUniqueInputSchema),
          z.lazy(() => ProductImageWhereUniqueInputSchema).array(),
        ])
        .optional(),
      disconnect: z
        .union([
          z.lazy(() => ProductImageWhereUniqueInputSchema),
          z.lazy(() => ProductImageWhereUniqueInputSchema).array(),
        ])
        .optional(),
      delete: z
        .union([
          z.lazy(() => ProductImageWhereUniqueInputSchema),
          z.lazy(() => ProductImageWhereUniqueInputSchema).array(),
        ])
        .optional(),
      connect: z
        .union([
          z.lazy(() => ProductImageWhereUniqueInputSchema),
          z.lazy(() => ProductImageWhereUniqueInputSchema).array(),
        ])
        .optional(),
      update: z
        .union([
          z.lazy(
            () =>
              ProductImageUpdateWithWhereUniqueWithoutProductVariantInputSchema,
          ),
          z
            .lazy(
              () =>
                ProductImageUpdateWithWhereUniqueWithoutProductVariantInputSchema,
            )
            .array(),
        ])
        .optional(),
      updateMany: z
        .union([
          z.lazy(
            () =>
              ProductImageUpdateManyWithWhereWithoutProductVariantInputSchema,
          ),
          z
            .lazy(
              () =>
                ProductImageUpdateManyWithWhereWithoutProductVariantInputSchema,
            )
            .array(),
        ])
        .optional(),
      deleteMany: z
        .union([
          z.lazy(() => ProductImageScalarWhereInputSchema),
          z.lazy(() => ProductImageScalarWhereInputSchema).array(),
        ])
        .optional(),
    })
    .strict() as z.ZodType<Prisma.ProductImageUncheckedUpdateManyWithoutProductVariantNestedInput>;

export const OrderItemUncheckedUpdateManyWithoutProductVariantNestedInputSchema: z.ZodType<Prisma.OrderItemUncheckedUpdateManyWithoutProductVariantNestedInput> =
  z
    .object({
      create: z
        .union([
          z.lazy(() => OrderItemCreateWithoutProductVariantInputSchema),
          z.lazy(() => OrderItemCreateWithoutProductVariantInputSchema).array(),
          z.lazy(
            () => OrderItemUncheckedCreateWithoutProductVariantInputSchema,
          ),
          z
            .lazy(
              () => OrderItemUncheckedCreateWithoutProductVariantInputSchema,
            )
            .array(),
        ])
        .optional(),
      connectOrCreate: z
        .union([
          z.lazy(
            () => OrderItemCreateOrConnectWithoutProductVariantInputSchema,
          ),
          z
            .lazy(
              () => OrderItemCreateOrConnectWithoutProductVariantInputSchema,
            )
            .array(),
        ])
        .optional(),
      upsert: z
        .union([
          z.lazy(
            () =>
              OrderItemUpsertWithWhereUniqueWithoutProductVariantInputSchema,
          ),
          z
            .lazy(
              () =>
                OrderItemUpsertWithWhereUniqueWithoutProductVariantInputSchema,
            )
            .array(),
        ])
        .optional(),
      createMany: z
        .lazy(() => OrderItemCreateManyProductVariantInputEnvelopeSchema)
        .optional(),
      set: z
        .union([
          z.lazy(() => OrderItemWhereUniqueInputSchema),
          z.lazy(() => OrderItemWhereUniqueInputSchema).array(),
        ])
        .optional(),
      disconnect: z
        .union([
          z.lazy(() => OrderItemWhereUniqueInputSchema),
          z.lazy(() => OrderItemWhereUniqueInputSchema).array(),
        ])
        .optional(),
      delete: z
        .union([
          z.lazy(() => OrderItemWhereUniqueInputSchema),
          z.lazy(() => OrderItemWhereUniqueInputSchema).array(),
        ])
        .optional(),
      connect: z
        .union([
          z.lazy(() => OrderItemWhereUniqueInputSchema),
          z.lazy(() => OrderItemWhereUniqueInputSchema).array(),
        ])
        .optional(),
      update: z
        .union([
          z.lazy(
            () =>
              OrderItemUpdateWithWhereUniqueWithoutProductVariantInputSchema,
          ),
          z
            .lazy(
              () =>
                OrderItemUpdateWithWhereUniqueWithoutProductVariantInputSchema,
            )
            .array(),
        ])
        .optional(),
      updateMany: z
        .union([
          z.lazy(
            () => OrderItemUpdateManyWithWhereWithoutProductVariantInputSchema,
          ),
          z
            .lazy(
              () =>
                OrderItemUpdateManyWithWhereWithoutProductVariantInputSchema,
            )
            .array(),
        ])
        .optional(),
      deleteMany: z
        .union([
          z.lazy(() => OrderItemScalarWhereInputSchema),
          z.lazy(() => OrderItemScalarWhereInputSchema).array(),
        ])
        .optional(),
    })
    .strict() as z.ZodType<Prisma.OrderItemUncheckedUpdateManyWithoutProductVariantNestedInput>;

export const CartItemUncheckedUpdateManyWithoutProductVariantNestedInputSchema: z.ZodType<Prisma.CartItemUncheckedUpdateManyWithoutProductVariantNestedInput> =
  z
    .object({
      create: z
        .union([
          z.lazy(() => CartItemCreateWithoutProductVariantInputSchema),
          z.lazy(() => CartItemCreateWithoutProductVariantInputSchema).array(),
          z.lazy(() => CartItemUncheckedCreateWithoutProductVariantInputSchema),
          z
            .lazy(() => CartItemUncheckedCreateWithoutProductVariantInputSchema)
            .array(),
        ])
        .optional(),
      connectOrCreate: z
        .union([
          z.lazy(() => CartItemCreateOrConnectWithoutProductVariantInputSchema),
          z
            .lazy(() => CartItemCreateOrConnectWithoutProductVariantInputSchema)
            .array(),
        ])
        .optional(),
      upsert: z
        .union([
          z.lazy(
            () => CartItemUpsertWithWhereUniqueWithoutProductVariantInputSchema,
          ),
          z
            .lazy(
              () =>
                CartItemUpsertWithWhereUniqueWithoutProductVariantInputSchema,
            )
            .array(),
        ])
        .optional(),
      createMany: z
        .lazy(() => CartItemCreateManyProductVariantInputEnvelopeSchema)
        .optional(),
      set: z
        .union([
          z.lazy(() => CartItemWhereUniqueInputSchema),
          z.lazy(() => CartItemWhereUniqueInputSchema).array(),
        ])
        .optional(),
      disconnect: z
        .union([
          z.lazy(() => CartItemWhereUniqueInputSchema),
          z.lazy(() => CartItemWhereUniqueInputSchema).array(),
        ])
        .optional(),
      delete: z
        .union([
          z.lazy(() => CartItemWhereUniqueInputSchema),
          z.lazy(() => CartItemWhereUniqueInputSchema).array(),
        ])
        .optional(),
      connect: z
        .union([
          z.lazy(() => CartItemWhereUniqueInputSchema),
          z.lazy(() => CartItemWhereUniqueInputSchema).array(),
        ])
        .optional(),
      update: z
        .union([
          z.lazy(
            () => CartItemUpdateWithWhereUniqueWithoutProductVariantInputSchema,
          ),
          z
            .lazy(
              () =>
                CartItemUpdateWithWhereUniqueWithoutProductVariantInputSchema,
            )
            .array(),
        ])
        .optional(),
      updateMany: z
        .union([
          z.lazy(
            () => CartItemUpdateManyWithWhereWithoutProductVariantInputSchema,
          ),
          z
            .lazy(
              () => CartItemUpdateManyWithWhereWithoutProductVariantInputSchema,
            )
            .array(),
        ])
        .optional(),
      deleteMany: z
        .union([
          z.lazy(() => CartItemScalarWhereInputSchema),
          z.lazy(() => CartItemScalarWhereInputSchema).array(),
        ])
        .optional(),
    })
    .strict() as z.ZodType<Prisma.CartItemUncheckedUpdateManyWithoutProductVariantNestedInput>;

export const ProductCreateNestedOneWithoutProductCategoriesInputSchema: z.ZodType<Prisma.ProductCreateNestedOneWithoutProductCategoriesInput> =
  z
    .object({
      create: z
        .union([
          z.lazy(() => ProductCreateWithoutProductCategoriesInputSchema),
          z.lazy(
            () => ProductUncheckedCreateWithoutProductCategoriesInputSchema,
          ),
        ])
        .optional(),
      connectOrCreate: z
        .lazy(() => ProductCreateOrConnectWithoutProductCategoriesInputSchema)
        .optional(),
      connect: z.lazy(() => ProductWhereUniqueInputSchema).optional(),
    })
    .strict() as z.ZodType<Prisma.ProductCreateNestedOneWithoutProductCategoriesInput>;

export const CategoryCreateNestedOneWithoutProductCategoriesInputSchema: z.ZodType<Prisma.CategoryCreateNestedOneWithoutProductCategoriesInput> =
  z
    .object({
      create: z
        .union([
          z.lazy(() => CategoryCreateWithoutProductCategoriesInputSchema),
          z.lazy(
            () => CategoryUncheckedCreateWithoutProductCategoriesInputSchema,
          ),
        ])
        .optional(),
      connectOrCreate: z
        .lazy(() => CategoryCreateOrConnectWithoutProductCategoriesInputSchema)
        .optional(),
      connect: z.lazy(() => CategoryWhereUniqueInputSchema).optional(),
    })
    .strict() as z.ZodType<Prisma.CategoryCreateNestedOneWithoutProductCategoriesInput>;

export const ProductUpdateOneRequiredWithoutProductCategoriesNestedInputSchema: z.ZodType<Prisma.ProductUpdateOneRequiredWithoutProductCategoriesNestedInput> =
  z
    .object({
      create: z
        .union([
          z.lazy(() => ProductCreateWithoutProductCategoriesInputSchema),
          z.lazy(
            () => ProductUncheckedCreateWithoutProductCategoriesInputSchema,
          ),
        ])
        .optional(),
      connectOrCreate: z
        .lazy(() => ProductCreateOrConnectWithoutProductCategoriesInputSchema)
        .optional(),
      upsert: z
        .lazy(() => ProductUpsertWithoutProductCategoriesInputSchema)
        .optional(),
      connect: z.lazy(() => ProductWhereUniqueInputSchema).optional(),
      update: z
        .union([
          z.lazy(
            () =>
              ProductUpdateToOneWithWhereWithoutProductCategoriesInputSchema,
          ),
          z.lazy(() => ProductUpdateWithoutProductCategoriesInputSchema),
          z.lazy(
            () => ProductUncheckedUpdateWithoutProductCategoriesInputSchema,
          ),
        ])
        .optional(),
    })
    .strict() as z.ZodType<Prisma.ProductUpdateOneRequiredWithoutProductCategoriesNestedInput>;

export const CategoryUpdateOneRequiredWithoutProductCategoriesNestedInputSchema: z.ZodType<Prisma.CategoryUpdateOneRequiredWithoutProductCategoriesNestedInput> =
  z
    .object({
      create: z
        .union([
          z.lazy(() => CategoryCreateWithoutProductCategoriesInputSchema),
          z.lazy(
            () => CategoryUncheckedCreateWithoutProductCategoriesInputSchema,
          ),
        ])
        .optional(),
      connectOrCreate: z
        .lazy(() => CategoryCreateOrConnectWithoutProductCategoriesInputSchema)
        .optional(),
      upsert: z
        .lazy(() => CategoryUpsertWithoutProductCategoriesInputSchema)
        .optional(),
      connect: z.lazy(() => CategoryWhereUniqueInputSchema).optional(),
      update: z
        .union([
          z.lazy(
            () =>
              CategoryUpdateToOneWithWhereWithoutProductCategoriesInputSchema,
          ),
          z.lazy(() => CategoryUpdateWithoutProductCategoriesInputSchema),
          z.lazy(
            () => CategoryUncheckedUpdateWithoutProductCategoriesInputSchema,
          ),
        ])
        .optional(),
    })
    .strict() as z.ZodType<Prisma.CategoryUpdateOneRequiredWithoutProductCategoriesNestedInput>;

export const ProductCreateNestedOneWithoutProductImagesInputSchema: z.ZodType<Prisma.ProductCreateNestedOneWithoutProductImagesInput> =
  z
    .object({
      create: z
        .union([
          z.lazy(() => ProductCreateWithoutProductImagesInputSchema),
          z.lazy(() => ProductUncheckedCreateWithoutProductImagesInputSchema),
        ])
        .optional(),
      connectOrCreate: z
        .lazy(() => ProductCreateOrConnectWithoutProductImagesInputSchema)
        .optional(),
      connect: z.lazy(() => ProductWhereUniqueInputSchema).optional(),
    })
    .strict() as z.ZodType<Prisma.ProductCreateNestedOneWithoutProductImagesInput>;

export const ProductVariantCreateNestedOneWithoutProductImagesInputSchema: z.ZodType<Prisma.ProductVariantCreateNestedOneWithoutProductImagesInput> =
  z
    .object({
      create: z
        .union([
          z.lazy(() => ProductVariantCreateWithoutProductImagesInputSchema),
          z.lazy(
            () => ProductVariantUncheckedCreateWithoutProductImagesInputSchema,
          ),
        ])
        .optional(),
      connectOrCreate: z
        .lazy(
          () => ProductVariantCreateOrConnectWithoutProductImagesInputSchema,
        )
        .optional(),
      connect: z.lazy(() => ProductVariantWhereUniqueInputSchema).optional(),
    })
    .strict() as z.ZodType<Prisma.ProductVariantCreateNestedOneWithoutProductImagesInput>;

export const ProductUpdateOneWithoutProductImagesNestedInputSchema: z.ZodType<Prisma.ProductUpdateOneWithoutProductImagesNestedInput> =
  z
    .object({
      create: z
        .union([
          z.lazy(() => ProductCreateWithoutProductImagesInputSchema),
          z.lazy(() => ProductUncheckedCreateWithoutProductImagesInputSchema),
        ])
        .optional(),
      connectOrCreate: z
        .lazy(() => ProductCreateOrConnectWithoutProductImagesInputSchema)
        .optional(),
      upsert: z
        .lazy(() => ProductUpsertWithoutProductImagesInputSchema)
        .optional(),
      disconnect: z
        .union([z.boolean(), z.lazy(() => ProductWhereInputSchema)])
        .optional(),
      delete: z
        .union([z.boolean(), z.lazy(() => ProductWhereInputSchema)])
        .optional(),
      connect: z.lazy(() => ProductWhereUniqueInputSchema).optional(),
      update: z
        .union([
          z.lazy(
            () => ProductUpdateToOneWithWhereWithoutProductImagesInputSchema,
          ),
          z.lazy(() => ProductUpdateWithoutProductImagesInputSchema),
          z.lazy(() => ProductUncheckedUpdateWithoutProductImagesInputSchema),
        ])
        .optional(),
    })
    .strict() as z.ZodType<Prisma.ProductUpdateOneWithoutProductImagesNestedInput>;

export const ProductVariantUpdateOneWithoutProductImagesNestedInputSchema: z.ZodType<Prisma.ProductVariantUpdateOneWithoutProductImagesNestedInput> =
  z
    .object({
      create: z
        .union([
          z.lazy(() => ProductVariantCreateWithoutProductImagesInputSchema),
          z.lazy(
            () => ProductVariantUncheckedCreateWithoutProductImagesInputSchema,
          ),
        ])
        .optional(),
      connectOrCreate: z
        .lazy(
          () => ProductVariantCreateOrConnectWithoutProductImagesInputSchema,
        )
        .optional(),
      upsert: z
        .lazy(() => ProductVariantUpsertWithoutProductImagesInputSchema)
        .optional(),
      disconnect: z
        .union([z.boolean(), z.lazy(() => ProductVariantWhereInputSchema)])
        .optional(),
      delete: z
        .union([z.boolean(), z.lazy(() => ProductVariantWhereInputSchema)])
        .optional(),
      connect: z.lazy(() => ProductVariantWhereUniqueInputSchema).optional(),
      update: z
        .union([
          z.lazy(
            () =>
              ProductVariantUpdateToOneWithWhereWithoutProductImagesInputSchema,
          ),
          z.lazy(() => ProductVariantUpdateWithoutProductImagesInputSchema),
          z.lazy(
            () => ProductVariantUncheckedUpdateWithoutProductImagesInputSchema,
          ),
        ])
        .optional(),
    })
    .strict() as z.ZodType<Prisma.ProductVariantUpdateOneWithoutProductImagesNestedInput>;

export const UserCreateNestedOneWithoutOrdersInputSchema: z.ZodType<Prisma.UserCreateNestedOneWithoutOrdersInput> =
  z
    .object({
      create: z
        .union([
          z.lazy(() => UserCreateWithoutOrdersInputSchema),
          z.lazy(() => UserUncheckedCreateWithoutOrdersInputSchema),
        ])
        .optional(),
      connectOrCreate: z
        .lazy(() => UserCreateOrConnectWithoutOrdersInputSchema)
        .optional(),
      connect: z.lazy(() => UserWhereUniqueInputSchema).optional(),
    })
    .strict() as z.ZodType<Prisma.UserCreateNestedOneWithoutOrdersInput>;

export const OrderItemCreateNestedManyWithoutOrderInputSchema: z.ZodType<Prisma.OrderItemCreateNestedManyWithoutOrderInput> =
  z
    .object({
      create: z
        .union([
          z.lazy(() => OrderItemCreateWithoutOrderInputSchema),
          z.lazy(() => OrderItemCreateWithoutOrderInputSchema).array(),
          z.lazy(() => OrderItemUncheckedCreateWithoutOrderInputSchema),
          z.lazy(() => OrderItemUncheckedCreateWithoutOrderInputSchema).array(),
        ])
        .optional(),
      connectOrCreate: z
        .union([
          z.lazy(() => OrderItemCreateOrConnectWithoutOrderInputSchema),
          z.lazy(() => OrderItemCreateOrConnectWithoutOrderInputSchema).array(),
        ])
        .optional(),
      createMany: z
        .lazy(() => OrderItemCreateManyOrderInputEnvelopeSchema)
        .optional(),
      connect: z
        .union([
          z.lazy(() => OrderItemWhereUniqueInputSchema),
          z.lazy(() => OrderItemWhereUniqueInputSchema).array(),
        ])
        .optional(),
    })
    .strict() as z.ZodType<Prisma.OrderItemCreateNestedManyWithoutOrderInput>;

export const OrderAddressCreateNestedManyWithoutOrderInputSchema: z.ZodType<Prisma.OrderAddressCreateNestedManyWithoutOrderInput> =
  z
    .object({
      create: z
        .union([
          z.lazy(() => OrderAddressCreateWithoutOrderInputSchema),
          z.lazy(() => OrderAddressCreateWithoutOrderInputSchema).array(),
          z.lazy(() => OrderAddressUncheckedCreateWithoutOrderInputSchema),
          z
            .lazy(() => OrderAddressUncheckedCreateWithoutOrderInputSchema)
            .array(),
        ])
        .optional(),
      connectOrCreate: z
        .union([
          z.lazy(() => OrderAddressCreateOrConnectWithoutOrderInputSchema),
          z
            .lazy(() => OrderAddressCreateOrConnectWithoutOrderInputSchema)
            .array(),
        ])
        .optional(),
      createMany: z
        .lazy(() => OrderAddressCreateManyOrderInputEnvelopeSchema)
        .optional(),
      connect: z
        .union([
          z.lazy(() => OrderAddressWhereUniqueInputSchema),
          z.lazy(() => OrderAddressWhereUniqueInputSchema).array(),
        ])
        .optional(),
    })
    .strict() as z.ZodType<Prisma.OrderAddressCreateNestedManyWithoutOrderInput>;

export const OrderPromotionCreateNestedManyWithoutOrderInputSchema: z.ZodType<Prisma.OrderPromotionCreateNestedManyWithoutOrderInput> =
  z
    .object({
      create: z
        .union([
          z.lazy(() => OrderPromotionCreateWithoutOrderInputSchema),
          z.lazy(() => OrderPromotionCreateWithoutOrderInputSchema).array(),
          z.lazy(() => OrderPromotionUncheckedCreateWithoutOrderInputSchema),
          z
            .lazy(() => OrderPromotionUncheckedCreateWithoutOrderInputSchema)
            .array(),
        ])
        .optional(),
      connectOrCreate: z
        .union([
          z.lazy(() => OrderPromotionCreateOrConnectWithoutOrderInputSchema),
          z
            .lazy(() => OrderPromotionCreateOrConnectWithoutOrderInputSchema)
            .array(),
        ])
        .optional(),
      createMany: z
        .lazy(() => OrderPromotionCreateManyOrderInputEnvelopeSchema)
        .optional(),
      connect: z
        .union([
          z.lazy(() => OrderPromotionWhereUniqueInputSchema),
          z.lazy(() => OrderPromotionWhereUniqueInputSchema).array(),
        ])
        .optional(),
    })
    .strict() as z.ZodType<Prisma.OrderPromotionCreateNestedManyWithoutOrderInput>;

export const PaymentCreateNestedManyWithoutOrderInputSchema: z.ZodType<Prisma.PaymentCreateNestedManyWithoutOrderInput> =
  z
    .object({
      create: z
        .union([
          z.lazy(() => PaymentCreateWithoutOrderInputSchema),
          z.lazy(() => PaymentCreateWithoutOrderInputSchema).array(),
          z.lazy(() => PaymentUncheckedCreateWithoutOrderInputSchema),
          z.lazy(() => PaymentUncheckedCreateWithoutOrderInputSchema).array(),
        ])
        .optional(),
      connectOrCreate: z
        .union([
          z.lazy(() => PaymentCreateOrConnectWithoutOrderInputSchema),
          z.lazy(() => PaymentCreateOrConnectWithoutOrderInputSchema).array(),
        ])
        .optional(),
      createMany: z
        .lazy(() => PaymentCreateManyOrderInputEnvelopeSchema)
        .optional(),
      connect: z
        .union([
          z.lazy(() => PaymentWhereUniqueInputSchema),
          z.lazy(() => PaymentWhereUniqueInputSchema).array(),
        ])
        .optional(),
    })
    .strict() as z.ZodType<Prisma.PaymentCreateNestedManyWithoutOrderInput>;

export const OrderItemUncheckedCreateNestedManyWithoutOrderInputSchema: z.ZodType<Prisma.OrderItemUncheckedCreateNestedManyWithoutOrderInput> =
  z
    .object({
      create: z
        .union([
          z.lazy(() => OrderItemCreateWithoutOrderInputSchema),
          z.lazy(() => OrderItemCreateWithoutOrderInputSchema).array(),
          z.lazy(() => OrderItemUncheckedCreateWithoutOrderInputSchema),
          z.lazy(() => OrderItemUncheckedCreateWithoutOrderInputSchema).array(),
        ])
        .optional(),
      connectOrCreate: z
        .union([
          z.lazy(() => OrderItemCreateOrConnectWithoutOrderInputSchema),
          z.lazy(() => OrderItemCreateOrConnectWithoutOrderInputSchema).array(),
        ])
        .optional(),
      createMany: z
        .lazy(() => OrderItemCreateManyOrderInputEnvelopeSchema)
        .optional(),
      connect: z
        .union([
          z.lazy(() => OrderItemWhereUniqueInputSchema),
          z.lazy(() => OrderItemWhereUniqueInputSchema).array(),
        ])
        .optional(),
    })
    .strict() as z.ZodType<Prisma.OrderItemUncheckedCreateNestedManyWithoutOrderInput>;

export const OrderAddressUncheckedCreateNestedManyWithoutOrderInputSchema: z.ZodType<Prisma.OrderAddressUncheckedCreateNestedManyWithoutOrderInput> =
  z
    .object({
      create: z
        .union([
          z.lazy(() => OrderAddressCreateWithoutOrderInputSchema),
          z.lazy(() => OrderAddressCreateWithoutOrderInputSchema).array(),
          z.lazy(() => OrderAddressUncheckedCreateWithoutOrderInputSchema),
          z
            .lazy(() => OrderAddressUncheckedCreateWithoutOrderInputSchema)
            .array(),
        ])
        .optional(),
      connectOrCreate: z
        .union([
          z.lazy(() => OrderAddressCreateOrConnectWithoutOrderInputSchema),
          z
            .lazy(() => OrderAddressCreateOrConnectWithoutOrderInputSchema)
            .array(),
        ])
        .optional(),
      createMany: z
        .lazy(() => OrderAddressCreateManyOrderInputEnvelopeSchema)
        .optional(),
      connect: z
        .union([
          z.lazy(() => OrderAddressWhereUniqueInputSchema),
          z.lazy(() => OrderAddressWhereUniqueInputSchema).array(),
        ])
        .optional(),
    })
    .strict() as z.ZodType<Prisma.OrderAddressUncheckedCreateNestedManyWithoutOrderInput>;

export const OrderPromotionUncheckedCreateNestedManyWithoutOrderInputSchema: z.ZodType<Prisma.OrderPromotionUncheckedCreateNestedManyWithoutOrderInput> =
  z
    .object({
      create: z
        .union([
          z.lazy(() => OrderPromotionCreateWithoutOrderInputSchema),
          z.lazy(() => OrderPromotionCreateWithoutOrderInputSchema).array(),
          z.lazy(() => OrderPromotionUncheckedCreateWithoutOrderInputSchema),
          z
            .lazy(() => OrderPromotionUncheckedCreateWithoutOrderInputSchema)
            .array(),
        ])
        .optional(),
      connectOrCreate: z
        .union([
          z.lazy(() => OrderPromotionCreateOrConnectWithoutOrderInputSchema),
          z
            .lazy(() => OrderPromotionCreateOrConnectWithoutOrderInputSchema)
            .array(),
        ])
        .optional(),
      createMany: z
        .lazy(() => OrderPromotionCreateManyOrderInputEnvelopeSchema)
        .optional(),
      connect: z
        .union([
          z.lazy(() => OrderPromotionWhereUniqueInputSchema),
          z.lazy(() => OrderPromotionWhereUniqueInputSchema).array(),
        ])
        .optional(),
    })
    .strict() as z.ZodType<Prisma.OrderPromotionUncheckedCreateNestedManyWithoutOrderInput>;

export const PaymentUncheckedCreateNestedManyWithoutOrderInputSchema: z.ZodType<Prisma.PaymentUncheckedCreateNestedManyWithoutOrderInput> =
  z
    .object({
      create: z
        .union([
          z.lazy(() => PaymentCreateWithoutOrderInputSchema),
          z.lazy(() => PaymentCreateWithoutOrderInputSchema).array(),
          z.lazy(() => PaymentUncheckedCreateWithoutOrderInputSchema),
          z.lazy(() => PaymentUncheckedCreateWithoutOrderInputSchema).array(),
        ])
        .optional(),
      connectOrCreate: z
        .union([
          z.lazy(() => PaymentCreateOrConnectWithoutOrderInputSchema),
          z.lazy(() => PaymentCreateOrConnectWithoutOrderInputSchema).array(),
        ])
        .optional(),
      createMany: z
        .lazy(() => PaymentCreateManyOrderInputEnvelopeSchema)
        .optional(),
      connect: z
        .union([
          z.lazy(() => PaymentWhereUniqueInputSchema),
          z.lazy(() => PaymentWhereUniqueInputSchema).array(),
        ])
        .optional(),
    })
    .strict() as z.ZodType<Prisma.PaymentUncheckedCreateNestedManyWithoutOrderInput>;

export const EnumOrderStatusFieldUpdateOperationsInputSchema: z.ZodType<Prisma.EnumOrderStatusFieldUpdateOperationsInput> =
  z
    .object({
      set: z.lazy(() => OrderStatusSchema).optional(),
    })
    .strict() as z.ZodType<Prisma.EnumOrderStatusFieldUpdateOperationsInput>;

export const UserUpdateOneRequiredWithoutOrdersNestedInputSchema: z.ZodType<Prisma.UserUpdateOneRequiredWithoutOrdersNestedInput> =
  z
    .object({
      create: z
        .union([
          z.lazy(() => UserCreateWithoutOrdersInputSchema),
          z.lazy(() => UserUncheckedCreateWithoutOrdersInputSchema),
        ])
        .optional(),
      connectOrCreate: z
        .lazy(() => UserCreateOrConnectWithoutOrdersInputSchema)
        .optional(),
      upsert: z.lazy(() => UserUpsertWithoutOrdersInputSchema).optional(),
      connect: z.lazy(() => UserWhereUniqueInputSchema).optional(),
      update: z
        .union([
          z.lazy(() => UserUpdateToOneWithWhereWithoutOrdersInputSchema),
          z.lazy(() => UserUpdateWithoutOrdersInputSchema),
          z.lazy(() => UserUncheckedUpdateWithoutOrdersInputSchema),
        ])
        .optional(),
    })
    .strict() as z.ZodType<Prisma.UserUpdateOneRequiredWithoutOrdersNestedInput>;

export const OrderItemUpdateManyWithoutOrderNestedInputSchema: z.ZodType<Prisma.OrderItemUpdateManyWithoutOrderNestedInput> =
  z
    .object({
      create: z
        .union([
          z.lazy(() => OrderItemCreateWithoutOrderInputSchema),
          z.lazy(() => OrderItemCreateWithoutOrderInputSchema).array(),
          z.lazy(() => OrderItemUncheckedCreateWithoutOrderInputSchema),
          z.lazy(() => OrderItemUncheckedCreateWithoutOrderInputSchema).array(),
        ])
        .optional(),
      connectOrCreate: z
        .union([
          z.lazy(() => OrderItemCreateOrConnectWithoutOrderInputSchema),
          z.lazy(() => OrderItemCreateOrConnectWithoutOrderInputSchema).array(),
        ])
        .optional(),
      upsert: z
        .union([
          z.lazy(() => OrderItemUpsertWithWhereUniqueWithoutOrderInputSchema),
          z
            .lazy(() => OrderItemUpsertWithWhereUniqueWithoutOrderInputSchema)
            .array(),
        ])
        .optional(),
      createMany: z
        .lazy(() => OrderItemCreateManyOrderInputEnvelopeSchema)
        .optional(),
      set: z
        .union([
          z.lazy(() => OrderItemWhereUniqueInputSchema),
          z.lazy(() => OrderItemWhereUniqueInputSchema).array(),
        ])
        .optional(),
      disconnect: z
        .union([
          z.lazy(() => OrderItemWhereUniqueInputSchema),
          z.lazy(() => OrderItemWhereUniqueInputSchema).array(),
        ])
        .optional(),
      delete: z
        .union([
          z.lazy(() => OrderItemWhereUniqueInputSchema),
          z.lazy(() => OrderItemWhereUniqueInputSchema).array(),
        ])
        .optional(),
      connect: z
        .union([
          z.lazy(() => OrderItemWhereUniqueInputSchema),
          z.lazy(() => OrderItemWhereUniqueInputSchema).array(),
        ])
        .optional(),
      update: z
        .union([
          z.lazy(() => OrderItemUpdateWithWhereUniqueWithoutOrderInputSchema),
          z
            .lazy(() => OrderItemUpdateWithWhereUniqueWithoutOrderInputSchema)
            .array(),
        ])
        .optional(),
      updateMany: z
        .union([
          z.lazy(() => OrderItemUpdateManyWithWhereWithoutOrderInputSchema),
          z
            .lazy(() => OrderItemUpdateManyWithWhereWithoutOrderInputSchema)
            .array(),
        ])
        .optional(),
      deleteMany: z
        .union([
          z.lazy(() => OrderItemScalarWhereInputSchema),
          z.lazy(() => OrderItemScalarWhereInputSchema).array(),
        ])
        .optional(),
    })
    .strict() as z.ZodType<Prisma.OrderItemUpdateManyWithoutOrderNestedInput>;

export const OrderAddressUpdateManyWithoutOrderNestedInputSchema: z.ZodType<Prisma.OrderAddressUpdateManyWithoutOrderNestedInput> =
  z
    .object({
      create: z
        .union([
          z.lazy(() => OrderAddressCreateWithoutOrderInputSchema),
          z.lazy(() => OrderAddressCreateWithoutOrderInputSchema).array(),
          z.lazy(() => OrderAddressUncheckedCreateWithoutOrderInputSchema),
          z
            .lazy(() => OrderAddressUncheckedCreateWithoutOrderInputSchema)
            .array(),
        ])
        .optional(),
      connectOrCreate: z
        .union([
          z.lazy(() => OrderAddressCreateOrConnectWithoutOrderInputSchema),
          z
            .lazy(() => OrderAddressCreateOrConnectWithoutOrderInputSchema)
            .array(),
        ])
        .optional(),
      upsert: z
        .union([
          z.lazy(
            () => OrderAddressUpsertWithWhereUniqueWithoutOrderInputSchema,
          ),
          z
            .lazy(
              () => OrderAddressUpsertWithWhereUniqueWithoutOrderInputSchema,
            )
            .array(),
        ])
        .optional(),
      createMany: z
        .lazy(() => OrderAddressCreateManyOrderInputEnvelopeSchema)
        .optional(),
      set: z
        .union([
          z.lazy(() => OrderAddressWhereUniqueInputSchema),
          z.lazy(() => OrderAddressWhereUniqueInputSchema).array(),
        ])
        .optional(),
      disconnect: z
        .union([
          z.lazy(() => OrderAddressWhereUniqueInputSchema),
          z.lazy(() => OrderAddressWhereUniqueInputSchema).array(),
        ])
        .optional(),
      delete: z
        .union([
          z.lazy(() => OrderAddressWhereUniqueInputSchema),
          z.lazy(() => OrderAddressWhereUniqueInputSchema).array(),
        ])
        .optional(),
      connect: z
        .union([
          z.lazy(() => OrderAddressWhereUniqueInputSchema),
          z.lazy(() => OrderAddressWhereUniqueInputSchema).array(),
        ])
        .optional(),
      update: z
        .union([
          z.lazy(
            () => OrderAddressUpdateWithWhereUniqueWithoutOrderInputSchema,
          ),
          z
            .lazy(
              () => OrderAddressUpdateWithWhereUniqueWithoutOrderInputSchema,
            )
            .array(),
        ])
        .optional(),
      updateMany: z
        .union([
          z.lazy(() => OrderAddressUpdateManyWithWhereWithoutOrderInputSchema),
          z
            .lazy(() => OrderAddressUpdateManyWithWhereWithoutOrderInputSchema)
            .array(),
        ])
        .optional(),
      deleteMany: z
        .union([
          z.lazy(() => OrderAddressScalarWhereInputSchema),
          z.lazy(() => OrderAddressScalarWhereInputSchema).array(),
        ])
        .optional(),
    })
    .strict() as z.ZodType<Prisma.OrderAddressUpdateManyWithoutOrderNestedInput>;

export const OrderPromotionUpdateManyWithoutOrderNestedInputSchema: z.ZodType<Prisma.OrderPromotionUpdateManyWithoutOrderNestedInput> =
  z
    .object({
      create: z
        .union([
          z.lazy(() => OrderPromotionCreateWithoutOrderInputSchema),
          z.lazy(() => OrderPromotionCreateWithoutOrderInputSchema).array(),
          z.lazy(() => OrderPromotionUncheckedCreateWithoutOrderInputSchema),
          z
            .lazy(() => OrderPromotionUncheckedCreateWithoutOrderInputSchema)
            .array(),
        ])
        .optional(),
      connectOrCreate: z
        .union([
          z.lazy(() => OrderPromotionCreateOrConnectWithoutOrderInputSchema),
          z
            .lazy(() => OrderPromotionCreateOrConnectWithoutOrderInputSchema)
            .array(),
        ])
        .optional(),
      upsert: z
        .union([
          z.lazy(
            () => OrderPromotionUpsertWithWhereUniqueWithoutOrderInputSchema,
          ),
          z
            .lazy(
              () => OrderPromotionUpsertWithWhereUniqueWithoutOrderInputSchema,
            )
            .array(),
        ])
        .optional(),
      createMany: z
        .lazy(() => OrderPromotionCreateManyOrderInputEnvelopeSchema)
        .optional(),
      set: z
        .union([
          z.lazy(() => OrderPromotionWhereUniqueInputSchema),
          z.lazy(() => OrderPromotionWhereUniqueInputSchema).array(),
        ])
        .optional(),
      disconnect: z
        .union([
          z.lazy(() => OrderPromotionWhereUniqueInputSchema),
          z.lazy(() => OrderPromotionWhereUniqueInputSchema).array(),
        ])
        .optional(),
      delete: z
        .union([
          z.lazy(() => OrderPromotionWhereUniqueInputSchema),
          z.lazy(() => OrderPromotionWhereUniqueInputSchema).array(),
        ])
        .optional(),
      connect: z
        .union([
          z.lazy(() => OrderPromotionWhereUniqueInputSchema),
          z.lazy(() => OrderPromotionWhereUniqueInputSchema).array(),
        ])
        .optional(),
      update: z
        .union([
          z.lazy(
            () => OrderPromotionUpdateWithWhereUniqueWithoutOrderInputSchema,
          ),
          z
            .lazy(
              () => OrderPromotionUpdateWithWhereUniqueWithoutOrderInputSchema,
            )
            .array(),
        ])
        .optional(),
      updateMany: z
        .union([
          z.lazy(
            () => OrderPromotionUpdateManyWithWhereWithoutOrderInputSchema,
          ),
          z
            .lazy(
              () => OrderPromotionUpdateManyWithWhereWithoutOrderInputSchema,
            )
            .array(),
        ])
        .optional(),
      deleteMany: z
        .union([
          z.lazy(() => OrderPromotionScalarWhereInputSchema),
          z.lazy(() => OrderPromotionScalarWhereInputSchema).array(),
        ])
        .optional(),
    })
    .strict() as z.ZodType<Prisma.OrderPromotionUpdateManyWithoutOrderNestedInput>;

export const PaymentUpdateManyWithoutOrderNestedInputSchema: z.ZodType<Prisma.PaymentUpdateManyWithoutOrderNestedInput> =
  z
    .object({
      create: z
        .union([
          z.lazy(() => PaymentCreateWithoutOrderInputSchema),
          z.lazy(() => PaymentCreateWithoutOrderInputSchema).array(),
          z.lazy(() => PaymentUncheckedCreateWithoutOrderInputSchema),
          z.lazy(() => PaymentUncheckedCreateWithoutOrderInputSchema).array(),
        ])
        .optional(),
      connectOrCreate: z
        .union([
          z.lazy(() => PaymentCreateOrConnectWithoutOrderInputSchema),
          z.lazy(() => PaymentCreateOrConnectWithoutOrderInputSchema).array(),
        ])
        .optional(),
      upsert: z
        .union([
          z.lazy(() => PaymentUpsertWithWhereUniqueWithoutOrderInputSchema),
          z
            .lazy(() => PaymentUpsertWithWhereUniqueWithoutOrderInputSchema)
            .array(),
        ])
        .optional(),
      createMany: z
        .lazy(() => PaymentCreateManyOrderInputEnvelopeSchema)
        .optional(),
      set: z
        .union([
          z.lazy(() => PaymentWhereUniqueInputSchema),
          z.lazy(() => PaymentWhereUniqueInputSchema).array(),
        ])
        .optional(),
      disconnect: z
        .union([
          z.lazy(() => PaymentWhereUniqueInputSchema),
          z.lazy(() => PaymentWhereUniqueInputSchema).array(),
        ])
        .optional(),
      delete: z
        .union([
          z.lazy(() => PaymentWhereUniqueInputSchema),
          z.lazy(() => PaymentWhereUniqueInputSchema).array(),
        ])
        .optional(),
      connect: z
        .union([
          z.lazy(() => PaymentWhereUniqueInputSchema),
          z.lazy(() => PaymentWhereUniqueInputSchema).array(),
        ])
        .optional(),
      update: z
        .union([
          z.lazy(() => PaymentUpdateWithWhereUniqueWithoutOrderInputSchema),
          z
            .lazy(() => PaymentUpdateWithWhereUniqueWithoutOrderInputSchema)
            .array(),
        ])
        .optional(),
      updateMany: z
        .union([
          z.lazy(() => PaymentUpdateManyWithWhereWithoutOrderInputSchema),
          z
            .lazy(() => PaymentUpdateManyWithWhereWithoutOrderInputSchema)
            .array(),
        ])
        .optional(),
      deleteMany: z
        .union([
          z.lazy(() => PaymentScalarWhereInputSchema),
          z.lazy(() => PaymentScalarWhereInputSchema).array(),
        ])
        .optional(),
    })
    .strict() as z.ZodType<Prisma.PaymentUpdateManyWithoutOrderNestedInput>;

export const OrderItemUncheckedUpdateManyWithoutOrderNestedInputSchema: z.ZodType<Prisma.OrderItemUncheckedUpdateManyWithoutOrderNestedInput> =
  z
    .object({
      create: z
        .union([
          z.lazy(() => OrderItemCreateWithoutOrderInputSchema),
          z.lazy(() => OrderItemCreateWithoutOrderInputSchema).array(),
          z.lazy(() => OrderItemUncheckedCreateWithoutOrderInputSchema),
          z.lazy(() => OrderItemUncheckedCreateWithoutOrderInputSchema).array(),
        ])
        .optional(),
      connectOrCreate: z
        .union([
          z.lazy(() => OrderItemCreateOrConnectWithoutOrderInputSchema),
          z.lazy(() => OrderItemCreateOrConnectWithoutOrderInputSchema).array(),
        ])
        .optional(),
      upsert: z
        .union([
          z.lazy(() => OrderItemUpsertWithWhereUniqueWithoutOrderInputSchema),
          z
            .lazy(() => OrderItemUpsertWithWhereUniqueWithoutOrderInputSchema)
            .array(),
        ])
        .optional(),
      createMany: z
        .lazy(() => OrderItemCreateManyOrderInputEnvelopeSchema)
        .optional(),
      set: z
        .union([
          z.lazy(() => OrderItemWhereUniqueInputSchema),
          z.lazy(() => OrderItemWhereUniqueInputSchema).array(),
        ])
        .optional(),
      disconnect: z
        .union([
          z.lazy(() => OrderItemWhereUniqueInputSchema),
          z.lazy(() => OrderItemWhereUniqueInputSchema).array(),
        ])
        .optional(),
      delete: z
        .union([
          z.lazy(() => OrderItemWhereUniqueInputSchema),
          z.lazy(() => OrderItemWhereUniqueInputSchema).array(),
        ])
        .optional(),
      connect: z
        .union([
          z.lazy(() => OrderItemWhereUniqueInputSchema),
          z.lazy(() => OrderItemWhereUniqueInputSchema).array(),
        ])
        .optional(),
      update: z
        .union([
          z.lazy(() => OrderItemUpdateWithWhereUniqueWithoutOrderInputSchema),
          z
            .lazy(() => OrderItemUpdateWithWhereUniqueWithoutOrderInputSchema)
            .array(),
        ])
        .optional(),
      updateMany: z
        .union([
          z.lazy(() => OrderItemUpdateManyWithWhereWithoutOrderInputSchema),
          z
            .lazy(() => OrderItemUpdateManyWithWhereWithoutOrderInputSchema)
            .array(),
        ])
        .optional(),
      deleteMany: z
        .union([
          z.lazy(() => OrderItemScalarWhereInputSchema),
          z.lazy(() => OrderItemScalarWhereInputSchema).array(),
        ])
        .optional(),
    })
    .strict() as z.ZodType<Prisma.OrderItemUncheckedUpdateManyWithoutOrderNestedInput>;

export const OrderAddressUncheckedUpdateManyWithoutOrderNestedInputSchema: z.ZodType<Prisma.OrderAddressUncheckedUpdateManyWithoutOrderNestedInput> =
  z
    .object({
      create: z
        .union([
          z.lazy(() => OrderAddressCreateWithoutOrderInputSchema),
          z.lazy(() => OrderAddressCreateWithoutOrderInputSchema).array(),
          z.lazy(() => OrderAddressUncheckedCreateWithoutOrderInputSchema),
          z
            .lazy(() => OrderAddressUncheckedCreateWithoutOrderInputSchema)
            .array(),
        ])
        .optional(),
      connectOrCreate: z
        .union([
          z.lazy(() => OrderAddressCreateOrConnectWithoutOrderInputSchema),
          z
            .lazy(() => OrderAddressCreateOrConnectWithoutOrderInputSchema)
            .array(),
        ])
        .optional(),
      upsert: z
        .union([
          z.lazy(
            () => OrderAddressUpsertWithWhereUniqueWithoutOrderInputSchema,
          ),
          z
            .lazy(
              () => OrderAddressUpsertWithWhereUniqueWithoutOrderInputSchema,
            )
            .array(),
        ])
        .optional(),
      createMany: z
        .lazy(() => OrderAddressCreateManyOrderInputEnvelopeSchema)
        .optional(),
      set: z
        .union([
          z.lazy(() => OrderAddressWhereUniqueInputSchema),
          z.lazy(() => OrderAddressWhereUniqueInputSchema).array(),
        ])
        .optional(),
      disconnect: z
        .union([
          z.lazy(() => OrderAddressWhereUniqueInputSchema),
          z.lazy(() => OrderAddressWhereUniqueInputSchema).array(),
        ])
        .optional(),
      delete: z
        .union([
          z.lazy(() => OrderAddressWhereUniqueInputSchema),
          z.lazy(() => OrderAddressWhereUniqueInputSchema).array(),
        ])
        .optional(),
      connect: z
        .union([
          z.lazy(() => OrderAddressWhereUniqueInputSchema),
          z.lazy(() => OrderAddressWhereUniqueInputSchema).array(),
        ])
        .optional(),
      update: z
        .union([
          z.lazy(
            () => OrderAddressUpdateWithWhereUniqueWithoutOrderInputSchema,
          ),
          z
            .lazy(
              () => OrderAddressUpdateWithWhereUniqueWithoutOrderInputSchema,
            )
            .array(),
        ])
        .optional(),
      updateMany: z
        .union([
          z.lazy(() => OrderAddressUpdateManyWithWhereWithoutOrderInputSchema),
          z
            .lazy(() => OrderAddressUpdateManyWithWhereWithoutOrderInputSchema)
            .array(),
        ])
        .optional(),
      deleteMany: z
        .union([
          z.lazy(() => OrderAddressScalarWhereInputSchema),
          z.lazy(() => OrderAddressScalarWhereInputSchema).array(),
        ])
        .optional(),
    })
    .strict() as z.ZodType<Prisma.OrderAddressUncheckedUpdateManyWithoutOrderNestedInput>;

export const OrderPromotionUncheckedUpdateManyWithoutOrderNestedInputSchema: z.ZodType<Prisma.OrderPromotionUncheckedUpdateManyWithoutOrderNestedInput> =
  z
    .object({
      create: z
        .union([
          z.lazy(() => OrderPromotionCreateWithoutOrderInputSchema),
          z.lazy(() => OrderPromotionCreateWithoutOrderInputSchema).array(),
          z.lazy(() => OrderPromotionUncheckedCreateWithoutOrderInputSchema),
          z
            .lazy(() => OrderPromotionUncheckedCreateWithoutOrderInputSchema)
            .array(),
        ])
        .optional(),
      connectOrCreate: z
        .union([
          z.lazy(() => OrderPromotionCreateOrConnectWithoutOrderInputSchema),
          z
            .lazy(() => OrderPromotionCreateOrConnectWithoutOrderInputSchema)
            .array(),
        ])
        .optional(),
      upsert: z
        .union([
          z.lazy(
            () => OrderPromotionUpsertWithWhereUniqueWithoutOrderInputSchema,
          ),
          z
            .lazy(
              () => OrderPromotionUpsertWithWhereUniqueWithoutOrderInputSchema,
            )
            .array(),
        ])
        .optional(),
      createMany: z
        .lazy(() => OrderPromotionCreateManyOrderInputEnvelopeSchema)
        .optional(),
      set: z
        .union([
          z.lazy(() => OrderPromotionWhereUniqueInputSchema),
          z.lazy(() => OrderPromotionWhereUniqueInputSchema).array(),
        ])
        .optional(),
      disconnect: z
        .union([
          z.lazy(() => OrderPromotionWhereUniqueInputSchema),
          z.lazy(() => OrderPromotionWhereUniqueInputSchema).array(),
        ])
        .optional(),
      delete: z
        .union([
          z.lazy(() => OrderPromotionWhereUniqueInputSchema),
          z.lazy(() => OrderPromotionWhereUniqueInputSchema).array(),
        ])
        .optional(),
      connect: z
        .union([
          z.lazy(() => OrderPromotionWhereUniqueInputSchema),
          z.lazy(() => OrderPromotionWhereUniqueInputSchema).array(),
        ])
        .optional(),
      update: z
        .union([
          z.lazy(
            () => OrderPromotionUpdateWithWhereUniqueWithoutOrderInputSchema,
          ),
          z
            .lazy(
              () => OrderPromotionUpdateWithWhereUniqueWithoutOrderInputSchema,
            )
            .array(),
        ])
        .optional(),
      updateMany: z
        .union([
          z.lazy(
            () => OrderPromotionUpdateManyWithWhereWithoutOrderInputSchema,
          ),
          z
            .lazy(
              () => OrderPromotionUpdateManyWithWhereWithoutOrderInputSchema,
            )
            .array(),
        ])
        .optional(),
      deleteMany: z
        .union([
          z.lazy(() => OrderPromotionScalarWhereInputSchema),
          z.lazy(() => OrderPromotionScalarWhereInputSchema).array(),
        ])
        .optional(),
    })
    .strict() as z.ZodType<Prisma.OrderPromotionUncheckedUpdateManyWithoutOrderNestedInput>;

export const PaymentUncheckedUpdateManyWithoutOrderNestedInputSchema: z.ZodType<Prisma.PaymentUncheckedUpdateManyWithoutOrderNestedInput> =
  z
    .object({
      create: z
        .union([
          z.lazy(() => PaymentCreateWithoutOrderInputSchema),
          z.lazy(() => PaymentCreateWithoutOrderInputSchema).array(),
          z.lazy(() => PaymentUncheckedCreateWithoutOrderInputSchema),
          z.lazy(() => PaymentUncheckedCreateWithoutOrderInputSchema).array(),
        ])
        .optional(),
      connectOrCreate: z
        .union([
          z.lazy(() => PaymentCreateOrConnectWithoutOrderInputSchema),
          z.lazy(() => PaymentCreateOrConnectWithoutOrderInputSchema).array(),
        ])
        .optional(),
      upsert: z
        .union([
          z.lazy(() => PaymentUpsertWithWhereUniqueWithoutOrderInputSchema),
          z
            .lazy(() => PaymentUpsertWithWhereUniqueWithoutOrderInputSchema)
            .array(),
        ])
        .optional(),
      createMany: z
        .lazy(() => PaymentCreateManyOrderInputEnvelopeSchema)
        .optional(),
      set: z
        .union([
          z.lazy(() => PaymentWhereUniqueInputSchema),
          z.lazy(() => PaymentWhereUniqueInputSchema).array(),
        ])
        .optional(),
      disconnect: z
        .union([
          z.lazy(() => PaymentWhereUniqueInputSchema),
          z.lazy(() => PaymentWhereUniqueInputSchema).array(),
        ])
        .optional(),
      delete: z
        .union([
          z.lazy(() => PaymentWhereUniqueInputSchema),
          z.lazy(() => PaymentWhereUniqueInputSchema).array(),
        ])
        .optional(),
      connect: z
        .union([
          z.lazy(() => PaymentWhereUniqueInputSchema),
          z.lazy(() => PaymentWhereUniqueInputSchema).array(),
        ])
        .optional(),
      update: z
        .union([
          z.lazy(() => PaymentUpdateWithWhereUniqueWithoutOrderInputSchema),
          z
            .lazy(() => PaymentUpdateWithWhereUniqueWithoutOrderInputSchema)
            .array(),
        ])
        .optional(),
      updateMany: z
        .union([
          z.lazy(() => PaymentUpdateManyWithWhereWithoutOrderInputSchema),
          z
            .lazy(() => PaymentUpdateManyWithWhereWithoutOrderInputSchema)
            .array(),
        ])
        .optional(),
      deleteMany: z
        .union([
          z.lazy(() => PaymentScalarWhereInputSchema),
          z.lazy(() => PaymentScalarWhereInputSchema).array(),
        ])
        .optional(),
    })
    .strict() as z.ZodType<Prisma.PaymentUncheckedUpdateManyWithoutOrderNestedInput>;

export const ProductVariantCreateNestedOneWithoutOrderItemsInputSchema: z.ZodType<Prisma.ProductVariantCreateNestedOneWithoutOrderItemsInput> =
  z
    .object({
      create: z
        .union([
          z.lazy(() => ProductVariantCreateWithoutOrderItemsInputSchema),
          z.lazy(
            () => ProductVariantUncheckedCreateWithoutOrderItemsInputSchema,
          ),
        ])
        .optional(),
      connectOrCreate: z
        .lazy(() => ProductVariantCreateOrConnectWithoutOrderItemsInputSchema)
        .optional(),
      connect: z.lazy(() => ProductVariantWhereUniqueInputSchema).optional(),
    })
    .strict() as z.ZodType<Prisma.ProductVariantCreateNestedOneWithoutOrderItemsInput>;

export const OrderCreateNestedOneWithoutOrderItemsInputSchema: z.ZodType<Prisma.OrderCreateNestedOneWithoutOrderItemsInput> =
  z
    .object({
      create: z
        .union([
          z.lazy(() => OrderCreateWithoutOrderItemsInputSchema),
          z.lazy(() => OrderUncheckedCreateWithoutOrderItemsInputSchema),
        ])
        .optional(),
      connectOrCreate: z
        .lazy(() => OrderCreateOrConnectWithoutOrderItemsInputSchema)
        .optional(),
      connect: z.lazy(() => OrderWhereUniqueInputSchema).optional(),
    })
    .strict() as z.ZodType<Prisma.OrderCreateNestedOneWithoutOrderItemsInput>;

export const ProductVariantUpdateOneRequiredWithoutOrderItemsNestedInputSchema: z.ZodType<Prisma.ProductVariantUpdateOneRequiredWithoutOrderItemsNestedInput> =
  z
    .object({
      create: z
        .union([
          z.lazy(() => ProductVariantCreateWithoutOrderItemsInputSchema),
          z.lazy(
            () => ProductVariantUncheckedCreateWithoutOrderItemsInputSchema,
          ),
        ])
        .optional(),
      connectOrCreate: z
        .lazy(() => ProductVariantCreateOrConnectWithoutOrderItemsInputSchema)
        .optional(),
      upsert: z
        .lazy(() => ProductVariantUpsertWithoutOrderItemsInputSchema)
        .optional(),
      connect: z.lazy(() => ProductVariantWhereUniqueInputSchema).optional(),
      update: z
        .union([
          z.lazy(
            () =>
              ProductVariantUpdateToOneWithWhereWithoutOrderItemsInputSchema,
          ),
          z.lazy(() => ProductVariantUpdateWithoutOrderItemsInputSchema),
          z.lazy(
            () => ProductVariantUncheckedUpdateWithoutOrderItemsInputSchema,
          ),
        ])
        .optional(),
    })
    .strict() as z.ZodType<Prisma.ProductVariantUpdateOneRequiredWithoutOrderItemsNestedInput>;

export const OrderUpdateOneRequiredWithoutOrderItemsNestedInputSchema: z.ZodType<Prisma.OrderUpdateOneRequiredWithoutOrderItemsNestedInput> =
  z
    .object({
      create: z
        .union([
          z.lazy(() => OrderCreateWithoutOrderItemsInputSchema),
          z.lazy(() => OrderUncheckedCreateWithoutOrderItemsInputSchema),
        ])
        .optional(),
      connectOrCreate: z
        .lazy(() => OrderCreateOrConnectWithoutOrderItemsInputSchema)
        .optional(),
      upsert: z.lazy(() => OrderUpsertWithoutOrderItemsInputSchema).optional(),
      connect: z.lazy(() => OrderWhereUniqueInputSchema).optional(),
      update: z
        .union([
          z.lazy(() => OrderUpdateToOneWithWhereWithoutOrderItemsInputSchema),
          z.lazy(() => OrderUpdateWithoutOrderItemsInputSchema),
          z.lazy(() => OrderUncheckedUpdateWithoutOrderItemsInputSchema),
        ])
        .optional(),
    })
    .strict() as z.ZodType<Prisma.OrderUpdateOneRequiredWithoutOrderItemsNestedInput>;

export const OrderCreateNestedOneWithoutOrderAddressesInputSchema: z.ZodType<Prisma.OrderCreateNestedOneWithoutOrderAddressesInput> =
  z
    .object({
      create: z
        .union([
          z.lazy(() => OrderCreateWithoutOrderAddressesInputSchema),
          z.lazy(() => OrderUncheckedCreateWithoutOrderAddressesInputSchema),
        ])
        .optional(),
      connectOrCreate: z
        .lazy(() => OrderCreateOrConnectWithoutOrderAddressesInputSchema)
        .optional(),
      connect: z.lazy(() => OrderWhereUniqueInputSchema).optional(),
    })
    .strict() as z.ZodType<Prisma.OrderCreateNestedOneWithoutOrderAddressesInput>;

export const EnumAddressTypeFieldUpdateOperationsInputSchema: z.ZodType<Prisma.EnumAddressTypeFieldUpdateOperationsInput> =
  z
    .object({
      set: z.lazy(() => AddressTypeSchema).optional(),
    })
    .strict() as z.ZodType<Prisma.EnumAddressTypeFieldUpdateOperationsInput>;

export const OrderUpdateOneRequiredWithoutOrderAddressesNestedInputSchema: z.ZodType<Prisma.OrderUpdateOneRequiredWithoutOrderAddressesNestedInput> =
  z
    .object({
      create: z
        .union([
          z.lazy(() => OrderCreateWithoutOrderAddressesInputSchema),
          z.lazy(() => OrderUncheckedCreateWithoutOrderAddressesInputSchema),
        ])
        .optional(),
      connectOrCreate: z
        .lazy(() => OrderCreateOrConnectWithoutOrderAddressesInputSchema)
        .optional(),
      upsert: z
        .lazy(() => OrderUpsertWithoutOrderAddressesInputSchema)
        .optional(),
      connect: z.lazy(() => OrderWhereUniqueInputSchema).optional(),
      update: z
        .union([
          z.lazy(
            () => OrderUpdateToOneWithWhereWithoutOrderAddressesInputSchema,
          ),
          z.lazy(() => OrderUpdateWithoutOrderAddressesInputSchema),
          z.lazy(() => OrderUncheckedUpdateWithoutOrderAddressesInputSchema),
        ])
        .optional(),
    })
    .strict() as z.ZodType<Prisma.OrderUpdateOneRequiredWithoutOrderAddressesNestedInput>;

export const OrderPromotionCreateNestedManyWithoutPromotionInputSchema: z.ZodType<Prisma.OrderPromotionCreateNestedManyWithoutPromotionInput> =
  z
    .object({
      create: z
        .union([
          z.lazy(() => OrderPromotionCreateWithoutPromotionInputSchema),
          z.lazy(() => OrderPromotionCreateWithoutPromotionInputSchema).array(),
          z.lazy(
            () => OrderPromotionUncheckedCreateWithoutPromotionInputSchema,
          ),
          z
            .lazy(
              () => OrderPromotionUncheckedCreateWithoutPromotionInputSchema,
            )
            .array(),
        ])
        .optional(),
      connectOrCreate: z
        .union([
          z.lazy(
            () => OrderPromotionCreateOrConnectWithoutPromotionInputSchema,
          ),
          z
            .lazy(
              () => OrderPromotionCreateOrConnectWithoutPromotionInputSchema,
            )
            .array(),
        ])
        .optional(),
      createMany: z
        .lazy(() => OrderPromotionCreateManyPromotionInputEnvelopeSchema)
        .optional(),
      connect: z
        .union([
          z.lazy(() => OrderPromotionWhereUniqueInputSchema),
          z.lazy(() => OrderPromotionWhereUniqueInputSchema).array(),
        ])
        .optional(),
    })
    .strict() as z.ZodType<Prisma.OrderPromotionCreateNestedManyWithoutPromotionInput>;

export const OrderPromotionUncheckedCreateNestedManyWithoutPromotionInputSchema: z.ZodType<Prisma.OrderPromotionUncheckedCreateNestedManyWithoutPromotionInput> =
  z
    .object({
      create: z
        .union([
          z.lazy(() => OrderPromotionCreateWithoutPromotionInputSchema),
          z.lazy(() => OrderPromotionCreateWithoutPromotionInputSchema).array(),
          z.lazy(
            () => OrderPromotionUncheckedCreateWithoutPromotionInputSchema,
          ),
          z
            .lazy(
              () => OrderPromotionUncheckedCreateWithoutPromotionInputSchema,
            )
            .array(),
        ])
        .optional(),
      connectOrCreate: z
        .union([
          z.lazy(
            () => OrderPromotionCreateOrConnectWithoutPromotionInputSchema,
          ),
          z
            .lazy(
              () => OrderPromotionCreateOrConnectWithoutPromotionInputSchema,
            )
            .array(),
        ])
        .optional(),
      createMany: z
        .lazy(() => OrderPromotionCreateManyPromotionInputEnvelopeSchema)
        .optional(),
      connect: z
        .union([
          z.lazy(() => OrderPromotionWhereUniqueInputSchema),
          z.lazy(() => OrderPromotionWhereUniqueInputSchema).array(),
        ])
        .optional(),
    })
    .strict() as z.ZodType<Prisma.OrderPromotionUncheckedCreateNestedManyWithoutPromotionInput>;

export const EnumPromotionTypeFieldUpdateOperationsInputSchema: z.ZodType<Prisma.EnumPromotionTypeFieldUpdateOperationsInput> =
  z
    .object({
      set: z.lazy(() => PromotionTypeSchema).optional(),
    })
    .strict() as z.ZodType<Prisma.EnumPromotionTypeFieldUpdateOperationsInput>;

export const NullableIntFieldUpdateOperationsInputSchema: z.ZodType<Prisma.NullableIntFieldUpdateOperationsInput> =
  z
    .object({
      set: z.number().optional().nullable(),
      increment: z.number().optional(),
      decrement: z.number().optional(),
      multiply: z.number().optional(),
      divide: z.number().optional(),
    })
    .strict() as z.ZodType<Prisma.NullableIntFieldUpdateOperationsInput>;

export const EnumPromotionStatusFieldUpdateOperationsInputSchema: z.ZodType<Prisma.EnumPromotionStatusFieldUpdateOperationsInput> =
  z
    .object({
      set: z.lazy(() => PromotionStatusSchema).optional(),
    })
    .strict() as z.ZodType<Prisma.EnumPromotionStatusFieldUpdateOperationsInput>;

export const OrderPromotionUpdateManyWithoutPromotionNestedInputSchema: z.ZodType<Prisma.OrderPromotionUpdateManyWithoutPromotionNestedInput> =
  z
    .object({
      create: z
        .union([
          z.lazy(() => OrderPromotionCreateWithoutPromotionInputSchema),
          z.lazy(() => OrderPromotionCreateWithoutPromotionInputSchema).array(),
          z.lazy(
            () => OrderPromotionUncheckedCreateWithoutPromotionInputSchema,
          ),
          z
            .lazy(
              () => OrderPromotionUncheckedCreateWithoutPromotionInputSchema,
            )
            .array(),
        ])
        .optional(),
      connectOrCreate: z
        .union([
          z.lazy(
            () => OrderPromotionCreateOrConnectWithoutPromotionInputSchema,
          ),
          z
            .lazy(
              () => OrderPromotionCreateOrConnectWithoutPromotionInputSchema,
            )
            .array(),
        ])
        .optional(),
      upsert: z
        .union([
          z.lazy(
            () =>
              OrderPromotionUpsertWithWhereUniqueWithoutPromotionInputSchema,
          ),
          z
            .lazy(
              () =>
                OrderPromotionUpsertWithWhereUniqueWithoutPromotionInputSchema,
            )
            .array(),
        ])
        .optional(),
      createMany: z
        .lazy(() => OrderPromotionCreateManyPromotionInputEnvelopeSchema)
        .optional(),
      set: z
        .union([
          z.lazy(() => OrderPromotionWhereUniqueInputSchema),
          z.lazy(() => OrderPromotionWhereUniqueInputSchema).array(),
        ])
        .optional(),
      disconnect: z
        .union([
          z.lazy(() => OrderPromotionWhereUniqueInputSchema),
          z.lazy(() => OrderPromotionWhereUniqueInputSchema).array(),
        ])
        .optional(),
      delete: z
        .union([
          z.lazy(() => OrderPromotionWhereUniqueInputSchema),
          z.lazy(() => OrderPromotionWhereUniqueInputSchema).array(),
        ])
        .optional(),
      connect: z
        .union([
          z.lazy(() => OrderPromotionWhereUniqueInputSchema),
          z.lazy(() => OrderPromotionWhereUniqueInputSchema).array(),
        ])
        .optional(),
      update: z
        .union([
          z.lazy(
            () =>
              OrderPromotionUpdateWithWhereUniqueWithoutPromotionInputSchema,
          ),
          z
            .lazy(
              () =>
                OrderPromotionUpdateWithWhereUniqueWithoutPromotionInputSchema,
            )
            .array(),
        ])
        .optional(),
      updateMany: z
        .union([
          z.lazy(
            () => OrderPromotionUpdateManyWithWhereWithoutPromotionInputSchema,
          ),
          z
            .lazy(
              () =>
                OrderPromotionUpdateManyWithWhereWithoutPromotionInputSchema,
            )
            .array(),
        ])
        .optional(),
      deleteMany: z
        .union([
          z.lazy(() => OrderPromotionScalarWhereInputSchema),
          z.lazy(() => OrderPromotionScalarWhereInputSchema).array(),
        ])
        .optional(),
    })
    .strict() as z.ZodType<Prisma.OrderPromotionUpdateManyWithoutPromotionNestedInput>;

export const OrderPromotionUncheckedUpdateManyWithoutPromotionNestedInputSchema: z.ZodType<Prisma.OrderPromotionUncheckedUpdateManyWithoutPromotionNestedInput> =
  z
    .object({
      create: z
        .union([
          z.lazy(() => OrderPromotionCreateWithoutPromotionInputSchema),
          z.lazy(() => OrderPromotionCreateWithoutPromotionInputSchema).array(),
          z.lazy(
            () => OrderPromotionUncheckedCreateWithoutPromotionInputSchema,
          ),
          z
            .lazy(
              () => OrderPromotionUncheckedCreateWithoutPromotionInputSchema,
            )
            .array(),
        ])
        .optional(),
      connectOrCreate: z
        .union([
          z.lazy(
            () => OrderPromotionCreateOrConnectWithoutPromotionInputSchema,
          ),
          z
            .lazy(
              () => OrderPromotionCreateOrConnectWithoutPromotionInputSchema,
            )
            .array(),
        ])
        .optional(),
      upsert: z
        .union([
          z.lazy(
            () =>
              OrderPromotionUpsertWithWhereUniqueWithoutPromotionInputSchema,
          ),
          z
            .lazy(
              () =>
                OrderPromotionUpsertWithWhereUniqueWithoutPromotionInputSchema,
            )
            .array(),
        ])
        .optional(),
      createMany: z
        .lazy(() => OrderPromotionCreateManyPromotionInputEnvelopeSchema)
        .optional(),
      set: z
        .union([
          z.lazy(() => OrderPromotionWhereUniqueInputSchema),
          z.lazy(() => OrderPromotionWhereUniqueInputSchema).array(),
        ])
        .optional(),
      disconnect: z
        .union([
          z.lazy(() => OrderPromotionWhereUniqueInputSchema),
          z.lazy(() => OrderPromotionWhereUniqueInputSchema).array(),
        ])
        .optional(),
      delete: z
        .union([
          z.lazy(() => OrderPromotionWhereUniqueInputSchema),
          z.lazy(() => OrderPromotionWhereUniqueInputSchema).array(),
        ])
        .optional(),
      connect: z
        .union([
          z.lazy(() => OrderPromotionWhereUniqueInputSchema),
          z.lazy(() => OrderPromotionWhereUniqueInputSchema).array(),
        ])
        .optional(),
      update: z
        .union([
          z.lazy(
            () =>
              OrderPromotionUpdateWithWhereUniqueWithoutPromotionInputSchema,
          ),
          z
            .lazy(
              () =>
                OrderPromotionUpdateWithWhereUniqueWithoutPromotionInputSchema,
            )
            .array(),
        ])
        .optional(),
      updateMany: z
        .union([
          z.lazy(
            () => OrderPromotionUpdateManyWithWhereWithoutPromotionInputSchema,
          ),
          z
            .lazy(
              () =>
                OrderPromotionUpdateManyWithWhereWithoutPromotionInputSchema,
            )
            .array(),
        ])
        .optional(),
      deleteMany: z
        .union([
          z.lazy(() => OrderPromotionScalarWhereInputSchema),
          z.lazy(() => OrderPromotionScalarWhereInputSchema).array(),
        ])
        .optional(),
    })
    .strict() as z.ZodType<Prisma.OrderPromotionUncheckedUpdateManyWithoutPromotionNestedInput>;

export const OrderCreateNestedOneWithoutOrderPromotionsInputSchema: z.ZodType<Prisma.OrderCreateNestedOneWithoutOrderPromotionsInput> =
  z
    .object({
      create: z
        .union([
          z.lazy(() => OrderCreateWithoutOrderPromotionsInputSchema),
          z.lazy(() => OrderUncheckedCreateWithoutOrderPromotionsInputSchema),
        ])
        .optional(),
      connectOrCreate: z
        .lazy(() => OrderCreateOrConnectWithoutOrderPromotionsInputSchema)
        .optional(),
      connect: z.lazy(() => OrderWhereUniqueInputSchema).optional(),
    })
    .strict() as z.ZodType<Prisma.OrderCreateNestedOneWithoutOrderPromotionsInput>;

export const PromotionCreateNestedOneWithoutOrderPromotionsInputSchema: z.ZodType<Prisma.PromotionCreateNestedOneWithoutOrderPromotionsInput> =
  z
    .object({
      create: z
        .union([
          z.lazy(() => PromotionCreateWithoutOrderPromotionsInputSchema),
          z.lazy(
            () => PromotionUncheckedCreateWithoutOrderPromotionsInputSchema,
          ),
        ])
        .optional(),
      connectOrCreate: z
        .lazy(() => PromotionCreateOrConnectWithoutOrderPromotionsInputSchema)
        .optional(),
      connect: z.lazy(() => PromotionWhereUniqueInputSchema).optional(),
    })
    .strict() as z.ZodType<Prisma.PromotionCreateNestedOneWithoutOrderPromotionsInput>;

export const OrderUpdateOneRequiredWithoutOrderPromotionsNestedInputSchema: z.ZodType<Prisma.OrderUpdateOneRequiredWithoutOrderPromotionsNestedInput> =
  z
    .object({
      create: z
        .union([
          z.lazy(() => OrderCreateWithoutOrderPromotionsInputSchema),
          z.lazy(() => OrderUncheckedCreateWithoutOrderPromotionsInputSchema),
        ])
        .optional(),
      connectOrCreate: z
        .lazy(() => OrderCreateOrConnectWithoutOrderPromotionsInputSchema)
        .optional(),
      upsert: z
        .lazy(() => OrderUpsertWithoutOrderPromotionsInputSchema)
        .optional(),
      connect: z.lazy(() => OrderWhereUniqueInputSchema).optional(),
      update: z
        .union([
          z.lazy(
            () => OrderUpdateToOneWithWhereWithoutOrderPromotionsInputSchema,
          ),
          z.lazy(() => OrderUpdateWithoutOrderPromotionsInputSchema),
          z.lazy(() => OrderUncheckedUpdateWithoutOrderPromotionsInputSchema),
        ])
        .optional(),
    })
    .strict() as z.ZodType<Prisma.OrderUpdateOneRequiredWithoutOrderPromotionsNestedInput>;

export const PromotionUpdateOneRequiredWithoutOrderPromotionsNestedInputSchema: z.ZodType<Prisma.PromotionUpdateOneRequiredWithoutOrderPromotionsNestedInput> =
  z
    .object({
      create: z
        .union([
          z.lazy(() => PromotionCreateWithoutOrderPromotionsInputSchema),
          z.lazy(
            () => PromotionUncheckedCreateWithoutOrderPromotionsInputSchema,
          ),
        ])
        .optional(),
      connectOrCreate: z
        .lazy(() => PromotionCreateOrConnectWithoutOrderPromotionsInputSchema)
        .optional(),
      upsert: z
        .lazy(() => PromotionUpsertWithoutOrderPromotionsInputSchema)
        .optional(),
      connect: z.lazy(() => PromotionWhereUniqueInputSchema).optional(),
      update: z
        .union([
          z.lazy(
            () =>
              PromotionUpdateToOneWithWhereWithoutOrderPromotionsInputSchema,
          ),
          z.lazy(() => PromotionUpdateWithoutOrderPromotionsInputSchema),
          z.lazy(
            () => PromotionUncheckedUpdateWithoutOrderPromotionsInputSchema,
          ),
        ])
        .optional(),
    })
    .strict() as z.ZodType<Prisma.PromotionUpdateOneRequiredWithoutOrderPromotionsNestedInput>;

export const UserCreateNestedOneWithoutCartInputSchema: z.ZodType<Prisma.UserCreateNestedOneWithoutCartInput> =
  z
    .object({
      create: z
        .union([
          z.lazy(() => UserCreateWithoutCartInputSchema),
          z.lazy(() => UserUncheckedCreateWithoutCartInputSchema),
        ])
        .optional(),
      connectOrCreate: z
        .lazy(() => UserCreateOrConnectWithoutCartInputSchema)
        .optional(),
      connect: z.lazy(() => UserWhereUniqueInputSchema).optional(),
    })
    .strict() as z.ZodType<Prisma.UserCreateNestedOneWithoutCartInput>;

export const CartItemCreateNestedManyWithoutCartInputSchema: z.ZodType<Prisma.CartItemCreateNestedManyWithoutCartInput> =
  z
    .object({
      create: z
        .union([
          z.lazy(() => CartItemCreateWithoutCartInputSchema),
          z.lazy(() => CartItemCreateWithoutCartInputSchema).array(),
          z.lazy(() => CartItemUncheckedCreateWithoutCartInputSchema),
          z.lazy(() => CartItemUncheckedCreateWithoutCartInputSchema).array(),
        ])
        .optional(),
      connectOrCreate: z
        .union([
          z.lazy(() => CartItemCreateOrConnectWithoutCartInputSchema),
          z.lazy(() => CartItemCreateOrConnectWithoutCartInputSchema).array(),
        ])
        .optional(),
      createMany: z
        .lazy(() => CartItemCreateManyCartInputEnvelopeSchema)
        .optional(),
      connect: z
        .union([
          z.lazy(() => CartItemWhereUniqueInputSchema),
          z.lazy(() => CartItemWhereUniqueInputSchema).array(),
        ])
        .optional(),
    })
    .strict() as z.ZodType<Prisma.CartItemCreateNestedManyWithoutCartInput>;

export const CartItemUncheckedCreateNestedManyWithoutCartInputSchema: z.ZodType<Prisma.CartItemUncheckedCreateNestedManyWithoutCartInput> =
  z
    .object({
      create: z
        .union([
          z.lazy(() => CartItemCreateWithoutCartInputSchema),
          z.lazy(() => CartItemCreateWithoutCartInputSchema).array(),
          z.lazy(() => CartItemUncheckedCreateWithoutCartInputSchema),
          z.lazy(() => CartItemUncheckedCreateWithoutCartInputSchema).array(),
        ])
        .optional(),
      connectOrCreate: z
        .union([
          z.lazy(() => CartItemCreateOrConnectWithoutCartInputSchema),
          z.lazy(() => CartItemCreateOrConnectWithoutCartInputSchema).array(),
        ])
        .optional(),
      createMany: z
        .lazy(() => CartItemCreateManyCartInputEnvelopeSchema)
        .optional(),
      connect: z
        .union([
          z.lazy(() => CartItemWhereUniqueInputSchema),
          z.lazy(() => CartItemWhereUniqueInputSchema).array(),
        ])
        .optional(),
    })
    .strict() as z.ZodType<Prisma.CartItemUncheckedCreateNestedManyWithoutCartInput>;

export const UserUpdateOneRequiredWithoutCartNestedInputSchema: z.ZodType<Prisma.UserUpdateOneRequiredWithoutCartNestedInput> =
  z
    .object({
      create: z
        .union([
          z.lazy(() => UserCreateWithoutCartInputSchema),
          z.lazy(() => UserUncheckedCreateWithoutCartInputSchema),
        ])
        .optional(),
      connectOrCreate: z
        .lazy(() => UserCreateOrConnectWithoutCartInputSchema)
        .optional(),
      upsert: z.lazy(() => UserUpsertWithoutCartInputSchema).optional(),
      connect: z.lazy(() => UserWhereUniqueInputSchema).optional(),
      update: z
        .union([
          z.lazy(() => UserUpdateToOneWithWhereWithoutCartInputSchema),
          z.lazy(() => UserUpdateWithoutCartInputSchema),
          z.lazy(() => UserUncheckedUpdateWithoutCartInputSchema),
        ])
        .optional(),
    })
    .strict() as z.ZodType<Prisma.UserUpdateOneRequiredWithoutCartNestedInput>;

export const CartItemUpdateManyWithoutCartNestedInputSchema: z.ZodType<Prisma.CartItemUpdateManyWithoutCartNestedInput> =
  z
    .object({
      create: z
        .union([
          z.lazy(() => CartItemCreateWithoutCartInputSchema),
          z.lazy(() => CartItemCreateWithoutCartInputSchema).array(),
          z.lazy(() => CartItemUncheckedCreateWithoutCartInputSchema),
          z.lazy(() => CartItemUncheckedCreateWithoutCartInputSchema).array(),
        ])
        .optional(),
      connectOrCreate: z
        .union([
          z.lazy(() => CartItemCreateOrConnectWithoutCartInputSchema),
          z.lazy(() => CartItemCreateOrConnectWithoutCartInputSchema).array(),
        ])
        .optional(),
      upsert: z
        .union([
          z.lazy(() => CartItemUpsertWithWhereUniqueWithoutCartInputSchema),
          z
            .lazy(() => CartItemUpsertWithWhereUniqueWithoutCartInputSchema)
            .array(),
        ])
        .optional(),
      createMany: z
        .lazy(() => CartItemCreateManyCartInputEnvelopeSchema)
        .optional(),
      set: z
        .union([
          z.lazy(() => CartItemWhereUniqueInputSchema),
          z.lazy(() => CartItemWhereUniqueInputSchema).array(),
        ])
        .optional(),
      disconnect: z
        .union([
          z.lazy(() => CartItemWhereUniqueInputSchema),
          z.lazy(() => CartItemWhereUniqueInputSchema).array(),
        ])
        .optional(),
      delete: z
        .union([
          z.lazy(() => CartItemWhereUniqueInputSchema),
          z.lazy(() => CartItemWhereUniqueInputSchema).array(),
        ])
        .optional(),
      connect: z
        .union([
          z.lazy(() => CartItemWhereUniqueInputSchema),
          z.lazy(() => CartItemWhereUniqueInputSchema).array(),
        ])
        .optional(),
      update: z
        .union([
          z.lazy(() => CartItemUpdateWithWhereUniqueWithoutCartInputSchema),
          z
            .lazy(() => CartItemUpdateWithWhereUniqueWithoutCartInputSchema)
            .array(),
        ])
        .optional(),
      updateMany: z
        .union([
          z.lazy(() => CartItemUpdateManyWithWhereWithoutCartInputSchema),
          z
            .lazy(() => CartItemUpdateManyWithWhereWithoutCartInputSchema)
            .array(),
        ])
        .optional(),
      deleteMany: z
        .union([
          z.lazy(() => CartItemScalarWhereInputSchema),
          z.lazy(() => CartItemScalarWhereInputSchema).array(),
        ])
        .optional(),
    })
    .strict() as z.ZodType<Prisma.CartItemUpdateManyWithoutCartNestedInput>;

export const CartItemUncheckedUpdateManyWithoutCartNestedInputSchema: z.ZodType<Prisma.CartItemUncheckedUpdateManyWithoutCartNestedInput> =
  z
    .object({
      create: z
        .union([
          z.lazy(() => CartItemCreateWithoutCartInputSchema),
          z.lazy(() => CartItemCreateWithoutCartInputSchema).array(),
          z.lazy(() => CartItemUncheckedCreateWithoutCartInputSchema),
          z.lazy(() => CartItemUncheckedCreateWithoutCartInputSchema).array(),
        ])
        .optional(),
      connectOrCreate: z
        .union([
          z.lazy(() => CartItemCreateOrConnectWithoutCartInputSchema),
          z.lazy(() => CartItemCreateOrConnectWithoutCartInputSchema).array(),
        ])
        .optional(),
      upsert: z
        .union([
          z.lazy(() => CartItemUpsertWithWhereUniqueWithoutCartInputSchema),
          z
            .lazy(() => CartItemUpsertWithWhereUniqueWithoutCartInputSchema)
            .array(),
        ])
        .optional(),
      createMany: z
        .lazy(() => CartItemCreateManyCartInputEnvelopeSchema)
        .optional(),
      set: z
        .union([
          z.lazy(() => CartItemWhereUniqueInputSchema),
          z.lazy(() => CartItemWhereUniqueInputSchema).array(),
        ])
        .optional(),
      disconnect: z
        .union([
          z.lazy(() => CartItemWhereUniqueInputSchema),
          z.lazy(() => CartItemWhereUniqueInputSchema).array(),
        ])
        .optional(),
      delete: z
        .union([
          z.lazy(() => CartItemWhereUniqueInputSchema),
          z.lazy(() => CartItemWhereUniqueInputSchema).array(),
        ])
        .optional(),
      connect: z
        .union([
          z.lazy(() => CartItemWhereUniqueInputSchema),
          z.lazy(() => CartItemWhereUniqueInputSchema).array(),
        ])
        .optional(),
      update: z
        .union([
          z.lazy(() => CartItemUpdateWithWhereUniqueWithoutCartInputSchema),
          z
            .lazy(() => CartItemUpdateWithWhereUniqueWithoutCartInputSchema)
            .array(),
        ])
        .optional(),
      updateMany: z
        .union([
          z.lazy(() => CartItemUpdateManyWithWhereWithoutCartInputSchema),
          z
            .lazy(() => CartItemUpdateManyWithWhereWithoutCartInputSchema)
            .array(),
        ])
        .optional(),
      deleteMany: z
        .union([
          z.lazy(() => CartItemScalarWhereInputSchema),
          z.lazy(() => CartItemScalarWhereInputSchema).array(),
        ])
        .optional(),
    })
    .strict() as z.ZodType<Prisma.CartItemUncheckedUpdateManyWithoutCartNestedInput>;

export const CartCreateNestedOneWithoutCartItemsInputSchema: z.ZodType<Prisma.CartCreateNestedOneWithoutCartItemsInput> =
  z
    .object({
      create: z
        .union([
          z.lazy(() => CartCreateWithoutCartItemsInputSchema),
          z.lazy(() => CartUncheckedCreateWithoutCartItemsInputSchema),
        ])
        .optional(),
      connectOrCreate: z
        .lazy(() => CartCreateOrConnectWithoutCartItemsInputSchema)
        .optional(),
      connect: z.lazy(() => CartWhereUniqueInputSchema).optional(),
    })
    .strict() as z.ZodType<Prisma.CartCreateNestedOneWithoutCartItemsInput>;

export const ProductVariantCreateNestedOneWithoutCartItemsInputSchema: z.ZodType<Prisma.ProductVariantCreateNestedOneWithoutCartItemsInput> =
  z
    .object({
      create: z
        .union([
          z.lazy(() => ProductVariantCreateWithoutCartItemsInputSchema),
          z.lazy(
            () => ProductVariantUncheckedCreateWithoutCartItemsInputSchema,
          ),
        ])
        .optional(),
      connectOrCreate: z
        .lazy(() => ProductVariantCreateOrConnectWithoutCartItemsInputSchema)
        .optional(),
      connect: z.lazy(() => ProductVariantWhereUniqueInputSchema).optional(),
    })
    .strict() as z.ZodType<Prisma.ProductVariantCreateNestedOneWithoutCartItemsInput>;

export const CartUpdateOneRequiredWithoutCartItemsNestedInputSchema: z.ZodType<Prisma.CartUpdateOneRequiredWithoutCartItemsNestedInput> =
  z
    .object({
      create: z
        .union([
          z.lazy(() => CartCreateWithoutCartItemsInputSchema),
          z.lazy(() => CartUncheckedCreateWithoutCartItemsInputSchema),
        ])
        .optional(),
      connectOrCreate: z
        .lazy(() => CartCreateOrConnectWithoutCartItemsInputSchema)
        .optional(),
      upsert: z.lazy(() => CartUpsertWithoutCartItemsInputSchema).optional(),
      connect: z.lazy(() => CartWhereUniqueInputSchema).optional(),
      update: z
        .union([
          z.lazy(() => CartUpdateToOneWithWhereWithoutCartItemsInputSchema),
          z.lazy(() => CartUpdateWithoutCartItemsInputSchema),
          z.lazy(() => CartUncheckedUpdateWithoutCartItemsInputSchema),
        ])
        .optional(),
    })
    .strict() as z.ZodType<Prisma.CartUpdateOneRequiredWithoutCartItemsNestedInput>;

export const ProductVariantUpdateOneRequiredWithoutCartItemsNestedInputSchema: z.ZodType<Prisma.ProductVariantUpdateOneRequiredWithoutCartItemsNestedInput> =
  z
    .object({
      create: z
        .union([
          z.lazy(() => ProductVariantCreateWithoutCartItemsInputSchema),
          z.lazy(
            () => ProductVariantUncheckedCreateWithoutCartItemsInputSchema,
          ),
        ])
        .optional(),
      connectOrCreate: z
        .lazy(() => ProductVariantCreateOrConnectWithoutCartItemsInputSchema)
        .optional(),
      upsert: z
        .lazy(() => ProductVariantUpsertWithoutCartItemsInputSchema)
        .optional(),
      connect: z.lazy(() => ProductVariantWhereUniqueInputSchema).optional(),
      update: z
        .union([
          z.lazy(
            () => ProductVariantUpdateToOneWithWhereWithoutCartItemsInputSchema,
          ),
          z.lazy(() => ProductVariantUpdateWithoutCartItemsInputSchema),
          z.lazy(
            () => ProductVariantUncheckedUpdateWithoutCartItemsInputSchema,
          ),
        ])
        .optional(),
    })
    .strict() as z.ZodType<Prisma.ProductVariantUpdateOneRequiredWithoutCartItemsNestedInput>;

export const UserCreateNestedOneWithoutNotificationsInputSchema: z.ZodType<Prisma.UserCreateNestedOneWithoutNotificationsInput> =
  z
    .object({
      create: z
        .union([
          z.lazy(() => UserCreateWithoutNotificationsInputSchema),
          z.lazy(() => UserUncheckedCreateWithoutNotificationsInputSchema),
        ])
        .optional(),
      connectOrCreate: z
        .lazy(() => UserCreateOrConnectWithoutNotificationsInputSchema)
        .optional(),
      connect: z.lazy(() => UserWhereUniqueInputSchema).optional(),
    })
    .strict() as z.ZodType<Prisma.UserCreateNestedOneWithoutNotificationsInput>;

export const UserUpdateOneWithoutNotificationsNestedInputSchema: z.ZodType<Prisma.UserUpdateOneWithoutNotificationsNestedInput> =
  z
    .object({
      create: z
        .union([
          z.lazy(() => UserCreateWithoutNotificationsInputSchema),
          z.lazy(() => UserUncheckedCreateWithoutNotificationsInputSchema),
        ])
        .optional(),
      connectOrCreate: z
        .lazy(() => UserCreateOrConnectWithoutNotificationsInputSchema)
        .optional(),
      upsert: z
        .lazy(() => UserUpsertWithoutNotificationsInputSchema)
        .optional(),
      disconnect: z
        .union([z.boolean(), z.lazy(() => UserWhereInputSchema)])
        .optional(),
      delete: z
        .union([z.boolean(), z.lazy(() => UserWhereInputSchema)])
        .optional(),
      connect: z.lazy(() => UserWhereUniqueInputSchema).optional(),
      update: z
        .union([
          z.lazy(() => UserUpdateToOneWithWhereWithoutNotificationsInputSchema),
          z.lazy(() => UserUpdateWithoutNotificationsInputSchema),
          z.lazy(() => UserUncheckedUpdateWithoutNotificationsInputSchema),
        ])
        .optional(),
    })
    .strict() as z.ZodType<Prisma.UserUpdateOneWithoutNotificationsNestedInput>;

export const OrderCreateNestedOneWithoutPaymentsInputSchema: z.ZodType<Prisma.OrderCreateNestedOneWithoutPaymentsInput> =
  z
    .object({
      create: z
        .union([
          z.lazy(() => OrderCreateWithoutPaymentsInputSchema),
          z.lazy(() => OrderUncheckedCreateWithoutPaymentsInputSchema),
        ])
        .optional(),
      connectOrCreate: z
        .lazy(() => OrderCreateOrConnectWithoutPaymentsInputSchema)
        .optional(),
      connect: z.lazy(() => OrderWhereUniqueInputSchema).optional(),
    })
    .strict() as z.ZodType<Prisma.OrderCreateNestedOneWithoutPaymentsInput>;

export const EnumPaymentTypeFieldUpdateOperationsInputSchema: z.ZodType<Prisma.EnumPaymentTypeFieldUpdateOperationsInput> =
  z
    .object({
      set: z.lazy(() => PaymentTypeSchema).optional(),
    })
    .strict() as z.ZodType<Prisma.EnumPaymentTypeFieldUpdateOperationsInput>;

export const EnumPaymentStatusFieldUpdateOperationsInputSchema: z.ZodType<Prisma.EnumPaymentStatusFieldUpdateOperationsInput> =
  z
    .object({
      set: z.lazy(() => PaymentStatusSchema).optional(),
    })
    .strict() as z.ZodType<Prisma.EnumPaymentStatusFieldUpdateOperationsInput>;

export const OrderUpdateOneRequiredWithoutPaymentsNestedInputSchema: z.ZodType<Prisma.OrderUpdateOneRequiredWithoutPaymentsNestedInput> =
  z
    .object({
      create: z
        .union([
          z.lazy(() => OrderCreateWithoutPaymentsInputSchema),
          z.lazy(() => OrderUncheckedCreateWithoutPaymentsInputSchema),
        ])
        .optional(),
      connectOrCreate: z
        .lazy(() => OrderCreateOrConnectWithoutPaymentsInputSchema)
        .optional(),
      upsert: z.lazy(() => OrderUpsertWithoutPaymentsInputSchema).optional(),
      connect: z.lazy(() => OrderWhereUniqueInputSchema).optional(),
      update: z
        .union([
          z.lazy(() => OrderUpdateToOneWithWhereWithoutPaymentsInputSchema),
          z.lazy(() => OrderUpdateWithoutPaymentsInputSchema),
          z.lazy(() => OrderUncheckedUpdateWithoutPaymentsInputSchema),
        ])
        .optional(),
    })
    .strict() as z.ZodType<Prisma.OrderUpdateOneRequiredWithoutPaymentsNestedInput>;

export const NestedStringFilterSchema: z.ZodType<Prisma.NestedStringFilter> = z
  .object({
    equals: z.string().optional(),
    in: z.string().array().optional(),
    notIn: z.string().array().optional(),
    lt: z.string().optional(),
    lte: z.string().optional(),
    gt: z.string().optional(),
    gte: z.string().optional(),
    contains: z.string().optional(),
    startsWith: z.string().optional(),
    endsWith: z.string().optional(),
    not: z
      .union([z.string(), z.lazy(() => NestedStringFilterSchema)])
      .optional(),
  })
  .strict() as z.ZodType<Prisma.NestedStringFilter>;

export const NestedStringNullableFilterSchema: z.ZodType<Prisma.NestedStringNullableFilter> =
  z
    .object({
      equals: z.string().optional().nullable(),
      in: z.string().array().optional().nullable(),
      notIn: z.string().array().optional().nullable(),
      lt: z.string().optional(),
      lte: z.string().optional(),
      gt: z.string().optional(),
      gte: z.string().optional(),
      contains: z.string().optional(),
      startsWith: z.string().optional(),
      endsWith: z.string().optional(),
      not: z
        .union([z.string(), z.lazy(() => NestedStringNullableFilterSchema)])
        .optional()
        .nullable(),
    })
    .strict() as z.ZodType<Prisma.NestedStringNullableFilter>;

export const NestedEnumUserStatusFilterSchema: z.ZodType<Prisma.NestedEnumUserStatusFilter> =
  z
    .object({
      equals: z.lazy(() => UserStatusSchema).optional(),
      in: z
        .lazy(() => UserStatusSchema)
        .array()
        .optional(),
      notIn: z
        .lazy(() => UserStatusSchema)
        .array()
        .optional(),
      not: z
        .union([
          z.lazy(() => UserStatusSchema),
          z.lazy(() => NestedEnumUserStatusFilterSchema),
        ])
        .optional(),
    })
    .strict() as z.ZodType<Prisma.NestedEnumUserStatusFilter>;

export const NestedDateTimeFilterSchema: z.ZodType<Prisma.NestedDateTimeFilter> =
  z
    .object({
      equals: z.coerce.date().optional(),
      in: z.coerce.date().array().optional(),
      notIn: z.coerce.date().array().optional(),
      lt: z.coerce.date().optional(),
      lte: z.coerce.date().optional(),
      gt: z.coerce.date().optional(),
      gte: z.coerce.date().optional(),
      not: z
        .union([z.coerce.date(), z.lazy(() => NestedDateTimeFilterSchema)])
        .optional(),
    })
    .strict() as z.ZodType<Prisma.NestedDateTimeFilter>;

export const NestedDateTimeNullableFilterSchema: z.ZodType<Prisma.NestedDateTimeNullableFilter> =
  z
    .object({
      equals: z.coerce.date().optional().nullable(),
      in: z.coerce.date().array().optional().nullable(),
      notIn: z.coerce.date().array().optional().nullable(),
      lt: z.coerce.date().optional(),
      lte: z.coerce.date().optional(),
      gt: z.coerce.date().optional(),
      gte: z.coerce.date().optional(),
      not: z
        .union([
          z.coerce.date(),
          z.lazy(() => NestedDateTimeNullableFilterSchema),
        ])
        .optional()
        .nullable(),
    })
    .strict() as z.ZodType<Prisma.NestedDateTimeNullableFilter>;

export const NestedStringWithAggregatesFilterSchema: z.ZodType<Prisma.NestedStringWithAggregatesFilter> =
  z
    .object({
      equals: z.string().optional(),
      in: z.string().array().optional(),
      notIn: z.string().array().optional(),
      lt: z.string().optional(),
      lte: z.string().optional(),
      gt: z.string().optional(),
      gte: z.string().optional(),
      contains: z.string().optional(),
      startsWith: z.string().optional(),
      endsWith: z.string().optional(),
      not: z
        .union([
          z.string(),
          z.lazy(() => NestedStringWithAggregatesFilterSchema),
        ])
        .optional(),
      _count: z.lazy(() => NestedIntFilterSchema).optional(),
      _min: z.lazy(() => NestedStringFilterSchema).optional(),
      _max: z.lazy(() => NestedStringFilterSchema).optional(),
    })
    .strict() as z.ZodType<Prisma.NestedStringWithAggregatesFilter>;

export const NestedIntFilterSchema: z.ZodType<Prisma.NestedIntFilter> = z
  .object({
    equals: z.number().optional(),
    in: z.number().array().optional(),
    notIn: z.number().array().optional(),
    lt: z.number().optional(),
    lte: z.number().optional(),
    gt: z.number().optional(),
    gte: z.number().optional(),
    not: z.union([z.number(), z.lazy(() => NestedIntFilterSchema)]).optional(),
  })
  .strict() as z.ZodType<Prisma.NestedIntFilter>;

export const NestedStringNullableWithAggregatesFilterSchema: z.ZodType<Prisma.NestedStringNullableWithAggregatesFilter> =
  z
    .object({
      equals: z.string().optional().nullable(),
      in: z.string().array().optional().nullable(),
      notIn: z.string().array().optional().nullable(),
      lt: z.string().optional(),
      lte: z.string().optional(),
      gt: z.string().optional(),
      gte: z.string().optional(),
      contains: z.string().optional(),
      startsWith: z.string().optional(),
      endsWith: z.string().optional(),
      not: z
        .union([
          z.string(),
          z.lazy(() => NestedStringNullableWithAggregatesFilterSchema),
        ])
        .optional()
        .nullable(),
      _count: z.lazy(() => NestedIntNullableFilterSchema).optional(),
      _min: z.lazy(() => NestedStringNullableFilterSchema).optional(),
      _max: z.lazy(() => NestedStringNullableFilterSchema).optional(),
    })
    .strict() as z.ZodType<Prisma.NestedStringNullableWithAggregatesFilter>;

export const NestedIntNullableFilterSchema: z.ZodType<Prisma.NestedIntNullableFilter> =
  z
    .object({
      equals: z.number().optional().nullable(),
      in: z.number().array().optional().nullable(),
      notIn: z.number().array().optional().nullable(),
      lt: z.number().optional(),
      lte: z.number().optional(),
      gt: z.number().optional(),
      gte: z.number().optional(),
      not: z
        .union([z.number(), z.lazy(() => NestedIntNullableFilterSchema)])
        .optional()
        .nullable(),
    })
    .strict() as z.ZodType<Prisma.NestedIntNullableFilter>;

export const NestedEnumUserStatusWithAggregatesFilterSchema: z.ZodType<Prisma.NestedEnumUserStatusWithAggregatesFilter> =
  z
    .object({
      equals: z.lazy(() => UserStatusSchema).optional(),
      in: z
        .lazy(() => UserStatusSchema)
        .array()
        .optional(),
      notIn: z
        .lazy(() => UserStatusSchema)
        .array()
        .optional(),
      not: z
        .union([
          z.lazy(() => UserStatusSchema),
          z.lazy(() => NestedEnumUserStatusWithAggregatesFilterSchema),
        ])
        .optional(),
      _count: z.lazy(() => NestedIntFilterSchema).optional(),
      _min: z.lazy(() => NestedEnumUserStatusFilterSchema).optional(),
      _max: z.lazy(() => NestedEnumUserStatusFilterSchema).optional(),
    })
    .strict() as z.ZodType<Prisma.NestedEnumUserStatusWithAggregatesFilter>;

export const NestedDateTimeWithAggregatesFilterSchema: z.ZodType<Prisma.NestedDateTimeWithAggregatesFilter> =
  z
    .object({
      equals: z.coerce.date().optional(),
      in: z.coerce.date().array().optional(),
      notIn: z.coerce.date().array().optional(),
      lt: z.coerce.date().optional(),
      lte: z.coerce.date().optional(),
      gt: z.coerce.date().optional(),
      gte: z.coerce.date().optional(),
      not: z
        .union([
          z.coerce.date(),
          z.lazy(() => NestedDateTimeWithAggregatesFilterSchema),
        ])
        .optional(),
      _count: z.lazy(() => NestedIntFilterSchema).optional(),
      _min: z.lazy(() => NestedDateTimeFilterSchema).optional(),
      _max: z.lazy(() => NestedDateTimeFilterSchema).optional(),
    })
    .strict() as z.ZodType<Prisma.NestedDateTimeWithAggregatesFilter>;

export const NestedDateTimeNullableWithAggregatesFilterSchema: z.ZodType<Prisma.NestedDateTimeNullableWithAggregatesFilter> =
  z
    .object({
      equals: z.coerce.date().optional().nullable(),
      in: z.coerce.date().array().optional().nullable(),
      notIn: z.coerce.date().array().optional().nullable(),
      lt: z.coerce.date().optional(),
      lte: z.coerce.date().optional(),
      gt: z.coerce.date().optional(),
      gte: z.coerce.date().optional(),
      not: z
        .union([
          z.coerce.date(),
          z.lazy(() => NestedDateTimeNullableWithAggregatesFilterSchema),
        ])
        .optional()
        .nullable(),
      _count: z.lazy(() => NestedIntNullableFilterSchema).optional(),
      _min: z.lazy(() => NestedDateTimeNullableFilterSchema).optional(),
      _max: z.lazy(() => NestedDateTimeNullableFilterSchema).optional(),
    })
    .strict() as z.ZodType<Prisma.NestedDateTimeNullableWithAggregatesFilter>;

export const NestedEnumVendorStatusFilterSchema: z.ZodType<Prisma.NestedEnumVendorStatusFilter> =
  z
    .object({
      equals: z.lazy(() => VendorStatusSchema).optional(),
      in: z
        .lazy(() => VendorStatusSchema)
        .array()
        .optional(),
      notIn: z
        .lazy(() => VendorStatusSchema)
        .array()
        .optional(),
      not: z
        .union([
          z.lazy(() => VendorStatusSchema),
          z.lazy(() => NestedEnumVendorStatusFilterSchema),
        ])
        .optional(),
    })
    .strict() as z.ZodType<Prisma.NestedEnumVendorStatusFilter>;

export const NestedIntWithAggregatesFilterSchema: z.ZodType<Prisma.NestedIntWithAggregatesFilter> =
  z
    .object({
      equals: z.number().optional(),
      in: z.number().array().optional(),
      notIn: z.number().array().optional(),
      lt: z.number().optional(),
      lte: z.number().optional(),
      gt: z.number().optional(),
      gte: z.number().optional(),
      not: z
        .union([z.number(), z.lazy(() => NestedIntWithAggregatesFilterSchema)])
        .optional(),
      _count: z.lazy(() => NestedIntFilterSchema).optional(),
      _avg: z.lazy(() => NestedFloatFilterSchema).optional(),
      _sum: z.lazy(() => NestedIntFilterSchema).optional(),
      _min: z.lazy(() => NestedIntFilterSchema).optional(),
      _max: z.lazy(() => NestedIntFilterSchema).optional(),
    })
    .strict() as z.ZodType<Prisma.NestedIntWithAggregatesFilter>;

export const NestedFloatFilterSchema: z.ZodType<Prisma.NestedFloatFilter> = z
  .object({
    equals: z.number().optional(),
    in: z.number().array().optional(),
    notIn: z.number().array().optional(),
    lt: z.number().optional(),
    lte: z.number().optional(),
    gt: z.number().optional(),
    gte: z.number().optional(),
    not: z
      .union([z.number(), z.lazy(() => NestedFloatFilterSchema)])
      .optional(),
  })
  .strict() as z.ZodType<Prisma.NestedFloatFilter>;

export const NestedEnumVendorStatusWithAggregatesFilterSchema: z.ZodType<Prisma.NestedEnumVendorStatusWithAggregatesFilter> =
  z
    .object({
      equals: z.lazy(() => VendorStatusSchema).optional(),
      in: z
        .lazy(() => VendorStatusSchema)
        .array()
        .optional(),
      notIn: z
        .lazy(() => VendorStatusSchema)
        .array()
        .optional(),
      not: z
        .union([
          z.lazy(() => VendorStatusSchema),
          z.lazy(() => NestedEnumVendorStatusWithAggregatesFilterSchema),
        ])
        .optional(),
      _count: z.lazy(() => NestedIntFilterSchema).optional(),
      _min: z.lazy(() => NestedEnumVendorStatusFilterSchema).optional(),
      _max: z.lazy(() => NestedEnumVendorStatusFilterSchema).optional(),
    })
    .strict() as z.ZodType<Prisma.NestedEnumVendorStatusWithAggregatesFilter>;

export const NestedBoolFilterSchema: z.ZodType<Prisma.NestedBoolFilter> = z
  .object({
    equals: z.boolean().optional(),
    not: z
      .union([z.boolean(), z.lazy(() => NestedBoolFilterSchema)])
      .optional(),
  })
  .strict() as z.ZodType<Prisma.NestedBoolFilter>;

export const NestedBoolWithAggregatesFilterSchema: z.ZodType<Prisma.NestedBoolWithAggregatesFilter> =
  z
    .object({
      equals: z.boolean().optional(),
      not: z
        .union([
          z.boolean(),
          z.lazy(() => NestedBoolWithAggregatesFilterSchema),
        ])
        .optional(),
      _count: z.lazy(() => NestedIntFilterSchema).optional(),
      _min: z.lazy(() => NestedBoolFilterSchema).optional(),
      _max: z.lazy(() => NestedBoolFilterSchema).optional(),
    })
    .strict() as z.ZodType<Prisma.NestedBoolWithAggregatesFilter>;

export const NestedEnumUserVendorRoleStatusFilterSchema: z.ZodType<Prisma.NestedEnumUserVendorRoleStatusFilter> =
  z
    .object({
      equals: z.lazy(() => UserVendorRoleStatusSchema).optional(),
      in: z
        .lazy(() => UserVendorRoleStatusSchema)
        .array()
        .optional(),
      notIn: z
        .lazy(() => UserVendorRoleStatusSchema)
        .array()
        .optional(),
      not: z
        .union([
          z.lazy(() => UserVendorRoleStatusSchema),
          z.lazy(() => NestedEnumUserVendorRoleStatusFilterSchema),
        ])
        .optional(),
    })
    .strict() as z.ZodType<Prisma.NestedEnumUserVendorRoleStatusFilter>;

export const NestedEnumUserVendorRoleStatusWithAggregatesFilterSchema: z.ZodType<Prisma.NestedEnumUserVendorRoleStatusWithAggregatesFilter> =
  z
    .object({
      equals: z.lazy(() => UserVendorRoleStatusSchema).optional(),
      in: z
        .lazy(() => UserVendorRoleStatusSchema)
        .array()
        .optional(),
      notIn: z
        .lazy(() => UserVendorRoleStatusSchema)
        .array()
        .optional(),
      not: z
        .union([
          z.lazy(() => UserVendorRoleStatusSchema),
          z.lazy(
            () => NestedEnumUserVendorRoleStatusWithAggregatesFilterSchema,
          ),
        ])
        .optional(),
      _count: z.lazy(() => NestedIntFilterSchema).optional(),
      _min: z.lazy(() => NestedEnumUserVendorRoleStatusFilterSchema).optional(),
      _max: z.lazy(() => NestedEnumUserVendorRoleStatusFilterSchema).optional(),
    })
    .strict() as z.ZodType<Prisma.NestedEnumUserVendorRoleStatusWithAggregatesFilter>;

export const NestedDecimalFilterSchema: z.ZodType<Prisma.NestedDecimalFilter> =
  z
    .object({
      equals: z
        .union([
          z.number(),
          z.string(),
          z.instanceof(Decimal),
          z.instanceof(Prisma.Decimal),
          DecimalJsLikeSchema,
        ])
        .refine((v) => isValidDecimalInput(v), { message: 'Must be a Decimal' })
        .optional(),
      in: z
        .union([
          z.number().array(),
          z.string().array(),
          z.instanceof(Decimal).array(),
          z.instanceof(Prisma.Decimal).array(),
          DecimalJsLikeSchema.array(),
        ])
        .refine(
          (v) =>
            Array.isArray(v) &&
            (v as any[]).every((v) => isValidDecimalInput(v)),
          { message: 'Must be a Decimal' },
        )
        .optional(),
      notIn: z
        .union([
          z.number().array(),
          z.string().array(),
          z.instanceof(Decimal).array(),
          z.instanceof(Prisma.Decimal).array(),
          DecimalJsLikeSchema.array(),
        ])
        .refine(
          (v) =>
            Array.isArray(v) &&
            (v as any[]).every((v) => isValidDecimalInput(v)),
          { message: 'Must be a Decimal' },
        )
        .optional(),
      lt: z
        .union([
          z.number(),
          z.string(),
          z.instanceof(Decimal),
          z.instanceof(Prisma.Decimal),
          DecimalJsLikeSchema,
        ])
        .refine((v) => isValidDecimalInput(v), { message: 'Must be a Decimal' })
        .optional(),
      lte: z
        .union([
          z.number(),
          z.string(),
          z.instanceof(Decimal),
          z.instanceof(Prisma.Decimal),
          DecimalJsLikeSchema,
        ])
        .refine((v) => isValidDecimalInput(v), { message: 'Must be a Decimal' })
        .optional(),
      gt: z
        .union([
          z.number(),
          z.string(),
          z.instanceof(Decimal),
          z.instanceof(Prisma.Decimal),
          DecimalJsLikeSchema,
        ])
        .refine((v) => isValidDecimalInput(v), { message: 'Must be a Decimal' })
        .optional(),
      gte: z
        .union([
          z.number(),
          z.string(),
          z.instanceof(Decimal),
          z.instanceof(Prisma.Decimal),
          DecimalJsLikeSchema,
        ])
        .refine((v) => isValidDecimalInput(v), { message: 'Must be a Decimal' })
        .optional(),
      not: z
        .union([
          z
            .union([
              z.number(),
              z.string(),
              z.instanceof(Decimal),
              z.instanceof(Prisma.Decimal),
              DecimalJsLikeSchema,
            ])
            .refine((v) => isValidDecimalInput(v), {
              message: 'Must be a Decimal',
            }),
          z.lazy(() => NestedDecimalFilterSchema),
        ])
        .optional(),
    })
    .strict() as z.ZodType<Prisma.NestedDecimalFilter>;

export const NestedEnumProductStatusFilterSchema: z.ZodType<Prisma.NestedEnumProductStatusFilter> =
  z
    .object({
      equals: z.lazy(() => ProductStatusSchema).optional(),
      in: z
        .lazy(() => ProductStatusSchema)
        .array()
        .optional(),
      notIn: z
        .lazy(() => ProductStatusSchema)
        .array()
        .optional(),
      not: z
        .union([
          z.lazy(() => ProductStatusSchema),
          z.lazy(() => NestedEnumProductStatusFilterSchema),
        ])
        .optional(),
    })
    .strict() as z.ZodType<Prisma.NestedEnumProductStatusFilter>;

export const NestedDecimalWithAggregatesFilterSchema: z.ZodType<Prisma.NestedDecimalWithAggregatesFilter> =
  z
    .object({
      equals: z
        .union([
          z.number(),
          z.string(),
          z.instanceof(Decimal),
          z.instanceof(Prisma.Decimal),
          DecimalJsLikeSchema,
        ])
        .refine((v) => isValidDecimalInput(v), { message: 'Must be a Decimal' })
        .optional(),
      in: z
        .union([
          z.number().array(),
          z.string().array(),
          z.instanceof(Decimal).array(),
          z.instanceof(Prisma.Decimal).array(),
          DecimalJsLikeSchema.array(),
        ])
        .refine(
          (v) =>
            Array.isArray(v) &&
            (v as any[]).every((v) => isValidDecimalInput(v)),
          { message: 'Must be a Decimal' },
        )
        .optional(),
      notIn: z
        .union([
          z.number().array(),
          z.string().array(),
          z.instanceof(Decimal).array(),
          z.instanceof(Prisma.Decimal).array(),
          DecimalJsLikeSchema.array(),
        ])
        .refine(
          (v) =>
            Array.isArray(v) &&
            (v as any[]).every((v) => isValidDecimalInput(v)),
          { message: 'Must be a Decimal' },
        )
        .optional(),
      lt: z
        .union([
          z.number(),
          z.string(),
          z.instanceof(Decimal),
          z.instanceof(Prisma.Decimal),
          DecimalJsLikeSchema,
        ])
        .refine((v) => isValidDecimalInput(v), { message: 'Must be a Decimal' })
        .optional(),
      lte: z
        .union([
          z.number(),
          z.string(),
          z.instanceof(Decimal),
          z.instanceof(Prisma.Decimal),
          DecimalJsLikeSchema,
        ])
        .refine((v) => isValidDecimalInput(v), { message: 'Must be a Decimal' })
        .optional(),
      gt: z
        .union([
          z.number(),
          z.string(),
          z.instanceof(Decimal),
          z.instanceof(Prisma.Decimal),
          DecimalJsLikeSchema,
        ])
        .refine((v) => isValidDecimalInput(v), { message: 'Must be a Decimal' })
        .optional(),
      gte: z
        .union([
          z.number(),
          z.string(),
          z.instanceof(Decimal),
          z.instanceof(Prisma.Decimal),
          DecimalJsLikeSchema,
        ])
        .refine((v) => isValidDecimalInput(v), { message: 'Must be a Decimal' })
        .optional(),
      not: z
        .union([
          z
            .union([
              z.number(),
              z.string(),
              z.instanceof(Decimal),
              z.instanceof(Prisma.Decimal),
              DecimalJsLikeSchema,
            ])
            .refine((v) => isValidDecimalInput(v), {
              message: 'Must be a Decimal',
            }),
          z.lazy(() => NestedDecimalWithAggregatesFilterSchema),
        ])
        .optional(),
      _count: z.lazy(() => NestedIntFilterSchema).optional(),
      _avg: z.lazy(() => NestedDecimalFilterSchema).optional(),
      _sum: z.lazy(() => NestedDecimalFilterSchema).optional(),
      _min: z.lazy(() => NestedDecimalFilterSchema).optional(),
      _max: z.lazy(() => NestedDecimalFilterSchema).optional(),
    })
    .strict() as z.ZodType<Prisma.NestedDecimalWithAggregatesFilter>;

export const NestedEnumProductStatusWithAggregatesFilterSchema: z.ZodType<Prisma.NestedEnumProductStatusWithAggregatesFilter> =
  z
    .object({
      equals: z.lazy(() => ProductStatusSchema).optional(),
      in: z
        .lazy(() => ProductStatusSchema)
        .array()
        .optional(),
      notIn: z
        .lazy(() => ProductStatusSchema)
        .array()
        .optional(),
      not: z
        .union([
          z.lazy(() => ProductStatusSchema),
          z.lazy(() => NestedEnumProductStatusWithAggregatesFilterSchema),
        ])
        .optional(),
      _count: z.lazy(() => NestedIntFilterSchema).optional(),
      _min: z.lazy(() => NestedEnumProductStatusFilterSchema).optional(),
      _max: z.lazy(() => NestedEnumProductStatusFilterSchema).optional(),
    })
    .strict() as z.ZodType<Prisma.NestedEnumProductStatusWithAggregatesFilter>;

export const NestedJsonNullableFilterSchema: z.ZodType<Prisma.NestedJsonNullableFilter> =
  z
    .object({
      equals: InputJsonValueSchema.optional(),
      path: z.string().array().optional(),
      mode: z.lazy(() => QueryModeSchema).optional(),
      string_contains: z.string().optional(),
      string_starts_with: z.string().optional(),
      string_ends_with: z.string().optional(),
      array_starts_with: InputJsonValueSchema.optional().nullable(),
      array_ends_with: InputJsonValueSchema.optional().nullable(),
      array_contains: InputJsonValueSchema.optional().nullable(),
      lt: InputJsonValueSchema.optional(),
      lte: InputJsonValueSchema.optional(),
      gt: InputJsonValueSchema.optional(),
      gte: InputJsonValueSchema.optional(),
      not: InputJsonValueSchema.optional(),
    })
    .strict() as z.ZodType<Prisma.NestedJsonNullableFilter>;

export const NestedEnumOrderStatusFilterSchema: z.ZodType<Prisma.NestedEnumOrderStatusFilter> =
  z
    .object({
      equals: z.lazy(() => OrderStatusSchema).optional(),
      in: z
        .lazy(() => OrderStatusSchema)
        .array()
        .optional(),
      notIn: z
        .lazy(() => OrderStatusSchema)
        .array()
        .optional(),
      not: z
        .union([
          z.lazy(() => OrderStatusSchema),
          z.lazy(() => NestedEnumOrderStatusFilterSchema),
        ])
        .optional(),
    })
    .strict() as z.ZodType<Prisma.NestedEnumOrderStatusFilter>;

export const NestedEnumOrderStatusWithAggregatesFilterSchema: z.ZodType<Prisma.NestedEnumOrderStatusWithAggregatesFilter> =
  z
    .object({
      equals: z.lazy(() => OrderStatusSchema).optional(),
      in: z
        .lazy(() => OrderStatusSchema)
        .array()
        .optional(),
      notIn: z
        .lazy(() => OrderStatusSchema)
        .array()
        .optional(),
      not: z
        .union([
          z.lazy(() => OrderStatusSchema),
          z.lazy(() => NestedEnumOrderStatusWithAggregatesFilterSchema),
        ])
        .optional(),
      _count: z.lazy(() => NestedIntFilterSchema).optional(),
      _min: z.lazy(() => NestedEnumOrderStatusFilterSchema).optional(),
      _max: z.lazy(() => NestedEnumOrderStatusFilterSchema).optional(),
    })
    .strict() as z.ZodType<Prisma.NestedEnumOrderStatusWithAggregatesFilter>;

export const NestedEnumAddressTypeFilterSchema: z.ZodType<Prisma.NestedEnumAddressTypeFilter> =
  z
    .object({
      equals: z.lazy(() => AddressTypeSchema).optional(),
      in: z
        .lazy(() => AddressTypeSchema)
        .array()
        .optional(),
      notIn: z
        .lazy(() => AddressTypeSchema)
        .array()
        .optional(),
      not: z
        .union([
          z.lazy(() => AddressTypeSchema),
          z.lazy(() => NestedEnumAddressTypeFilterSchema),
        ])
        .optional(),
    })
    .strict() as z.ZodType<Prisma.NestedEnumAddressTypeFilter>;

export const NestedEnumAddressTypeWithAggregatesFilterSchema: z.ZodType<Prisma.NestedEnumAddressTypeWithAggregatesFilter> =
  z
    .object({
      equals: z.lazy(() => AddressTypeSchema).optional(),
      in: z
        .lazy(() => AddressTypeSchema)
        .array()
        .optional(),
      notIn: z
        .lazy(() => AddressTypeSchema)
        .array()
        .optional(),
      not: z
        .union([
          z.lazy(() => AddressTypeSchema),
          z.lazy(() => NestedEnumAddressTypeWithAggregatesFilterSchema),
        ])
        .optional(),
      _count: z.lazy(() => NestedIntFilterSchema).optional(),
      _min: z.lazy(() => NestedEnumAddressTypeFilterSchema).optional(),
      _max: z.lazy(() => NestedEnumAddressTypeFilterSchema).optional(),
    })
    .strict() as z.ZodType<Prisma.NestedEnumAddressTypeWithAggregatesFilter>;

export const NestedEnumPromotionTypeFilterSchema: z.ZodType<Prisma.NestedEnumPromotionTypeFilter> =
  z
    .object({
      equals: z.lazy(() => PromotionTypeSchema).optional(),
      in: z
        .lazy(() => PromotionTypeSchema)
        .array()
        .optional(),
      notIn: z
        .lazy(() => PromotionTypeSchema)
        .array()
        .optional(),
      not: z
        .union([
          z.lazy(() => PromotionTypeSchema),
          z.lazy(() => NestedEnumPromotionTypeFilterSchema),
        ])
        .optional(),
    })
    .strict() as z.ZodType<Prisma.NestedEnumPromotionTypeFilter>;

export const NestedEnumPromotionStatusFilterSchema: z.ZodType<Prisma.NestedEnumPromotionStatusFilter> =
  z
    .object({
      equals: z.lazy(() => PromotionStatusSchema).optional(),
      in: z
        .lazy(() => PromotionStatusSchema)
        .array()
        .optional(),
      notIn: z
        .lazy(() => PromotionStatusSchema)
        .array()
        .optional(),
      not: z
        .union([
          z.lazy(() => PromotionStatusSchema),
          z.lazy(() => NestedEnumPromotionStatusFilterSchema),
        ])
        .optional(),
    })
    .strict() as z.ZodType<Prisma.NestedEnumPromotionStatusFilter>;

export const NestedEnumPromotionTypeWithAggregatesFilterSchema: z.ZodType<Prisma.NestedEnumPromotionTypeWithAggregatesFilter> =
  z
    .object({
      equals: z.lazy(() => PromotionTypeSchema).optional(),
      in: z
        .lazy(() => PromotionTypeSchema)
        .array()
        .optional(),
      notIn: z
        .lazy(() => PromotionTypeSchema)
        .array()
        .optional(),
      not: z
        .union([
          z.lazy(() => PromotionTypeSchema),
          z.lazy(() => NestedEnumPromotionTypeWithAggregatesFilterSchema),
        ])
        .optional(),
      _count: z.lazy(() => NestedIntFilterSchema).optional(),
      _min: z.lazy(() => NestedEnumPromotionTypeFilterSchema).optional(),
      _max: z.lazy(() => NestedEnumPromotionTypeFilterSchema).optional(),
    })
    .strict() as z.ZodType<Prisma.NestedEnumPromotionTypeWithAggregatesFilter>;

export const NestedIntNullableWithAggregatesFilterSchema: z.ZodType<Prisma.NestedIntNullableWithAggregatesFilter> =
  z
    .object({
      equals: z.number().optional().nullable(),
      in: z.number().array().optional().nullable(),
      notIn: z.number().array().optional().nullable(),
      lt: z.number().optional(),
      lte: z.number().optional(),
      gt: z.number().optional(),
      gte: z.number().optional(),
      not: z
        .union([
          z.number(),
          z.lazy(() => NestedIntNullableWithAggregatesFilterSchema),
        ])
        .optional()
        .nullable(),
      _count: z.lazy(() => NestedIntNullableFilterSchema).optional(),
      _avg: z.lazy(() => NestedFloatNullableFilterSchema).optional(),
      _sum: z.lazy(() => NestedIntNullableFilterSchema).optional(),
      _min: z.lazy(() => NestedIntNullableFilterSchema).optional(),
      _max: z.lazy(() => NestedIntNullableFilterSchema).optional(),
    })
    .strict() as z.ZodType<Prisma.NestedIntNullableWithAggregatesFilter>;

export const NestedFloatNullableFilterSchema: z.ZodType<Prisma.NestedFloatNullableFilter> =
  z
    .object({
      equals: z.number().optional().nullable(),
      in: z.number().array().optional().nullable(),
      notIn: z.number().array().optional().nullable(),
      lt: z.number().optional(),
      lte: z.number().optional(),
      gt: z.number().optional(),
      gte: z.number().optional(),
      not: z
        .union([z.number(), z.lazy(() => NestedFloatNullableFilterSchema)])
        .optional()
        .nullable(),
    })
    .strict() as z.ZodType<Prisma.NestedFloatNullableFilter>;

export const NestedEnumPromotionStatusWithAggregatesFilterSchema: z.ZodType<Prisma.NestedEnumPromotionStatusWithAggregatesFilter> =
  z
    .object({
      equals: z.lazy(() => PromotionStatusSchema).optional(),
      in: z
        .lazy(() => PromotionStatusSchema)
        .array()
        .optional(),
      notIn: z
        .lazy(() => PromotionStatusSchema)
        .array()
        .optional(),
      not: z
        .union([
          z.lazy(() => PromotionStatusSchema),
          z.lazy(() => NestedEnumPromotionStatusWithAggregatesFilterSchema),
        ])
        .optional(),
      _count: z.lazy(() => NestedIntFilterSchema).optional(),
      _min: z.lazy(() => NestedEnumPromotionStatusFilterSchema).optional(),
      _max: z.lazy(() => NestedEnumPromotionStatusFilterSchema).optional(),
    })
    .strict() as z.ZodType<Prisma.NestedEnumPromotionStatusWithAggregatesFilter>;

export const NestedEnumPaymentTypeFilterSchema: z.ZodType<Prisma.NestedEnumPaymentTypeFilter> =
  z
    .object({
      equals: z.lazy(() => PaymentTypeSchema).optional(),
      in: z
        .lazy(() => PaymentTypeSchema)
        .array()
        .optional(),
      notIn: z
        .lazy(() => PaymentTypeSchema)
        .array()
        .optional(),
      not: z
        .union([
          z.lazy(() => PaymentTypeSchema),
          z.lazy(() => NestedEnumPaymentTypeFilterSchema),
        ])
        .optional(),
    })
    .strict() as z.ZodType<Prisma.NestedEnumPaymentTypeFilter>;

export const NestedEnumPaymentStatusFilterSchema: z.ZodType<Prisma.NestedEnumPaymentStatusFilter> =
  z
    .object({
      equals: z.lazy(() => PaymentStatusSchema).optional(),
      in: z
        .lazy(() => PaymentStatusSchema)
        .array()
        .optional(),
      notIn: z
        .lazy(() => PaymentStatusSchema)
        .array()
        .optional(),
      not: z
        .union([
          z.lazy(() => PaymentStatusSchema),
          z.lazy(() => NestedEnumPaymentStatusFilterSchema),
        ])
        .optional(),
    })
    .strict() as z.ZodType<Prisma.NestedEnumPaymentStatusFilter>;

export const NestedEnumPaymentTypeWithAggregatesFilterSchema: z.ZodType<Prisma.NestedEnumPaymentTypeWithAggregatesFilter> =
  z
    .object({
      equals: z.lazy(() => PaymentTypeSchema).optional(),
      in: z
        .lazy(() => PaymentTypeSchema)
        .array()
        .optional(),
      notIn: z
        .lazy(() => PaymentTypeSchema)
        .array()
        .optional(),
      not: z
        .union([
          z.lazy(() => PaymentTypeSchema),
          z.lazy(() => NestedEnumPaymentTypeWithAggregatesFilterSchema),
        ])
        .optional(),
      _count: z.lazy(() => NestedIntFilterSchema).optional(),
      _min: z.lazy(() => NestedEnumPaymentTypeFilterSchema).optional(),
      _max: z.lazy(() => NestedEnumPaymentTypeFilterSchema).optional(),
    })
    .strict() as z.ZodType<Prisma.NestedEnumPaymentTypeWithAggregatesFilter>;

export const NestedEnumPaymentStatusWithAggregatesFilterSchema: z.ZodType<Prisma.NestedEnumPaymentStatusWithAggregatesFilter> =
  z
    .object({
      equals: z.lazy(() => PaymentStatusSchema).optional(),
      in: z
        .lazy(() => PaymentStatusSchema)
        .array()
        .optional(),
      notIn: z
        .lazy(() => PaymentStatusSchema)
        .array()
        .optional(),
      not: z
        .union([
          z.lazy(() => PaymentStatusSchema),
          z.lazy(() => NestedEnumPaymentStatusWithAggregatesFilterSchema),
        ])
        .optional(),
      _count: z.lazy(() => NestedIntFilterSchema).optional(),
      _min: z.lazy(() => NestedEnumPaymentStatusFilterSchema).optional(),
      _max: z.lazy(() => NestedEnumPaymentStatusFilterSchema).optional(),
    })
    .strict() as z.ZodType<Prisma.NestedEnumPaymentStatusWithAggregatesFilter>;

export const VendorCreateWithoutUserInputSchema: z.ZodType<Prisma.VendorCreateWithoutUserInput> =
  z
    .object({
      id: z.string().uuid().optional(),
      name: z.string(),
      slug: z.string(),
      description: z.string().optional().nullable(),
      logoUrl: z.string().optional().nullable(),
      taxCode: z.string().optional().nullable(),
      totalProducts: z.number().int().optional(),
      totalOrders: z.number().int().optional(),
      status: z.lazy(() => VendorStatusSchema).optional(),
      createdAt: z.coerce.date().optional(),
      createdBy: z.string().optional().nullable(),
      updatedAt: z.coerce.date().optional(),
      deletedAt: z.coerce.date().optional().nullable(),
      products: z
        .lazy(() => ProductCreateNestedManyWithoutVendorInputSchema)
        .optional(),
      userVendorRoles: z
        .lazy(() => UserVendorRoleCreateNestedManyWithoutVendorInputSchema)
        .optional(),
    })
    .strict() as z.ZodType<Prisma.VendorCreateWithoutUserInput>;

export const VendorUncheckedCreateWithoutUserInputSchema: z.ZodType<Prisma.VendorUncheckedCreateWithoutUserInput> =
  z
    .object({
      id: z.string().uuid().optional(),
      name: z.string(),
      slug: z.string(),
      description: z.string().optional().nullable(),
      logoUrl: z.string().optional().nullable(),
      taxCode: z.string().optional().nullable(),
      totalProducts: z.number().int().optional(),
      totalOrders: z.number().int().optional(),
      status: z.lazy(() => VendorStatusSchema).optional(),
      createdAt: z.coerce.date().optional(),
      createdBy: z.string().optional().nullable(),
      updatedAt: z.coerce.date().optional(),
      deletedAt: z.coerce.date().optional().nullable(),
      products: z
        .lazy(() => ProductUncheckedCreateNestedManyWithoutVendorInputSchema)
        .optional(),
      userVendorRoles: z
        .lazy(
          () => UserVendorRoleUncheckedCreateNestedManyWithoutVendorInputSchema,
        )
        .optional(),
    })
    .strict() as z.ZodType<Prisma.VendorUncheckedCreateWithoutUserInput>;

export const VendorCreateOrConnectWithoutUserInputSchema: z.ZodType<Prisma.VendorCreateOrConnectWithoutUserInput> =
  z
    .object({
      where: z.lazy(() => VendorWhereUniqueInputSchema),
      create: z.union([
        z.lazy(() => VendorCreateWithoutUserInputSchema),
        z.lazy(() => VendorUncheckedCreateWithoutUserInputSchema),
      ]),
    })
    .strict() as z.ZodType<Prisma.VendorCreateOrConnectWithoutUserInput>;

export const VendorCreateManyUserInputEnvelopeSchema: z.ZodType<Prisma.VendorCreateManyUserInputEnvelope> =
  z
    .object({
      data: z.union([
        z.lazy(() => VendorCreateManyUserInputSchema),
        z.lazy(() => VendorCreateManyUserInputSchema).array(),
      ]),
      skipDuplicates: z.boolean().optional(),
    })
    .strict() as z.ZodType<Prisma.VendorCreateManyUserInputEnvelope>;

export const UserVendorRoleCreateWithoutUserInputSchema: z.ZodType<Prisma.UserVendorRoleCreateWithoutUserInput> =
  z
    .object({
      id: z.string().uuid().optional(),
      status: z.lazy(() => UserVendorRoleStatusSchema).optional(),
      createdAt: z.coerce.date().optional(),
      createdBy: z.string().optional().nullable(),
      vendor: z.lazy(
        () => VendorCreateNestedOneWithoutUserVendorRolesInputSchema,
      ),
      role: z.lazy(() => RoleCreateNestedOneWithoutUserVendorRolesInputSchema),
    })
    .strict() as z.ZodType<Prisma.UserVendorRoleCreateWithoutUserInput>;

export const UserVendorRoleUncheckedCreateWithoutUserInputSchema: z.ZodType<Prisma.UserVendorRoleUncheckedCreateWithoutUserInput> =
  z
    .object({
      id: z.string().uuid().optional(),
      vendorID: z.string(),
      roleID: z.string(),
      status: z.lazy(() => UserVendorRoleStatusSchema).optional(),
      createdAt: z.coerce.date().optional(),
      createdBy: z.string().optional().nullable(),
    })
    .strict() as z.ZodType<Prisma.UserVendorRoleUncheckedCreateWithoutUserInput>;

export const UserVendorRoleCreateOrConnectWithoutUserInputSchema: z.ZodType<Prisma.UserVendorRoleCreateOrConnectWithoutUserInput> =
  z
    .object({
      where: z.lazy(() => UserVendorRoleWhereUniqueInputSchema),
      create: z.union([
        z.lazy(() => UserVendorRoleCreateWithoutUserInputSchema),
        z.lazy(() => UserVendorRoleUncheckedCreateWithoutUserInputSchema),
      ]),
    })
    .strict() as z.ZodType<Prisma.UserVendorRoleCreateOrConnectWithoutUserInput>;

export const UserVendorRoleCreateManyUserInputEnvelopeSchema: z.ZodType<Prisma.UserVendorRoleCreateManyUserInputEnvelope> =
  z
    .object({
      data: z.union([
        z.lazy(() => UserVendorRoleCreateManyUserInputSchema),
        z.lazy(() => UserVendorRoleCreateManyUserInputSchema).array(),
      ]),
      skipDuplicates: z.boolean().optional(),
    })
    .strict() as z.ZodType<Prisma.UserVendorRoleCreateManyUserInputEnvelope>;

export const OrderCreateWithoutUserInputSchema: z.ZodType<Prisma.OrderCreateWithoutUserInput> =
  z
    .object({
      id: z.string().uuid().optional(),
      orderNumber: z.string(),
      status: z.lazy(() => OrderStatusSchema).optional(),
      subtotal: z
        .union([
          z.number(),
          z.string(),
          z.instanceof(Decimal),
          z.instanceof(Prisma.Decimal),
          DecimalJsLikeSchema,
        ])
        .refine((v) => isValidDecimalInput(v), {
          message: 'Must be a Decimal',
        }),
      taxAmount: z
        .union([
          z.number(),
          z.string(),
          z.instanceof(Decimal),
          z.instanceof(Prisma.Decimal),
          DecimalJsLikeSchema,
        ])
        .refine((v) => isValidDecimalInput(v), { message: 'Must be a Decimal' })
        .optional(),
      shippingAmount: z
        .union([
          z.number(),
          z.string(),
          z.instanceof(Decimal),
          z.instanceof(Prisma.Decimal),
          DecimalJsLikeSchema,
        ])
        .refine((v) => isValidDecimalInput(v), { message: 'Must be a Decimal' })
        .optional(),
      discountAmount: z
        .union([
          z.number(),
          z.string(),
          z.instanceof(Decimal),
          z.instanceof(Prisma.Decimal),
          DecimalJsLikeSchema,
        ])
        .refine((v) => isValidDecimalInput(v), { message: 'Must be a Decimal' })
        .optional(),
      totalAmount: z
        .union([
          z.number(),
          z.string(),
          z.instanceof(Decimal),
          z.instanceof(Prisma.Decimal),
          DecimalJsLikeSchema,
        ])
        .refine((v) => isValidDecimalInput(v), {
          message: 'Must be a Decimal',
        }),
      currency: z.string().optional(),
      notes: z.string().optional().nullable(),
      shippedAt: z.coerce.date().optional().nullable(),
      deliveredAt: z.coerce.date().optional().nullable(),
      createdAt: z.coerce.date().optional(),
      createdBy: z.string().optional().nullable(),
      updatedAt: z.coerce.date().optional(),
      deletedAt: z.coerce.date().optional().nullable(),
      orderItems: z
        .lazy(() => OrderItemCreateNestedManyWithoutOrderInputSchema)
        .optional(),
      orderAddresses: z
        .lazy(() => OrderAddressCreateNestedManyWithoutOrderInputSchema)
        .optional(),
      orderPromotions: z
        .lazy(() => OrderPromotionCreateNestedManyWithoutOrderInputSchema)
        .optional(),
      payments: z
        .lazy(() => PaymentCreateNestedManyWithoutOrderInputSchema)
        .optional(),
    })
    .strict() as z.ZodType<Prisma.OrderCreateWithoutUserInput>;

export const OrderUncheckedCreateWithoutUserInputSchema: z.ZodType<Prisma.OrderUncheckedCreateWithoutUserInput> =
  z
    .object({
      id: z.string().uuid().optional(),
      orderNumber: z.string(),
      status: z.lazy(() => OrderStatusSchema).optional(),
      subtotal: z
        .union([
          z.number(),
          z.string(),
          z.instanceof(Decimal),
          z.instanceof(Prisma.Decimal),
          DecimalJsLikeSchema,
        ])
        .refine((v) => isValidDecimalInput(v), {
          message: 'Must be a Decimal',
        }),
      taxAmount: z
        .union([
          z.number(),
          z.string(),
          z.instanceof(Decimal),
          z.instanceof(Prisma.Decimal),
          DecimalJsLikeSchema,
        ])
        .refine((v) => isValidDecimalInput(v), { message: 'Must be a Decimal' })
        .optional(),
      shippingAmount: z
        .union([
          z.number(),
          z.string(),
          z.instanceof(Decimal),
          z.instanceof(Prisma.Decimal),
          DecimalJsLikeSchema,
        ])
        .refine((v) => isValidDecimalInput(v), { message: 'Must be a Decimal' })
        .optional(),
      discountAmount: z
        .union([
          z.number(),
          z.string(),
          z.instanceof(Decimal),
          z.instanceof(Prisma.Decimal),
          DecimalJsLikeSchema,
        ])
        .refine((v) => isValidDecimalInput(v), { message: 'Must be a Decimal' })
        .optional(),
      totalAmount: z
        .union([
          z.number(),
          z.string(),
          z.instanceof(Decimal),
          z.instanceof(Prisma.Decimal),
          DecimalJsLikeSchema,
        ])
        .refine((v) => isValidDecimalInput(v), {
          message: 'Must be a Decimal',
        }),
      currency: z.string().optional(),
      notes: z.string().optional().nullable(),
      shippedAt: z.coerce.date().optional().nullable(),
      deliveredAt: z.coerce.date().optional().nullable(),
      createdAt: z.coerce.date().optional(),
      createdBy: z.string().optional().nullable(),
      updatedAt: z.coerce.date().optional(),
      deletedAt: z.coerce.date().optional().nullable(),
      orderItems: z
        .lazy(() => OrderItemUncheckedCreateNestedManyWithoutOrderInputSchema)
        .optional(),
      orderAddresses: z
        .lazy(
          () => OrderAddressUncheckedCreateNestedManyWithoutOrderInputSchema,
        )
        .optional(),
      orderPromotions: z
        .lazy(
          () => OrderPromotionUncheckedCreateNestedManyWithoutOrderInputSchema,
        )
        .optional(),
      payments: z
        .lazy(() => PaymentUncheckedCreateNestedManyWithoutOrderInputSchema)
        .optional(),
    })
    .strict() as z.ZodType<Prisma.OrderUncheckedCreateWithoutUserInput>;

export const OrderCreateOrConnectWithoutUserInputSchema: z.ZodType<Prisma.OrderCreateOrConnectWithoutUserInput> =
  z
    .object({
      where: z.lazy(() => OrderWhereUniqueInputSchema),
      create: z.union([
        z.lazy(() => OrderCreateWithoutUserInputSchema),
        z.lazy(() => OrderUncheckedCreateWithoutUserInputSchema),
      ]),
    })
    .strict() as z.ZodType<Prisma.OrderCreateOrConnectWithoutUserInput>;

export const OrderCreateManyUserInputEnvelopeSchema: z.ZodType<Prisma.OrderCreateManyUserInputEnvelope> =
  z
    .object({
      data: z.union([
        z.lazy(() => OrderCreateManyUserInputSchema),
        z.lazy(() => OrderCreateManyUserInputSchema).array(),
      ]),
      skipDuplicates: z.boolean().optional(),
    })
    .strict() as z.ZodType<Prisma.OrderCreateManyUserInputEnvelope>;

export const CartCreateWithoutUserInputSchema: z.ZodType<Prisma.CartCreateWithoutUserInput> =
  z
    .object({
      id: z.string().uuid().optional(),
      createdAt: z.coerce.date().optional(),
      updatedAt: z.coerce.date().optional(),
      cartItems: z
        .lazy(() => CartItemCreateNestedManyWithoutCartInputSchema)
        .optional(),
    })
    .strict() as z.ZodType<Prisma.CartCreateWithoutUserInput>;

export const CartUncheckedCreateWithoutUserInputSchema: z.ZodType<Prisma.CartUncheckedCreateWithoutUserInput> =
  z
    .object({
      id: z.string().uuid().optional(),
      createdAt: z.coerce.date().optional(),
      updatedAt: z.coerce.date().optional(),
      cartItems: z
        .lazy(() => CartItemUncheckedCreateNestedManyWithoutCartInputSchema)
        .optional(),
    })
    .strict() as z.ZodType<Prisma.CartUncheckedCreateWithoutUserInput>;

export const CartCreateOrConnectWithoutUserInputSchema: z.ZodType<Prisma.CartCreateOrConnectWithoutUserInput> =
  z
    .object({
      where: z.lazy(() => CartWhereUniqueInputSchema),
      create: z.union([
        z.lazy(() => CartCreateWithoutUserInputSchema),
        z.lazy(() => CartUncheckedCreateWithoutUserInputSchema),
      ]),
    })
    .strict() as z.ZodType<Prisma.CartCreateOrConnectWithoutUserInput>;

export const NotificationCreateWithoutUserInputSchema: z.ZodType<Prisma.NotificationCreateWithoutUserInput> =
  z
    .object({
      id: z.string().uuid().optional(),
      title: z.string(),
      message: z.string(),
      isRead: z.boolean().optional(),
    })
    .strict() as z.ZodType<Prisma.NotificationCreateWithoutUserInput>;

export const NotificationUncheckedCreateWithoutUserInputSchema: z.ZodType<Prisma.NotificationUncheckedCreateWithoutUserInput> =
  z
    .object({
      id: z.string().uuid().optional(),
      title: z.string(),
      message: z.string(),
      isRead: z.boolean().optional(),
    })
    .strict() as z.ZodType<Prisma.NotificationUncheckedCreateWithoutUserInput>;

export const NotificationCreateOrConnectWithoutUserInputSchema: z.ZodType<Prisma.NotificationCreateOrConnectWithoutUserInput> =
  z
    .object({
      where: z.lazy(() => NotificationWhereUniqueInputSchema),
      create: z.union([
        z.lazy(() => NotificationCreateWithoutUserInputSchema),
        z.lazy(() => NotificationUncheckedCreateWithoutUserInputSchema),
      ]),
    })
    .strict() as z.ZodType<Prisma.NotificationCreateOrConnectWithoutUserInput>;

export const NotificationCreateManyUserInputEnvelopeSchema: z.ZodType<Prisma.NotificationCreateManyUserInputEnvelope> =
  z
    .object({
      data: z.union([
        z.lazy(() => NotificationCreateManyUserInputSchema),
        z.lazy(() => NotificationCreateManyUserInputSchema).array(),
      ]),
      skipDuplicates: z.boolean().optional(),
    })
    .strict() as z.ZodType<Prisma.NotificationCreateManyUserInputEnvelope>;

export const VendorUpsertWithWhereUniqueWithoutUserInputSchema: z.ZodType<Prisma.VendorUpsertWithWhereUniqueWithoutUserInput> =
  z
    .object({
      where: z.lazy(() => VendorWhereUniqueInputSchema),
      update: z.union([
        z.lazy(() => VendorUpdateWithoutUserInputSchema),
        z.lazy(() => VendorUncheckedUpdateWithoutUserInputSchema),
      ]),
      create: z.union([
        z.lazy(() => VendorCreateWithoutUserInputSchema),
        z.lazy(() => VendorUncheckedCreateWithoutUserInputSchema),
      ]),
    })
    .strict() as z.ZodType<Prisma.VendorUpsertWithWhereUniqueWithoutUserInput>;

export const VendorUpdateWithWhereUniqueWithoutUserInputSchema: z.ZodType<Prisma.VendorUpdateWithWhereUniqueWithoutUserInput> =
  z
    .object({
      where: z.lazy(() => VendorWhereUniqueInputSchema),
      data: z.union([
        z.lazy(() => VendorUpdateWithoutUserInputSchema),
        z.lazy(() => VendorUncheckedUpdateWithoutUserInputSchema),
      ]),
    })
    .strict() as z.ZodType<Prisma.VendorUpdateWithWhereUniqueWithoutUserInput>;

export const VendorUpdateManyWithWhereWithoutUserInputSchema: z.ZodType<Prisma.VendorUpdateManyWithWhereWithoutUserInput> =
  z
    .object({
      where: z.lazy(() => VendorScalarWhereInputSchema),
      data: z.union([
        z.lazy(() => VendorUpdateManyMutationInputSchema),
        z.lazy(() => VendorUncheckedUpdateManyWithoutUserInputSchema),
      ]),
    })
    .strict() as z.ZodType<Prisma.VendorUpdateManyWithWhereWithoutUserInput>;

export const VendorScalarWhereInputSchema: z.ZodType<Prisma.VendorScalarWhereInput> =
  z
    .object({
      AND: z
        .union([
          z.lazy(() => VendorScalarWhereInputSchema),
          z.lazy(() => VendorScalarWhereInputSchema).array(),
        ])
        .optional(),
      OR: z
        .lazy(() => VendorScalarWhereInputSchema)
        .array()
        .optional(),
      NOT: z
        .union([
          z.lazy(() => VendorScalarWhereInputSchema),
          z.lazy(() => VendorScalarWhereInputSchema).array(),
        ])
        .optional(),
      id: z.union([z.lazy(() => StringFilterSchema), z.string()]).optional(),
      userID: z
        .union([z.lazy(() => StringFilterSchema), z.string()])
        .optional(),
      name: z.union([z.lazy(() => StringFilterSchema), z.string()]).optional(),
      slug: z.union([z.lazy(() => StringFilterSchema), z.string()]).optional(),
      description: z
        .union([z.lazy(() => StringNullableFilterSchema), z.string()])
        .optional()
        .nullable(),
      logoUrl: z
        .union([z.lazy(() => StringNullableFilterSchema), z.string()])
        .optional()
        .nullable(),
      taxCode: z
        .union([z.lazy(() => StringNullableFilterSchema), z.string()])
        .optional()
        .nullable(),
      totalProducts: z
        .union([z.lazy(() => IntFilterSchema), z.number()])
        .optional(),
      totalOrders: z
        .union([z.lazy(() => IntFilterSchema), z.number()])
        .optional(),
      status: z
        .union([
          z.lazy(() => EnumVendorStatusFilterSchema),
          z.lazy(() => VendorStatusSchema),
        ])
        .optional(),
      createdAt: z
        .union([z.lazy(() => DateTimeFilterSchema), z.coerce.date()])
        .optional(),
      createdBy: z
        .union([z.lazy(() => StringNullableFilterSchema), z.string()])
        .optional()
        .nullable(),
      updatedAt: z
        .union([z.lazy(() => DateTimeFilterSchema), z.coerce.date()])
        .optional(),
      deletedAt: z
        .union([z.lazy(() => DateTimeNullableFilterSchema), z.coerce.date()])
        .optional()
        .nullable(),
    })
    .strict() as z.ZodType<Prisma.VendorScalarWhereInput>;

export const UserVendorRoleUpsertWithWhereUniqueWithoutUserInputSchema: z.ZodType<Prisma.UserVendorRoleUpsertWithWhereUniqueWithoutUserInput> =
  z
    .object({
      where: z.lazy(() => UserVendorRoleWhereUniqueInputSchema),
      update: z.union([
        z.lazy(() => UserVendorRoleUpdateWithoutUserInputSchema),
        z.lazy(() => UserVendorRoleUncheckedUpdateWithoutUserInputSchema),
      ]),
      create: z.union([
        z.lazy(() => UserVendorRoleCreateWithoutUserInputSchema),
        z.lazy(() => UserVendorRoleUncheckedCreateWithoutUserInputSchema),
      ]),
    })
    .strict() as z.ZodType<Prisma.UserVendorRoleUpsertWithWhereUniqueWithoutUserInput>;

export const UserVendorRoleUpdateWithWhereUniqueWithoutUserInputSchema: z.ZodType<Prisma.UserVendorRoleUpdateWithWhereUniqueWithoutUserInput> =
  z
    .object({
      where: z.lazy(() => UserVendorRoleWhereUniqueInputSchema),
      data: z.union([
        z.lazy(() => UserVendorRoleUpdateWithoutUserInputSchema),
        z.lazy(() => UserVendorRoleUncheckedUpdateWithoutUserInputSchema),
      ]),
    })
    .strict() as z.ZodType<Prisma.UserVendorRoleUpdateWithWhereUniqueWithoutUserInput>;

export const UserVendorRoleUpdateManyWithWhereWithoutUserInputSchema: z.ZodType<Prisma.UserVendorRoleUpdateManyWithWhereWithoutUserInput> =
  z
    .object({
      where: z.lazy(() => UserVendorRoleScalarWhereInputSchema),
      data: z.union([
        z.lazy(() => UserVendorRoleUpdateManyMutationInputSchema),
        z.lazy(() => UserVendorRoleUncheckedUpdateManyWithoutUserInputSchema),
      ]),
    })
    .strict() as z.ZodType<Prisma.UserVendorRoleUpdateManyWithWhereWithoutUserInput>;

export const UserVendorRoleScalarWhereInputSchema: z.ZodType<Prisma.UserVendorRoleScalarWhereInput> =
  z
    .object({
      AND: z
        .union([
          z.lazy(() => UserVendorRoleScalarWhereInputSchema),
          z.lazy(() => UserVendorRoleScalarWhereInputSchema).array(),
        ])
        .optional(),
      OR: z
        .lazy(() => UserVendorRoleScalarWhereInputSchema)
        .array()
        .optional(),
      NOT: z
        .union([
          z.lazy(() => UserVendorRoleScalarWhereInputSchema),
          z.lazy(() => UserVendorRoleScalarWhereInputSchema).array(),
        ])
        .optional(),
      id: z.union([z.lazy(() => StringFilterSchema), z.string()]).optional(),
      userID: z
        .union([z.lazy(() => StringFilterSchema), z.string()])
        .optional(),
      vendorID: z
        .union([z.lazy(() => StringFilterSchema), z.string()])
        .optional(),
      roleID: z
        .union([z.lazy(() => StringFilterSchema), z.string()])
        .optional(),
      status: z
        .union([
          z.lazy(() => EnumUserVendorRoleStatusFilterSchema),
          z.lazy(() => UserVendorRoleStatusSchema),
        ])
        .optional(),
      createdAt: z
        .union([z.lazy(() => DateTimeFilterSchema), z.coerce.date()])
        .optional(),
      createdBy: z
        .union([z.lazy(() => StringNullableFilterSchema), z.string()])
        .optional()
        .nullable(),
    })
    .strict() as z.ZodType<Prisma.UserVendorRoleScalarWhereInput>;

export const OrderUpsertWithWhereUniqueWithoutUserInputSchema: z.ZodType<Prisma.OrderUpsertWithWhereUniqueWithoutUserInput> =
  z
    .object({
      where: z.lazy(() => OrderWhereUniqueInputSchema),
      update: z.union([
        z.lazy(() => OrderUpdateWithoutUserInputSchema),
        z.lazy(() => OrderUncheckedUpdateWithoutUserInputSchema),
      ]),
      create: z.union([
        z.lazy(() => OrderCreateWithoutUserInputSchema),
        z.lazy(() => OrderUncheckedCreateWithoutUserInputSchema),
      ]),
    })
    .strict() as z.ZodType<Prisma.OrderUpsertWithWhereUniqueWithoutUserInput>;

export const OrderUpdateWithWhereUniqueWithoutUserInputSchema: z.ZodType<Prisma.OrderUpdateWithWhereUniqueWithoutUserInput> =
  z
    .object({
      where: z.lazy(() => OrderWhereUniqueInputSchema),
      data: z.union([
        z.lazy(() => OrderUpdateWithoutUserInputSchema),
        z.lazy(() => OrderUncheckedUpdateWithoutUserInputSchema),
      ]),
    })
    .strict() as z.ZodType<Prisma.OrderUpdateWithWhereUniqueWithoutUserInput>;

export const OrderUpdateManyWithWhereWithoutUserInputSchema: z.ZodType<Prisma.OrderUpdateManyWithWhereWithoutUserInput> =
  z
    .object({
      where: z.lazy(() => OrderScalarWhereInputSchema),
      data: z.union([
        z.lazy(() => OrderUpdateManyMutationInputSchema),
        z.lazy(() => OrderUncheckedUpdateManyWithoutUserInputSchema),
      ]),
    })
    .strict() as z.ZodType<Prisma.OrderUpdateManyWithWhereWithoutUserInput>;

export const OrderScalarWhereInputSchema: z.ZodType<Prisma.OrderScalarWhereInput> =
  z
    .object({
      AND: z
        .union([
          z.lazy(() => OrderScalarWhereInputSchema),
          z.lazy(() => OrderScalarWhereInputSchema).array(),
        ])
        .optional(),
      OR: z
        .lazy(() => OrderScalarWhereInputSchema)
        .array()
        .optional(),
      NOT: z
        .union([
          z.lazy(() => OrderScalarWhereInputSchema),
          z.lazy(() => OrderScalarWhereInputSchema).array(),
        ])
        .optional(),
      id: z.union([z.lazy(() => StringFilterSchema), z.string()]).optional(),
      orderNumber: z
        .union([z.lazy(() => StringFilterSchema), z.string()])
        .optional(),
      userID: z
        .union([z.lazy(() => StringFilterSchema), z.string()])
        .optional(),
      status: z
        .union([
          z.lazy(() => EnumOrderStatusFilterSchema),
          z.lazy(() => OrderStatusSchema),
        ])
        .optional(),
      subtotal: z
        .union([
          z.lazy(() => DecimalFilterSchema),
          z
            .union([
              z.number(),
              z.string(),
              z.instanceof(Decimal),
              z.instanceof(Prisma.Decimal),
              DecimalJsLikeSchema,
            ])
            .refine((v) => isValidDecimalInput(v), {
              message: 'Must be a Decimal',
            }),
        ])
        .optional(),
      taxAmount: z
        .union([
          z.lazy(() => DecimalFilterSchema),
          z
            .union([
              z.number(),
              z.string(),
              z.instanceof(Decimal),
              z.instanceof(Prisma.Decimal),
              DecimalJsLikeSchema,
            ])
            .refine((v) => isValidDecimalInput(v), {
              message: 'Must be a Decimal',
            }),
        ])
        .optional(),
      shippingAmount: z
        .union([
          z.lazy(() => DecimalFilterSchema),
          z
            .union([
              z.number(),
              z.string(),
              z.instanceof(Decimal),
              z.instanceof(Prisma.Decimal),
              DecimalJsLikeSchema,
            ])
            .refine((v) => isValidDecimalInput(v), {
              message: 'Must be a Decimal',
            }),
        ])
        .optional(),
      discountAmount: z
        .union([
          z.lazy(() => DecimalFilterSchema),
          z
            .union([
              z.number(),
              z.string(),
              z.instanceof(Decimal),
              z.instanceof(Prisma.Decimal),
              DecimalJsLikeSchema,
            ])
            .refine((v) => isValidDecimalInput(v), {
              message: 'Must be a Decimal',
            }),
        ])
        .optional(),
      totalAmount: z
        .union([
          z.lazy(() => DecimalFilterSchema),
          z
            .union([
              z.number(),
              z.string(),
              z.instanceof(Decimal),
              z.instanceof(Prisma.Decimal),
              DecimalJsLikeSchema,
            ])
            .refine((v) => isValidDecimalInput(v), {
              message: 'Must be a Decimal',
            }),
        ])
        .optional(),
      currency: z
        .union([z.lazy(() => StringFilterSchema), z.string()])
        .optional(),
      notes: z
        .union([z.lazy(() => StringNullableFilterSchema), z.string()])
        .optional()
        .nullable(),
      shippedAt: z
        .union([z.lazy(() => DateTimeNullableFilterSchema), z.coerce.date()])
        .optional()
        .nullable(),
      deliveredAt: z
        .union([z.lazy(() => DateTimeNullableFilterSchema), z.coerce.date()])
        .optional()
        .nullable(),
      createdAt: z
        .union([z.lazy(() => DateTimeFilterSchema), z.coerce.date()])
        .optional(),
      createdBy: z
        .union([z.lazy(() => StringNullableFilterSchema), z.string()])
        .optional()
        .nullable(),
      updatedAt: z
        .union([z.lazy(() => DateTimeFilterSchema), z.coerce.date()])
        .optional(),
      deletedAt: z
        .union([z.lazy(() => DateTimeNullableFilterSchema), z.coerce.date()])
        .optional()
        .nullable(),
    })
    .strict() as z.ZodType<Prisma.OrderScalarWhereInput>;

export const CartUpsertWithoutUserInputSchema: z.ZodType<Prisma.CartUpsertWithoutUserInput> =
  z
    .object({
      update: z.union([
        z.lazy(() => CartUpdateWithoutUserInputSchema),
        z.lazy(() => CartUncheckedUpdateWithoutUserInputSchema),
      ]),
      create: z.union([
        z.lazy(() => CartCreateWithoutUserInputSchema),
        z.lazy(() => CartUncheckedCreateWithoutUserInputSchema),
      ]),
      where: z.lazy(() => CartWhereInputSchema).optional(),
    })
    .strict() as z.ZodType<Prisma.CartUpsertWithoutUserInput>;

export const CartUpdateToOneWithWhereWithoutUserInputSchema: z.ZodType<Prisma.CartUpdateToOneWithWhereWithoutUserInput> =
  z
    .object({
      where: z.lazy(() => CartWhereInputSchema).optional(),
      data: z.union([
        z.lazy(() => CartUpdateWithoutUserInputSchema),
        z.lazy(() => CartUncheckedUpdateWithoutUserInputSchema),
      ]),
    })
    .strict() as z.ZodType<Prisma.CartUpdateToOneWithWhereWithoutUserInput>;

export const CartUpdateWithoutUserInputSchema: z.ZodType<Prisma.CartUpdateWithoutUserInput> =
  z
    .object({
      id: z
        .union([
          z.string().uuid(),
          z.lazy(() => StringFieldUpdateOperationsInputSchema),
        ])
        .optional(),
      createdAt: z
        .union([
          z.coerce.date(),
          z.lazy(() => DateTimeFieldUpdateOperationsInputSchema),
        ])
        .optional(),
      updatedAt: z
        .union([
          z.coerce.date(),
          z.lazy(() => DateTimeFieldUpdateOperationsInputSchema),
        ])
        .optional(),
      cartItems: z
        .lazy(() => CartItemUpdateManyWithoutCartNestedInputSchema)
        .optional(),
    })
    .strict() as z.ZodType<Prisma.CartUpdateWithoutUserInput>;

export const CartUncheckedUpdateWithoutUserInputSchema: z.ZodType<Prisma.CartUncheckedUpdateWithoutUserInput> =
  z
    .object({
      id: z
        .union([
          z.string().uuid(),
          z.lazy(() => StringFieldUpdateOperationsInputSchema),
        ])
        .optional(),
      createdAt: z
        .union([
          z.coerce.date(),
          z.lazy(() => DateTimeFieldUpdateOperationsInputSchema),
        ])
        .optional(),
      updatedAt: z
        .union([
          z.coerce.date(),
          z.lazy(() => DateTimeFieldUpdateOperationsInputSchema),
        ])
        .optional(),
      cartItems: z
        .lazy(() => CartItemUncheckedUpdateManyWithoutCartNestedInputSchema)
        .optional(),
    })
    .strict() as z.ZodType<Prisma.CartUncheckedUpdateWithoutUserInput>;

export const NotificationUpsertWithWhereUniqueWithoutUserInputSchema: z.ZodType<Prisma.NotificationUpsertWithWhereUniqueWithoutUserInput> =
  z
    .object({
      where: z.lazy(() => NotificationWhereUniqueInputSchema),
      update: z.union([
        z.lazy(() => NotificationUpdateWithoutUserInputSchema),
        z.lazy(() => NotificationUncheckedUpdateWithoutUserInputSchema),
      ]),
      create: z.union([
        z.lazy(() => NotificationCreateWithoutUserInputSchema),
        z.lazy(() => NotificationUncheckedCreateWithoutUserInputSchema),
      ]),
    })
    .strict() as z.ZodType<Prisma.NotificationUpsertWithWhereUniqueWithoutUserInput>;

export const NotificationUpdateWithWhereUniqueWithoutUserInputSchema: z.ZodType<Prisma.NotificationUpdateWithWhereUniqueWithoutUserInput> =
  z
    .object({
      where: z.lazy(() => NotificationWhereUniqueInputSchema),
      data: z.union([
        z.lazy(() => NotificationUpdateWithoutUserInputSchema),
        z.lazy(() => NotificationUncheckedUpdateWithoutUserInputSchema),
      ]),
    })
    .strict() as z.ZodType<Prisma.NotificationUpdateWithWhereUniqueWithoutUserInput>;

export const NotificationUpdateManyWithWhereWithoutUserInputSchema: z.ZodType<Prisma.NotificationUpdateManyWithWhereWithoutUserInput> =
  z
    .object({
      where: z.lazy(() => NotificationScalarWhereInputSchema),
      data: z.union([
        z.lazy(() => NotificationUpdateManyMutationInputSchema),
        z.lazy(() => NotificationUncheckedUpdateManyWithoutUserInputSchema),
      ]),
    })
    .strict() as z.ZodType<Prisma.NotificationUpdateManyWithWhereWithoutUserInput>;

export const NotificationScalarWhereInputSchema: z.ZodType<Prisma.NotificationScalarWhereInput> =
  z
    .object({
      AND: z
        .union([
          z.lazy(() => NotificationScalarWhereInputSchema),
          z.lazy(() => NotificationScalarWhereInputSchema).array(),
        ])
        .optional(),
      OR: z
        .lazy(() => NotificationScalarWhereInputSchema)
        .array()
        .optional(),
      NOT: z
        .union([
          z.lazy(() => NotificationScalarWhereInputSchema),
          z.lazy(() => NotificationScalarWhereInputSchema).array(),
        ])
        .optional(),
      id: z.union([z.lazy(() => StringFilterSchema), z.string()]).optional(),
      userID: z
        .union([z.lazy(() => StringFilterSchema), z.string()])
        .optional(),
      title: z.union([z.lazy(() => StringFilterSchema), z.string()]).optional(),
      message: z
        .union([z.lazy(() => StringFilterSchema), z.string()])
        .optional(),
      isRead: z.union([z.lazy(() => BoolFilterSchema), z.boolean()]).optional(),
    })
    .strict() as z.ZodType<Prisma.NotificationScalarWhereInput>;

export const UserCreateWithoutVendorsInputSchema: z.ZodType<Prisma.UserCreateWithoutVendorsInput> =
  z
    .object({
      id: z.string().uuid().optional(),
      email: z.string().email(),
      password: z.string(),
      firstName: z.string(),
      lastName: z.string().optional().nullable(),
      fullAddress: z.string(),
      city: z.string().optional().nullable(),
      province: z.string().optional().nullable(),
      country: z.string().optional().nullable(),
      phone: z.string().optional().nullable(),
      status: z.lazy(() => UserStatusSchema).optional(),
      createdAt: z.coerce.date().optional(),
      createdBy: z.string().optional().nullable(),
      updatedAt: z.coerce.date().optional(),
      deletedAt: z.coerce.date().optional().nullable(),
      userVendorRoles: z
        .lazy(() => UserVendorRoleCreateNestedManyWithoutUserInputSchema)
        .optional(),
      orders: z
        .lazy(() => OrderCreateNestedManyWithoutUserInputSchema)
        .optional(),
      cart: z.lazy(() => CartCreateNestedOneWithoutUserInputSchema).optional(),
      notifications: z
        .lazy(() => NotificationCreateNestedManyWithoutUserInputSchema)
        .optional(),
    })
    .strict() as z.ZodType<Prisma.UserCreateWithoutVendorsInput>;

export const UserUncheckedCreateWithoutVendorsInputSchema: z.ZodType<Prisma.UserUncheckedCreateWithoutVendorsInput> =
  z
    .object({
      id: z.string().uuid().optional(),
      email: z.string().email(),
      password: z.string(),
      firstName: z.string(),
      lastName: z.string().optional().nullable(),
      fullAddress: z.string(),
      city: z.string().optional().nullable(),
      province: z.string().optional().nullable(),
      country: z.string().optional().nullable(),
      phone: z.string().optional().nullable(),
      status: z.lazy(() => UserStatusSchema).optional(),
      createdAt: z.coerce.date().optional(),
      createdBy: z.string().optional().nullable(),
      updatedAt: z.coerce.date().optional(),
      deletedAt: z.coerce.date().optional().nullable(),
      userVendorRoles: z
        .lazy(
          () => UserVendorRoleUncheckedCreateNestedManyWithoutUserInputSchema,
        )
        .optional(),
      orders: z
        .lazy(() => OrderUncheckedCreateNestedManyWithoutUserInputSchema)
        .optional(),
      cart: z
        .lazy(() => CartUncheckedCreateNestedOneWithoutUserInputSchema)
        .optional(),
      notifications: z
        .lazy(() => NotificationUncheckedCreateNestedManyWithoutUserInputSchema)
        .optional(),
    })
    .strict() as z.ZodType<Prisma.UserUncheckedCreateWithoutVendorsInput>;

export const UserCreateOrConnectWithoutVendorsInputSchema: z.ZodType<Prisma.UserCreateOrConnectWithoutVendorsInput> =
  z
    .object({
      where: z.lazy(() => UserWhereUniqueInputSchema),
      create: z.union([
        z.lazy(() => UserCreateWithoutVendorsInputSchema),
        z.lazy(() => UserUncheckedCreateWithoutVendorsInputSchema),
      ]),
    })
    .strict() as z.ZodType<Prisma.UserCreateOrConnectWithoutVendorsInput>;

export const ProductCreateWithoutVendorInputSchema: z.ZodType<Prisma.ProductCreateWithoutVendorInput> =
  z
    .object({
      id: z.string().uuid().optional(),
      name: z.string(),
      slug: z.string(),
      description: z.string().optional().nullable(),
      sku: z.string().optional().nullable(),
      price: z
        .union([
          z.number(),
          z.string(),
          z.instanceof(Decimal),
          z.instanceof(Prisma.Decimal),
          DecimalJsLikeSchema,
        ])
        .refine((v) => isValidDecimalInput(v), {
          message: 'Must be a Decimal',
        }),
      stockQuantity: z.number().int().optional(),
      status: z.lazy(() => ProductStatusSchema).optional(),
      createdAt: z.coerce.date().optional(),
      createdBy: z.string().optional().nullable(),
      updatedAt: z.coerce.date().optional(),
      deletedAt: z.coerce.date().optional().nullable(),
      productCategories: z
        .lazy(() => ProductCategoryCreateNestedManyWithoutProductInputSchema)
        .optional(),
      productImages: z
        .lazy(() => ProductImageCreateNestedManyWithoutProductInputSchema)
        .optional(),
      productVariants: z
        .lazy(() => ProductVariantCreateNestedManyWithoutProductInputSchema)
        .optional(),
    })
    .strict() as z.ZodType<Prisma.ProductCreateWithoutVendorInput>;

export const ProductUncheckedCreateWithoutVendorInputSchema: z.ZodType<Prisma.ProductUncheckedCreateWithoutVendorInput> =
  z
    .object({
      id: z.string().uuid().optional(),
      name: z.string(),
      slug: z.string(),
      description: z.string().optional().nullable(),
      sku: z.string().optional().nullable(),
      price: z
        .union([
          z.number(),
          z.string(),
          z.instanceof(Decimal),
          z.instanceof(Prisma.Decimal),
          DecimalJsLikeSchema,
        ])
        .refine((v) => isValidDecimalInput(v), {
          message: 'Must be a Decimal',
        }),
      stockQuantity: z.number().int().optional(),
      status: z.lazy(() => ProductStatusSchema).optional(),
      createdAt: z.coerce.date().optional(),
      createdBy: z.string().optional().nullable(),
      updatedAt: z.coerce.date().optional(),
      deletedAt: z.coerce.date().optional().nullable(),
      productCategories: z
        .lazy(
          () =>
            ProductCategoryUncheckedCreateNestedManyWithoutProductInputSchema,
        )
        .optional(),
      productImages: z
        .lazy(
          () => ProductImageUncheckedCreateNestedManyWithoutProductInputSchema,
        )
        .optional(),
      productVariants: z
        .lazy(
          () =>
            ProductVariantUncheckedCreateNestedManyWithoutProductInputSchema,
        )
        .optional(),
    })
    .strict() as z.ZodType<Prisma.ProductUncheckedCreateWithoutVendorInput>;

export const ProductCreateOrConnectWithoutVendorInputSchema: z.ZodType<Prisma.ProductCreateOrConnectWithoutVendorInput> =
  z
    .object({
      where: z.lazy(() => ProductWhereUniqueInputSchema),
      create: z.union([
        z.lazy(() => ProductCreateWithoutVendorInputSchema),
        z.lazy(() => ProductUncheckedCreateWithoutVendorInputSchema),
      ]),
    })
    .strict() as z.ZodType<Prisma.ProductCreateOrConnectWithoutVendorInput>;

export const ProductCreateManyVendorInputEnvelopeSchema: z.ZodType<Prisma.ProductCreateManyVendorInputEnvelope> =
  z
    .object({
      data: z.union([
        z.lazy(() => ProductCreateManyVendorInputSchema),
        z.lazy(() => ProductCreateManyVendorInputSchema).array(),
      ]),
      skipDuplicates: z.boolean().optional(),
    })
    .strict() as z.ZodType<Prisma.ProductCreateManyVendorInputEnvelope>;

export const UserVendorRoleCreateWithoutVendorInputSchema: z.ZodType<Prisma.UserVendorRoleCreateWithoutVendorInput> =
  z
    .object({
      id: z.string().uuid().optional(),
      status: z.lazy(() => UserVendorRoleStatusSchema).optional(),
      createdAt: z.coerce.date().optional(),
      createdBy: z.string().optional().nullable(),
      user: z.lazy(() => UserCreateNestedOneWithoutUserVendorRolesInputSchema),
      role: z.lazy(() => RoleCreateNestedOneWithoutUserVendorRolesInputSchema),
    })
    .strict() as z.ZodType<Prisma.UserVendorRoleCreateWithoutVendorInput>;

export const UserVendorRoleUncheckedCreateWithoutVendorInputSchema: z.ZodType<Prisma.UserVendorRoleUncheckedCreateWithoutVendorInput> =
  z
    .object({
      id: z.string().uuid().optional(),
      userID: z.string(),
      roleID: z.string(),
      status: z.lazy(() => UserVendorRoleStatusSchema).optional(),
      createdAt: z.coerce.date().optional(),
      createdBy: z.string().optional().nullable(),
    })
    .strict() as z.ZodType<Prisma.UserVendorRoleUncheckedCreateWithoutVendorInput>;

export const UserVendorRoleCreateOrConnectWithoutVendorInputSchema: z.ZodType<Prisma.UserVendorRoleCreateOrConnectWithoutVendorInput> =
  z
    .object({
      where: z.lazy(() => UserVendorRoleWhereUniqueInputSchema),
      create: z.union([
        z.lazy(() => UserVendorRoleCreateWithoutVendorInputSchema),
        z.lazy(() => UserVendorRoleUncheckedCreateWithoutVendorInputSchema),
      ]),
    })
    .strict() as z.ZodType<Prisma.UserVendorRoleCreateOrConnectWithoutVendorInput>;

export const UserVendorRoleCreateManyVendorInputEnvelopeSchema: z.ZodType<Prisma.UserVendorRoleCreateManyVendorInputEnvelope> =
  z
    .object({
      data: z.union([
        z.lazy(() => UserVendorRoleCreateManyVendorInputSchema),
        z.lazy(() => UserVendorRoleCreateManyVendorInputSchema).array(),
      ]),
      skipDuplicates: z.boolean().optional(),
    })
    .strict() as z.ZodType<Prisma.UserVendorRoleCreateManyVendorInputEnvelope>;

export const UserUpsertWithoutVendorsInputSchema: z.ZodType<Prisma.UserUpsertWithoutVendorsInput> =
  z
    .object({
      update: z.union([
        z.lazy(() => UserUpdateWithoutVendorsInputSchema),
        z.lazy(() => UserUncheckedUpdateWithoutVendorsInputSchema),
      ]),
      create: z.union([
        z.lazy(() => UserCreateWithoutVendorsInputSchema),
        z.lazy(() => UserUncheckedCreateWithoutVendorsInputSchema),
      ]),
      where: z.lazy(() => UserWhereInputSchema).optional(),
    })
    .strict() as z.ZodType<Prisma.UserUpsertWithoutVendorsInput>;

export const UserUpdateToOneWithWhereWithoutVendorsInputSchema: z.ZodType<Prisma.UserUpdateToOneWithWhereWithoutVendorsInput> =
  z
    .object({
      where: z.lazy(() => UserWhereInputSchema).optional(),
      data: z.union([
        z.lazy(() => UserUpdateWithoutVendorsInputSchema),
        z.lazy(() => UserUncheckedUpdateWithoutVendorsInputSchema),
      ]),
    })
    .strict() as z.ZodType<Prisma.UserUpdateToOneWithWhereWithoutVendorsInput>;

export const UserUpdateWithoutVendorsInputSchema: z.ZodType<Prisma.UserUpdateWithoutVendorsInput> =
  z
    .object({
      id: z
        .union([
          z.string().uuid(),
          z.lazy(() => StringFieldUpdateOperationsInputSchema),
        ])
        .optional(),
      email: z
        .union([
          z.string().email(),
          z.lazy(() => StringFieldUpdateOperationsInputSchema),
        ])
        .optional(),
      password: z
        .union([
          z.string(),
          z.lazy(() => StringFieldUpdateOperationsInputSchema),
        ])
        .optional(),
      firstName: z
        .union([
          z.string(),
          z.lazy(() => StringFieldUpdateOperationsInputSchema),
        ])
        .optional(),
      lastName: z
        .union([
          z.string(),
          z.lazy(() => NullableStringFieldUpdateOperationsInputSchema),
        ])
        .optional()
        .nullable(),
      fullAddress: z
        .union([
          z.string(),
          z.lazy(() => StringFieldUpdateOperationsInputSchema),
        ])
        .optional(),
      city: z
        .union([
          z.string(),
          z.lazy(() => NullableStringFieldUpdateOperationsInputSchema),
        ])
        .optional()
        .nullable(),
      province: z
        .union([
          z.string(),
          z.lazy(() => NullableStringFieldUpdateOperationsInputSchema),
        ])
        .optional()
        .nullable(),
      country: z
        .union([
          z.string(),
          z.lazy(() => NullableStringFieldUpdateOperationsInputSchema),
        ])
        .optional()
        .nullable(),
      phone: z
        .union([
          z.string(),
          z.lazy(() => NullableStringFieldUpdateOperationsInputSchema),
        ])
        .optional()
        .nullable(),
      status: z
        .union([
          z.lazy(() => UserStatusSchema),
          z.lazy(() => EnumUserStatusFieldUpdateOperationsInputSchema),
        ])
        .optional(),
      createdAt: z
        .union([
          z.coerce.date(),
          z.lazy(() => DateTimeFieldUpdateOperationsInputSchema),
        ])
        .optional(),
      createdBy: z
        .union([
          z.string(),
          z.lazy(() => NullableStringFieldUpdateOperationsInputSchema),
        ])
        .optional()
        .nullable(),
      updatedAt: z
        .union([
          z.coerce.date(),
          z.lazy(() => DateTimeFieldUpdateOperationsInputSchema),
        ])
        .optional(),
      deletedAt: z
        .union([
          z.coerce.date(),
          z.lazy(() => NullableDateTimeFieldUpdateOperationsInputSchema),
        ])
        .optional()
        .nullable(),
      userVendorRoles: z
        .lazy(() => UserVendorRoleUpdateManyWithoutUserNestedInputSchema)
        .optional(),
      orders: z
        .lazy(() => OrderUpdateManyWithoutUserNestedInputSchema)
        .optional(),
      cart: z.lazy(() => CartUpdateOneWithoutUserNestedInputSchema).optional(),
      notifications: z
        .lazy(() => NotificationUpdateManyWithoutUserNestedInputSchema)
        .optional(),
    })
    .strict() as z.ZodType<Prisma.UserUpdateWithoutVendorsInput>;

export const UserUncheckedUpdateWithoutVendorsInputSchema: z.ZodType<Prisma.UserUncheckedUpdateWithoutVendorsInput> =
  z
    .object({
      id: z
        .union([
          z.string().uuid(),
          z.lazy(() => StringFieldUpdateOperationsInputSchema),
        ])
        .optional(),
      email: z
        .union([
          z.string().email(),
          z.lazy(() => StringFieldUpdateOperationsInputSchema),
        ])
        .optional(),
      password: z
        .union([
          z.string(),
          z.lazy(() => StringFieldUpdateOperationsInputSchema),
        ])
        .optional(),
      firstName: z
        .union([
          z.string(),
          z.lazy(() => StringFieldUpdateOperationsInputSchema),
        ])
        .optional(),
      lastName: z
        .union([
          z.string(),
          z.lazy(() => NullableStringFieldUpdateOperationsInputSchema),
        ])
        .optional()
        .nullable(),
      fullAddress: z
        .union([
          z.string(),
          z.lazy(() => StringFieldUpdateOperationsInputSchema),
        ])
        .optional(),
      city: z
        .union([
          z.string(),
          z.lazy(() => NullableStringFieldUpdateOperationsInputSchema),
        ])
        .optional()
        .nullable(),
      province: z
        .union([
          z.string(),
          z.lazy(() => NullableStringFieldUpdateOperationsInputSchema),
        ])
        .optional()
        .nullable(),
      country: z
        .union([
          z.string(),
          z.lazy(() => NullableStringFieldUpdateOperationsInputSchema),
        ])
        .optional()
        .nullable(),
      phone: z
        .union([
          z.string(),
          z.lazy(() => NullableStringFieldUpdateOperationsInputSchema),
        ])
        .optional()
        .nullable(),
      status: z
        .union([
          z.lazy(() => UserStatusSchema),
          z.lazy(() => EnumUserStatusFieldUpdateOperationsInputSchema),
        ])
        .optional(),
      createdAt: z
        .union([
          z.coerce.date(),
          z.lazy(() => DateTimeFieldUpdateOperationsInputSchema),
        ])
        .optional(),
      createdBy: z
        .union([
          z.string(),
          z.lazy(() => NullableStringFieldUpdateOperationsInputSchema),
        ])
        .optional()
        .nullable(),
      updatedAt: z
        .union([
          z.coerce.date(),
          z.lazy(() => DateTimeFieldUpdateOperationsInputSchema),
        ])
        .optional(),
      deletedAt: z
        .union([
          z.coerce.date(),
          z.lazy(() => NullableDateTimeFieldUpdateOperationsInputSchema),
        ])
        .optional()
        .nullable(),
      userVendorRoles: z
        .lazy(
          () => UserVendorRoleUncheckedUpdateManyWithoutUserNestedInputSchema,
        )
        .optional(),
      orders: z
        .lazy(() => OrderUncheckedUpdateManyWithoutUserNestedInputSchema)
        .optional(),
      cart: z
        .lazy(() => CartUncheckedUpdateOneWithoutUserNestedInputSchema)
        .optional(),
      notifications: z
        .lazy(() => NotificationUncheckedUpdateManyWithoutUserNestedInputSchema)
        .optional(),
    })
    .strict() as z.ZodType<Prisma.UserUncheckedUpdateWithoutVendorsInput>;

export const ProductUpsertWithWhereUniqueWithoutVendorInputSchema: z.ZodType<Prisma.ProductUpsertWithWhereUniqueWithoutVendorInput> =
  z
    .object({
      where: z.lazy(() => ProductWhereUniqueInputSchema),
      update: z.union([
        z.lazy(() => ProductUpdateWithoutVendorInputSchema),
        z.lazy(() => ProductUncheckedUpdateWithoutVendorInputSchema),
      ]),
      create: z.union([
        z.lazy(() => ProductCreateWithoutVendorInputSchema),
        z.lazy(() => ProductUncheckedCreateWithoutVendorInputSchema),
      ]),
    })
    .strict() as z.ZodType<Prisma.ProductUpsertWithWhereUniqueWithoutVendorInput>;

export const ProductUpdateWithWhereUniqueWithoutVendorInputSchema: z.ZodType<Prisma.ProductUpdateWithWhereUniqueWithoutVendorInput> =
  z
    .object({
      where: z.lazy(() => ProductWhereUniqueInputSchema),
      data: z.union([
        z.lazy(() => ProductUpdateWithoutVendorInputSchema),
        z.lazy(() => ProductUncheckedUpdateWithoutVendorInputSchema),
      ]),
    })
    .strict() as z.ZodType<Prisma.ProductUpdateWithWhereUniqueWithoutVendorInput>;

export const ProductUpdateManyWithWhereWithoutVendorInputSchema: z.ZodType<Prisma.ProductUpdateManyWithWhereWithoutVendorInput> =
  z
    .object({
      where: z.lazy(() => ProductScalarWhereInputSchema),
      data: z.union([
        z.lazy(() => ProductUpdateManyMutationInputSchema),
        z.lazy(() => ProductUncheckedUpdateManyWithoutVendorInputSchema),
      ]),
    })
    .strict() as z.ZodType<Prisma.ProductUpdateManyWithWhereWithoutVendorInput>;

export const ProductScalarWhereInputSchema: z.ZodType<Prisma.ProductScalarWhereInput> =
  z
    .object({
      AND: z
        .union([
          z.lazy(() => ProductScalarWhereInputSchema),
          z.lazy(() => ProductScalarWhereInputSchema).array(),
        ])
        .optional(),
      OR: z
        .lazy(() => ProductScalarWhereInputSchema)
        .array()
        .optional(),
      NOT: z
        .union([
          z.lazy(() => ProductScalarWhereInputSchema),
          z.lazy(() => ProductScalarWhereInputSchema).array(),
        ])
        .optional(),
      id: z.union([z.lazy(() => StringFilterSchema), z.string()]).optional(),
      vendorID: z
        .union([z.lazy(() => StringFilterSchema), z.string()])
        .optional(),
      name: z.union([z.lazy(() => StringFilterSchema), z.string()]).optional(),
      slug: z.union([z.lazy(() => StringFilterSchema), z.string()]).optional(),
      description: z
        .union([z.lazy(() => StringNullableFilterSchema), z.string()])
        .optional()
        .nullable(),
      sku: z
        .union([z.lazy(() => StringNullableFilterSchema), z.string()])
        .optional()
        .nullable(),
      price: z
        .union([
          z.lazy(() => DecimalFilterSchema),
          z
            .union([
              z.number(),
              z.string(),
              z.instanceof(Decimal),
              z.instanceof(Prisma.Decimal),
              DecimalJsLikeSchema,
            ])
            .refine((v) => isValidDecimalInput(v), {
              message: 'Must be a Decimal',
            }),
        ])
        .optional(),
      stockQuantity: z
        .union([z.lazy(() => IntFilterSchema), z.number()])
        .optional(),
      status: z
        .union([
          z.lazy(() => EnumProductStatusFilterSchema),
          z.lazy(() => ProductStatusSchema),
        ])
        .optional(),
      createdAt: z
        .union([z.lazy(() => DateTimeFilterSchema), z.coerce.date()])
        .optional(),
      createdBy: z
        .union([z.lazy(() => StringNullableFilterSchema), z.string()])
        .optional()
        .nullable(),
      updatedAt: z
        .union([z.lazy(() => DateTimeFilterSchema), z.coerce.date()])
        .optional(),
      deletedAt: z
        .union([z.lazy(() => DateTimeNullableFilterSchema), z.coerce.date()])
        .optional()
        .nullable(),
    })
    .strict() as z.ZodType<Prisma.ProductScalarWhereInput>;

export const UserVendorRoleUpsertWithWhereUniqueWithoutVendorInputSchema: z.ZodType<Prisma.UserVendorRoleUpsertWithWhereUniqueWithoutVendorInput> =
  z
    .object({
      where: z.lazy(() => UserVendorRoleWhereUniqueInputSchema),
      update: z.union([
        z.lazy(() => UserVendorRoleUpdateWithoutVendorInputSchema),
        z.lazy(() => UserVendorRoleUncheckedUpdateWithoutVendorInputSchema),
      ]),
      create: z.union([
        z.lazy(() => UserVendorRoleCreateWithoutVendorInputSchema),
        z.lazy(() => UserVendorRoleUncheckedCreateWithoutVendorInputSchema),
      ]),
    })
    .strict() as z.ZodType<Prisma.UserVendorRoleUpsertWithWhereUniqueWithoutVendorInput>;

export const UserVendorRoleUpdateWithWhereUniqueWithoutVendorInputSchema: z.ZodType<Prisma.UserVendorRoleUpdateWithWhereUniqueWithoutVendorInput> =
  z
    .object({
      where: z.lazy(() => UserVendorRoleWhereUniqueInputSchema),
      data: z.union([
        z.lazy(() => UserVendorRoleUpdateWithoutVendorInputSchema),
        z.lazy(() => UserVendorRoleUncheckedUpdateWithoutVendorInputSchema),
      ]),
    })
    .strict() as z.ZodType<Prisma.UserVendorRoleUpdateWithWhereUniqueWithoutVendorInput>;

export const UserVendorRoleUpdateManyWithWhereWithoutVendorInputSchema: z.ZodType<Prisma.UserVendorRoleUpdateManyWithWhereWithoutVendorInput> =
  z
    .object({
      where: z.lazy(() => UserVendorRoleScalarWhereInputSchema),
      data: z.union([
        z.lazy(() => UserVendorRoleUpdateManyMutationInputSchema),
        z.lazy(() => UserVendorRoleUncheckedUpdateManyWithoutVendorInputSchema),
      ]),
    })
    .strict() as z.ZodType<Prisma.UserVendorRoleUpdateManyWithWhereWithoutVendorInput>;

export const UserVendorRoleCreateWithoutRoleInputSchema: z.ZodType<Prisma.UserVendorRoleCreateWithoutRoleInput> =
  z
    .object({
      id: z.string().uuid().optional(),
      status: z.lazy(() => UserVendorRoleStatusSchema).optional(),
      createdAt: z.coerce.date().optional(),
      createdBy: z.string().optional().nullable(),
      user: z.lazy(() => UserCreateNestedOneWithoutUserVendorRolesInputSchema),
      vendor: z.lazy(
        () => VendorCreateNestedOneWithoutUserVendorRolesInputSchema,
      ),
    })
    .strict() as z.ZodType<Prisma.UserVendorRoleCreateWithoutRoleInput>;

export const UserVendorRoleUncheckedCreateWithoutRoleInputSchema: z.ZodType<Prisma.UserVendorRoleUncheckedCreateWithoutRoleInput> =
  z
    .object({
      id: z.string().uuid().optional(),
      userID: z.string(),
      vendorID: z.string(),
      status: z.lazy(() => UserVendorRoleStatusSchema).optional(),
      createdAt: z.coerce.date().optional(),
      createdBy: z.string().optional().nullable(),
    })
    .strict() as z.ZodType<Prisma.UserVendorRoleUncheckedCreateWithoutRoleInput>;

export const UserVendorRoleCreateOrConnectWithoutRoleInputSchema: z.ZodType<Prisma.UserVendorRoleCreateOrConnectWithoutRoleInput> =
  z
    .object({
      where: z.lazy(() => UserVendorRoleWhereUniqueInputSchema),
      create: z.union([
        z.lazy(() => UserVendorRoleCreateWithoutRoleInputSchema),
        z.lazy(() => UserVendorRoleUncheckedCreateWithoutRoleInputSchema),
      ]),
    })
    .strict() as z.ZodType<Prisma.UserVendorRoleCreateOrConnectWithoutRoleInput>;

export const UserVendorRoleCreateManyRoleInputEnvelopeSchema: z.ZodType<Prisma.UserVendorRoleCreateManyRoleInputEnvelope> =
  z
    .object({
      data: z.union([
        z.lazy(() => UserVendorRoleCreateManyRoleInputSchema),
        z.lazy(() => UserVendorRoleCreateManyRoleInputSchema).array(),
      ]),
      skipDuplicates: z.boolean().optional(),
    })
    .strict() as z.ZodType<Prisma.UserVendorRoleCreateManyRoleInputEnvelope>;

export const RolePermissionCreateWithoutRoleInputSchema: z.ZodType<Prisma.RolePermissionCreateWithoutRoleInput> =
  z
    .object({
      createdAt: z.coerce.date().optional(),
      createdBy: z.string().optional().nullable(),
      permission: z.lazy(
        () => PermissionCreateNestedOneWithoutRolePermissionsInputSchema,
      ),
    })
    .strict() as z.ZodType<Prisma.RolePermissionCreateWithoutRoleInput>;

export const RolePermissionUncheckedCreateWithoutRoleInputSchema: z.ZodType<Prisma.RolePermissionUncheckedCreateWithoutRoleInput> =
  z
    .object({
      permissionID: z.string(),
      createdAt: z.coerce.date().optional(),
      createdBy: z.string().optional().nullable(),
    })
    .strict() as z.ZodType<Prisma.RolePermissionUncheckedCreateWithoutRoleInput>;

export const RolePermissionCreateOrConnectWithoutRoleInputSchema: z.ZodType<Prisma.RolePermissionCreateOrConnectWithoutRoleInput> =
  z
    .object({
      where: z.lazy(() => RolePermissionWhereUniqueInputSchema),
      create: z.union([
        z.lazy(() => RolePermissionCreateWithoutRoleInputSchema),
        z.lazy(() => RolePermissionUncheckedCreateWithoutRoleInputSchema),
      ]),
    })
    .strict() as z.ZodType<Prisma.RolePermissionCreateOrConnectWithoutRoleInput>;

export const RolePermissionCreateManyRoleInputEnvelopeSchema: z.ZodType<Prisma.RolePermissionCreateManyRoleInputEnvelope> =
  z
    .object({
      data: z.union([
        z.lazy(() => RolePermissionCreateManyRoleInputSchema),
        z.lazy(() => RolePermissionCreateManyRoleInputSchema).array(),
      ]),
      skipDuplicates: z.boolean().optional(),
    })
    .strict() as z.ZodType<Prisma.RolePermissionCreateManyRoleInputEnvelope>;

export const UserVendorRoleUpsertWithWhereUniqueWithoutRoleInputSchema: z.ZodType<Prisma.UserVendorRoleUpsertWithWhereUniqueWithoutRoleInput> =
  z
    .object({
      where: z.lazy(() => UserVendorRoleWhereUniqueInputSchema),
      update: z.union([
        z.lazy(() => UserVendorRoleUpdateWithoutRoleInputSchema),
        z.lazy(() => UserVendorRoleUncheckedUpdateWithoutRoleInputSchema),
      ]),
      create: z.union([
        z.lazy(() => UserVendorRoleCreateWithoutRoleInputSchema),
        z.lazy(() => UserVendorRoleUncheckedCreateWithoutRoleInputSchema),
      ]),
    })
    .strict() as z.ZodType<Prisma.UserVendorRoleUpsertWithWhereUniqueWithoutRoleInput>;

export const UserVendorRoleUpdateWithWhereUniqueWithoutRoleInputSchema: z.ZodType<Prisma.UserVendorRoleUpdateWithWhereUniqueWithoutRoleInput> =
  z
    .object({
      where: z.lazy(() => UserVendorRoleWhereUniqueInputSchema),
      data: z.union([
        z.lazy(() => UserVendorRoleUpdateWithoutRoleInputSchema),
        z.lazy(() => UserVendorRoleUncheckedUpdateWithoutRoleInputSchema),
      ]),
    })
    .strict() as z.ZodType<Prisma.UserVendorRoleUpdateWithWhereUniqueWithoutRoleInput>;

export const UserVendorRoleUpdateManyWithWhereWithoutRoleInputSchema: z.ZodType<Prisma.UserVendorRoleUpdateManyWithWhereWithoutRoleInput> =
  z
    .object({
      where: z.lazy(() => UserVendorRoleScalarWhereInputSchema),
      data: z.union([
        z.lazy(() => UserVendorRoleUpdateManyMutationInputSchema),
        z.lazy(() => UserVendorRoleUncheckedUpdateManyWithoutRoleInputSchema),
      ]),
    })
    .strict() as z.ZodType<Prisma.UserVendorRoleUpdateManyWithWhereWithoutRoleInput>;

export const RolePermissionUpsertWithWhereUniqueWithoutRoleInputSchema: z.ZodType<Prisma.RolePermissionUpsertWithWhereUniqueWithoutRoleInput> =
  z
    .object({
      where: z.lazy(() => RolePermissionWhereUniqueInputSchema),
      update: z.union([
        z.lazy(() => RolePermissionUpdateWithoutRoleInputSchema),
        z.lazy(() => RolePermissionUncheckedUpdateWithoutRoleInputSchema),
      ]),
      create: z.union([
        z.lazy(() => RolePermissionCreateWithoutRoleInputSchema),
        z.lazy(() => RolePermissionUncheckedCreateWithoutRoleInputSchema),
      ]),
    })
    .strict() as z.ZodType<Prisma.RolePermissionUpsertWithWhereUniqueWithoutRoleInput>;

export const RolePermissionUpdateWithWhereUniqueWithoutRoleInputSchema: z.ZodType<Prisma.RolePermissionUpdateWithWhereUniqueWithoutRoleInput> =
  z
    .object({
      where: z.lazy(() => RolePermissionWhereUniqueInputSchema),
      data: z.union([
        z.lazy(() => RolePermissionUpdateWithoutRoleInputSchema),
        z.lazy(() => RolePermissionUncheckedUpdateWithoutRoleInputSchema),
      ]),
    })
    .strict() as z.ZodType<Prisma.RolePermissionUpdateWithWhereUniqueWithoutRoleInput>;

export const RolePermissionUpdateManyWithWhereWithoutRoleInputSchema: z.ZodType<Prisma.RolePermissionUpdateManyWithWhereWithoutRoleInput> =
  z
    .object({
      where: z.lazy(() => RolePermissionScalarWhereInputSchema),
      data: z.union([
        z.lazy(() => RolePermissionUpdateManyMutationInputSchema),
        z.lazy(() => RolePermissionUncheckedUpdateManyWithoutRoleInputSchema),
      ]),
    })
    .strict() as z.ZodType<Prisma.RolePermissionUpdateManyWithWhereWithoutRoleInput>;

export const RolePermissionScalarWhereInputSchema: z.ZodType<Prisma.RolePermissionScalarWhereInput> =
  z
    .object({
      AND: z
        .union([
          z.lazy(() => RolePermissionScalarWhereInputSchema),
          z.lazy(() => RolePermissionScalarWhereInputSchema).array(),
        ])
        .optional(),
      OR: z
        .lazy(() => RolePermissionScalarWhereInputSchema)
        .array()
        .optional(),
      NOT: z
        .union([
          z.lazy(() => RolePermissionScalarWhereInputSchema),
          z.lazy(() => RolePermissionScalarWhereInputSchema).array(),
        ])
        .optional(),
      roleID: z
        .union([z.lazy(() => StringFilterSchema), z.string()])
        .optional(),
      permissionID: z
        .union([z.lazy(() => StringFilterSchema), z.string()])
        .optional(),
      createdAt: z
        .union([z.lazy(() => DateTimeFilterSchema), z.coerce.date()])
        .optional(),
      createdBy: z
        .union([z.lazy(() => StringNullableFilterSchema), z.string()])
        .optional()
        .nullable(),
    })
    .strict() as z.ZodType<Prisma.RolePermissionScalarWhereInput>;

export const RolePermissionCreateWithoutPermissionInputSchema: z.ZodType<Prisma.RolePermissionCreateWithoutPermissionInput> =
  z
    .object({
      createdAt: z.coerce.date().optional(),
      createdBy: z.string().optional().nullable(),
      role: z.lazy(() => RoleCreateNestedOneWithoutRolePermissionsInputSchema),
    })
    .strict() as z.ZodType<Prisma.RolePermissionCreateWithoutPermissionInput>;

export const RolePermissionUncheckedCreateWithoutPermissionInputSchema: z.ZodType<Prisma.RolePermissionUncheckedCreateWithoutPermissionInput> =
  z
    .object({
      roleID: z.string(),
      createdAt: z.coerce.date().optional(),
      createdBy: z.string().optional().nullable(),
    })
    .strict() as z.ZodType<Prisma.RolePermissionUncheckedCreateWithoutPermissionInput>;

export const RolePermissionCreateOrConnectWithoutPermissionInputSchema: z.ZodType<Prisma.RolePermissionCreateOrConnectWithoutPermissionInput> =
  z
    .object({
      where: z.lazy(() => RolePermissionWhereUniqueInputSchema),
      create: z.union([
        z.lazy(() => RolePermissionCreateWithoutPermissionInputSchema),
        z.lazy(() => RolePermissionUncheckedCreateWithoutPermissionInputSchema),
      ]),
    })
    .strict() as z.ZodType<Prisma.RolePermissionCreateOrConnectWithoutPermissionInput>;

export const RolePermissionCreateManyPermissionInputEnvelopeSchema: z.ZodType<Prisma.RolePermissionCreateManyPermissionInputEnvelope> =
  z
    .object({
      data: z.union([
        z.lazy(() => RolePermissionCreateManyPermissionInputSchema),
        z.lazy(() => RolePermissionCreateManyPermissionInputSchema).array(),
      ]),
      skipDuplicates: z.boolean().optional(),
    })
    .strict() as z.ZodType<Prisma.RolePermissionCreateManyPermissionInputEnvelope>;

export const RolePermissionUpsertWithWhereUniqueWithoutPermissionInputSchema: z.ZodType<Prisma.RolePermissionUpsertWithWhereUniqueWithoutPermissionInput> =
  z
    .object({
      where: z.lazy(() => RolePermissionWhereUniqueInputSchema),
      update: z.union([
        z.lazy(() => RolePermissionUpdateWithoutPermissionInputSchema),
        z.lazy(() => RolePermissionUncheckedUpdateWithoutPermissionInputSchema),
      ]),
      create: z.union([
        z.lazy(() => RolePermissionCreateWithoutPermissionInputSchema),
        z.lazy(() => RolePermissionUncheckedCreateWithoutPermissionInputSchema),
      ]),
    })
    .strict() as z.ZodType<Prisma.RolePermissionUpsertWithWhereUniqueWithoutPermissionInput>;

export const RolePermissionUpdateWithWhereUniqueWithoutPermissionInputSchema: z.ZodType<Prisma.RolePermissionUpdateWithWhereUniqueWithoutPermissionInput> =
  z
    .object({
      where: z.lazy(() => RolePermissionWhereUniqueInputSchema),
      data: z.union([
        z.lazy(() => RolePermissionUpdateWithoutPermissionInputSchema),
        z.lazy(() => RolePermissionUncheckedUpdateWithoutPermissionInputSchema),
      ]),
    })
    .strict() as z.ZodType<Prisma.RolePermissionUpdateWithWhereUniqueWithoutPermissionInput>;

export const RolePermissionUpdateManyWithWhereWithoutPermissionInputSchema: z.ZodType<Prisma.RolePermissionUpdateManyWithWhereWithoutPermissionInput> =
  z
    .object({
      where: z.lazy(() => RolePermissionScalarWhereInputSchema),
      data: z.union([
        z.lazy(() => RolePermissionUpdateManyMutationInputSchema),
        z.lazy(
          () => RolePermissionUncheckedUpdateManyWithoutPermissionInputSchema,
        ),
      ]),
    })
    .strict() as z.ZodType<Prisma.RolePermissionUpdateManyWithWhereWithoutPermissionInput>;

export const RoleCreateWithoutRolePermissionsInputSchema: z.ZodType<Prisma.RoleCreateWithoutRolePermissionsInput> =
  z
    .object({
      id: z.string().uuid().optional(),
      name: z.string(),
      description: z.string().optional().nullable(),
      isSystemRole: z.boolean().optional(),
      createdAt: z.coerce.date().optional(),
      createdBy: z.string().optional().nullable(),
      updatedAt: z.coerce.date().optional(),
      deletedAt: z.coerce.date().optional().nullable(),
      userVendorRoles: z
        .lazy(() => UserVendorRoleCreateNestedManyWithoutRoleInputSchema)
        .optional(),
    })
    .strict() as z.ZodType<Prisma.RoleCreateWithoutRolePermissionsInput>;

export const RoleUncheckedCreateWithoutRolePermissionsInputSchema: z.ZodType<Prisma.RoleUncheckedCreateWithoutRolePermissionsInput> =
  z
    .object({
      id: z.string().uuid().optional(),
      name: z.string(),
      description: z.string().optional().nullable(),
      isSystemRole: z.boolean().optional(),
      createdAt: z.coerce.date().optional(),
      createdBy: z.string().optional().nullable(),
      updatedAt: z.coerce.date().optional(),
      deletedAt: z.coerce.date().optional().nullable(),
      userVendorRoles: z
        .lazy(
          () => UserVendorRoleUncheckedCreateNestedManyWithoutRoleInputSchema,
        )
        .optional(),
    })
    .strict() as z.ZodType<Prisma.RoleUncheckedCreateWithoutRolePermissionsInput>;

export const RoleCreateOrConnectWithoutRolePermissionsInputSchema: z.ZodType<Prisma.RoleCreateOrConnectWithoutRolePermissionsInput> =
  z
    .object({
      where: z.lazy(() => RoleWhereUniqueInputSchema),
      create: z.union([
        z.lazy(() => RoleCreateWithoutRolePermissionsInputSchema),
        z.lazy(() => RoleUncheckedCreateWithoutRolePermissionsInputSchema),
      ]),
    })
    .strict() as z.ZodType<Prisma.RoleCreateOrConnectWithoutRolePermissionsInput>;

export const PermissionCreateWithoutRolePermissionsInputSchema: z.ZodType<Prisma.PermissionCreateWithoutRolePermissionsInput> =
  z
    .object({
      id: z.string().uuid().optional(),
      name: z.string(),
      description: z.string().optional().nullable(),
      key: z
        .string()
        .describe(
          'Pattern: [/resource]_[action], e.g: [/product]_[read], [/product]_[create], [/product]_[manage]',
        ),
      isSystemPermission: z.boolean().optional(),
      createdAt: z.coerce.date().optional(),
      createdBy: z.string().optional().nullable(),
      updatedAt: z.coerce.date().optional(),
      deletedAt: z.coerce.date().optional().nullable(),
    })
    .strict() as z.ZodType<Prisma.PermissionCreateWithoutRolePermissionsInput>;

export const PermissionUncheckedCreateWithoutRolePermissionsInputSchema: z.ZodType<Prisma.PermissionUncheckedCreateWithoutRolePermissionsInput> =
  z
    .object({
      id: z.string().uuid().optional(),
      name: z.string(),
      description: z.string().optional().nullable(),
      key: z
        .string()
        .describe(
          'Pattern: [/resource]_[action], e.g: [/product]_[read], [/product]_[create], [/product]_[manage]',
        ),
      isSystemPermission: z.boolean().optional(),
      createdAt: z.coerce.date().optional(),
      createdBy: z.string().optional().nullable(),
      updatedAt: z.coerce.date().optional(),
      deletedAt: z.coerce.date().optional().nullable(),
    })
    .strict() as z.ZodType<Prisma.PermissionUncheckedCreateWithoutRolePermissionsInput>;

export const PermissionCreateOrConnectWithoutRolePermissionsInputSchema: z.ZodType<Prisma.PermissionCreateOrConnectWithoutRolePermissionsInput> =
  z
    .object({
      where: z.lazy(() => PermissionWhereUniqueInputSchema),
      create: z.union([
        z.lazy(() => PermissionCreateWithoutRolePermissionsInputSchema),
        z.lazy(
          () => PermissionUncheckedCreateWithoutRolePermissionsInputSchema,
        ),
      ]),
    })
    .strict() as z.ZodType<Prisma.PermissionCreateOrConnectWithoutRolePermissionsInput>;

export const RoleUpsertWithoutRolePermissionsInputSchema: z.ZodType<Prisma.RoleUpsertWithoutRolePermissionsInput> =
  z
    .object({
      update: z.union([
        z.lazy(() => RoleUpdateWithoutRolePermissionsInputSchema),
        z.lazy(() => RoleUncheckedUpdateWithoutRolePermissionsInputSchema),
      ]),
      create: z.union([
        z.lazy(() => RoleCreateWithoutRolePermissionsInputSchema),
        z.lazy(() => RoleUncheckedCreateWithoutRolePermissionsInputSchema),
      ]),
      where: z.lazy(() => RoleWhereInputSchema).optional(),
    })
    .strict() as z.ZodType<Prisma.RoleUpsertWithoutRolePermissionsInput>;

export const RoleUpdateToOneWithWhereWithoutRolePermissionsInputSchema: z.ZodType<Prisma.RoleUpdateToOneWithWhereWithoutRolePermissionsInput> =
  z
    .object({
      where: z.lazy(() => RoleWhereInputSchema).optional(),
      data: z.union([
        z.lazy(() => RoleUpdateWithoutRolePermissionsInputSchema),
        z.lazy(() => RoleUncheckedUpdateWithoutRolePermissionsInputSchema),
      ]),
    })
    .strict() as z.ZodType<Prisma.RoleUpdateToOneWithWhereWithoutRolePermissionsInput>;

export const RoleUpdateWithoutRolePermissionsInputSchema: z.ZodType<Prisma.RoleUpdateWithoutRolePermissionsInput> =
  z
    .object({
      id: z
        .union([
          z.string().uuid(),
          z.lazy(() => StringFieldUpdateOperationsInputSchema),
        ])
        .optional(),
      name: z
        .union([
          z.string(),
          z.lazy(() => StringFieldUpdateOperationsInputSchema),
        ])
        .optional(),
      description: z
        .union([
          z.string(),
          z.lazy(() => NullableStringFieldUpdateOperationsInputSchema),
        ])
        .optional()
        .nullable(),
      isSystemRole: z
        .union([
          z.boolean(),
          z.lazy(() => BoolFieldUpdateOperationsInputSchema),
        ])
        .optional(),
      createdAt: z
        .union([
          z.coerce.date(),
          z.lazy(() => DateTimeFieldUpdateOperationsInputSchema),
        ])
        .optional(),
      createdBy: z
        .union([
          z.string(),
          z.lazy(() => NullableStringFieldUpdateOperationsInputSchema),
        ])
        .optional()
        .nullable(),
      updatedAt: z
        .union([
          z.coerce.date(),
          z.lazy(() => DateTimeFieldUpdateOperationsInputSchema),
        ])
        .optional(),
      deletedAt: z
        .union([
          z.coerce.date(),
          z.lazy(() => NullableDateTimeFieldUpdateOperationsInputSchema),
        ])
        .optional()
        .nullable(),
      userVendorRoles: z
        .lazy(() => UserVendorRoleUpdateManyWithoutRoleNestedInputSchema)
        .optional(),
    })
    .strict() as z.ZodType<Prisma.RoleUpdateWithoutRolePermissionsInput>;

export const RoleUncheckedUpdateWithoutRolePermissionsInputSchema: z.ZodType<Prisma.RoleUncheckedUpdateWithoutRolePermissionsInput> =
  z
    .object({
      id: z
        .union([
          z.string().uuid(),
          z.lazy(() => StringFieldUpdateOperationsInputSchema),
        ])
        .optional(),
      name: z
        .union([
          z.string(),
          z.lazy(() => StringFieldUpdateOperationsInputSchema),
        ])
        .optional(),
      description: z
        .union([
          z.string(),
          z.lazy(() => NullableStringFieldUpdateOperationsInputSchema),
        ])
        .optional()
        .nullable(),
      isSystemRole: z
        .union([
          z.boolean(),
          z.lazy(() => BoolFieldUpdateOperationsInputSchema),
        ])
        .optional(),
      createdAt: z
        .union([
          z.coerce.date(),
          z.lazy(() => DateTimeFieldUpdateOperationsInputSchema),
        ])
        .optional(),
      createdBy: z
        .union([
          z.string(),
          z.lazy(() => NullableStringFieldUpdateOperationsInputSchema),
        ])
        .optional()
        .nullable(),
      updatedAt: z
        .union([
          z.coerce.date(),
          z.lazy(() => DateTimeFieldUpdateOperationsInputSchema),
        ])
        .optional(),
      deletedAt: z
        .union([
          z.coerce.date(),
          z.lazy(() => NullableDateTimeFieldUpdateOperationsInputSchema),
        ])
        .optional()
        .nullable(),
      userVendorRoles: z
        .lazy(
          () => UserVendorRoleUncheckedUpdateManyWithoutRoleNestedInputSchema,
        )
        .optional(),
    })
    .strict() as z.ZodType<Prisma.RoleUncheckedUpdateWithoutRolePermissionsInput>;

export const PermissionUpsertWithoutRolePermissionsInputSchema: z.ZodType<Prisma.PermissionUpsertWithoutRolePermissionsInput> =
  z
    .object({
      update: z.union([
        z.lazy(() => PermissionUpdateWithoutRolePermissionsInputSchema),
        z.lazy(
          () => PermissionUncheckedUpdateWithoutRolePermissionsInputSchema,
        ),
      ]),
      create: z.union([
        z.lazy(() => PermissionCreateWithoutRolePermissionsInputSchema),
        z.lazy(
          () => PermissionUncheckedCreateWithoutRolePermissionsInputSchema,
        ),
      ]),
      where: z.lazy(() => PermissionWhereInputSchema).optional(),
    })
    .strict() as z.ZodType<Prisma.PermissionUpsertWithoutRolePermissionsInput>;

export const PermissionUpdateToOneWithWhereWithoutRolePermissionsInputSchema: z.ZodType<Prisma.PermissionUpdateToOneWithWhereWithoutRolePermissionsInput> =
  z
    .object({
      where: z.lazy(() => PermissionWhereInputSchema).optional(),
      data: z.union([
        z.lazy(() => PermissionUpdateWithoutRolePermissionsInputSchema),
        z.lazy(
          () => PermissionUncheckedUpdateWithoutRolePermissionsInputSchema,
        ),
      ]),
    })
    .strict() as z.ZodType<Prisma.PermissionUpdateToOneWithWhereWithoutRolePermissionsInput>;

export const PermissionUpdateWithoutRolePermissionsInputSchema: z.ZodType<Prisma.PermissionUpdateWithoutRolePermissionsInput> =
  z
    .object({
      id: z
        .union([
          z.string().uuid(),
          z.lazy(() => StringFieldUpdateOperationsInputSchema),
        ])
        .optional(),
      name: z
        .union([
          z.string(),
          z.lazy(() => StringFieldUpdateOperationsInputSchema),
        ])
        .optional(),
      description: z
        .union([
          z.string(),
          z.lazy(() => NullableStringFieldUpdateOperationsInputSchema),
        ])
        .optional()
        .nullable(),
      key: z
        .union([
          z
            .string()
            .describe(
              'Pattern: [/resource]_[action], e.g: [/product]_[read], [/product]_[create], [/product]_[manage]',
            ),
          z.lazy(() => StringFieldUpdateOperationsInputSchema),
        ])
        .optional(),
      isSystemPermission: z
        .union([
          z.boolean(),
          z.lazy(() => BoolFieldUpdateOperationsInputSchema),
        ])
        .optional(),
      createdAt: z
        .union([
          z.coerce.date(),
          z.lazy(() => DateTimeFieldUpdateOperationsInputSchema),
        ])
        .optional(),
      createdBy: z
        .union([
          z.string(),
          z.lazy(() => NullableStringFieldUpdateOperationsInputSchema),
        ])
        .optional()
        .nullable(),
      updatedAt: z
        .union([
          z.coerce.date(),
          z.lazy(() => DateTimeFieldUpdateOperationsInputSchema),
        ])
        .optional(),
      deletedAt: z
        .union([
          z.coerce.date(),
          z.lazy(() => NullableDateTimeFieldUpdateOperationsInputSchema),
        ])
        .optional()
        .nullable(),
    })
    .strict() as z.ZodType<Prisma.PermissionUpdateWithoutRolePermissionsInput>;

export const PermissionUncheckedUpdateWithoutRolePermissionsInputSchema: z.ZodType<Prisma.PermissionUncheckedUpdateWithoutRolePermissionsInput> =
  z
    .object({
      id: z
        .union([
          z.string().uuid(),
          z.lazy(() => StringFieldUpdateOperationsInputSchema),
        ])
        .optional(),
      name: z
        .union([
          z.string(),
          z.lazy(() => StringFieldUpdateOperationsInputSchema),
        ])
        .optional(),
      description: z
        .union([
          z.string(),
          z.lazy(() => NullableStringFieldUpdateOperationsInputSchema),
        ])
        .optional()
        .nullable(),
      key: z
        .union([
          z
            .string()
            .describe(
              'Pattern: [/resource]_[action], e.g: [/product]_[read], [/product]_[create], [/product]_[manage]',
            ),
          z.lazy(() => StringFieldUpdateOperationsInputSchema),
        ])
        .optional(),
      isSystemPermission: z
        .union([
          z.boolean(),
          z.lazy(() => BoolFieldUpdateOperationsInputSchema),
        ])
        .optional(),
      createdAt: z
        .union([
          z.coerce.date(),
          z.lazy(() => DateTimeFieldUpdateOperationsInputSchema),
        ])
        .optional(),
      createdBy: z
        .union([
          z.string(),
          z.lazy(() => NullableStringFieldUpdateOperationsInputSchema),
        ])
        .optional()
        .nullable(),
      updatedAt: z
        .union([
          z.coerce.date(),
          z.lazy(() => DateTimeFieldUpdateOperationsInputSchema),
        ])
        .optional(),
      deletedAt: z
        .union([
          z.coerce.date(),
          z.lazy(() => NullableDateTimeFieldUpdateOperationsInputSchema),
        ])
        .optional()
        .nullable(),
    })
    .strict() as z.ZodType<Prisma.PermissionUncheckedUpdateWithoutRolePermissionsInput>;

export const UserCreateWithoutUserVendorRolesInputSchema: z.ZodType<Prisma.UserCreateWithoutUserVendorRolesInput> =
  z
    .object({
      id: z.string().uuid().optional(),
      email: z.string().email(),
      password: z.string(),
      firstName: z.string(),
      lastName: z.string().optional().nullable(),
      fullAddress: z.string(),
      city: z.string().optional().nullable(),
      province: z.string().optional().nullable(),
      country: z.string().optional().nullable(),
      phone: z.string().optional().nullable(),
      status: z.lazy(() => UserStatusSchema).optional(),
      createdAt: z.coerce.date().optional(),
      createdBy: z.string().optional().nullable(),
      updatedAt: z.coerce.date().optional(),
      deletedAt: z.coerce.date().optional().nullable(),
      vendors: z
        .lazy(() => VendorCreateNestedManyWithoutUserInputSchema)
        .optional(),
      orders: z
        .lazy(() => OrderCreateNestedManyWithoutUserInputSchema)
        .optional(),
      cart: z.lazy(() => CartCreateNestedOneWithoutUserInputSchema).optional(),
      notifications: z
        .lazy(() => NotificationCreateNestedManyWithoutUserInputSchema)
        .optional(),
    })
    .strict() as z.ZodType<Prisma.UserCreateWithoutUserVendorRolesInput>;

export const UserUncheckedCreateWithoutUserVendorRolesInputSchema: z.ZodType<Prisma.UserUncheckedCreateWithoutUserVendorRolesInput> =
  z
    .object({
      id: z.string().uuid().optional(),
      email: z.string().email(),
      password: z.string(),
      firstName: z.string(),
      lastName: z.string().optional().nullable(),
      fullAddress: z.string(),
      city: z.string().optional().nullable(),
      province: z.string().optional().nullable(),
      country: z.string().optional().nullable(),
      phone: z.string().optional().nullable(),
      status: z.lazy(() => UserStatusSchema).optional(),
      createdAt: z.coerce.date().optional(),
      createdBy: z.string().optional().nullable(),
      updatedAt: z.coerce.date().optional(),
      deletedAt: z.coerce.date().optional().nullable(),
      vendors: z
        .lazy(() => VendorUncheckedCreateNestedManyWithoutUserInputSchema)
        .optional(),
      orders: z
        .lazy(() => OrderUncheckedCreateNestedManyWithoutUserInputSchema)
        .optional(),
      cart: z
        .lazy(() => CartUncheckedCreateNestedOneWithoutUserInputSchema)
        .optional(),
      notifications: z
        .lazy(() => NotificationUncheckedCreateNestedManyWithoutUserInputSchema)
        .optional(),
    })
    .strict() as z.ZodType<Prisma.UserUncheckedCreateWithoutUserVendorRolesInput>;

export const UserCreateOrConnectWithoutUserVendorRolesInputSchema: z.ZodType<Prisma.UserCreateOrConnectWithoutUserVendorRolesInput> =
  z
    .object({
      where: z.lazy(() => UserWhereUniqueInputSchema),
      create: z.union([
        z.lazy(() => UserCreateWithoutUserVendorRolesInputSchema),
        z.lazy(() => UserUncheckedCreateWithoutUserVendorRolesInputSchema),
      ]),
    })
    .strict() as z.ZodType<Prisma.UserCreateOrConnectWithoutUserVendorRolesInput>;

export const VendorCreateWithoutUserVendorRolesInputSchema: z.ZodType<Prisma.VendorCreateWithoutUserVendorRolesInput> =
  z
    .object({
      id: z.string().uuid().optional(),
      name: z.string(),
      slug: z.string(),
      description: z.string().optional().nullable(),
      logoUrl: z.string().optional().nullable(),
      taxCode: z.string().optional().nullable(),
      totalProducts: z.number().int().optional(),
      totalOrders: z.number().int().optional(),
      status: z.lazy(() => VendorStatusSchema).optional(),
      createdAt: z.coerce.date().optional(),
      createdBy: z.string().optional().nullable(),
      updatedAt: z.coerce.date().optional(),
      deletedAt: z.coerce.date().optional().nullable(),
      user: z.lazy(() => UserCreateNestedOneWithoutVendorsInputSchema),
      products: z
        .lazy(() => ProductCreateNestedManyWithoutVendorInputSchema)
        .optional(),
    })
    .strict() as z.ZodType<Prisma.VendorCreateWithoutUserVendorRolesInput>;

export const VendorUncheckedCreateWithoutUserVendorRolesInputSchema: z.ZodType<Prisma.VendorUncheckedCreateWithoutUserVendorRolesInput> =
  z
    .object({
      id: z.string().uuid().optional(),
      userID: z.string(),
      name: z.string(),
      slug: z.string(),
      description: z.string().optional().nullable(),
      logoUrl: z.string().optional().nullable(),
      taxCode: z.string().optional().nullable(),
      totalProducts: z.number().int().optional(),
      totalOrders: z.number().int().optional(),
      status: z.lazy(() => VendorStatusSchema).optional(),
      createdAt: z.coerce.date().optional(),
      createdBy: z.string().optional().nullable(),
      updatedAt: z.coerce.date().optional(),
      deletedAt: z.coerce.date().optional().nullable(),
      products: z
        .lazy(() => ProductUncheckedCreateNestedManyWithoutVendorInputSchema)
        .optional(),
    })
    .strict() as z.ZodType<Prisma.VendorUncheckedCreateWithoutUserVendorRolesInput>;

export const VendorCreateOrConnectWithoutUserVendorRolesInputSchema: z.ZodType<Prisma.VendorCreateOrConnectWithoutUserVendorRolesInput> =
  z
    .object({
      where: z.lazy(() => VendorWhereUniqueInputSchema),
      create: z.union([
        z.lazy(() => VendorCreateWithoutUserVendorRolesInputSchema),
        z.lazy(() => VendorUncheckedCreateWithoutUserVendorRolesInputSchema),
      ]),
    })
    .strict() as z.ZodType<Prisma.VendorCreateOrConnectWithoutUserVendorRolesInput>;

export const RoleCreateWithoutUserVendorRolesInputSchema: z.ZodType<Prisma.RoleCreateWithoutUserVendorRolesInput> =
  z
    .object({
      id: z.string().uuid().optional(),
      name: z.string(),
      description: z.string().optional().nullable(),
      isSystemRole: z.boolean().optional(),
      createdAt: z.coerce.date().optional(),
      createdBy: z.string().optional().nullable(),
      updatedAt: z.coerce.date().optional(),
      deletedAt: z.coerce.date().optional().nullable(),
      rolePermissions: z
        .lazy(() => RolePermissionCreateNestedManyWithoutRoleInputSchema)
        .optional(),
    })
    .strict() as z.ZodType<Prisma.RoleCreateWithoutUserVendorRolesInput>;

export const RoleUncheckedCreateWithoutUserVendorRolesInputSchema: z.ZodType<Prisma.RoleUncheckedCreateWithoutUserVendorRolesInput> =
  z
    .object({
      id: z.string().uuid().optional(),
      name: z.string(),
      description: z.string().optional().nullable(),
      isSystemRole: z.boolean().optional(),
      createdAt: z.coerce.date().optional(),
      createdBy: z.string().optional().nullable(),
      updatedAt: z.coerce.date().optional(),
      deletedAt: z.coerce.date().optional().nullable(),
      rolePermissions: z
        .lazy(
          () => RolePermissionUncheckedCreateNestedManyWithoutRoleInputSchema,
        )
        .optional(),
    })
    .strict() as z.ZodType<Prisma.RoleUncheckedCreateWithoutUserVendorRolesInput>;

export const RoleCreateOrConnectWithoutUserVendorRolesInputSchema: z.ZodType<Prisma.RoleCreateOrConnectWithoutUserVendorRolesInput> =
  z
    .object({
      where: z.lazy(() => RoleWhereUniqueInputSchema),
      create: z.union([
        z.lazy(() => RoleCreateWithoutUserVendorRolesInputSchema),
        z.lazy(() => RoleUncheckedCreateWithoutUserVendorRolesInputSchema),
      ]),
    })
    .strict() as z.ZodType<Prisma.RoleCreateOrConnectWithoutUserVendorRolesInput>;

export const UserUpsertWithoutUserVendorRolesInputSchema: z.ZodType<Prisma.UserUpsertWithoutUserVendorRolesInput> =
  z
    .object({
      update: z.union([
        z.lazy(() => UserUpdateWithoutUserVendorRolesInputSchema),
        z.lazy(() => UserUncheckedUpdateWithoutUserVendorRolesInputSchema),
      ]),
      create: z.union([
        z.lazy(() => UserCreateWithoutUserVendorRolesInputSchema),
        z.lazy(() => UserUncheckedCreateWithoutUserVendorRolesInputSchema),
      ]),
      where: z.lazy(() => UserWhereInputSchema).optional(),
    })
    .strict() as z.ZodType<Prisma.UserUpsertWithoutUserVendorRolesInput>;

export const UserUpdateToOneWithWhereWithoutUserVendorRolesInputSchema: z.ZodType<Prisma.UserUpdateToOneWithWhereWithoutUserVendorRolesInput> =
  z
    .object({
      where: z.lazy(() => UserWhereInputSchema).optional(),
      data: z.union([
        z.lazy(() => UserUpdateWithoutUserVendorRolesInputSchema),
        z.lazy(() => UserUncheckedUpdateWithoutUserVendorRolesInputSchema),
      ]),
    })
    .strict() as z.ZodType<Prisma.UserUpdateToOneWithWhereWithoutUserVendorRolesInput>;

export const UserUpdateWithoutUserVendorRolesInputSchema: z.ZodType<Prisma.UserUpdateWithoutUserVendorRolesInput> =
  z
    .object({
      id: z
        .union([
          z.string().uuid(),
          z.lazy(() => StringFieldUpdateOperationsInputSchema),
        ])
        .optional(),
      email: z
        .union([
          z.string().email(),
          z.lazy(() => StringFieldUpdateOperationsInputSchema),
        ])
        .optional(),
      password: z
        .union([
          z.string(),
          z.lazy(() => StringFieldUpdateOperationsInputSchema),
        ])
        .optional(),
      firstName: z
        .union([
          z.string(),
          z.lazy(() => StringFieldUpdateOperationsInputSchema),
        ])
        .optional(),
      lastName: z
        .union([
          z.string(),
          z.lazy(() => NullableStringFieldUpdateOperationsInputSchema),
        ])
        .optional()
        .nullable(),
      fullAddress: z
        .union([
          z.string(),
          z.lazy(() => StringFieldUpdateOperationsInputSchema),
        ])
        .optional(),
      city: z
        .union([
          z.string(),
          z.lazy(() => NullableStringFieldUpdateOperationsInputSchema),
        ])
        .optional()
        .nullable(),
      province: z
        .union([
          z.string(),
          z.lazy(() => NullableStringFieldUpdateOperationsInputSchema),
        ])
        .optional()
        .nullable(),
      country: z
        .union([
          z.string(),
          z.lazy(() => NullableStringFieldUpdateOperationsInputSchema),
        ])
        .optional()
        .nullable(),
      phone: z
        .union([
          z.string(),
          z.lazy(() => NullableStringFieldUpdateOperationsInputSchema),
        ])
        .optional()
        .nullable(),
      status: z
        .union([
          z.lazy(() => UserStatusSchema),
          z.lazy(() => EnumUserStatusFieldUpdateOperationsInputSchema),
        ])
        .optional(),
      createdAt: z
        .union([
          z.coerce.date(),
          z.lazy(() => DateTimeFieldUpdateOperationsInputSchema),
        ])
        .optional(),
      createdBy: z
        .union([
          z.string(),
          z.lazy(() => NullableStringFieldUpdateOperationsInputSchema),
        ])
        .optional()
        .nullable(),
      updatedAt: z
        .union([
          z.coerce.date(),
          z.lazy(() => DateTimeFieldUpdateOperationsInputSchema),
        ])
        .optional(),
      deletedAt: z
        .union([
          z.coerce.date(),
          z.lazy(() => NullableDateTimeFieldUpdateOperationsInputSchema),
        ])
        .optional()
        .nullable(),
      vendors: z
        .lazy(() => VendorUpdateManyWithoutUserNestedInputSchema)
        .optional(),
      orders: z
        .lazy(() => OrderUpdateManyWithoutUserNestedInputSchema)
        .optional(),
      cart: z.lazy(() => CartUpdateOneWithoutUserNestedInputSchema).optional(),
      notifications: z
        .lazy(() => NotificationUpdateManyWithoutUserNestedInputSchema)
        .optional(),
    })
    .strict() as z.ZodType<Prisma.UserUpdateWithoutUserVendorRolesInput>;

export const UserUncheckedUpdateWithoutUserVendorRolesInputSchema: z.ZodType<Prisma.UserUncheckedUpdateWithoutUserVendorRolesInput> =
  z
    .object({
      id: z
        .union([
          z.string().uuid(),
          z.lazy(() => StringFieldUpdateOperationsInputSchema),
        ])
        .optional(),
      email: z
        .union([
          z.string().email(),
          z.lazy(() => StringFieldUpdateOperationsInputSchema),
        ])
        .optional(),
      password: z
        .union([
          z.string(),
          z.lazy(() => StringFieldUpdateOperationsInputSchema),
        ])
        .optional(),
      firstName: z
        .union([
          z.string(),
          z.lazy(() => StringFieldUpdateOperationsInputSchema),
        ])
        .optional(),
      lastName: z
        .union([
          z.string(),
          z.lazy(() => NullableStringFieldUpdateOperationsInputSchema),
        ])
        .optional()
        .nullable(),
      fullAddress: z
        .union([
          z.string(),
          z.lazy(() => StringFieldUpdateOperationsInputSchema),
        ])
        .optional(),
      city: z
        .union([
          z.string(),
          z.lazy(() => NullableStringFieldUpdateOperationsInputSchema),
        ])
        .optional()
        .nullable(),
      province: z
        .union([
          z.string(),
          z.lazy(() => NullableStringFieldUpdateOperationsInputSchema),
        ])
        .optional()
        .nullable(),
      country: z
        .union([
          z.string(),
          z.lazy(() => NullableStringFieldUpdateOperationsInputSchema),
        ])
        .optional()
        .nullable(),
      phone: z
        .union([
          z.string(),
          z.lazy(() => NullableStringFieldUpdateOperationsInputSchema),
        ])
        .optional()
        .nullable(),
      status: z
        .union([
          z.lazy(() => UserStatusSchema),
          z.lazy(() => EnumUserStatusFieldUpdateOperationsInputSchema),
        ])
        .optional(),
      createdAt: z
        .union([
          z.coerce.date(),
          z.lazy(() => DateTimeFieldUpdateOperationsInputSchema),
        ])
        .optional(),
      createdBy: z
        .union([
          z.string(),
          z.lazy(() => NullableStringFieldUpdateOperationsInputSchema),
        ])
        .optional()
        .nullable(),
      updatedAt: z
        .union([
          z.coerce.date(),
          z.lazy(() => DateTimeFieldUpdateOperationsInputSchema),
        ])
        .optional(),
      deletedAt: z
        .union([
          z.coerce.date(),
          z.lazy(() => NullableDateTimeFieldUpdateOperationsInputSchema),
        ])
        .optional()
        .nullable(),
      vendors: z
        .lazy(() => VendorUncheckedUpdateManyWithoutUserNestedInputSchema)
        .optional(),
      orders: z
        .lazy(() => OrderUncheckedUpdateManyWithoutUserNestedInputSchema)
        .optional(),
      cart: z
        .lazy(() => CartUncheckedUpdateOneWithoutUserNestedInputSchema)
        .optional(),
      notifications: z
        .lazy(() => NotificationUncheckedUpdateManyWithoutUserNestedInputSchema)
        .optional(),
    })
    .strict() as z.ZodType<Prisma.UserUncheckedUpdateWithoutUserVendorRolesInput>;

export const VendorUpsertWithoutUserVendorRolesInputSchema: z.ZodType<Prisma.VendorUpsertWithoutUserVendorRolesInput> =
  z
    .object({
      update: z.union([
        z.lazy(() => VendorUpdateWithoutUserVendorRolesInputSchema),
        z.lazy(() => VendorUncheckedUpdateWithoutUserVendorRolesInputSchema),
      ]),
      create: z.union([
        z.lazy(() => VendorCreateWithoutUserVendorRolesInputSchema),
        z.lazy(() => VendorUncheckedCreateWithoutUserVendorRolesInputSchema),
      ]),
      where: z.lazy(() => VendorWhereInputSchema).optional(),
    })
    .strict() as z.ZodType<Prisma.VendorUpsertWithoutUserVendorRolesInput>;

export const VendorUpdateToOneWithWhereWithoutUserVendorRolesInputSchema: z.ZodType<Prisma.VendorUpdateToOneWithWhereWithoutUserVendorRolesInput> =
  z
    .object({
      where: z.lazy(() => VendorWhereInputSchema).optional(),
      data: z.union([
        z.lazy(() => VendorUpdateWithoutUserVendorRolesInputSchema),
        z.lazy(() => VendorUncheckedUpdateWithoutUserVendorRolesInputSchema),
      ]),
    })
    .strict() as z.ZodType<Prisma.VendorUpdateToOneWithWhereWithoutUserVendorRolesInput>;

export const VendorUpdateWithoutUserVendorRolesInputSchema: z.ZodType<Prisma.VendorUpdateWithoutUserVendorRolesInput> =
  z
    .object({
      id: z
        .union([
          z.string().uuid(),
          z.lazy(() => StringFieldUpdateOperationsInputSchema),
        ])
        .optional(),
      name: z
        .union([
          z.string(),
          z.lazy(() => StringFieldUpdateOperationsInputSchema),
        ])
        .optional(),
      slug: z
        .union([
          z.string(),
          z.lazy(() => StringFieldUpdateOperationsInputSchema),
        ])
        .optional(),
      description: z
        .union([
          z.string(),
          z.lazy(() => NullableStringFieldUpdateOperationsInputSchema),
        ])
        .optional()
        .nullable(),
      logoUrl: z
        .union([
          z.string(),
          z.lazy(() => NullableStringFieldUpdateOperationsInputSchema),
        ])
        .optional()
        .nullable(),
      taxCode: z
        .union([
          z.string(),
          z.lazy(() => NullableStringFieldUpdateOperationsInputSchema),
        ])
        .optional()
        .nullable(),
      totalProducts: z
        .union([
          z.number().int(),
          z.lazy(() => IntFieldUpdateOperationsInputSchema),
        ])
        .optional(),
      totalOrders: z
        .union([
          z.number().int(),
          z.lazy(() => IntFieldUpdateOperationsInputSchema),
        ])
        .optional(),
      status: z
        .union([
          z.lazy(() => VendorStatusSchema),
          z.lazy(() => EnumVendorStatusFieldUpdateOperationsInputSchema),
        ])
        .optional(),
      createdAt: z
        .union([
          z.coerce.date(),
          z.lazy(() => DateTimeFieldUpdateOperationsInputSchema),
        ])
        .optional(),
      createdBy: z
        .union([
          z.string(),
          z.lazy(() => NullableStringFieldUpdateOperationsInputSchema),
        ])
        .optional()
        .nullable(),
      updatedAt: z
        .union([
          z.coerce.date(),
          z.lazy(() => DateTimeFieldUpdateOperationsInputSchema),
        ])
        .optional(),
      deletedAt: z
        .union([
          z.coerce.date(),
          z.lazy(() => NullableDateTimeFieldUpdateOperationsInputSchema),
        ])
        .optional()
        .nullable(),
      user: z
        .lazy(() => UserUpdateOneRequiredWithoutVendorsNestedInputSchema)
        .optional(),
      products: z
        .lazy(() => ProductUpdateManyWithoutVendorNestedInputSchema)
        .optional(),
    })
    .strict() as z.ZodType<Prisma.VendorUpdateWithoutUserVendorRolesInput>;

export const VendorUncheckedUpdateWithoutUserVendorRolesInputSchema: z.ZodType<Prisma.VendorUncheckedUpdateWithoutUserVendorRolesInput> =
  z
    .object({
      id: z
        .union([
          z.string().uuid(),
          z.lazy(() => StringFieldUpdateOperationsInputSchema),
        ])
        .optional(),
      userID: z
        .union([
          z.string(),
          z.lazy(() => StringFieldUpdateOperationsInputSchema),
        ])
        .optional(),
      name: z
        .union([
          z.string(),
          z.lazy(() => StringFieldUpdateOperationsInputSchema),
        ])
        .optional(),
      slug: z
        .union([
          z.string(),
          z.lazy(() => StringFieldUpdateOperationsInputSchema),
        ])
        .optional(),
      description: z
        .union([
          z.string(),
          z.lazy(() => NullableStringFieldUpdateOperationsInputSchema),
        ])
        .optional()
        .nullable(),
      logoUrl: z
        .union([
          z.string(),
          z.lazy(() => NullableStringFieldUpdateOperationsInputSchema),
        ])
        .optional()
        .nullable(),
      taxCode: z
        .union([
          z.string(),
          z.lazy(() => NullableStringFieldUpdateOperationsInputSchema),
        ])
        .optional()
        .nullable(),
      totalProducts: z
        .union([
          z.number().int(),
          z.lazy(() => IntFieldUpdateOperationsInputSchema),
        ])
        .optional(),
      totalOrders: z
        .union([
          z.number().int(),
          z.lazy(() => IntFieldUpdateOperationsInputSchema),
        ])
        .optional(),
      status: z
        .union([
          z.lazy(() => VendorStatusSchema),
          z.lazy(() => EnumVendorStatusFieldUpdateOperationsInputSchema),
        ])
        .optional(),
      createdAt: z
        .union([
          z.coerce.date(),
          z.lazy(() => DateTimeFieldUpdateOperationsInputSchema),
        ])
        .optional(),
      createdBy: z
        .union([
          z.string(),
          z.lazy(() => NullableStringFieldUpdateOperationsInputSchema),
        ])
        .optional()
        .nullable(),
      updatedAt: z
        .union([
          z.coerce.date(),
          z.lazy(() => DateTimeFieldUpdateOperationsInputSchema),
        ])
        .optional(),
      deletedAt: z
        .union([
          z.coerce.date(),
          z.lazy(() => NullableDateTimeFieldUpdateOperationsInputSchema),
        ])
        .optional()
        .nullable(),
      products: z
        .lazy(() => ProductUncheckedUpdateManyWithoutVendorNestedInputSchema)
        .optional(),
    })
    .strict() as z.ZodType<Prisma.VendorUncheckedUpdateWithoutUserVendorRolesInput>;

export const RoleUpsertWithoutUserVendorRolesInputSchema: z.ZodType<Prisma.RoleUpsertWithoutUserVendorRolesInput> =
  z
    .object({
      update: z.union([
        z.lazy(() => RoleUpdateWithoutUserVendorRolesInputSchema),
        z.lazy(() => RoleUncheckedUpdateWithoutUserVendorRolesInputSchema),
      ]),
      create: z.union([
        z.lazy(() => RoleCreateWithoutUserVendorRolesInputSchema),
        z.lazy(() => RoleUncheckedCreateWithoutUserVendorRolesInputSchema),
      ]),
      where: z.lazy(() => RoleWhereInputSchema).optional(),
    })
    .strict() as z.ZodType<Prisma.RoleUpsertWithoutUserVendorRolesInput>;

export const RoleUpdateToOneWithWhereWithoutUserVendorRolesInputSchema: z.ZodType<Prisma.RoleUpdateToOneWithWhereWithoutUserVendorRolesInput> =
  z
    .object({
      where: z.lazy(() => RoleWhereInputSchema).optional(),
      data: z.union([
        z.lazy(() => RoleUpdateWithoutUserVendorRolesInputSchema),
        z.lazy(() => RoleUncheckedUpdateWithoutUserVendorRolesInputSchema),
      ]),
    })
    .strict() as z.ZodType<Prisma.RoleUpdateToOneWithWhereWithoutUserVendorRolesInput>;

export const RoleUpdateWithoutUserVendorRolesInputSchema: z.ZodType<Prisma.RoleUpdateWithoutUserVendorRolesInput> =
  z
    .object({
      id: z
        .union([
          z.string().uuid(),
          z.lazy(() => StringFieldUpdateOperationsInputSchema),
        ])
        .optional(),
      name: z
        .union([
          z.string(),
          z.lazy(() => StringFieldUpdateOperationsInputSchema),
        ])
        .optional(),
      description: z
        .union([
          z.string(),
          z.lazy(() => NullableStringFieldUpdateOperationsInputSchema),
        ])
        .optional()
        .nullable(),
      isSystemRole: z
        .union([
          z.boolean(),
          z.lazy(() => BoolFieldUpdateOperationsInputSchema),
        ])
        .optional(),
      createdAt: z
        .union([
          z.coerce.date(),
          z.lazy(() => DateTimeFieldUpdateOperationsInputSchema),
        ])
        .optional(),
      createdBy: z
        .union([
          z.string(),
          z.lazy(() => NullableStringFieldUpdateOperationsInputSchema),
        ])
        .optional()
        .nullable(),
      updatedAt: z
        .union([
          z.coerce.date(),
          z.lazy(() => DateTimeFieldUpdateOperationsInputSchema),
        ])
        .optional(),
      deletedAt: z
        .union([
          z.coerce.date(),
          z.lazy(() => NullableDateTimeFieldUpdateOperationsInputSchema),
        ])
        .optional()
        .nullable(),
      rolePermissions: z
        .lazy(() => RolePermissionUpdateManyWithoutRoleNestedInputSchema)
        .optional(),
    })
    .strict() as z.ZodType<Prisma.RoleUpdateWithoutUserVendorRolesInput>;

export const RoleUncheckedUpdateWithoutUserVendorRolesInputSchema: z.ZodType<Prisma.RoleUncheckedUpdateWithoutUserVendorRolesInput> =
  z
    .object({
      id: z
        .union([
          z.string().uuid(),
          z.lazy(() => StringFieldUpdateOperationsInputSchema),
        ])
        .optional(),
      name: z
        .union([
          z.string(),
          z.lazy(() => StringFieldUpdateOperationsInputSchema),
        ])
        .optional(),
      description: z
        .union([
          z.string(),
          z.lazy(() => NullableStringFieldUpdateOperationsInputSchema),
        ])
        .optional()
        .nullable(),
      isSystemRole: z
        .union([
          z.boolean(),
          z.lazy(() => BoolFieldUpdateOperationsInputSchema),
        ])
        .optional(),
      createdAt: z
        .union([
          z.coerce.date(),
          z.lazy(() => DateTimeFieldUpdateOperationsInputSchema),
        ])
        .optional(),
      createdBy: z
        .union([
          z.string(),
          z.lazy(() => NullableStringFieldUpdateOperationsInputSchema),
        ])
        .optional()
        .nullable(),
      updatedAt: z
        .union([
          z.coerce.date(),
          z.lazy(() => DateTimeFieldUpdateOperationsInputSchema),
        ])
        .optional(),
      deletedAt: z
        .union([
          z.coerce.date(),
          z.lazy(() => NullableDateTimeFieldUpdateOperationsInputSchema),
        ])
        .optional()
        .nullable(),
      rolePermissions: z
        .lazy(
          () => RolePermissionUncheckedUpdateManyWithoutRoleNestedInputSchema,
        )
        .optional(),
    })
    .strict() as z.ZodType<Prisma.RoleUncheckedUpdateWithoutUserVendorRolesInput>;

export const CategoryCreateWithoutChildrenInputSchema: z.ZodType<Prisma.CategoryCreateWithoutChildrenInput> =
  z
    .object({
      id: z.string().uuid().optional(),
      name: z.string(),
      slug: z.string(),
      description: z.string().optional().nullable(),
      imageUrl: z.string().optional().nullable(),
      createdAt: z.coerce.date().optional(),
      createdBy: z.string().optional().nullable(),
      updatedAt: z.coerce.date().optional(),
      deletedAt: z.coerce.date().optional().nullable(),
      parent: z
        .lazy(() => CategoryCreateNestedOneWithoutChildrenInputSchema)
        .optional(),
      productCategories: z
        .lazy(() => ProductCategoryCreateNestedManyWithoutCategoryInputSchema)
        .optional(),
    })
    .strict() as z.ZodType<Prisma.CategoryCreateWithoutChildrenInput>;

export const CategoryUncheckedCreateWithoutChildrenInputSchema: z.ZodType<Prisma.CategoryUncheckedCreateWithoutChildrenInput> =
  z
    .object({
      id: z.string().uuid().optional(),
      name: z.string(),
      slug: z.string(),
      description: z.string().optional().nullable(),
      parentID: z.string().optional().nullable(),
      imageUrl: z.string().optional().nullable(),
      createdAt: z.coerce.date().optional(),
      createdBy: z.string().optional().nullable(),
      updatedAt: z.coerce.date().optional(),
      deletedAt: z.coerce.date().optional().nullable(),
      productCategories: z
        .lazy(
          () =>
            ProductCategoryUncheckedCreateNestedManyWithoutCategoryInputSchema,
        )
        .optional(),
    })
    .strict() as z.ZodType<Prisma.CategoryUncheckedCreateWithoutChildrenInput>;

export const CategoryCreateOrConnectWithoutChildrenInputSchema: z.ZodType<Prisma.CategoryCreateOrConnectWithoutChildrenInput> =
  z
    .object({
      where: z.lazy(() => CategoryWhereUniqueInputSchema),
      create: z.union([
        z.lazy(() => CategoryCreateWithoutChildrenInputSchema),
        z.lazy(() => CategoryUncheckedCreateWithoutChildrenInputSchema),
      ]),
    })
    .strict() as z.ZodType<Prisma.CategoryCreateOrConnectWithoutChildrenInput>;

export const CategoryCreateWithoutParentInputSchema: z.ZodType<Prisma.CategoryCreateWithoutParentInput> =
  z
    .object({
      id: z.string().uuid().optional(),
      name: z.string(),
      slug: z.string(),
      description: z.string().optional().nullable(),
      imageUrl: z.string().optional().nullable(),
      createdAt: z.coerce.date().optional(),
      createdBy: z.string().optional().nullable(),
      updatedAt: z.coerce.date().optional(),
      deletedAt: z.coerce.date().optional().nullable(),
      children: z
        .lazy(() => CategoryCreateNestedManyWithoutParentInputSchema)
        .optional(),
      productCategories: z
        .lazy(() => ProductCategoryCreateNestedManyWithoutCategoryInputSchema)
        .optional(),
    })
    .strict() as z.ZodType<Prisma.CategoryCreateWithoutParentInput>;

export const CategoryUncheckedCreateWithoutParentInputSchema: z.ZodType<Prisma.CategoryUncheckedCreateWithoutParentInput> =
  z
    .object({
      id: z.string().uuid().optional(),
      name: z.string(),
      slug: z.string(),
      description: z.string().optional().nullable(),
      imageUrl: z.string().optional().nullable(),
      createdAt: z.coerce.date().optional(),
      createdBy: z.string().optional().nullable(),
      updatedAt: z.coerce.date().optional(),
      deletedAt: z.coerce.date().optional().nullable(),
      children: z
        .lazy(() => CategoryUncheckedCreateNestedManyWithoutParentInputSchema)
        .optional(),
      productCategories: z
        .lazy(
          () =>
            ProductCategoryUncheckedCreateNestedManyWithoutCategoryInputSchema,
        )
        .optional(),
    })
    .strict() as z.ZodType<Prisma.CategoryUncheckedCreateWithoutParentInput>;

export const CategoryCreateOrConnectWithoutParentInputSchema: z.ZodType<Prisma.CategoryCreateOrConnectWithoutParentInput> =
  z
    .object({
      where: z.lazy(() => CategoryWhereUniqueInputSchema),
      create: z.union([
        z.lazy(() => CategoryCreateWithoutParentInputSchema),
        z.lazy(() => CategoryUncheckedCreateWithoutParentInputSchema),
      ]),
    })
    .strict() as z.ZodType<Prisma.CategoryCreateOrConnectWithoutParentInput>;

export const CategoryCreateManyParentInputEnvelopeSchema: z.ZodType<Prisma.CategoryCreateManyParentInputEnvelope> =
  z
    .object({
      data: z.union([
        z.lazy(() => CategoryCreateManyParentInputSchema),
        z.lazy(() => CategoryCreateManyParentInputSchema).array(),
      ]),
      skipDuplicates: z.boolean().optional(),
    })
    .strict() as z.ZodType<Prisma.CategoryCreateManyParentInputEnvelope>;

export const ProductCategoryCreateWithoutCategoryInputSchema: z.ZodType<Prisma.ProductCategoryCreateWithoutCategoryInput> =
  z
    .object({
      product: z.lazy(
        () => ProductCreateNestedOneWithoutProductCategoriesInputSchema,
      ),
    })
    .strict() as z.ZodType<Prisma.ProductCategoryCreateWithoutCategoryInput>;

export const ProductCategoryUncheckedCreateWithoutCategoryInputSchema: z.ZodType<Prisma.ProductCategoryUncheckedCreateWithoutCategoryInput> =
  z
    .object({
      productID: z.string(),
    })
    .strict() as z.ZodType<Prisma.ProductCategoryUncheckedCreateWithoutCategoryInput>;

export const ProductCategoryCreateOrConnectWithoutCategoryInputSchema: z.ZodType<Prisma.ProductCategoryCreateOrConnectWithoutCategoryInput> =
  z
    .object({
      where: z.lazy(() => ProductCategoryWhereUniqueInputSchema),
      create: z.union([
        z.lazy(() => ProductCategoryCreateWithoutCategoryInputSchema),
        z.lazy(() => ProductCategoryUncheckedCreateWithoutCategoryInputSchema),
      ]),
    })
    .strict() as z.ZodType<Prisma.ProductCategoryCreateOrConnectWithoutCategoryInput>;

export const ProductCategoryCreateManyCategoryInputEnvelopeSchema: z.ZodType<Prisma.ProductCategoryCreateManyCategoryInputEnvelope> =
  z
    .object({
      data: z.union([
        z.lazy(() => ProductCategoryCreateManyCategoryInputSchema),
        z.lazy(() => ProductCategoryCreateManyCategoryInputSchema).array(),
      ]),
      skipDuplicates: z.boolean().optional(),
    })
    .strict() as z.ZodType<Prisma.ProductCategoryCreateManyCategoryInputEnvelope>;

export const CategoryUpsertWithoutChildrenInputSchema: z.ZodType<Prisma.CategoryUpsertWithoutChildrenInput> =
  z
    .object({
      update: z.union([
        z.lazy(() => CategoryUpdateWithoutChildrenInputSchema),
        z.lazy(() => CategoryUncheckedUpdateWithoutChildrenInputSchema),
      ]),
      create: z.union([
        z.lazy(() => CategoryCreateWithoutChildrenInputSchema),
        z.lazy(() => CategoryUncheckedCreateWithoutChildrenInputSchema),
      ]),
      where: z.lazy(() => CategoryWhereInputSchema).optional(),
    })
    .strict() as z.ZodType<Prisma.CategoryUpsertWithoutChildrenInput>;

export const CategoryUpdateToOneWithWhereWithoutChildrenInputSchema: z.ZodType<Prisma.CategoryUpdateToOneWithWhereWithoutChildrenInput> =
  z
    .object({
      where: z.lazy(() => CategoryWhereInputSchema).optional(),
      data: z.union([
        z.lazy(() => CategoryUpdateWithoutChildrenInputSchema),
        z.lazy(() => CategoryUncheckedUpdateWithoutChildrenInputSchema),
      ]),
    })
    .strict() as z.ZodType<Prisma.CategoryUpdateToOneWithWhereWithoutChildrenInput>;

export const CategoryUpdateWithoutChildrenInputSchema: z.ZodType<Prisma.CategoryUpdateWithoutChildrenInput> =
  z
    .object({
      id: z
        .union([
          z.string().uuid(),
          z.lazy(() => StringFieldUpdateOperationsInputSchema),
        ])
        .optional(),
      name: z
        .union([
          z.string(),
          z.lazy(() => StringFieldUpdateOperationsInputSchema),
        ])
        .optional(),
      slug: z
        .union([
          z.string(),
          z.lazy(() => StringFieldUpdateOperationsInputSchema),
        ])
        .optional(),
      description: z
        .union([
          z.string(),
          z.lazy(() => NullableStringFieldUpdateOperationsInputSchema),
        ])
        .optional()
        .nullable(),
      imageUrl: z
        .union([
          z.string(),
          z.lazy(() => NullableStringFieldUpdateOperationsInputSchema),
        ])
        .optional()
        .nullable(),
      createdAt: z
        .union([
          z.coerce.date(),
          z.lazy(() => DateTimeFieldUpdateOperationsInputSchema),
        ])
        .optional(),
      createdBy: z
        .union([
          z.string(),
          z.lazy(() => NullableStringFieldUpdateOperationsInputSchema),
        ])
        .optional()
        .nullable(),
      updatedAt: z
        .union([
          z.coerce.date(),
          z.lazy(() => DateTimeFieldUpdateOperationsInputSchema),
        ])
        .optional(),
      deletedAt: z
        .union([
          z.coerce.date(),
          z.lazy(() => NullableDateTimeFieldUpdateOperationsInputSchema),
        ])
        .optional()
        .nullable(),
      parent: z
        .lazy(() => CategoryUpdateOneWithoutChildrenNestedInputSchema)
        .optional(),
      productCategories: z
        .lazy(() => ProductCategoryUpdateManyWithoutCategoryNestedInputSchema)
        .optional(),
    })
    .strict() as z.ZodType<Prisma.CategoryUpdateWithoutChildrenInput>;

export const CategoryUncheckedUpdateWithoutChildrenInputSchema: z.ZodType<Prisma.CategoryUncheckedUpdateWithoutChildrenInput> =
  z
    .object({
      id: z
        .union([
          z.string().uuid(),
          z.lazy(() => StringFieldUpdateOperationsInputSchema),
        ])
        .optional(),
      name: z
        .union([
          z.string(),
          z.lazy(() => StringFieldUpdateOperationsInputSchema),
        ])
        .optional(),
      slug: z
        .union([
          z.string(),
          z.lazy(() => StringFieldUpdateOperationsInputSchema),
        ])
        .optional(),
      description: z
        .union([
          z.string(),
          z.lazy(() => NullableStringFieldUpdateOperationsInputSchema),
        ])
        .optional()
        .nullable(),
      parentID: z
        .union([
          z.string(),
          z.lazy(() => NullableStringFieldUpdateOperationsInputSchema),
        ])
        .optional()
        .nullable(),
      imageUrl: z
        .union([
          z.string(),
          z.lazy(() => NullableStringFieldUpdateOperationsInputSchema),
        ])
        .optional()
        .nullable(),
      createdAt: z
        .union([
          z.coerce.date(),
          z.lazy(() => DateTimeFieldUpdateOperationsInputSchema),
        ])
        .optional(),
      createdBy: z
        .union([
          z.string(),
          z.lazy(() => NullableStringFieldUpdateOperationsInputSchema),
        ])
        .optional()
        .nullable(),
      updatedAt: z
        .union([
          z.coerce.date(),
          z.lazy(() => DateTimeFieldUpdateOperationsInputSchema),
        ])
        .optional(),
      deletedAt: z
        .union([
          z.coerce.date(),
          z.lazy(() => NullableDateTimeFieldUpdateOperationsInputSchema),
        ])
        .optional()
        .nullable(),
      productCategories: z
        .lazy(
          () =>
            ProductCategoryUncheckedUpdateManyWithoutCategoryNestedInputSchema,
        )
        .optional(),
    })
    .strict() as z.ZodType<Prisma.CategoryUncheckedUpdateWithoutChildrenInput>;

export const CategoryUpsertWithWhereUniqueWithoutParentInputSchema: z.ZodType<Prisma.CategoryUpsertWithWhereUniqueWithoutParentInput> =
  z
    .object({
      where: z.lazy(() => CategoryWhereUniqueInputSchema),
      update: z.union([
        z.lazy(() => CategoryUpdateWithoutParentInputSchema),
        z.lazy(() => CategoryUncheckedUpdateWithoutParentInputSchema),
      ]),
      create: z.union([
        z.lazy(() => CategoryCreateWithoutParentInputSchema),
        z.lazy(() => CategoryUncheckedCreateWithoutParentInputSchema),
      ]),
    })
    .strict() as z.ZodType<Prisma.CategoryUpsertWithWhereUniqueWithoutParentInput>;

export const CategoryUpdateWithWhereUniqueWithoutParentInputSchema: z.ZodType<Prisma.CategoryUpdateWithWhereUniqueWithoutParentInput> =
  z
    .object({
      where: z.lazy(() => CategoryWhereUniqueInputSchema),
      data: z.union([
        z.lazy(() => CategoryUpdateWithoutParentInputSchema),
        z.lazy(() => CategoryUncheckedUpdateWithoutParentInputSchema),
      ]),
    })
    .strict() as z.ZodType<Prisma.CategoryUpdateWithWhereUniqueWithoutParentInput>;

export const CategoryUpdateManyWithWhereWithoutParentInputSchema: z.ZodType<Prisma.CategoryUpdateManyWithWhereWithoutParentInput> =
  z
    .object({
      where: z.lazy(() => CategoryScalarWhereInputSchema),
      data: z.union([
        z.lazy(() => CategoryUpdateManyMutationInputSchema),
        z.lazy(() => CategoryUncheckedUpdateManyWithoutParentInputSchema),
      ]),
    })
    .strict() as z.ZodType<Prisma.CategoryUpdateManyWithWhereWithoutParentInput>;

export const CategoryScalarWhereInputSchema: z.ZodType<Prisma.CategoryScalarWhereInput> =
  z
    .object({
      AND: z
        .union([
          z.lazy(() => CategoryScalarWhereInputSchema),
          z.lazy(() => CategoryScalarWhereInputSchema).array(),
        ])
        .optional(),
      OR: z
        .lazy(() => CategoryScalarWhereInputSchema)
        .array()
        .optional(),
      NOT: z
        .union([
          z.lazy(() => CategoryScalarWhereInputSchema),
          z.lazy(() => CategoryScalarWhereInputSchema).array(),
        ])
        .optional(),
      id: z.union([z.lazy(() => StringFilterSchema), z.string()]).optional(),
      name: z.union([z.lazy(() => StringFilterSchema), z.string()]).optional(),
      slug: z.union([z.lazy(() => StringFilterSchema), z.string()]).optional(),
      description: z
        .union([z.lazy(() => StringNullableFilterSchema), z.string()])
        .optional()
        .nullable(),
      parentID: z
        .union([z.lazy(() => StringNullableFilterSchema), z.string()])
        .optional()
        .nullable(),
      imageUrl: z
        .union([z.lazy(() => StringNullableFilterSchema), z.string()])
        .optional()
        .nullable(),
      createdAt: z
        .union([z.lazy(() => DateTimeFilterSchema), z.coerce.date()])
        .optional(),
      createdBy: z
        .union([z.lazy(() => StringNullableFilterSchema), z.string()])
        .optional()
        .nullable(),
      updatedAt: z
        .union([z.lazy(() => DateTimeFilterSchema), z.coerce.date()])
        .optional(),
      deletedAt: z
        .union([z.lazy(() => DateTimeNullableFilterSchema), z.coerce.date()])
        .optional()
        .nullable(),
    })
    .strict() as z.ZodType<Prisma.CategoryScalarWhereInput>;

export const ProductCategoryUpsertWithWhereUniqueWithoutCategoryInputSchema: z.ZodType<Prisma.ProductCategoryUpsertWithWhereUniqueWithoutCategoryInput> =
  z
    .object({
      where: z.lazy(() => ProductCategoryWhereUniqueInputSchema),
      update: z.union([
        z.lazy(() => ProductCategoryUpdateWithoutCategoryInputSchema),
        z.lazy(() => ProductCategoryUncheckedUpdateWithoutCategoryInputSchema),
      ]),
      create: z.union([
        z.lazy(() => ProductCategoryCreateWithoutCategoryInputSchema),
        z.lazy(() => ProductCategoryUncheckedCreateWithoutCategoryInputSchema),
      ]),
    })
    .strict() as z.ZodType<Prisma.ProductCategoryUpsertWithWhereUniqueWithoutCategoryInput>;

export const ProductCategoryUpdateWithWhereUniqueWithoutCategoryInputSchema: z.ZodType<Prisma.ProductCategoryUpdateWithWhereUniqueWithoutCategoryInput> =
  z
    .object({
      where: z.lazy(() => ProductCategoryWhereUniqueInputSchema),
      data: z.union([
        z.lazy(() => ProductCategoryUpdateWithoutCategoryInputSchema),
        z.lazy(() => ProductCategoryUncheckedUpdateWithoutCategoryInputSchema),
      ]),
    })
    .strict() as z.ZodType<Prisma.ProductCategoryUpdateWithWhereUniqueWithoutCategoryInput>;

export const ProductCategoryUpdateManyWithWhereWithoutCategoryInputSchema: z.ZodType<Prisma.ProductCategoryUpdateManyWithWhereWithoutCategoryInput> =
  z
    .object({
      where: z.lazy(() => ProductCategoryScalarWhereInputSchema),
      data: z.union([
        z.lazy(() => ProductCategoryUpdateManyMutationInputSchema),
        z.lazy(
          () => ProductCategoryUncheckedUpdateManyWithoutCategoryInputSchema,
        ),
      ]),
    })
    .strict() as z.ZodType<Prisma.ProductCategoryUpdateManyWithWhereWithoutCategoryInput>;

export const ProductCategoryScalarWhereInputSchema: z.ZodType<Prisma.ProductCategoryScalarWhereInput> =
  z
    .object({
      AND: z
        .union([
          z.lazy(() => ProductCategoryScalarWhereInputSchema),
          z.lazy(() => ProductCategoryScalarWhereInputSchema).array(),
        ])
        .optional(),
      OR: z
        .lazy(() => ProductCategoryScalarWhereInputSchema)
        .array()
        .optional(),
      NOT: z
        .union([
          z.lazy(() => ProductCategoryScalarWhereInputSchema),
          z.lazy(() => ProductCategoryScalarWhereInputSchema).array(),
        ])
        .optional(),
      productID: z
        .union([z.lazy(() => StringFilterSchema), z.string()])
        .optional(),
      categoryID: z
        .union([z.lazy(() => StringFilterSchema), z.string()])
        .optional(),
    })
    .strict() as z.ZodType<Prisma.ProductCategoryScalarWhereInput>;

export const VendorCreateWithoutProductsInputSchema: z.ZodType<Prisma.VendorCreateWithoutProductsInput> =
  z
    .object({
      id: z.string().uuid().optional(),
      name: z.string(),
      slug: z.string(),
      description: z.string().optional().nullable(),
      logoUrl: z.string().optional().nullable(),
      taxCode: z.string().optional().nullable(),
      totalProducts: z.number().int().optional(),
      totalOrders: z.number().int().optional(),
      status: z.lazy(() => VendorStatusSchema).optional(),
      createdAt: z.coerce.date().optional(),
      createdBy: z.string().optional().nullable(),
      updatedAt: z.coerce.date().optional(),
      deletedAt: z.coerce.date().optional().nullable(),
      user: z.lazy(() => UserCreateNestedOneWithoutVendorsInputSchema),
      userVendorRoles: z
        .lazy(() => UserVendorRoleCreateNestedManyWithoutVendorInputSchema)
        .optional(),
    })
    .strict() as z.ZodType<Prisma.VendorCreateWithoutProductsInput>;

export const VendorUncheckedCreateWithoutProductsInputSchema: z.ZodType<Prisma.VendorUncheckedCreateWithoutProductsInput> =
  z
    .object({
      id: z.string().uuid().optional(),
      userID: z.string(),
      name: z.string(),
      slug: z.string(),
      description: z.string().optional().nullable(),
      logoUrl: z.string().optional().nullable(),
      taxCode: z.string().optional().nullable(),
      totalProducts: z.number().int().optional(),
      totalOrders: z.number().int().optional(),
      status: z.lazy(() => VendorStatusSchema).optional(),
      createdAt: z.coerce.date().optional(),
      createdBy: z.string().optional().nullable(),
      updatedAt: z.coerce.date().optional(),
      deletedAt: z.coerce.date().optional().nullable(),
      userVendorRoles: z
        .lazy(
          () => UserVendorRoleUncheckedCreateNestedManyWithoutVendorInputSchema,
        )
        .optional(),
    })
    .strict() as z.ZodType<Prisma.VendorUncheckedCreateWithoutProductsInput>;

export const VendorCreateOrConnectWithoutProductsInputSchema: z.ZodType<Prisma.VendorCreateOrConnectWithoutProductsInput> =
  z
    .object({
      where: z.lazy(() => VendorWhereUniqueInputSchema),
      create: z.union([
        z.lazy(() => VendorCreateWithoutProductsInputSchema),
        z.lazy(() => VendorUncheckedCreateWithoutProductsInputSchema),
      ]),
    })
    .strict() as z.ZodType<Prisma.VendorCreateOrConnectWithoutProductsInput>;

export const ProductCategoryCreateWithoutProductInputSchema: z.ZodType<Prisma.ProductCategoryCreateWithoutProductInput> =
  z
    .object({
      category: z.lazy(
        () => CategoryCreateNestedOneWithoutProductCategoriesInputSchema,
      ),
    })
    .strict() as z.ZodType<Prisma.ProductCategoryCreateWithoutProductInput>;

export const ProductCategoryUncheckedCreateWithoutProductInputSchema: z.ZodType<Prisma.ProductCategoryUncheckedCreateWithoutProductInput> =
  z
    .object({
      categoryID: z.string(),
    })
    .strict() as z.ZodType<Prisma.ProductCategoryUncheckedCreateWithoutProductInput>;

export const ProductCategoryCreateOrConnectWithoutProductInputSchema: z.ZodType<Prisma.ProductCategoryCreateOrConnectWithoutProductInput> =
  z
    .object({
      where: z.lazy(() => ProductCategoryWhereUniqueInputSchema),
      create: z.union([
        z.lazy(() => ProductCategoryCreateWithoutProductInputSchema),
        z.lazy(() => ProductCategoryUncheckedCreateWithoutProductInputSchema),
      ]),
    })
    .strict() as z.ZodType<Prisma.ProductCategoryCreateOrConnectWithoutProductInput>;

export const ProductCategoryCreateManyProductInputEnvelopeSchema: z.ZodType<Prisma.ProductCategoryCreateManyProductInputEnvelope> =
  z
    .object({
      data: z.union([
        z.lazy(() => ProductCategoryCreateManyProductInputSchema),
        z.lazy(() => ProductCategoryCreateManyProductInputSchema).array(),
      ]),
      skipDuplicates: z.boolean().optional(),
    })
    .strict() as z.ZodType<Prisma.ProductCategoryCreateManyProductInputEnvelope>;

export const ProductImageCreateWithoutProductInputSchema: z.ZodType<Prisma.ProductImageCreateWithoutProductInput> =
  z
    .object({
      id: z.string().uuid().optional(),
      name: z.string(),
      description: z.string().optional().nullable(),
      imageUrl: z.string(),
      sortOrder: z.number().int().optional(),
      createdAt: z.coerce.date().optional(),
      createdBy: z.string().optional().nullable(),
      updatedAt: z.coerce.date().optional(),
      deletedAt: z.coerce.date().optional().nullable(),
      productVariant: z
        .lazy(
          () => ProductVariantCreateNestedOneWithoutProductImagesInputSchema,
        )
        .optional(),
    })
    .strict() as z.ZodType<Prisma.ProductImageCreateWithoutProductInput>;

export const ProductImageUncheckedCreateWithoutProductInputSchema: z.ZodType<Prisma.ProductImageUncheckedCreateWithoutProductInput> =
  z
    .object({
      id: z.string().uuid().optional(),
      name: z.string(),
      description: z.string().optional().nullable(),
      productVariantID: z.string().optional().nullable(),
      imageUrl: z.string(),
      sortOrder: z.number().int().optional(),
      createdAt: z.coerce.date().optional(),
      createdBy: z.string().optional().nullable(),
      updatedAt: z.coerce.date().optional(),
      deletedAt: z.coerce.date().optional().nullable(),
    })
    .strict() as z.ZodType<Prisma.ProductImageUncheckedCreateWithoutProductInput>;

export const ProductImageCreateOrConnectWithoutProductInputSchema: z.ZodType<Prisma.ProductImageCreateOrConnectWithoutProductInput> =
  z
    .object({
      where: z.lazy(() => ProductImageWhereUniqueInputSchema),
      create: z.union([
        z.lazy(() => ProductImageCreateWithoutProductInputSchema),
        z.lazy(() => ProductImageUncheckedCreateWithoutProductInputSchema),
      ]),
    })
    .strict() as z.ZodType<Prisma.ProductImageCreateOrConnectWithoutProductInput>;

export const ProductImageCreateManyProductInputEnvelopeSchema: z.ZodType<Prisma.ProductImageCreateManyProductInputEnvelope> =
  z
    .object({
      data: z.union([
        z.lazy(() => ProductImageCreateManyProductInputSchema),
        z.lazy(() => ProductImageCreateManyProductInputSchema).array(),
      ]),
      skipDuplicates: z.boolean().optional(),
    })
    .strict() as z.ZodType<Prisma.ProductImageCreateManyProductInputEnvelope>;

export const ProductVariantCreateWithoutProductInputSchema: z.ZodType<Prisma.ProductVariantCreateWithoutProductInput> =
  z
    .object({
      id: z.string().uuid().optional(),
      name: z.string().optional().nullable(),
      sku: z.string().optional().nullable(),
      price: z
        .union([
          z.number(),
          z.string(),
          z.instanceof(Decimal),
          z.instanceof(Prisma.Decimal),
          DecimalJsLikeSchema,
        ])
        .refine((v) => isValidDecimalInput(v), {
          message: 'Must be a Decimal',
        }),
      stockQuantity: z.number().int().optional(),
      attributes: z
        .union([
          z.lazy(() => NullableJsonNullValueInputSchema),
          InputJsonValueSchema,
        ])
        .optional(),
      createdAt: z.coerce.date().optional(),
      createdBy: z.string().optional().nullable(),
      updatedAt: z.coerce.date().optional(),
      deletedAt: z.coerce.date().optional().nullable(),
      productImages: z
        .lazy(
          () => ProductImageCreateNestedManyWithoutProductVariantInputSchema,
        )
        .optional(),
      orderItems: z
        .lazy(() => OrderItemCreateNestedManyWithoutProductVariantInputSchema)
        .optional(),
      cartItems: z
        .lazy(() => CartItemCreateNestedManyWithoutProductVariantInputSchema)
        .optional(),
    })
    .strict() as z.ZodType<Prisma.ProductVariantCreateWithoutProductInput>;

export const ProductVariantUncheckedCreateWithoutProductInputSchema: z.ZodType<Prisma.ProductVariantUncheckedCreateWithoutProductInput> =
  z
    .object({
      id: z.string().uuid().optional(),
      name: z.string().optional().nullable(),
      sku: z.string().optional().nullable(),
      price: z
        .union([
          z.number(),
          z.string(),
          z.instanceof(Decimal),
          z.instanceof(Prisma.Decimal),
          DecimalJsLikeSchema,
        ])
        .refine((v) => isValidDecimalInput(v), {
          message: 'Must be a Decimal',
        }),
      stockQuantity: z.number().int().optional(),
      attributes: z
        .union([
          z.lazy(() => NullableJsonNullValueInputSchema),
          InputJsonValueSchema,
        ])
        .optional(),
      createdAt: z.coerce.date().optional(),
      createdBy: z.string().optional().nullable(),
      updatedAt: z.coerce.date().optional(),
      deletedAt: z.coerce.date().optional().nullable(),
      productImages: z
        .lazy(
          () =>
            ProductImageUncheckedCreateNestedManyWithoutProductVariantInputSchema,
        )
        .optional(),
      orderItems: z
        .lazy(
          () =>
            OrderItemUncheckedCreateNestedManyWithoutProductVariantInputSchema,
        )
        .optional(),
      cartItems: z
        .lazy(
          () =>
            CartItemUncheckedCreateNestedManyWithoutProductVariantInputSchema,
        )
        .optional(),
    })
    .strict() as z.ZodType<Prisma.ProductVariantUncheckedCreateWithoutProductInput>;

export const ProductVariantCreateOrConnectWithoutProductInputSchema: z.ZodType<Prisma.ProductVariantCreateOrConnectWithoutProductInput> =
  z
    .object({
      where: z.lazy(() => ProductVariantWhereUniqueInputSchema),
      create: z.union([
        z.lazy(() => ProductVariantCreateWithoutProductInputSchema),
        z.lazy(() => ProductVariantUncheckedCreateWithoutProductInputSchema),
      ]),
    })
    .strict() as z.ZodType<Prisma.ProductVariantCreateOrConnectWithoutProductInput>;

export const ProductVariantCreateManyProductInputEnvelopeSchema: z.ZodType<Prisma.ProductVariantCreateManyProductInputEnvelope> =
  z
    .object({
      data: z.union([
        z.lazy(() => ProductVariantCreateManyProductInputSchema),
        z.lazy(() => ProductVariantCreateManyProductInputSchema).array(),
      ]),
      skipDuplicates: z.boolean().optional(),
    })
    .strict() as z.ZodType<Prisma.ProductVariantCreateManyProductInputEnvelope>;

export const VendorUpsertWithoutProductsInputSchema: z.ZodType<Prisma.VendorUpsertWithoutProductsInput> =
  z
    .object({
      update: z.union([
        z.lazy(() => VendorUpdateWithoutProductsInputSchema),
        z.lazy(() => VendorUncheckedUpdateWithoutProductsInputSchema),
      ]),
      create: z.union([
        z.lazy(() => VendorCreateWithoutProductsInputSchema),
        z.lazy(() => VendorUncheckedCreateWithoutProductsInputSchema),
      ]),
      where: z.lazy(() => VendorWhereInputSchema).optional(),
    })
    .strict() as z.ZodType<Prisma.VendorUpsertWithoutProductsInput>;

export const VendorUpdateToOneWithWhereWithoutProductsInputSchema: z.ZodType<Prisma.VendorUpdateToOneWithWhereWithoutProductsInput> =
  z
    .object({
      where: z.lazy(() => VendorWhereInputSchema).optional(),
      data: z.union([
        z.lazy(() => VendorUpdateWithoutProductsInputSchema),
        z.lazy(() => VendorUncheckedUpdateWithoutProductsInputSchema),
      ]),
    })
    .strict() as z.ZodType<Prisma.VendorUpdateToOneWithWhereWithoutProductsInput>;

export const VendorUpdateWithoutProductsInputSchema: z.ZodType<Prisma.VendorUpdateWithoutProductsInput> =
  z
    .object({
      id: z
        .union([
          z.string().uuid(),
          z.lazy(() => StringFieldUpdateOperationsInputSchema),
        ])
        .optional(),
      name: z
        .union([
          z.string(),
          z.lazy(() => StringFieldUpdateOperationsInputSchema),
        ])
        .optional(),
      slug: z
        .union([
          z.string(),
          z.lazy(() => StringFieldUpdateOperationsInputSchema),
        ])
        .optional(),
      description: z
        .union([
          z.string(),
          z.lazy(() => NullableStringFieldUpdateOperationsInputSchema),
        ])
        .optional()
        .nullable(),
      logoUrl: z
        .union([
          z.string(),
          z.lazy(() => NullableStringFieldUpdateOperationsInputSchema),
        ])
        .optional()
        .nullable(),
      taxCode: z
        .union([
          z.string(),
          z.lazy(() => NullableStringFieldUpdateOperationsInputSchema),
        ])
        .optional()
        .nullable(),
      totalProducts: z
        .union([
          z.number().int(),
          z.lazy(() => IntFieldUpdateOperationsInputSchema),
        ])
        .optional(),
      totalOrders: z
        .union([
          z.number().int(),
          z.lazy(() => IntFieldUpdateOperationsInputSchema),
        ])
        .optional(),
      status: z
        .union([
          z.lazy(() => VendorStatusSchema),
          z.lazy(() => EnumVendorStatusFieldUpdateOperationsInputSchema),
        ])
        .optional(),
      createdAt: z
        .union([
          z.coerce.date(),
          z.lazy(() => DateTimeFieldUpdateOperationsInputSchema),
        ])
        .optional(),
      createdBy: z
        .union([
          z.string(),
          z.lazy(() => NullableStringFieldUpdateOperationsInputSchema),
        ])
        .optional()
        .nullable(),
      updatedAt: z
        .union([
          z.coerce.date(),
          z.lazy(() => DateTimeFieldUpdateOperationsInputSchema),
        ])
        .optional(),
      deletedAt: z
        .union([
          z.coerce.date(),
          z.lazy(() => NullableDateTimeFieldUpdateOperationsInputSchema),
        ])
        .optional()
        .nullable(),
      user: z
        .lazy(() => UserUpdateOneRequiredWithoutVendorsNestedInputSchema)
        .optional(),
      userVendorRoles: z
        .lazy(() => UserVendorRoleUpdateManyWithoutVendorNestedInputSchema)
        .optional(),
    })
    .strict() as z.ZodType<Prisma.VendorUpdateWithoutProductsInput>;

export const VendorUncheckedUpdateWithoutProductsInputSchema: z.ZodType<Prisma.VendorUncheckedUpdateWithoutProductsInput> =
  z
    .object({
      id: z
        .union([
          z.string().uuid(),
          z.lazy(() => StringFieldUpdateOperationsInputSchema),
        ])
        .optional(),
      userID: z
        .union([
          z.string(),
          z.lazy(() => StringFieldUpdateOperationsInputSchema),
        ])
        .optional(),
      name: z
        .union([
          z.string(),
          z.lazy(() => StringFieldUpdateOperationsInputSchema),
        ])
        .optional(),
      slug: z
        .union([
          z.string(),
          z.lazy(() => StringFieldUpdateOperationsInputSchema),
        ])
        .optional(),
      description: z
        .union([
          z.string(),
          z.lazy(() => NullableStringFieldUpdateOperationsInputSchema),
        ])
        .optional()
        .nullable(),
      logoUrl: z
        .union([
          z.string(),
          z.lazy(() => NullableStringFieldUpdateOperationsInputSchema),
        ])
        .optional()
        .nullable(),
      taxCode: z
        .union([
          z.string(),
          z.lazy(() => NullableStringFieldUpdateOperationsInputSchema),
        ])
        .optional()
        .nullable(),
      totalProducts: z
        .union([
          z.number().int(),
          z.lazy(() => IntFieldUpdateOperationsInputSchema),
        ])
        .optional(),
      totalOrders: z
        .union([
          z.number().int(),
          z.lazy(() => IntFieldUpdateOperationsInputSchema),
        ])
        .optional(),
      status: z
        .union([
          z.lazy(() => VendorStatusSchema),
          z.lazy(() => EnumVendorStatusFieldUpdateOperationsInputSchema),
        ])
        .optional(),
      createdAt: z
        .union([
          z.coerce.date(),
          z.lazy(() => DateTimeFieldUpdateOperationsInputSchema),
        ])
        .optional(),
      createdBy: z
        .union([
          z.string(),
          z.lazy(() => NullableStringFieldUpdateOperationsInputSchema),
        ])
        .optional()
        .nullable(),
      updatedAt: z
        .union([
          z.coerce.date(),
          z.lazy(() => DateTimeFieldUpdateOperationsInputSchema),
        ])
        .optional(),
      deletedAt: z
        .union([
          z.coerce.date(),
          z.lazy(() => NullableDateTimeFieldUpdateOperationsInputSchema),
        ])
        .optional()
        .nullable(),
      userVendorRoles: z
        .lazy(
          () => UserVendorRoleUncheckedUpdateManyWithoutVendorNestedInputSchema,
        )
        .optional(),
    })
    .strict() as z.ZodType<Prisma.VendorUncheckedUpdateWithoutProductsInput>;

export const ProductCategoryUpsertWithWhereUniqueWithoutProductInputSchema: z.ZodType<Prisma.ProductCategoryUpsertWithWhereUniqueWithoutProductInput> =
  z
    .object({
      where: z.lazy(() => ProductCategoryWhereUniqueInputSchema),
      update: z.union([
        z.lazy(() => ProductCategoryUpdateWithoutProductInputSchema),
        z.lazy(() => ProductCategoryUncheckedUpdateWithoutProductInputSchema),
      ]),
      create: z.union([
        z.lazy(() => ProductCategoryCreateWithoutProductInputSchema),
        z.lazy(() => ProductCategoryUncheckedCreateWithoutProductInputSchema),
      ]),
    })
    .strict() as z.ZodType<Prisma.ProductCategoryUpsertWithWhereUniqueWithoutProductInput>;

export const ProductCategoryUpdateWithWhereUniqueWithoutProductInputSchema: z.ZodType<Prisma.ProductCategoryUpdateWithWhereUniqueWithoutProductInput> =
  z
    .object({
      where: z.lazy(() => ProductCategoryWhereUniqueInputSchema),
      data: z.union([
        z.lazy(() => ProductCategoryUpdateWithoutProductInputSchema),
        z.lazy(() => ProductCategoryUncheckedUpdateWithoutProductInputSchema),
      ]),
    })
    .strict() as z.ZodType<Prisma.ProductCategoryUpdateWithWhereUniqueWithoutProductInput>;

export const ProductCategoryUpdateManyWithWhereWithoutProductInputSchema: z.ZodType<Prisma.ProductCategoryUpdateManyWithWhereWithoutProductInput> =
  z
    .object({
      where: z.lazy(() => ProductCategoryScalarWhereInputSchema),
      data: z.union([
        z.lazy(() => ProductCategoryUpdateManyMutationInputSchema),
        z.lazy(
          () => ProductCategoryUncheckedUpdateManyWithoutProductInputSchema,
        ),
      ]),
    })
    .strict() as z.ZodType<Prisma.ProductCategoryUpdateManyWithWhereWithoutProductInput>;

export const ProductImageUpsertWithWhereUniqueWithoutProductInputSchema: z.ZodType<Prisma.ProductImageUpsertWithWhereUniqueWithoutProductInput> =
  z
    .object({
      where: z.lazy(() => ProductImageWhereUniqueInputSchema),
      update: z.union([
        z.lazy(() => ProductImageUpdateWithoutProductInputSchema),
        z.lazy(() => ProductImageUncheckedUpdateWithoutProductInputSchema),
      ]),
      create: z.union([
        z.lazy(() => ProductImageCreateWithoutProductInputSchema),
        z.lazy(() => ProductImageUncheckedCreateWithoutProductInputSchema),
      ]),
    })
    .strict() as z.ZodType<Prisma.ProductImageUpsertWithWhereUniqueWithoutProductInput>;

export const ProductImageUpdateWithWhereUniqueWithoutProductInputSchema: z.ZodType<Prisma.ProductImageUpdateWithWhereUniqueWithoutProductInput> =
  z
    .object({
      where: z.lazy(() => ProductImageWhereUniqueInputSchema),
      data: z.union([
        z.lazy(() => ProductImageUpdateWithoutProductInputSchema),
        z.lazy(() => ProductImageUncheckedUpdateWithoutProductInputSchema),
      ]),
    })
    .strict() as z.ZodType<Prisma.ProductImageUpdateWithWhereUniqueWithoutProductInput>;

export const ProductImageUpdateManyWithWhereWithoutProductInputSchema: z.ZodType<Prisma.ProductImageUpdateManyWithWhereWithoutProductInput> =
  z
    .object({
      where: z.lazy(() => ProductImageScalarWhereInputSchema),
      data: z.union([
        z.lazy(() => ProductImageUpdateManyMutationInputSchema),
        z.lazy(() => ProductImageUncheckedUpdateManyWithoutProductInputSchema),
      ]),
    })
    .strict() as z.ZodType<Prisma.ProductImageUpdateManyWithWhereWithoutProductInput>;

export const ProductImageScalarWhereInputSchema: z.ZodType<Prisma.ProductImageScalarWhereInput> =
  z
    .object({
      AND: z
        .union([
          z.lazy(() => ProductImageScalarWhereInputSchema),
          z.lazy(() => ProductImageScalarWhereInputSchema).array(),
        ])
        .optional(),
      OR: z
        .lazy(() => ProductImageScalarWhereInputSchema)
        .array()
        .optional(),
      NOT: z
        .union([
          z.lazy(() => ProductImageScalarWhereInputSchema),
          z.lazy(() => ProductImageScalarWhereInputSchema).array(),
        ])
        .optional(),
      id: z.union([z.lazy(() => StringFilterSchema), z.string()]).optional(),
      name: z.union([z.lazy(() => StringFilterSchema), z.string()]).optional(),
      description: z
        .union([z.lazy(() => StringNullableFilterSchema), z.string()])
        .optional()
        .nullable(),
      productID: z
        .union([z.lazy(() => StringNullableFilterSchema), z.string()])
        .optional()
        .nullable(),
      productVariantID: z
        .union([z.lazy(() => StringNullableFilterSchema), z.string()])
        .optional()
        .nullable(),
      imageUrl: z
        .union([z.lazy(() => StringFilterSchema), z.string()])
        .optional(),
      sortOrder: z
        .union([z.lazy(() => IntFilterSchema), z.number()])
        .optional(),
      createdAt: z
        .union([z.lazy(() => DateTimeFilterSchema), z.coerce.date()])
        .optional(),
      createdBy: z
        .union([z.lazy(() => StringNullableFilterSchema), z.string()])
        .optional()
        .nullable(),
      updatedAt: z
        .union([z.lazy(() => DateTimeFilterSchema), z.coerce.date()])
        .optional(),
      deletedAt: z
        .union([z.lazy(() => DateTimeNullableFilterSchema), z.coerce.date()])
        .optional()
        .nullable(),
    })
    .strict() as z.ZodType<Prisma.ProductImageScalarWhereInput>;

export const ProductVariantUpsertWithWhereUniqueWithoutProductInputSchema: z.ZodType<Prisma.ProductVariantUpsertWithWhereUniqueWithoutProductInput> =
  z
    .object({
      where: z.lazy(() => ProductVariantWhereUniqueInputSchema),
      update: z.union([
        z.lazy(() => ProductVariantUpdateWithoutProductInputSchema),
        z.lazy(() => ProductVariantUncheckedUpdateWithoutProductInputSchema),
      ]),
      create: z.union([
        z.lazy(() => ProductVariantCreateWithoutProductInputSchema),
        z.lazy(() => ProductVariantUncheckedCreateWithoutProductInputSchema),
      ]),
    })
    .strict() as z.ZodType<Prisma.ProductVariantUpsertWithWhereUniqueWithoutProductInput>;

export const ProductVariantUpdateWithWhereUniqueWithoutProductInputSchema: z.ZodType<Prisma.ProductVariantUpdateWithWhereUniqueWithoutProductInput> =
  z
    .object({
      where: z.lazy(() => ProductVariantWhereUniqueInputSchema),
      data: z.union([
        z.lazy(() => ProductVariantUpdateWithoutProductInputSchema),
        z.lazy(() => ProductVariantUncheckedUpdateWithoutProductInputSchema),
      ]),
    })
    .strict() as z.ZodType<Prisma.ProductVariantUpdateWithWhereUniqueWithoutProductInput>;

export const ProductVariantUpdateManyWithWhereWithoutProductInputSchema: z.ZodType<Prisma.ProductVariantUpdateManyWithWhereWithoutProductInput> =
  z
    .object({
      where: z.lazy(() => ProductVariantScalarWhereInputSchema),
      data: z.union([
        z.lazy(() => ProductVariantUpdateManyMutationInputSchema),
        z.lazy(
          () => ProductVariantUncheckedUpdateManyWithoutProductInputSchema,
        ),
      ]),
    })
    .strict() as z.ZodType<Prisma.ProductVariantUpdateManyWithWhereWithoutProductInput>;

export const ProductVariantScalarWhereInputSchema: z.ZodType<Prisma.ProductVariantScalarWhereInput> =
  z
    .object({
      AND: z
        .union([
          z.lazy(() => ProductVariantScalarWhereInputSchema),
          z.lazy(() => ProductVariantScalarWhereInputSchema).array(),
        ])
        .optional(),
      OR: z
        .lazy(() => ProductVariantScalarWhereInputSchema)
        .array()
        .optional(),
      NOT: z
        .union([
          z.lazy(() => ProductVariantScalarWhereInputSchema),
          z.lazy(() => ProductVariantScalarWhereInputSchema).array(),
        ])
        .optional(),
      id: z.union([z.lazy(() => StringFilterSchema), z.string()]).optional(),
      productID: z
        .union([z.lazy(() => StringFilterSchema), z.string()])
        .optional(),
      name: z
        .union([z.lazy(() => StringNullableFilterSchema), z.string()])
        .optional()
        .nullable(),
      sku: z
        .union([z.lazy(() => StringNullableFilterSchema), z.string()])
        .optional()
        .nullable(),
      price: z
        .union([
          z.lazy(() => DecimalFilterSchema),
          z
            .union([
              z.number(),
              z.string(),
              z.instanceof(Decimal),
              z.instanceof(Prisma.Decimal),
              DecimalJsLikeSchema,
            ])
            .refine((v) => isValidDecimalInput(v), {
              message: 'Must be a Decimal',
            }),
        ])
        .optional(),
      stockQuantity: z
        .union([z.lazy(() => IntFilterSchema), z.number()])
        .optional(),
      attributes: z.lazy(() => JsonNullableFilterSchema).optional(),
      createdAt: z
        .union([z.lazy(() => DateTimeFilterSchema), z.coerce.date()])
        .optional(),
      createdBy: z
        .union([z.lazy(() => StringNullableFilterSchema), z.string()])
        .optional()
        .nullable(),
      updatedAt: z
        .union([z.lazy(() => DateTimeFilterSchema), z.coerce.date()])
        .optional(),
      deletedAt: z
        .union([z.lazy(() => DateTimeNullableFilterSchema), z.coerce.date()])
        .optional()
        .nullable(),
    })
    .strict() as z.ZodType<Prisma.ProductVariantScalarWhereInput>;

export const ProductCreateWithoutProductVariantsInputSchema: z.ZodType<Prisma.ProductCreateWithoutProductVariantsInput> =
  z
    .object({
      id: z.string().uuid().optional(),
      name: z.string(),
      slug: z.string(),
      description: z.string().optional().nullable(),
      sku: z.string().optional().nullable(),
      price: z
        .union([
          z.number(),
          z.string(),
          z.instanceof(Decimal),
          z.instanceof(Prisma.Decimal),
          DecimalJsLikeSchema,
        ])
        .refine((v) => isValidDecimalInput(v), {
          message: 'Must be a Decimal',
        }),
      stockQuantity: z.number().int().optional(),
      status: z.lazy(() => ProductStatusSchema).optional(),
      createdAt: z.coerce.date().optional(),
      createdBy: z.string().optional().nullable(),
      updatedAt: z.coerce.date().optional(),
      deletedAt: z.coerce.date().optional().nullable(),
      vendor: z.lazy(() => VendorCreateNestedOneWithoutProductsInputSchema),
      productCategories: z
        .lazy(() => ProductCategoryCreateNestedManyWithoutProductInputSchema)
        .optional(),
      productImages: z
        .lazy(() => ProductImageCreateNestedManyWithoutProductInputSchema)
        .optional(),
    })
    .strict() as z.ZodType<Prisma.ProductCreateWithoutProductVariantsInput>;

export const ProductUncheckedCreateWithoutProductVariantsInputSchema: z.ZodType<Prisma.ProductUncheckedCreateWithoutProductVariantsInput> =
  z
    .object({
      id: z.string().uuid().optional(),
      vendorID: z.string(),
      name: z.string(),
      slug: z.string(),
      description: z.string().optional().nullable(),
      sku: z.string().optional().nullable(),
      price: z
        .union([
          z.number(),
          z.string(),
          z.instanceof(Decimal),
          z.instanceof(Prisma.Decimal),
          DecimalJsLikeSchema,
        ])
        .refine((v) => isValidDecimalInput(v), {
          message: 'Must be a Decimal',
        }),
      stockQuantity: z.number().int().optional(),
      status: z.lazy(() => ProductStatusSchema).optional(),
      createdAt: z.coerce.date().optional(),
      createdBy: z.string().optional().nullable(),
      updatedAt: z.coerce.date().optional(),
      deletedAt: z.coerce.date().optional().nullable(),
      productCategories: z
        .lazy(
          () =>
            ProductCategoryUncheckedCreateNestedManyWithoutProductInputSchema,
        )
        .optional(),
      productImages: z
        .lazy(
          () => ProductImageUncheckedCreateNestedManyWithoutProductInputSchema,
        )
        .optional(),
    })
    .strict() as z.ZodType<Prisma.ProductUncheckedCreateWithoutProductVariantsInput>;

export const ProductCreateOrConnectWithoutProductVariantsInputSchema: z.ZodType<Prisma.ProductCreateOrConnectWithoutProductVariantsInput> =
  z
    .object({
      where: z.lazy(() => ProductWhereUniqueInputSchema),
      create: z.union([
        z.lazy(() => ProductCreateWithoutProductVariantsInputSchema),
        z.lazy(() => ProductUncheckedCreateWithoutProductVariantsInputSchema),
      ]),
    })
    .strict() as z.ZodType<Prisma.ProductCreateOrConnectWithoutProductVariantsInput>;

export const ProductImageCreateWithoutProductVariantInputSchema: z.ZodType<Prisma.ProductImageCreateWithoutProductVariantInput> =
  z
    .object({
      id: z.string().uuid().optional(),
      name: z.string(),
      description: z.string().optional().nullable(),
      imageUrl: z.string(),
      sortOrder: z.number().int().optional(),
      createdAt: z.coerce.date().optional(),
      createdBy: z.string().optional().nullable(),
      updatedAt: z.coerce.date().optional(),
      deletedAt: z.coerce.date().optional().nullable(),
      product: z
        .lazy(() => ProductCreateNestedOneWithoutProductImagesInputSchema)
        .optional(),
    })
    .strict() as z.ZodType<Prisma.ProductImageCreateWithoutProductVariantInput>;

export const ProductImageUncheckedCreateWithoutProductVariantInputSchema: z.ZodType<Prisma.ProductImageUncheckedCreateWithoutProductVariantInput> =
  z
    .object({
      id: z.string().uuid().optional(),
      name: z.string(),
      description: z.string().optional().nullable(),
      productID: z.string().optional().nullable(),
      imageUrl: z.string(),
      sortOrder: z.number().int().optional(),
      createdAt: z.coerce.date().optional(),
      createdBy: z.string().optional().nullable(),
      updatedAt: z.coerce.date().optional(),
      deletedAt: z.coerce.date().optional().nullable(),
    })
    .strict() as z.ZodType<Prisma.ProductImageUncheckedCreateWithoutProductVariantInput>;

export const ProductImageCreateOrConnectWithoutProductVariantInputSchema: z.ZodType<Prisma.ProductImageCreateOrConnectWithoutProductVariantInput> =
  z
    .object({
      where: z.lazy(() => ProductImageWhereUniqueInputSchema),
      create: z.union([
        z.lazy(() => ProductImageCreateWithoutProductVariantInputSchema),
        z.lazy(
          () => ProductImageUncheckedCreateWithoutProductVariantInputSchema,
        ),
      ]),
    })
    .strict() as z.ZodType<Prisma.ProductImageCreateOrConnectWithoutProductVariantInput>;

export const ProductImageCreateManyProductVariantInputEnvelopeSchema: z.ZodType<Prisma.ProductImageCreateManyProductVariantInputEnvelope> =
  z
    .object({
      data: z.union([
        z.lazy(() => ProductImageCreateManyProductVariantInputSchema),
        z.lazy(() => ProductImageCreateManyProductVariantInputSchema).array(),
      ]),
      skipDuplicates: z.boolean().optional(),
    })
    .strict() as z.ZodType<Prisma.ProductImageCreateManyProductVariantInputEnvelope>;

export const OrderItemCreateWithoutProductVariantInputSchema: z.ZodType<Prisma.OrderItemCreateWithoutProductVariantInput> =
  z
    .object({
      id: z.string().uuid().optional(),
      quantity: z.number().int().optional(),
      unitPrice: z
        .union([
          z.number(),
          z.string(),
          z.instanceof(Decimal),
          z.instanceof(Prisma.Decimal),
          DecimalJsLikeSchema,
        ])
        .refine((v) => isValidDecimalInput(v), {
          message: 'Must be a Decimal',
        }),
      totalPrice: z
        .union([
          z.number(),
          z.string(),
          z.instanceof(Decimal),
          z.instanceof(Prisma.Decimal),
          DecimalJsLikeSchema,
        ])
        .refine((v) => isValidDecimalInput(v), {
          message: 'Must be a Decimal',
        }),
      productVariantSnapshot: z
        .union([
          z.lazy(() => NullableJsonNullValueInputSchema),
          InputJsonValueSchema,
        ])
        .optional(),
      order: z.lazy(() => OrderCreateNestedOneWithoutOrderItemsInputSchema),
    })
    .strict() as z.ZodType<Prisma.OrderItemCreateWithoutProductVariantInput>;

export const OrderItemUncheckedCreateWithoutProductVariantInputSchema: z.ZodType<Prisma.OrderItemUncheckedCreateWithoutProductVariantInput> =
  z
    .object({
      id: z.string().uuid().optional(),
      orderID: z.string(),
      quantity: z.number().int().optional(),
      unitPrice: z
        .union([
          z.number(),
          z.string(),
          z.instanceof(Decimal),
          z.instanceof(Prisma.Decimal),
          DecimalJsLikeSchema,
        ])
        .refine((v) => isValidDecimalInput(v), {
          message: 'Must be a Decimal',
        }),
      totalPrice: z
        .union([
          z.number(),
          z.string(),
          z.instanceof(Decimal),
          z.instanceof(Prisma.Decimal),
          DecimalJsLikeSchema,
        ])
        .refine((v) => isValidDecimalInput(v), {
          message: 'Must be a Decimal',
        }),
      productVariantSnapshot: z
        .union([
          z.lazy(() => NullableJsonNullValueInputSchema),
          InputJsonValueSchema,
        ])
        .optional(),
    })
    .strict() as z.ZodType<Prisma.OrderItemUncheckedCreateWithoutProductVariantInput>;

export const OrderItemCreateOrConnectWithoutProductVariantInputSchema: z.ZodType<Prisma.OrderItemCreateOrConnectWithoutProductVariantInput> =
  z
    .object({
      where: z.lazy(() => OrderItemWhereUniqueInputSchema),
      create: z.union([
        z.lazy(() => OrderItemCreateWithoutProductVariantInputSchema),
        z.lazy(() => OrderItemUncheckedCreateWithoutProductVariantInputSchema),
      ]),
    })
    .strict() as z.ZodType<Prisma.OrderItemCreateOrConnectWithoutProductVariantInput>;

export const OrderItemCreateManyProductVariantInputEnvelopeSchema: z.ZodType<Prisma.OrderItemCreateManyProductVariantInputEnvelope> =
  z
    .object({
      data: z.union([
        z.lazy(() => OrderItemCreateManyProductVariantInputSchema),
        z.lazy(() => OrderItemCreateManyProductVariantInputSchema).array(),
      ]),
      skipDuplicates: z.boolean().optional(),
    })
    .strict() as z.ZodType<Prisma.OrderItemCreateManyProductVariantInputEnvelope>;

export const CartItemCreateWithoutProductVariantInputSchema: z.ZodType<Prisma.CartItemCreateWithoutProductVariantInput> =
  z
    .object({
      id: z.string().uuid().optional(),
      quantity: z.number().int().optional(),
      createdAt: z.coerce.date().optional(),
      updatedAt: z.coerce.date().optional(),
      cart: z.lazy(() => CartCreateNestedOneWithoutCartItemsInputSchema),
    })
    .strict() as z.ZodType<Prisma.CartItemCreateWithoutProductVariantInput>;

export const CartItemUncheckedCreateWithoutProductVariantInputSchema: z.ZodType<Prisma.CartItemUncheckedCreateWithoutProductVariantInput> =
  z
    .object({
      id: z.string().uuid().optional(),
      cartID: z.string(),
      quantity: z.number().int().optional(),
      createdAt: z.coerce.date().optional(),
      updatedAt: z.coerce.date().optional(),
    })
    .strict() as z.ZodType<Prisma.CartItemUncheckedCreateWithoutProductVariantInput>;

export const CartItemCreateOrConnectWithoutProductVariantInputSchema: z.ZodType<Prisma.CartItemCreateOrConnectWithoutProductVariantInput> =
  z
    .object({
      where: z.lazy(() => CartItemWhereUniqueInputSchema),
      create: z.union([
        z.lazy(() => CartItemCreateWithoutProductVariantInputSchema),
        z.lazy(() => CartItemUncheckedCreateWithoutProductVariantInputSchema),
      ]),
    })
    .strict() as z.ZodType<Prisma.CartItemCreateOrConnectWithoutProductVariantInput>;

export const CartItemCreateManyProductVariantInputEnvelopeSchema: z.ZodType<Prisma.CartItemCreateManyProductVariantInputEnvelope> =
  z
    .object({
      data: z.union([
        z.lazy(() => CartItemCreateManyProductVariantInputSchema),
        z.lazy(() => CartItemCreateManyProductVariantInputSchema).array(),
      ]),
      skipDuplicates: z.boolean().optional(),
    })
    .strict() as z.ZodType<Prisma.CartItemCreateManyProductVariantInputEnvelope>;

export const ProductUpsertWithoutProductVariantsInputSchema: z.ZodType<Prisma.ProductUpsertWithoutProductVariantsInput> =
  z
    .object({
      update: z.union([
        z.lazy(() => ProductUpdateWithoutProductVariantsInputSchema),
        z.lazy(() => ProductUncheckedUpdateWithoutProductVariantsInputSchema),
      ]),
      create: z.union([
        z.lazy(() => ProductCreateWithoutProductVariantsInputSchema),
        z.lazy(() => ProductUncheckedCreateWithoutProductVariantsInputSchema),
      ]),
      where: z.lazy(() => ProductWhereInputSchema).optional(),
    })
    .strict() as z.ZodType<Prisma.ProductUpsertWithoutProductVariantsInput>;

export const ProductUpdateToOneWithWhereWithoutProductVariantsInputSchema: z.ZodType<Prisma.ProductUpdateToOneWithWhereWithoutProductVariantsInput> =
  z
    .object({
      where: z.lazy(() => ProductWhereInputSchema).optional(),
      data: z.union([
        z.lazy(() => ProductUpdateWithoutProductVariantsInputSchema),
        z.lazy(() => ProductUncheckedUpdateWithoutProductVariantsInputSchema),
      ]),
    })
    .strict() as z.ZodType<Prisma.ProductUpdateToOneWithWhereWithoutProductVariantsInput>;

export const ProductUpdateWithoutProductVariantsInputSchema: z.ZodType<Prisma.ProductUpdateWithoutProductVariantsInput> =
  z
    .object({
      id: z
        .union([
          z.string().uuid(),
          z.lazy(() => StringFieldUpdateOperationsInputSchema),
        ])
        .optional(),
      name: z
        .union([
          z.string(),
          z.lazy(() => StringFieldUpdateOperationsInputSchema),
        ])
        .optional(),
      slug: z
        .union([
          z.string(),
          z.lazy(() => StringFieldUpdateOperationsInputSchema),
        ])
        .optional(),
      description: z
        .union([
          z.string(),
          z.lazy(() => NullableStringFieldUpdateOperationsInputSchema),
        ])
        .optional()
        .nullable(),
      sku: z
        .union([
          z.string(),
          z.lazy(() => NullableStringFieldUpdateOperationsInputSchema),
        ])
        .optional()
        .nullable(),
      price: z
        .union([
          z
            .union([
              z.number(),
              z.string(),
              z.instanceof(Decimal),
              z.instanceof(Prisma.Decimal),
              DecimalJsLikeSchema,
            ])
            .refine((v) => isValidDecimalInput(v), {
              message: 'Must be a Decimal',
            }),
          z.lazy(() => DecimalFieldUpdateOperationsInputSchema),
        ])
        .optional(),
      stockQuantity: z
        .union([
          z.number().int(),
          z.lazy(() => IntFieldUpdateOperationsInputSchema),
        ])
        .optional(),
      status: z
        .union([
          z.lazy(() => ProductStatusSchema),
          z.lazy(() => EnumProductStatusFieldUpdateOperationsInputSchema),
        ])
        .optional(),
      createdAt: z
        .union([
          z.coerce.date(),
          z.lazy(() => DateTimeFieldUpdateOperationsInputSchema),
        ])
        .optional(),
      createdBy: z
        .union([
          z.string(),
          z.lazy(() => NullableStringFieldUpdateOperationsInputSchema),
        ])
        .optional()
        .nullable(),
      updatedAt: z
        .union([
          z.coerce.date(),
          z.lazy(() => DateTimeFieldUpdateOperationsInputSchema),
        ])
        .optional(),
      deletedAt: z
        .union([
          z.coerce.date(),
          z.lazy(() => NullableDateTimeFieldUpdateOperationsInputSchema),
        ])
        .optional()
        .nullable(),
      vendor: z
        .lazy(() => VendorUpdateOneRequiredWithoutProductsNestedInputSchema)
        .optional(),
      productCategories: z
        .lazy(() => ProductCategoryUpdateManyWithoutProductNestedInputSchema)
        .optional(),
      productImages: z
        .lazy(() => ProductImageUpdateManyWithoutProductNestedInputSchema)
        .optional(),
    })
    .strict() as z.ZodType<Prisma.ProductUpdateWithoutProductVariantsInput>;

export const ProductUncheckedUpdateWithoutProductVariantsInputSchema: z.ZodType<Prisma.ProductUncheckedUpdateWithoutProductVariantsInput> =
  z
    .object({
      id: z
        .union([
          z.string().uuid(),
          z.lazy(() => StringFieldUpdateOperationsInputSchema),
        ])
        .optional(),
      vendorID: z
        .union([
          z.string(),
          z.lazy(() => StringFieldUpdateOperationsInputSchema),
        ])
        .optional(),
      name: z
        .union([
          z.string(),
          z.lazy(() => StringFieldUpdateOperationsInputSchema),
        ])
        .optional(),
      slug: z
        .union([
          z.string(),
          z.lazy(() => StringFieldUpdateOperationsInputSchema),
        ])
        .optional(),
      description: z
        .union([
          z.string(),
          z.lazy(() => NullableStringFieldUpdateOperationsInputSchema),
        ])
        .optional()
        .nullable(),
      sku: z
        .union([
          z.string(),
          z.lazy(() => NullableStringFieldUpdateOperationsInputSchema),
        ])
        .optional()
        .nullable(),
      price: z
        .union([
          z
            .union([
              z.number(),
              z.string(),
              z.instanceof(Decimal),
              z.instanceof(Prisma.Decimal),
              DecimalJsLikeSchema,
            ])
            .refine((v) => isValidDecimalInput(v), {
              message: 'Must be a Decimal',
            }),
          z.lazy(() => DecimalFieldUpdateOperationsInputSchema),
        ])
        .optional(),
      stockQuantity: z
        .union([
          z.number().int(),
          z.lazy(() => IntFieldUpdateOperationsInputSchema),
        ])
        .optional(),
      status: z
        .union([
          z.lazy(() => ProductStatusSchema),
          z.lazy(() => EnumProductStatusFieldUpdateOperationsInputSchema),
        ])
        .optional(),
      createdAt: z
        .union([
          z.coerce.date(),
          z.lazy(() => DateTimeFieldUpdateOperationsInputSchema),
        ])
        .optional(),
      createdBy: z
        .union([
          z.string(),
          z.lazy(() => NullableStringFieldUpdateOperationsInputSchema),
        ])
        .optional()
        .nullable(),
      updatedAt: z
        .union([
          z.coerce.date(),
          z.lazy(() => DateTimeFieldUpdateOperationsInputSchema),
        ])
        .optional(),
      deletedAt: z
        .union([
          z.coerce.date(),
          z.lazy(() => NullableDateTimeFieldUpdateOperationsInputSchema),
        ])
        .optional()
        .nullable(),
      productCategories: z
        .lazy(
          () =>
            ProductCategoryUncheckedUpdateManyWithoutProductNestedInputSchema,
        )
        .optional(),
      productImages: z
        .lazy(
          () => ProductImageUncheckedUpdateManyWithoutProductNestedInputSchema,
        )
        .optional(),
    })
    .strict() as z.ZodType<Prisma.ProductUncheckedUpdateWithoutProductVariantsInput>;

export const ProductImageUpsertWithWhereUniqueWithoutProductVariantInputSchema: z.ZodType<Prisma.ProductImageUpsertWithWhereUniqueWithoutProductVariantInput> =
  z
    .object({
      where: z.lazy(() => ProductImageWhereUniqueInputSchema),
      update: z.union([
        z.lazy(() => ProductImageUpdateWithoutProductVariantInputSchema),
        z.lazy(
          () => ProductImageUncheckedUpdateWithoutProductVariantInputSchema,
        ),
      ]),
      create: z.union([
        z.lazy(() => ProductImageCreateWithoutProductVariantInputSchema),
        z.lazy(
          () => ProductImageUncheckedCreateWithoutProductVariantInputSchema,
        ),
      ]),
    })
    .strict() as z.ZodType<Prisma.ProductImageUpsertWithWhereUniqueWithoutProductVariantInput>;

export const ProductImageUpdateWithWhereUniqueWithoutProductVariantInputSchema: z.ZodType<Prisma.ProductImageUpdateWithWhereUniqueWithoutProductVariantInput> =
  z
    .object({
      where: z.lazy(() => ProductImageWhereUniqueInputSchema),
      data: z.union([
        z.lazy(() => ProductImageUpdateWithoutProductVariantInputSchema),
        z.lazy(
          () => ProductImageUncheckedUpdateWithoutProductVariantInputSchema,
        ),
      ]),
    })
    .strict() as z.ZodType<Prisma.ProductImageUpdateWithWhereUniqueWithoutProductVariantInput>;

export const ProductImageUpdateManyWithWhereWithoutProductVariantInputSchema: z.ZodType<Prisma.ProductImageUpdateManyWithWhereWithoutProductVariantInput> =
  z
    .object({
      where: z.lazy(() => ProductImageScalarWhereInputSchema),
      data: z.union([
        z.lazy(() => ProductImageUpdateManyMutationInputSchema),
        z.lazy(
          () => ProductImageUncheckedUpdateManyWithoutProductVariantInputSchema,
        ),
      ]),
    })
    .strict() as z.ZodType<Prisma.ProductImageUpdateManyWithWhereWithoutProductVariantInput>;

export const OrderItemUpsertWithWhereUniqueWithoutProductVariantInputSchema: z.ZodType<Prisma.OrderItemUpsertWithWhereUniqueWithoutProductVariantInput> =
  z
    .object({
      where: z.lazy(() => OrderItemWhereUniqueInputSchema),
      update: z.union([
        z.lazy(() => OrderItemUpdateWithoutProductVariantInputSchema),
        z.lazy(() => OrderItemUncheckedUpdateWithoutProductVariantInputSchema),
      ]),
      create: z.union([
        z.lazy(() => OrderItemCreateWithoutProductVariantInputSchema),
        z.lazy(() => OrderItemUncheckedCreateWithoutProductVariantInputSchema),
      ]),
    })
    .strict() as z.ZodType<Prisma.OrderItemUpsertWithWhereUniqueWithoutProductVariantInput>;

export const OrderItemUpdateWithWhereUniqueWithoutProductVariantInputSchema: z.ZodType<Prisma.OrderItemUpdateWithWhereUniqueWithoutProductVariantInput> =
  z
    .object({
      where: z.lazy(() => OrderItemWhereUniqueInputSchema),
      data: z.union([
        z.lazy(() => OrderItemUpdateWithoutProductVariantInputSchema),
        z.lazy(() => OrderItemUncheckedUpdateWithoutProductVariantInputSchema),
      ]),
    })
    .strict() as z.ZodType<Prisma.OrderItemUpdateWithWhereUniqueWithoutProductVariantInput>;

export const OrderItemUpdateManyWithWhereWithoutProductVariantInputSchema: z.ZodType<Prisma.OrderItemUpdateManyWithWhereWithoutProductVariantInput> =
  z
    .object({
      where: z.lazy(() => OrderItemScalarWhereInputSchema),
      data: z.union([
        z.lazy(() => OrderItemUpdateManyMutationInputSchema),
        z.lazy(
          () => OrderItemUncheckedUpdateManyWithoutProductVariantInputSchema,
        ),
      ]),
    })
    .strict() as z.ZodType<Prisma.OrderItemUpdateManyWithWhereWithoutProductVariantInput>;

export const OrderItemScalarWhereInputSchema: z.ZodType<Prisma.OrderItemScalarWhereInput> =
  z
    .object({
      AND: z
        .union([
          z.lazy(() => OrderItemScalarWhereInputSchema),
          z.lazy(() => OrderItemScalarWhereInputSchema).array(),
        ])
        .optional(),
      OR: z
        .lazy(() => OrderItemScalarWhereInputSchema)
        .array()
        .optional(),
      NOT: z
        .union([
          z.lazy(() => OrderItemScalarWhereInputSchema),
          z.lazy(() => OrderItemScalarWhereInputSchema).array(),
        ])
        .optional(),
      id: z.union([z.lazy(() => StringFilterSchema), z.string()]).optional(),
      orderID: z
        .union([z.lazy(() => StringFilterSchema), z.string()])
        .optional(),
      productVariantID: z
        .union([z.lazy(() => StringFilterSchema), z.string()])
        .optional(),
      quantity: z.union([z.lazy(() => IntFilterSchema), z.number()]).optional(),
      unitPrice: z
        .union([
          z.lazy(() => DecimalFilterSchema),
          z
            .union([
              z.number(),
              z.string(),
              z.instanceof(Decimal),
              z.instanceof(Prisma.Decimal),
              DecimalJsLikeSchema,
            ])
            .refine((v) => isValidDecimalInput(v), {
              message: 'Must be a Decimal',
            }),
        ])
        .optional(),
      totalPrice: z
        .union([
          z.lazy(() => DecimalFilterSchema),
          z
            .union([
              z.number(),
              z.string(),
              z.instanceof(Decimal),
              z.instanceof(Prisma.Decimal),
              DecimalJsLikeSchema,
            ])
            .refine((v) => isValidDecimalInput(v), {
              message: 'Must be a Decimal',
            }),
        ])
        .optional(),
      productVariantSnapshot: z.lazy(() => JsonNullableFilterSchema).optional(),
    })
    .strict() as z.ZodType<Prisma.OrderItemScalarWhereInput>;

export const CartItemUpsertWithWhereUniqueWithoutProductVariantInputSchema: z.ZodType<Prisma.CartItemUpsertWithWhereUniqueWithoutProductVariantInput> =
  z
    .object({
      where: z.lazy(() => CartItemWhereUniqueInputSchema),
      update: z.union([
        z.lazy(() => CartItemUpdateWithoutProductVariantInputSchema),
        z.lazy(() => CartItemUncheckedUpdateWithoutProductVariantInputSchema),
      ]),
      create: z.union([
        z.lazy(() => CartItemCreateWithoutProductVariantInputSchema),
        z.lazy(() => CartItemUncheckedCreateWithoutProductVariantInputSchema),
      ]),
    })
    .strict() as z.ZodType<Prisma.CartItemUpsertWithWhereUniqueWithoutProductVariantInput>;

export const CartItemUpdateWithWhereUniqueWithoutProductVariantInputSchema: z.ZodType<Prisma.CartItemUpdateWithWhereUniqueWithoutProductVariantInput> =
  z
    .object({
      where: z.lazy(() => CartItemWhereUniqueInputSchema),
      data: z.union([
        z.lazy(() => CartItemUpdateWithoutProductVariantInputSchema),
        z.lazy(() => CartItemUncheckedUpdateWithoutProductVariantInputSchema),
      ]),
    })
    .strict() as z.ZodType<Prisma.CartItemUpdateWithWhereUniqueWithoutProductVariantInput>;

export const CartItemUpdateManyWithWhereWithoutProductVariantInputSchema: z.ZodType<Prisma.CartItemUpdateManyWithWhereWithoutProductVariantInput> =
  z
    .object({
      where: z.lazy(() => CartItemScalarWhereInputSchema),
      data: z.union([
        z.lazy(() => CartItemUpdateManyMutationInputSchema),
        z.lazy(
          () => CartItemUncheckedUpdateManyWithoutProductVariantInputSchema,
        ),
      ]),
    })
    .strict() as z.ZodType<Prisma.CartItemUpdateManyWithWhereWithoutProductVariantInput>;

export const CartItemScalarWhereInputSchema: z.ZodType<Prisma.CartItemScalarWhereInput> =
  z
    .object({
      AND: z
        .union([
          z.lazy(() => CartItemScalarWhereInputSchema),
          z.lazy(() => CartItemScalarWhereInputSchema).array(),
        ])
        .optional(),
      OR: z
        .lazy(() => CartItemScalarWhereInputSchema)
        .array()
        .optional(),
      NOT: z
        .union([
          z.lazy(() => CartItemScalarWhereInputSchema),
          z.lazy(() => CartItemScalarWhereInputSchema).array(),
        ])
        .optional(),
      id: z.union([z.lazy(() => StringFilterSchema), z.string()]).optional(),
      cartID: z
        .union([z.lazy(() => StringFilterSchema), z.string()])
        .optional(),
      productVariantID: z
        .union([z.lazy(() => StringFilterSchema), z.string()])
        .optional(),
      quantity: z.union([z.lazy(() => IntFilterSchema), z.number()]).optional(),
      createdAt: z
        .union([z.lazy(() => DateTimeFilterSchema), z.coerce.date()])
        .optional(),
      updatedAt: z
        .union([z.lazy(() => DateTimeFilterSchema), z.coerce.date()])
        .optional(),
    })
    .strict() as z.ZodType<Prisma.CartItemScalarWhereInput>;

export const ProductCreateWithoutProductCategoriesInputSchema: z.ZodType<Prisma.ProductCreateWithoutProductCategoriesInput> =
  z
    .object({
      id: z.string().uuid().optional(),
      name: z.string(),
      slug: z.string(),
      description: z.string().optional().nullable(),
      sku: z.string().optional().nullable(),
      price: z
        .union([
          z.number(),
          z.string(),
          z.instanceof(Decimal),
          z.instanceof(Prisma.Decimal),
          DecimalJsLikeSchema,
        ])
        .refine((v) => isValidDecimalInput(v), {
          message: 'Must be a Decimal',
        }),
      stockQuantity: z.number().int().optional(),
      status: z.lazy(() => ProductStatusSchema).optional(),
      createdAt: z.coerce.date().optional(),
      createdBy: z.string().optional().nullable(),
      updatedAt: z.coerce.date().optional(),
      deletedAt: z.coerce.date().optional().nullable(),
      vendor: z.lazy(() => VendorCreateNestedOneWithoutProductsInputSchema),
      productImages: z
        .lazy(() => ProductImageCreateNestedManyWithoutProductInputSchema)
        .optional(),
      productVariants: z
        .lazy(() => ProductVariantCreateNestedManyWithoutProductInputSchema)
        .optional(),
    })
    .strict() as z.ZodType<Prisma.ProductCreateWithoutProductCategoriesInput>;

export const ProductUncheckedCreateWithoutProductCategoriesInputSchema: z.ZodType<Prisma.ProductUncheckedCreateWithoutProductCategoriesInput> =
  z
    .object({
      id: z.string().uuid().optional(),
      vendorID: z.string(),
      name: z.string(),
      slug: z.string(),
      description: z.string().optional().nullable(),
      sku: z.string().optional().nullable(),
      price: z
        .union([
          z.number(),
          z.string(),
          z.instanceof(Decimal),
          z.instanceof(Prisma.Decimal),
          DecimalJsLikeSchema,
        ])
        .refine((v) => isValidDecimalInput(v), {
          message: 'Must be a Decimal',
        }),
      stockQuantity: z.number().int().optional(),
      status: z.lazy(() => ProductStatusSchema).optional(),
      createdAt: z.coerce.date().optional(),
      createdBy: z.string().optional().nullable(),
      updatedAt: z.coerce.date().optional(),
      deletedAt: z.coerce.date().optional().nullable(),
      productImages: z
        .lazy(
          () => ProductImageUncheckedCreateNestedManyWithoutProductInputSchema,
        )
        .optional(),
      productVariants: z
        .lazy(
          () =>
            ProductVariantUncheckedCreateNestedManyWithoutProductInputSchema,
        )
        .optional(),
    })
    .strict() as z.ZodType<Prisma.ProductUncheckedCreateWithoutProductCategoriesInput>;

export const ProductCreateOrConnectWithoutProductCategoriesInputSchema: z.ZodType<Prisma.ProductCreateOrConnectWithoutProductCategoriesInput> =
  z
    .object({
      where: z.lazy(() => ProductWhereUniqueInputSchema),
      create: z.union([
        z.lazy(() => ProductCreateWithoutProductCategoriesInputSchema),
        z.lazy(() => ProductUncheckedCreateWithoutProductCategoriesInputSchema),
      ]),
    })
    .strict() as z.ZodType<Prisma.ProductCreateOrConnectWithoutProductCategoriesInput>;

export const CategoryCreateWithoutProductCategoriesInputSchema: z.ZodType<Prisma.CategoryCreateWithoutProductCategoriesInput> =
  z
    .object({
      id: z.string().uuid().optional(),
      name: z.string(),
      slug: z.string(),
      description: z.string().optional().nullable(),
      imageUrl: z.string().optional().nullable(),
      createdAt: z.coerce.date().optional(),
      createdBy: z.string().optional().nullable(),
      updatedAt: z.coerce.date().optional(),
      deletedAt: z.coerce.date().optional().nullable(),
      parent: z
        .lazy(() => CategoryCreateNestedOneWithoutChildrenInputSchema)
        .optional(),
      children: z
        .lazy(() => CategoryCreateNestedManyWithoutParentInputSchema)
        .optional(),
    })
    .strict() as z.ZodType<Prisma.CategoryCreateWithoutProductCategoriesInput>;

export const CategoryUncheckedCreateWithoutProductCategoriesInputSchema: z.ZodType<Prisma.CategoryUncheckedCreateWithoutProductCategoriesInput> =
  z
    .object({
      id: z.string().uuid().optional(),
      name: z.string(),
      slug: z.string(),
      description: z.string().optional().nullable(),
      parentID: z.string().optional().nullable(),
      imageUrl: z.string().optional().nullable(),
      createdAt: z.coerce.date().optional(),
      createdBy: z.string().optional().nullable(),
      updatedAt: z.coerce.date().optional(),
      deletedAt: z.coerce.date().optional().nullable(),
      children: z
        .lazy(() => CategoryUncheckedCreateNestedManyWithoutParentInputSchema)
        .optional(),
    })
    .strict() as z.ZodType<Prisma.CategoryUncheckedCreateWithoutProductCategoriesInput>;

export const CategoryCreateOrConnectWithoutProductCategoriesInputSchema: z.ZodType<Prisma.CategoryCreateOrConnectWithoutProductCategoriesInput> =
  z
    .object({
      where: z.lazy(() => CategoryWhereUniqueInputSchema),
      create: z.union([
        z.lazy(() => CategoryCreateWithoutProductCategoriesInputSchema),
        z.lazy(
          () => CategoryUncheckedCreateWithoutProductCategoriesInputSchema,
        ),
      ]),
    })
    .strict() as z.ZodType<Prisma.CategoryCreateOrConnectWithoutProductCategoriesInput>;

export const ProductUpsertWithoutProductCategoriesInputSchema: z.ZodType<Prisma.ProductUpsertWithoutProductCategoriesInput> =
  z
    .object({
      update: z.union([
        z.lazy(() => ProductUpdateWithoutProductCategoriesInputSchema),
        z.lazy(() => ProductUncheckedUpdateWithoutProductCategoriesInputSchema),
      ]),
      create: z.union([
        z.lazy(() => ProductCreateWithoutProductCategoriesInputSchema),
        z.lazy(() => ProductUncheckedCreateWithoutProductCategoriesInputSchema),
      ]),
      where: z.lazy(() => ProductWhereInputSchema).optional(),
    })
    .strict() as z.ZodType<Prisma.ProductUpsertWithoutProductCategoriesInput>;

export const ProductUpdateToOneWithWhereWithoutProductCategoriesInputSchema: z.ZodType<Prisma.ProductUpdateToOneWithWhereWithoutProductCategoriesInput> =
  z
    .object({
      where: z.lazy(() => ProductWhereInputSchema).optional(),
      data: z.union([
        z.lazy(() => ProductUpdateWithoutProductCategoriesInputSchema),
        z.lazy(() => ProductUncheckedUpdateWithoutProductCategoriesInputSchema),
      ]),
    })
    .strict() as z.ZodType<Prisma.ProductUpdateToOneWithWhereWithoutProductCategoriesInput>;

export const ProductUpdateWithoutProductCategoriesInputSchema: z.ZodType<Prisma.ProductUpdateWithoutProductCategoriesInput> =
  z
    .object({
      id: z
        .union([
          z.string().uuid(),
          z.lazy(() => StringFieldUpdateOperationsInputSchema),
        ])
        .optional(),
      name: z
        .union([
          z.string(),
          z.lazy(() => StringFieldUpdateOperationsInputSchema),
        ])
        .optional(),
      slug: z
        .union([
          z.string(),
          z.lazy(() => StringFieldUpdateOperationsInputSchema),
        ])
        .optional(),
      description: z
        .union([
          z.string(),
          z.lazy(() => NullableStringFieldUpdateOperationsInputSchema),
        ])
        .optional()
        .nullable(),
      sku: z
        .union([
          z.string(),
          z.lazy(() => NullableStringFieldUpdateOperationsInputSchema),
        ])
        .optional()
        .nullable(),
      price: z
        .union([
          z
            .union([
              z.number(),
              z.string(),
              z.instanceof(Decimal),
              z.instanceof(Prisma.Decimal),
              DecimalJsLikeSchema,
            ])
            .refine((v) => isValidDecimalInput(v), {
              message: 'Must be a Decimal',
            }),
          z.lazy(() => DecimalFieldUpdateOperationsInputSchema),
        ])
        .optional(),
      stockQuantity: z
        .union([
          z.number().int(),
          z.lazy(() => IntFieldUpdateOperationsInputSchema),
        ])
        .optional(),
      status: z
        .union([
          z.lazy(() => ProductStatusSchema),
          z.lazy(() => EnumProductStatusFieldUpdateOperationsInputSchema),
        ])
        .optional(),
      createdAt: z
        .union([
          z.coerce.date(),
          z.lazy(() => DateTimeFieldUpdateOperationsInputSchema),
        ])
        .optional(),
      createdBy: z
        .union([
          z.string(),
          z.lazy(() => NullableStringFieldUpdateOperationsInputSchema),
        ])
        .optional()
        .nullable(),
      updatedAt: z
        .union([
          z.coerce.date(),
          z.lazy(() => DateTimeFieldUpdateOperationsInputSchema),
        ])
        .optional(),
      deletedAt: z
        .union([
          z.coerce.date(),
          z.lazy(() => NullableDateTimeFieldUpdateOperationsInputSchema),
        ])
        .optional()
        .nullable(),
      vendor: z
        .lazy(() => VendorUpdateOneRequiredWithoutProductsNestedInputSchema)
        .optional(),
      productImages: z
        .lazy(() => ProductImageUpdateManyWithoutProductNestedInputSchema)
        .optional(),
      productVariants: z
        .lazy(() => ProductVariantUpdateManyWithoutProductNestedInputSchema)
        .optional(),
    })
    .strict() as z.ZodType<Prisma.ProductUpdateWithoutProductCategoriesInput>;

export const ProductUncheckedUpdateWithoutProductCategoriesInputSchema: z.ZodType<Prisma.ProductUncheckedUpdateWithoutProductCategoriesInput> =
  z
    .object({
      id: z
        .union([
          z.string().uuid(),
          z.lazy(() => StringFieldUpdateOperationsInputSchema),
        ])
        .optional(),
      vendorID: z
        .union([
          z.string(),
          z.lazy(() => StringFieldUpdateOperationsInputSchema),
        ])
        .optional(),
      name: z
        .union([
          z.string(),
          z.lazy(() => StringFieldUpdateOperationsInputSchema),
        ])
        .optional(),
      slug: z
        .union([
          z.string(),
          z.lazy(() => StringFieldUpdateOperationsInputSchema),
        ])
        .optional(),
      description: z
        .union([
          z.string(),
          z.lazy(() => NullableStringFieldUpdateOperationsInputSchema),
        ])
        .optional()
        .nullable(),
      sku: z
        .union([
          z.string(),
          z.lazy(() => NullableStringFieldUpdateOperationsInputSchema),
        ])
        .optional()
        .nullable(),
      price: z
        .union([
          z
            .union([
              z.number(),
              z.string(),
              z.instanceof(Decimal),
              z.instanceof(Prisma.Decimal),
              DecimalJsLikeSchema,
            ])
            .refine((v) => isValidDecimalInput(v), {
              message: 'Must be a Decimal',
            }),
          z.lazy(() => DecimalFieldUpdateOperationsInputSchema),
        ])
        .optional(),
      stockQuantity: z
        .union([
          z.number().int(),
          z.lazy(() => IntFieldUpdateOperationsInputSchema),
        ])
        .optional(),
      status: z
        .union([
          z.lazy(() => ProductStatusSchema),
          z.lazy(() => EnumProductStatusFieldUpdateOperationsInputSchema),
        ])
        .optional(),
      createdAt: z
        .union([
          z.coerce.date(),
          z.lazy(() => DateTimeFieldUpdateOperationsInputSchema),
        ])
        .optional(),
      createdBy: z
        .union([
          z.string(),
          z.lazy(() => NullableStringFieldUpdateOperationsInputSchema),
        ])
        .optional()
        .nullable(),
      updatedAt: z
        .union([
          z.coerce.date(),
          z.lazy(() => DateTimeFieldUpdateOperationsInputSchema),
        ])
        .optional(),
      deletedAt: z
        .union([
          z.coerce.date(),
          z.lazy(() => NullableDateTimeFieldUpdateOperationsInputSchema),
        ])
        .optional()
        .nullable(),
      productImages: z
        .lazy(
          () => ProductImageUncheckedUpdateManyWithoutProductNestedInputSchema,
        )
        .optional(),
      productVariants: z
        .lazy(
          () =>
            ProductVariantUncheckedUpdateManyWithoutProductNestedInputSchema,
        )
        .optional(),
    })
    .strict() as z.ZodType<Prisma.ProductUncheckedUpdateWithoutProductCategoriesInput>;

export const CategoryUpsertWithoutProductCategoriesInputSchema: z.ZodType<Prisma.CategoryUpsertWithoutProductCategoriesInput> =
  z
    .object({
      update: z.union([
        z.lazy(() => CategoryUpdateWithoutProductCategoriesInputSchema),
        z.lazy(
          () => CategoryUncheckedUpdateWithoutProductCategoriesInputSchema,
        ),
      ]),
      create: z.union([
        z.lazy(() => CategoryCreateWithoutProductCategoriesInputSchema),
        z.lazy(
          () => CategoryUncheckedCreateWithoutProductCategoriesInputSchema,
        ),
      ]),
      where: z.lazy(() => CategoryWhereInputSchema).optional(),
    })
    .strict() as z.ZodType<Prisma.CategoryUpsertWithoutProductCategoriesInput>;

export const CategoryUpdateToOneWithWhereWithoutProductCategoriesInputSchema: z.ZodType<Prisma.CategoryUpdateToOneWithWhereWithoutProductCategoriesInput> =
  z
    .object({
      where: z.lazy(() => CategoryWhereInputSchema).optional(),
      data: z.union([
        z.lazy(() => CategoryUpdateWithoutProductCategoriesInputSchema),
        z.lazy(
          () => CategoryUncheckedUpdateWithoutProductCategoriesInputSchema,
        ),
      ]),
    })
    .strict() as z.ZodType<Prisma.CategoryUpdateToOneWithWhereWithoutProductCategoriesInput>;

export const CategoryUpdateWithoutProductCategoriesInputSchema: z.ZodType<Prisma.CategoryUpdateWithoutProductCategoriesInput> =
  z
    .object({
      id: z
        .union([
          z.string().uuid(),
          z.lazy(() => StringFieldUpdateOperationsInputSchema),
        ])
        .optional(),
      name: z
        .union([
          z.string(),
          z.lazy(() => StringFieldUpdateOperationsInputSchema),
        ])
        .optional(),
      slug: z
        .union([
          z.string(),
          z.lazy(() => StringFieldUpdateOperationsInputSchema),
        ])
        .optional(),
      description: z
        .union([
          z.string(),
          z.lazy(() => NullableStringFieldUpdateOperationsInputSchema),
        ])
        .optional()
        .nullable(),
      imageUrl: z
        .union([
          z.string(),
          z.lazy(() => NullableStringFieldUpdateOperationsInputSchema),
        ])
        .optional()
        .nullable(),
      createdAt: z
        .union([
          z.coerce.date(),
          z.lazy(() => DateTimeFieldUpdateOperationsInputSchema),
        ])
        .optional(),
      createdBy: z
        .union([
          z.string(),
          z.lazy(() => NullableStringFieldUpdateOperationsInputSchema),
        ])
        .optional()
        .nullable(),
      updatedAt: z
        .union([
          z.coerce.date(),
          z.lazy(() => DateTimeFieldUpdateOperationsInputSchema),
        ])
        .optional(),
      deletedAt: z
        .union([
          z.coerce.date(),
          z.lazy(() => NullableDateTimeFieldUpdateOperationsInputSchema),
        ])
        .optional()
        .nullable(),
      parent: z
        .lazy(() => CategoryUpdateOneWithoutChildrenNestedInputSchema)
        .optional(),
      children: z
        .lazy(() => CategoryUpdateManyWithoutParentNestedInputSchema)
        .optional(),
    })
    .strict() as z.ZodType<Prisma.CategoryUpdateWithoutProductCategoriesInput>;

export const CategoryUncheckedUpdateWithoutProductCategoriesInputSchema: z.ZodType<Prisma.CategoryUncheckedUpdateWithoutProductCategoriesInput> =
  z
    .object({
      id: z
        .union([
          z.string().uuid(),
          z.lazy(() => StringFieldUpdateOperationsInputSchema),
        ])
        .optional(),
      name: z
        .union([
          z.string(),
          z.lazy(() => StringFieldUpdateOperationsInputSchema),
        ])
        .optional(),
      slug: z
        .union([
          z.string(),
          z.lazy(() => StringFieldUpdateOperationsInputSchema),
        ])
        .optional(),
      description: z
        .union([
          z.string(),
          z.lazy(() => NullableStringFieldUpdateOperationsInputSchema),
        ])
        .optional()
        .nullable(),
      parentID: z
        .union([
          z.string(),
          z.lazy(() => NullableStringFieldUpdateOperationsInputSchema),
        ])
        .optional()
        .nullable(),
      imageUrl: z
        .union([
          z.string(),
          z.lazy(() => NullableStringFieldUpdateOperationsInputSchema),
        ])
        .optional()
        .nullable(),
      createdAt: z
        .union([
          z.coerce.date(),
          z.lazy(() => DateTimeFieldUpdateOperationsInputSchema),
        ])
        .optional(),
      createdBy: z
        .union([
          z.string(),
          z.lazy(() => NullableStringFieldUpdateOperationsInputSchema),
        ])
        .optional()
        .nullable(),
      updatedAt: z
        .union([
          z.coerce.date(),
          z.lazy(() => DateTimeFieldUpdateOperationsInputSchema),
        ])
        .optional(),
      deletedAt: z
        .union([
          z.coerce.date(),
          z.lazy(() => NullableDateTimeFieldUpdateOperationsInputSchema),
        ])
        .optional()
        .nullable(),
      children: z
        .lazy(() => CategoryUncheckedUpdateManyWithoutParentNestedInputSchema)
        .optional(),
    })
    .strict() as z.ZodType<Prisma.CategoryUncheckedUpdateWithoutProductCategoriesInput>;

export const ProductCreateWithoutProductImagesInputSchema: z.ZodType<Prisma.ProductCreateWithoutProductImagesInput> =
  z
    .object({
      id: z.string().uuid().optional(),
      name: z.string(),
      slug: z.string(),
      description: z.string().optional().nullable(),
      sku: z.string().optional().nullable(),
      price: z
        .union([
          z.number(),
          z.string(),
          z.instanceof(Decimal),
          z.instanceof(Prisma.Decimal),
          DecimalJsLikeSchema,
        ])
        .refine((v) => isValidDecimalInput(v), {
          message: 'Must be a Decimal',
        }),
      stockQuantity: z.number().int().optional(),
      status: z.lazy(() => ProductStatusSchema).optional(),
      createdAt: z.coerce.date().optional(),
      createdBy: z.string().optional().nullable(),
      updatedAt: z.coerce.date().optional(),
      deletedAt: z.coerce.date().optional().nullable(),
      vendor: z.lazy(() => VendorCreateNestedOneWithoutProductsInputSchema),
      productCategories: z
        .lazy(() => ProductCategoryCreateNestedManyWithoutProductInputSchema)
        .optional(),
      productVariants: z
        .lazy(() => ProductVariantCreateNestedManyWithoutProductInputSchema)
        .optional(),
    })
    .strict() as z.ZodType<Prisma.ProductCreateWithoutProductImagesInput>;

export const ProductUncheckedCreateWithoutProductImagesInputSchema: z.ZodType<Prisma.ProductUncheckedCreateWithoutProductImagesInput> =
  z
    .object({
      id: z.string().uuid().optional(),
      vendorID: z.string(),
      name: z.string(),
      slug: z.string(),
      description: z.string().optional().nullable(),
      sku: z.string().optional().nullable(),
      price: z
        .union([
          z.number(),
          z.string(),
          z.instanceof(Decimal),
          z.instanceof(Prisma.Decimal),
          DecimalJsLikeSchema,
        ])
        .refine((v) => isValidDecimalInput(v), {
          message: 'Must be a Decimal',
        }),
      stockQuantity: z.number().int().optional(),
      status: z.lazy(() => ProductStatusSchema).optional(),
      createdAt: z.coerce.date().optional(),
      createdBy: z.string().optional().nullable(),
      updatedAt: z.coerce.date().optional(),
      deletedAt: z.coerce.date().optional().nullable(),
      productCategories: z
        .lazy(
          () =>
            ProductCategoryUncheckedCreateNestedManyWithoutProductInputSchema,
        )
        .optional(),
      productVariants: z
        .lazy(
          () =>
            ProductVariantUncheckedCreateNestedManyWithoutProductInputSchema,
        )
        .optional(),
    })
    .strict() as z.ZodType<Prisma.ProductUncheckedCreateWithoutProductImagesInput>;

export const ProductCreateOrConnectWithoutProductImagesInputSchema: z.ZodType<Prisma.ProductCreateOrConnectWithoutProductImagesInput> =
  z
    .object({
      where: z.lazy(() => ProductWhereUniqueInputSchema),
      create: z.union([
        z.lazy(() => ProductCreateWithoutProductImagesInputSchema),
        z.lazy(() => ProductUncheckedCreateWithoutProductImagesInputSchema),
      ]),
    })
    .strict() as z.ZodType<Prisma.ProductCreateOrConnectWithoutProductImagesInput>;

export const ProductVariantCreateWithoutProductImagesInputSchema: z.ZodType<Prisma.ProductVariantCreateWithoutProductImagesInput> =
  z
    .object({
      id: z.string().uuid().optional(),
      name: z.string().optional().nullable(),
      sku: z.string().optional().nullable(),
      price: z
        .union([
          z.number(),
          z.string(),
          z.instanceof(Decimal),
          z.instanceof(Prisma.Decimal),
          DecimalJsLikeSchema,
        ])
        .refine((v) => isValidDecimalInput(v), {
          message: 'Must be a Decimal',
        }),
      stockQuantity: z.number().int().optional(),
      attributes: z
        .union([
          z.lazy(() => NullableJsonNullValueInputSchema),
          InputJsonValueSchema,
        ])
        .optional(),
      createdAt: z.coerce.date().optional(),
      createdBy: z.string().optional().nullable(),
      updatedAt: z.coerce.date().optional(),
      deletedAt: z.coerce.date().optional().nullable(),
      product: z.lazy(
        () => ProductCreateNestedOneWithoutProductVariantsInputSchema,
      ),
      orderItems: z
        .lazy(() => OrderItemCreateNestedManyWithoutProductVariantInputSchema)
        .optional(),
      cartItems: z
        .lazy(() => CartItemCreateNestedManyWithoutProductVariantInputSchema)
        .optional(),
    })
    .strict() as z.ZodType<Prisma.ProductVariantCreateWithoutProductImagesInput>;

export const ProductVariantUncheckedCreateWithoutProductImagesInputSchema: z.ZodType<Prisma.ProductVariantUncheckedCreateWithoutProductImagesInput> =
  z
    .object({
      id: z.string().uuid().optional(),
      productID: z.string(),
      name: z.string().optional().nullable(),
      sku: z.string().optional().nullable(),
      price: z
        .union([
          z.number(),
          z.string(),
          z.instanceof(Decimal),
          z.instanceof(Prisma.Decimal),
          DecimalJsLikeSchema,
        ])
        .refine((v) => isValidDecimalInput(v), {
          message: 'Must be a Decimal',
        }),
      stockQuantity: z.number().int().optional(),
      attributes: z
        .union([
          z.lazy(() => NullableJsonNullValueInputSchema),
          InputJsonValueSchema,
        ])
        .optional(),
      createdAt: z.coerce.date().optional(),
      createdBy: z.string().optional().nullable(),
      updatedAt: z.coerce.date().optional(),
      deletedAt: z.coerce.date().optional().nullable(),
      orderItems: z
        .lazy(
          () =>
            OrderItemUncheckedCreateNestedManyWithoutProductVariantInputSchema,
        )
        .optional(),
      cartItems: z
        .lazy(
          () =>
            CartItemUncheckedCreateNestedManyWithoutProductVariantInputSchema,
        )
        .optional(),
    })
    .strict() as z.ZodType<Prisma.ProductVariantUncheckedCreateWithoutProductImagesInput>;

export const ProductVariantCreateOrConnectWithoutProductImagesInputSchema: z.ZodType<Prisma.ProductVariantCreateOrConnectWithoutProductImagesInput> =
  z
    .object({
      where: z.lazy(() => ProductVariantWhereUniqueInputSchema),
      create: z.union([
        z.lazy(() => ProductVariantCreateWithoutProductImagesInputSchema),
        z.lazy(
          () => ProductVariantUncheckedCreateWithoutProductImagesInputSchema,
        ),
      ]),
    })
    .strict() as z.ZodType<Prisma.ProductVariantCreateOrConnectWithoutProductImagesInput>;

export const ProductUpsertWithoutProductImagesInputSchema: z.ZodType<Prisma.ProductUpsertWithoutProductImagesInput> =
  z
    .object({
      update: z.union([
        z.lazy(() => ProductUpdateWithoutProductImagesInputSchema),
        z.lazy(() => ProductUncheckedUpdateWithoutProductImagesInputSchema),
      ]),
      create: z.union([
        z.lazy(() => ProductCreateWithoutProductImagesInputSchema),
        z.lazy(() => ProductUncheckedCreateWithoutProductImagesInputSchema),
      ]),
      where: z.lazy(() => ProductWhereInputSchema).optional(),
    })
    .strict() as z.ZodType<Prisma.ProductUpsertWithoutProductImagesInput>;

export const ProductUpdateToOneWithWhereWithoutProductImagesInputSchema: z.ZodType<Prisma.ProductUpdateToOneWithWhereWithoutProductImagesInput> =
  z
    .object({
      where: z.lazy(() => ProductWhereInputSchema).optional(),
      data: z.union([
        z.lazy(() => ProductUpdateWithoutProductImagesInputSchema),
        z.lazy(() => ProductUncheckedUpdateWithoutProductImagesInputSchema),
      ]),
    })
    .strict() as z.ZodType<Prisma.ProductUpdateToOneWithWhereWithoutProductImagesInput>;

export const ProductUpdateWithoutProductImagesInputSchema: z.ZodType<Prisma.ProductUpdateWithoutProductImagesInput> =
  z
    .object({
      id: z
        .union([
          z.string().uuid(),
          z.lazy(() => StringFieldUpdateOperationsInputSchema),
        ])
        .optional(),
      name: z
        .union([
          z.string(),
          z.lazy(() => StringFieldUpdateOperationsInputSchema),
        ])
        .optional(),
      slug: z
        .union([
          z.string(),
          z.lazy(() => StringFieldUpdateOperationsInputSchema),
        ])
        .optional(),
      description: z
        .union([
          z.string(),
          z.lazy(() => NullableStringFieldUpdateOperationsInputSchema),
        ])
        .optional()
        .nullable(),
      sku: z
        .union([
          z.string(),
          z.lazy(() => NullableStringFieldUpdateOperationsInputSchema),
        ])
        .optional()
        .nullable(),
      price: z
        .union([
          z
            .union([
              z.number(),
              z.string(),
              z.instanceof(Decimal),
              z.instanceof(Prisma.Decimal),
              DecimalJsLikeSchema,
            ])
            .refine((v) => isValidDecimalInput(v), {
              message: 'Must be a Decimal',
            }),
          z.lazy(() => DecimalFieldUpdateOperationsInputSchema),
        ])
        .optional(),
      stockQuantity: z
        .union([
          z.number().int(),
          z.lazy(() => IntFieldUpdateOperationsInputSchema),
        ])
        .optional(),
      status: z
        .union([
          z.lazy(() => ProductStatusSchema),
          z.lazy(() => EnumProductStatusFieldUpdateOperationsInputSchema),
        ])
        .optional(),
      createdAt: z
        .union([
          z.coerce.date(),
          z.lazy(() => DateTimeFieldUpdateOperationsInputSchema),
        ])
        .optional(),
      createdBy: z
        .union([
          z.string(),
          z.lazy(() => NullableStringFieldUpdateOperationsInputSchema),
        ])
        .optional()
        .nullable(),
      updatedAt: z
        .union([
          z.coerce.date(),
          z.lazy(() => DateTimeFieldUpdateOperationsInputSchema),
        ])
        .optional(),
      deletedAt: z
        .union([
          z.coerce.date(),
          z.lazy(() => NullableDateTimeFieldUpdateOperationsInputSchema),
        ])
        .optional()
        .nullable(),
      vendor: z
        .lazy(() => VendorUpdateOneRequiredWithoutProductsNestedInputSchema)
        .optional(),
      productCategories: z
        .lazy(() => ProductCategoryUpdateManyWithoutProductNestedInputSchema)
        .optional(),
      productVariants: z
        .lazy(() => ProductVariantUpdateManyWithoutProductNestedInputSchema)
        .optional(),
    })
    .strict() as z.ZodType<Prisma.ProductUpdateWithoutProductImagesInput>;

export const ProductUncheckedUpdateWithoutProductImagesInputSchema: z.ZodType<Prisma.ProductUncheckedUpdateWithoutProductImagesInput> =
  z
    .object({
      id: z
        .union([
          z.string().uuid(),
          z.lazy(() => StringFieldUpdateOperationsInputSchema),
        ])
        .optional(),
      vendorID: z
        .union([
          z.string(),
          z.lazy(() => StringFieldUpdateOperationsInputSchema),
        ])
        .optional(),
      name: z
        .union([
          z.string(),
          z.lazy(() => StringFieldUpdateOperationsInputSchema),
        ])
        .optional(),
      slug: z
        .union([
          z.string(),
          z.lazy(() => StringFieldUpdateOperationsInputSchema),
        ])
        .optional(),
      description: z
        .union([
          z.string(),
          z.lazy(() => NullableStringFieldUpdateOperationsInputSchema),
        ])
        .optional()
        .nullable(),
      sku: z
        .union([
          z.string(),
          z.lazy(() => NullableStringFieldUpdateOperationsInputSchema),
        ])
        .optional()
        .nullable(),
      price: z
        .union([
          z
            .union([
              z.number(),
              z.string(),
              z.instanceof(Decimal),
              z.instanceof(Prisma.Decimal),
              DecimalJsLikeSchema,
            ])
            .refine((v) => isValidDecimalInput(v), {
              message: 'Must be a Decimal',
            }),
          z.lazy(() => DecimalFieldUpdateOperationsInputSchema),
        ])
        .optional(),
      stockQuantity: z
        .union([
          z.number().int(),
          z.lazy(() => IntFieldUpdateOperationsInputSchema),
        ])
        .optional(),
      status: z
        .union([
          z.lazy(() => ProductStatusSchema),
          z.lazy(() => EnumProductStatusFieldUpdateOperationsInputSchema),
        ])
        .optional(),
      createdAt: z
        .union([
          z.coerce.date(),
          z.lazy(() => DateTimeFieldUpdateOperationsInputSchema),
        ])
        .optional(),
      createdBy: z
        .union([
          z.string(),
          z.lazy(() => NullableStringFieldUpdateOperationsInputSchema),
        ])
        .optional()
        .nullable(),
      updatedAt: z
        .union([
          z.coerce.date(),
          z.lazy(() => DateTimeFieldUpdateOperationsInputSchema),
        ])
        .optional(),
      deletedAt: z
        .union([
          z.coerce.date(),
          z.lazy(() => NullableDateTimeFieldUpdateOperationsInputSchema),
        ])
        .optional()
        .nullable(),
      productCategories: z
        .lazy(
          () =>
            ProductCategoryUncheckedUpdateManyWithoutProductNestedInputSchema,
        )
        .optional(),
      productVariants: z
        .lazy(
          () =>
            ProductVariantUncheckedUpdateManyWithoutProductNestedInputSchema,
        )
        .optional(),
    })
    .strict() as z.ZodType<Prisma.ProductUncheckedUpdateWithoutProductImagesInput>;

export const ProductVariantUpsertWithoutProductImagesInputSchema: z.ZodType<Prisma.ProductVariantUpsertWithoutProductImagesInput> =
  z
    .object({
      update: z.union([
        z.lazy(() => ProductVariantUpdateWithoutProductImagesInputSchema),
        z.lazy(
          () => ProductVariantUncheckedUpdateWithoutProductImagesInputSchema,
        ),
      ]),
      create: z.union([
        z.lazy(() => ProductVariantCreateWithoutProductImagesInputSchema),
        z.lazy(
          () => ProductVariantUncheckedCreateWithoutProductImagesInputSchema,
        ),
      ]),
      where: z.lazy(() => ProductVariantWhereInputSchema).optional(),
    })
    .strict() as z.ZodType<Prisma.ProductVariantUpsertWithoutProductImagesInput>;

export const ProductVariantUpdateToOneWithWhereWithoutProductImagesInputSchema: z.ZodType<Prisma.ProductVariantUpdateToOneWithWhereWithoutProductImagesInput> =
  z
    .object({
      where: z.lazy(() => ProductVariantWhereInputSchema).optional(),
      data: z.union([
        z.lazy(() => ProductVariantUpdateWithoutProductImagesInputSchema),
        z.lazy(
          () => ProductVariantUncheckedUpdateWithoutProductImagesInputSchema,
        ),
      ]),
    })
    .strict() as z.ZodType<Prisma.ProductVariantUpdateToOneWithWhereWithoutProductImagesInput>;

export const ProductVariantUpdateWithoutProductImagesInputSchema: z.ZodType<Prisma.ProductVariantUpdateWithoutProductImagesInput> =
  z
    .object({
      id: z
        .union([
          z.string().uuid(),
          z.lazy(() => StringFieldUpdateOperationsInputSchema),
        ])
        .optional(),
      name: z
        .union([
          z.string(),
          z.lazy(() => NullableStringFieldUpdateOperationsInputSchema),
        ])
        .optional()
        .nullable(),
      sku: z
        .union([
          z.string(),
          z.lazy(() => NullableStringFieldUpdateOperationsInputSchema),
        ])
        .optional()
        .nullable(),
      price: z
        .union([
          z
            .union([
              z.number(),
              z.string(),
              z.instanceof(Decimal),
              z.instanceof(Prisma.Decimal),
              DecimalJsLikeSchema,
            ])
            .refine((v) => isValidDecimalInput(v), {
              message: 'Must be a Decimal',
            }),
          z.lazy(() => DecimalFieldUpdateOperationsInputSchema),
        ])
        .optional(),
      stockQuantity: z
        .union([
          z.number().int(),
          z.lazy(() => IntFieldUpdateOperationsInputSchema),
        ])
        .optional(),
      attributes: z
        .union([
          z.lazy(() => NullableJsonNullValueInputSchema),
          InputJsonValueSchema,
        ])
        .optional(),
      createdAt: z
        .union([
          z.coerce.date(),
          z.lazy(() => DateTimeFieldUpdateOperationsInputSchema),
        ])
        .optional(),
      createdBy: z
        .union([
          z.string(),
          z.lazy(() => NullableStringFieldUpdateOperationsInputSchema),
        ])
        .optional()
        .nullable(),
      updatedAt: z
        .union([
          z.coerce.date(),
          z.lazy(() => DateTimeFieldUpdateOperationsInputSchema),
        ])
        .optional(),
      deletedAt: z
        .union([
          z.coerce.date(),
          z.lazy(() => NullableDateTimeFieldUpdateOperationsInputSchema),
        ])
        .optional()
        .nullable(),
      product: z
        .lazy(
          () => ProductUpdateOneRequiredWithoutProductVariantsNestedInputSchema,
        )
        .optional(),
      orderItems: z
        .lazy(() => OrderItemUpdateManyWithoutProductVariantNestedInputSchema)
        .optional(),
      cartItems: z
        .lazy(() => CartItemUpdateManyWithoutProductVariantNestedInputSchema)
        .optional(),
    })
    .strict() as z.ZodType<Prisma.ProductVariantUpdateWithoutProductImagesInput>;

export const ProductVariantUncheckedUpdateWithoutProductImagesInputSchema: z.ZodType<Prisma.ProductVariantUncheckedUpdateWithoutProductImagesInput> =
  z
    .object({
      id: z
        .union([
          z.string().uuid(),
          z.lazy(() => StringFieldUpdateOperationsInputSchema),
        ])
        .optional(),
      productID: z
        .union([
          z.string(),
          z.lazy(() => StringFieldUpdateOperationsInputSchema),
        ])
        .optional(),
      name: z
        .union([
          z.string(),
          z.lazy(() => NullableStringFieldUpdateOperationsInputSchema),
        ])
        .optional()
        .nullable(),
      sku: z
        .union([
          z.string(),
          z.lazy(() => NullableStringFieldUpdateOperationsInputSchema),
        ])
        .optional()
        .nullable(),
      price: z
        .union([
          z
            .union([
              z.number(),
              z.string(),
              z.instanceof(Decimal),
              z.instanceof(Prisma.Decimal),
              DecimalJsLikeSchema,
            ])
            .refine((v) => isValidDecimalInput(v), {
              message: 'Must be a Decimal',
            }),
          z.lazy(() => DecimalFieldUpdateOperationsInputSchema),
        ])
        .optional(),
      stockQuantity: z
        .union([
          z.number().int(),
          z.lazy(() => IntFieldUpdateOperationsInputSchema),
        ])
        .optional(),
      attributes: z
        .union([
          z.lazy(() => NullableJsonNullValueInputSchema),
          InputJsonValueSchema,
        ])
        .optional(),
      createdAt: z
        .union([
          z.coerce.date(),
          z.lazy(() => DateTimeFieldUpdateOperationsInputSchema),
        ])
        .optional(),
      createdBy: z
        .union([
          z.string(),
          z.lazy(() => NullableStringFieldUpdateOperationsInputSchema),
        ])
        .optional()
        .nullable(),
      updatedAt: z
        .union([
          z.coerce.date(),
          z.lazy(() => DateTimeFieldUpdateOperationsInputSchema),
        ])
        .optional(),
      deletedAt: z
        .union([
          z.coerce.date(),
          z.lazy(() => NullableDateTimeFieldUpdateOperationsInputSchema),
        ])
        .optional()
        .nullable(),
      orderItems: z
        .lazy(
          () =>
            OrderItemUncheckedUpdateManyWithoutProductVariantNestedInputSchema,
        )
        .optional(),
      cartItems: z
        .lazy(
          () =>
            CartItemUncheckedUpdateManyWithoutProductVariantNestedInputSchema,
        )
        .optional(),
    })
    .strict() as z.ZodType<Prisma.ProductVariantUncheckedUpdateWithoutProductImagesInput>;

export const UserCreateWithoutOrdersInputSchema: z.ZodType<Prisma.UserCreateWithoutOrdersInput> =
  z
    .object({
      id: z.string().uuid().optional(),
      email: z.string().email(),
      password: z.string(),
      firstName: z.string(),
      lastName: z.string().optional().nullable(),
      fullAddress: z.string(),
      city: z.string().optional().nullable(),
      province: z.string().optional().nullable(),
      country: z.string().optional().nullable(),
      phone: z.string().optional().nullable(),
      status: z.lazy(() => UserStatusSchema).optional(),
      createdAt: z.coerce.date().optional(),
      createdBy: z.string().optional().nullable(),
      updatedAt: z.coerce.date().optional(),
      deletedAt: z.coerce.date().optional().nullable(),
      vendors: z
        .lazy(() => VendorCreateNestedManyWithoutUserInputSchema)
        .optional(),
      userVendorRoles: z
        .lazy(() => UserVendorRoleCreateNestedManyWithoutUserInputSchema)
        .optional(),
      cart: z.lazy(() => CartCreateNestedOneWithoutUserInputSchema).optional(),
      notifications: z
        .lazy(() => NotificationCreateNestedManyWithoutUserInputSchema)
        .optional(),
    })
    .strict() as z.ZodType<Prisma.UserCreateWithoutOrdersInput>;

export const UserUncheckedCreateWithoutOrdersInputSchema: z.ZodType<Prisma.UserUncheckedCreateWithoutOrdersInput> =
  z
    .object({
      id: z.string().uuid().optional(),
      email: z.string().email(),
      password: z.string(),
      firstName: z.string(),
      lastName: z.string().optional().nullable(),
      fullAddress: z.string(),
      city: z.string().optional().nullable(),
      province: z.string().optional().nullable(),
      country: z.string().optional().nullable(),
      phone: z.string().optional().nullable(),
      status: z.lazy(() => UserStatusSchema).optional(),
      createdAt: z.coerce.date().optional(),
      createdBy: z.string().optional().nullable(),
      updatedAt: z.coerce.date().optional(),
      deletedAt: z.coerce.date().optional().nullable(),
      vendors: z
        .lazy(() => VendorUncheckedCreateNestedManyWithoutUserInputSchema)
        .optional(),
      userVendorRoles: z
        .lazy(
          () => UserVendorRoleUncheckedCreateNestedManyWithoutUserInputSchema,
        )
        .optional(),
      cart: z
        .lazy(() => CartUncheckedCreateNestedOneWithoutUserInputSchema)
        .optional(),
      notifications: z
        .lazy(() => NotificationUncheckedCreateNestedManyWithoutUserInputSchema)
        .optional(),
    })
    .strict() as z.ZodType<Prisma.UserUncheckedCreateWithoutOrdersInput>;

export const UserCreateOrConnectWithoutOrdersInputSchema: z.ZodType<Prisma.UserCreateOrConnectWithoutOrdersInput> =
  z
    .object({
      where: z.lazy(() => UserWhereUniqueInputSchema),
      create: z.union([
        z.lazy(() => UserCreateWithoutOrdersInputSchema),
        z.lazy(() => UserUncheckedCreateWithoutOrdersInputSchema),
      ]),
    })
    .strict() as z.ZodType<Prisma.UserCreateOrConnectWithoutOrdersInput>;

export const OrderItemCreateWithoutOrderInputSchema: z.ZodType<Prisma.OrderItemCreateWithoutOrderInput> =
  z
    .object({
      id: z.string().uuid().optional(),
      quantity: z.number().int().optional(),
      unitPrice: z
        .union([
          z.number(),
          z.string(),
          z.instanceof(Decimal),
          z.instanceof(Prisma.Decimal),
          DecimalJsLikeSchema,
        ])
        .refine((v) => isValidDecimalInput(v), {
          message: 'Must be a Decimal',
        }),
      totalPrice: z
        .union([
          z.number(),
          z.string(),
          z.instanceof(Decimal),
          z.instanceof(Prisma.Decimal),
          DecimalJsLikeSchema,
        ])
        .refine((v) => isValidDecimalInput(v), {
          message: 'Must be a Decimal',
        }),
      productVariantSnapshot: z
        .union([
          z.lazy(() => NullableJsonNullValueInputSchema),
          InputJsonValueSchema,
        ])
        .optional(),
      productVariant: z.lazy(
        () => ProductVariantCreateNestedOneWithoutOrderItemsInputSchema,
      ),
    })
    .strict() as z.ZodType<Prisma.OrderItemCreateWithoutOrderInput>;

export const OrderItemUncheckedCreateWithoutOrderInputSchema: z.ZodType<Prisma.OrderItemUncheckedCreateWithoutOrderInput> =
  z
    .object({
      id: z.string().uuid().optional(),
      productVariantID: z.string(),
      quantity: z.number().int().optional(),
      unitPrice: z
        .union([
          z.number(),
          z.string(),
          z.instanceof(Decimal),
          z.instanceof(Prisma.Decimal),
          DecimalJsLikeSchema,
        ])
        .refine((v) => isValidDecimalInput(v), {
          message: 'Must be a Decimal',
        }),
      totalPrice: z
        .union([
          z.number(),
          z.string(),
          z.instanceof(Decimal),
          z.instanceof(Prisma.Decimal),
          DecimalJsLikeSchema,
        ])
        .refine((v) => isValidDecimalInput(v), {
          message: 'Must be a Decimal',
        }),
      productVariantSnapshot: z
        .union([
          z.lazy(() => NullableJsonNullValueInputSchema),
          InputJsonValueSchema,
        ])
        .optional(),
    })
    .strict() as z.ZodType<Prisma.OrderItemUncheckedCreateWithoutOrderInput>;

export const OrderItemCreateOrConnectWithoutOrderInputSchema: z.ZodType<Prisma.OrderItemCreateOrConnectWithoutOrderInput> =
  z
    .object({
      where: z.lazy(() => OrderItemWhereUniqueInputSchema),
      create: z.union([
        z.lazy(() => OrderItemCreateWithoutOrderInputSchema),
        z.lazy(() => OrderItemUncheckedCreateWithoutOrderInputSchema),
      ]),
    })
    .strict() as z.ZodType<Prisma.OrderItemCreateOrConnectWithoutOrderInput>;

export const OrderItemCreateManyOrderInputEnvelopeSchema: z.ZodType<Prisma.OrderItemCreateManyOrderInputEnvelope> =
  z
    .object({
      data: z.union([
        z.lazy(() => OrderItemCreateManyOrderInputSchema),
        z.lazy(() => OrderItemCreateManyOrderInputSchema).array(),
      ]),
      skipDuplicates: z.boolean().optional(),
    })
    .strict() as z.ZodType<Prisma.OrderItemCreateManyOrderInputEnvelope>;

export const OrderAddressCreateWithoutOrderInputSchema: z.ZodType<Prisma.OrderAddressCreateWithoutOrderInput> =
  z
    .object({
      id: z.string().uuid().optional(),
      type: z.lazy(() => AddressTypeSchema).optional(),
      firstName: z.string(),
      lastName: z.string().optional().nullable(),
      company: z.string().optional().nullable(),
      fullAddress: z.string(),
      city: z.string().optional().nullable(),
      province: z.string().optional().nullable(),
      country: z.string().optional().nullable(),
      phone: z.string(),
    })
    .strict() as z.ZodType<Prisma.OrderAddressCreateWithoutOrderInput>;

export const OrderAddressUncheckedCreateWithoutOrderInputSchema: z.ZodType<Prisma.OrderAddressUncheckedCreateWithoutOrderInput> =
  z
    .object({
      id: z.string().uuid().optional(),
      type: z.lazy(() => AddressTypeSchema).optional(),
      firstName: z.string(),
      lastName: z.string().optional().nullable(),
      company: z.string().optional().nullable(),
      fullAddress: z.string(),
      city: z.string().optional().nullable(),
      province: z.string().optional().nullable(),
      country: z.string().optional().nullable(),
      phone: z.string(),
    })
    .strict() as z.ZodType<Prisma.OrderAddressUncheckedCreateWithoutOrderInput>;

export const OrderAddressCreateOrConnectWithoutOrderInputSchema: z.ZodType<Prisma.OrderAddressCreateOrConnectWithoutOrderInput> =
  z
    .object({
      where: z.lazy(() => OrderAddressWhereUniqueInputSchema),
      create: z.union([
        z.lazy(() => OrderAddressCreateWithoutOrderInputSchema),
        z.lazy(() => OrderAddressUncheckedCreateWithoutOrderInputSchema),
      ]),
    })
    .strict() as z.ZodType<Prisma.OrderAddressCreateOrConnectWithoutOrderInput>;

export const OrderAddressCreateManyOrderInputEnvelopeSchema: z.ZodType<Prisma.OrderAddressCreateManyOrderInputEnvelope> =
  z
    .object({
      data: z.union([
        z.lazy(() => OrderAddressCreateManyOrderInputSchema),
        z.lazy(() => OrderAddressCreateManyOrderInputSchema).array(),
      ]),
      skipDuplicates: z.boolean().optional(),
    })
    .strict() as z.ZodType<Prisma.OrderAddressCreateManyOrderInputEnvelope>;

export const OrderPromotionCreateWithoutOrderInputSchema: z.ZodType<Prisma.OrderPromotionCreateWithoutOrderInput> =
  z
    .object({
      id: z.string().uuid().optional(),
      discountAmount: z
        .union([
          z.number(),
          z.string(),
          z.instanceof(Decimal),
          z.instanceof(Prisma.Decimal),
          DecimalJsLikeSchema,
        ])
        .refine((v) => isValidDecimalInput(v), { message: 'Must be a Decimal' })
        .optional(),
      promotion: z.lazy(
        () => PromotionCreateNestedOneWithoutOrderPromotionsInputSchema,
      ),
    })
    .strict() as z.ZodType<Prisma.OrderPromotionCreateWithoutOrderInput>;

export const OrderPromotionUncheckedCreateWithoutOrderInputSchema: z.ZodType<Prisma.OrderPromotionUncheckedCreateWithoutOrderInput> =
  z
    .object({
      id: z.string().uuid().optional(),
      promotionID: z.string(),
      discountAmount: z
        .union([
          z.number(),
          z.string(),
          z.instanceof(Decimal),
          z.instanceof(Prisma.Decimal),
          DecimalJsLikeSchema,
        ])
        .refine((v) => isValidDecimalInput(v), { message: 'Must be a Decimal' })
        .optional(),
    })
    .strict() as z.ZodType<Prisma.OrderPromotionUncheckedCreateWithoutOrderInput>;

export const OrderPromotionCreateOrConnectWithoutOrderInputSchema: z.ZodType<Prisma.OrderPromotionCreateOrConnectWithoutOrderInput> =
  z
    .object({
      where: z.lazy(() => OrderPromotionWhereUniqueInputSchema),
      create: z.union([
        z.lazy(() => OrderPromotionCreateWithoutOrderInputSchema),
        z.lazy(() => OrderPromotionUncheckedCreateWithoutOrderInputSchema),
      ]),
    })
    .strict() as z.ZodType<Prisma.OrderPromotionCreateOrConnectWithoutOrderInput>;

export const OrderPromotionCreateManyOrderInputEnvelopeSchema: z.ZodType<Prisma.OrderPromotionCreateManyOrderInputEnvelope> =
  z
    .object({
      data: z.union([
        z.lazy(() => OrderPromotionCreateManyOrderInputSchema),
        z.lazy(() => OrderPromotionCreateManyOrderInputSchema).array(),
      ]),
      skipDuplicates: z.boolean().optional(),
    })
    .strict() as z.ZodType<Prisma.OrderPromotionCreateManyOrderInputEnvelope>;

export const PaymentCreateWithoutOrderInputSchema: z.ZodType<Prisma.PaymentCreateWithoutOrderInput> =
  z
    .object({
      id: z.string().uuid().optional(),
      type: z.lazy(() => PaymentTypeSchema),
      status: z.lazy(() => PaymentStatusSchema),
      amount: z
        .union([
          z.number(),
          z.string(),
          z.instanceof(Decimal),
          z.instanceof(Prisma.Decimal),
          DecimalJsLikeSchema,
        ])
        .refine((v) => isValidDecimalInput(v), {
          message: 'Must be a Decimal',
        }),
      transactionID: z.string().optional().nullable(),
      createdAt: z.coerce.date().optional(),
      createdBy: z.string().optional().nullable(),
      updatedAt: z.coerce.date().optional(),
      deletedAt: z.coerce.date().optional().nullable(),
    })
    .strict() as z.ZodType<Prisma.PaymentCreateWithoutOrderInput>;

export const PaymentUncheckedCreateWithoutOrderInputSchema: z.ZodType<Prisma.PaymentUncheckedCreateWithoutOrderInput> =
  z
    .object({
      id: z.string().uuid().optional(),
      type: z.lazy(() => PaymentTypeSchema),
      status: z.lazy(() => PaymentStatusSchema),
      amount: z
        .union([
          z.number(),
          z.string(),
          z.instanceof(Decimal),
          z.instanceof(Prisma.Decimal),
          DecimalJsLikeSchema,
        ])
        .refine((v) => isValidDecimalInput(v), {
          message: 'Must be a Decimal',
        }),
      transactionID: z.string().optional().nullable(),
      createdAt: z.coerce.date().optional(),
      createdBy: z.string().optional().nullable(),
      updatedAt: z.coerce.date().optional(),
      deletedAt: z.coerce.date().optional().nullable(),
    })
    .strict() as z.ZodType<Prisma.PaymentUncheckedCreateWithoutOrderInput>;

export const PaymentCreateOrConnectWithoutOrderInputSchema: z.ZodType<Prisma.PaymentCreateOrConnectWithoutOrderInput> =
  z
    .object({
      where: z.lazy(() => PaymentWhereUniqueInputSchema),
      create: z.union([
        z.lazy(() => PaymentCreateWithoutOrderInputSchema),
        z.lazy(() => PaymentUncheckedCreateWithoutOrderInputSchema),
      ]),
    })
    .strict() as z.ZodType<Prisma.PaymentCreateOrConnectWithoutOrderInput>;

export const PaymentCreateManyOrderInputEnvelopeSchema: z.ZodType<Prisma.PaymentCreateManyOrderInputEnvelope> =
  z
    .object({
      data: z.union([
        z.lazy(() => PaymentCreateManyOrderInputSchema),
        z.lazy(() => PaymentCreateManyOrderInputSchema).array(),
      ]),
      skipDuplicates: z.boolean().optional(),
    })
    .strict() as z.ZodType<Prisma.PaymentCreateManyOrderInputEnvelope>;

export const UserUpsertWithoutOrdersInputSchema: z.ZodType<Prisma.UserUpsertWithoutOrdersInput> =
  z
    .object({
      update: z.union([
        z.lazy(() => UserUpdateWithoutOrdersInputSchema),
        z.lazy(() => UserUncheckedUpdateWithoutOrdersInputSchema),
      ]),
      create: z.union([
        z.lazy(() => UserCreateWithoutOrdersInputSchema),
        z.lazy(() => UserUncheckedCreateWithoutOrdersInputSchema),
      ]),
      where: z.lazy(() => UserWhereInputSchema).optional(),
    })
    .strict() as z.ZodType<Prisma.UserUpsertWithoutOrdersInput>;

export const UserUpdateToOneWithWhereWithoutOrdersInputSchema: z.ZodType<Prisma.UserUpdateToOneWithWhereWithoutOrdersInput> =
  z
    .object({
      where: z.lazy(() => UserWhereInputSchema).optional(),
      data: z.union([
        z.lazy(() => UserUpdateWithoutOrdersInputSchema),
        z.lazy(() => UserUncheckedUpdateWithoutOrdersInputSchema),
      ]),
    })
    .strict() as z.ZodType<Prisma.UserUpdateToOneWithWhereWithoutOrdersInput>;

export const UserUpdateWithoutOrdersInputSchema: z.ZodType<Prisma.UserUpdateWithoutOrdersInput> =
  z
    .object({
      id: z
        .union([
          z.string().uuid(),
          z.lazy(() => StringFieldUpdateOperationsInputSchema),
        ])
        .optional(),
      email: z
        .union([
          z.string().email(),
          z.lazy(() => StringFieldUpdateOperationsInputSchema),
        ])
        .optional(),
      password: z
        .union([
          z.string(),
          z.lazy(() => StringFieldUpdateOperationsInputSchema),
        ])
        .optional(),
      firstName: z
        .union([
          z.string(),
          z.lazy(() => StringFieldUpdateOperationsInputSchema),
        ])
        .optional(),
      lastName: z
        .union([
          z.string(),
          z.lazy(() => NullableStringFieldUpdateOperationsInputSchema),
        ])
        .optional()
        .nullable(),
      fullAddress: z
        .union([
          z.string(),
          z.lazy(() => StringFieldUpdateOperationsInputSchema),
        ])
        .optional(),
      city: z
        .union([
          z.string(),
          z.lazy(() => NullableStringFieldUpdateOperationsInputSchema),
        ])
        .optional()
        .nullable(),
      province: z
        .union([
          z.string(),
          z.lazy(() => NullableStringFieldUpdateOperationsInputSchema),
        ])
        .optional()
        .nullable(),
      country: z
        .union([
          z.string(),
          z.lazy(() => NullableStringFieldUpdateOperationsInputSchema),
        ])
        .optional()
        .nullable(),
      phone: z
        .union([
          z.string(),
          z.lazy(() => NullableStringFieldUpdateOperationsInputSchema),
        ])
        .optional()
        .nullable(),
      status: z
        .union([
          z.lazy(() => UserStatusSchema),
          z.lazy(() => EnumUserStatusFieldUpdateOperationsInputSchema),
        ])
        .optional(),
      createdAt: z
        .union([
          z.coerce.date(),
          z.lazy(() => DateTimeFieldUpdateOperationsInputSchema),
        ])
        .optional(),
      createdBy: z
        .union([
          z.string(),
          z.lazy(() => NullableStringFieldUpdateOperationsInputSchema),
        ])
        .optional()
        .nullable(),
      updatedAt: z
        .union([
          z.coerce.date(),
          z.lazy(() => DateTimeFieldUpdateOperationsInputSchema),
        ])
        .optional(),
      deletedAt: z
        .union([
          z.coerce.date(),
          z.lazy(() => NullableDateTimeFieldUpdateOperationsInputSchema),
        ])
        .optional()
        .nullable(),
      vendors: z
        .lazy(() => VendorUpdateManyWithoutUserNestedInputSchema)
        .optional(),
      userVendorRoles: z
        .lazy(() => UserVendorRoleUpdateManyWithoutUserNestedInputSchema)
        .optional(),
      cart: z.lazy(() => CartUpdateOneWithoutUserNestedInputSchema).optional(),
      notifications: z
        .lazy(() => NotificationUpdateManyWithoutUserNestedInputSchema)
        .optional(),
    })
    .strict() as z.ZodType<Prisma.UserUpdateWithoutOrdersInput>;

export const UserUncheckedUpdateWithoutOrdersInputSchema: z.ZodType<Prisma.UserUncheckedUpdateWithoutOrdersInput> =
  z
    .object({
      id: z
        .union([
          z.string().uuid(),
          z.lazy(() => StringFieldUpdateOperationsInputSchema),
        ])
        .optional(),
      email: z
        .union([
          z.string().email(),
          z.lazy(() => StringFieldUpdateOperationsInputSchema),
        ])
        .optional(),
      password: z
        .union([
          z.string(),
          z.lazy(() => StringFieldUpdateOperationsInputSchema),
        ])
        .optional(),
      firstName: z
        .union([
          z.string(),
          z.lazy(() => StringFieldUpdateOperationsInputSchema),
        ])
        .optional(),
      lastName: z
        .union([
          z.string(),
          z.lazy(() => NullableStringFieldUpdateOperationsInputSchema),
        ])
        .optional()
        .nullable(),
      fullAddress: z
        .union([
          z.string(),
          z.lazy(() => StringFieldUpdateOperationsInputSchema),
        ])
        .optional(),
      city: z
        .union([
          z.string(),
          z.lazy(() => NullableStringFieldUpdateOperationsInputSchema),
        ])
        .optional()
        .nullable(),
      province: z
        .union([
          z.string(),
          z.lazy(() => NullableStringFieldUpdateOperationsInputSchema),
        ])
        .optional()
        .nullable(),
      country: z
        .union([
          z.string(),
          z.lazy(() => NullableStringFieldUpdateOperationsInputSchema),
        ])
        .optional()
        .nullable(),
      phone: z
        .union([
          z.string(),
          z.lazy(() => NullableStringFieldUpdateOperationsInputSchema),
        ])
        .optional()
        .nullable(),
      status: z
        .union([
          z.lazy(() => UserStatusSchema),
          z.lazy(() => EnumUserStatusFieldUpdateOperationsInputSchema),
        ])
        .optional(),
      createdAt: z
        .union([
          z.coerce.date(),
          z.lazy(() => DateTimeFieldUpdateOperationsInputSchema),
        ])
        .optional(),
      createdBy: z
        .union([
          z.string(),
          z.lazy(() => NullableStringFieldUpdateOperationsInputSchema),
        ])
        .optional()
        .nullable(),
      updatedAt: z
        .union([
          z.coerce.date(),
          z.lazy(() => DateTimeFieldUpdateOperationsInputSchema),
        ])
        .optional(),
      deletedAt: z
        .union([
          z.coerce.date(),
          z.lazy(() => NullableDateTimeFieldUpdateOperationsInputSchema),
        ])
        .optional()
        .nullable(),
      vendors: z
        .lazy(() => VendorUncheckedUpdateManyWithoutUserNestedInputSchema)
        .optional(),
      userVendorRoles: z
        .lazy(
          () => UserVendorRoleUncheckedUpdateManyWithoutUserNestedInputSchema,
        )
        .optional(),
      cart: z
        .lazy(() => CartUncheckedUpdateOneWithoutUserNestedInputSchema)
        .optional(),
      notifications: z
        .lazy(() => NotificationUncheckedUpdateManyWithoutUserNestedInputSchema)
        .optional(),
    })
    .strict() as z.ZodType<Prisma.UserUncheckedUpdateWithoutOrdersInput>;

export const OrderItemUpsertWithWhereUniqueWithoutOrderInputSchema: z.ZodType<Prisma.OrderItemUpsertWithWhereUniqueWithoutOrderInput> =
  z
    .object({
      where: z.lazy(() => OrderItemWhereUniqueInputSchema),
      update: z.union([
        z.lazy(() => OrderItemUpdateWithoutOrderInputSchema),
        z.lazy(() => OrderItemUncheckedUpdateWithoutOrderInputSchema),
      ]),
      create: z.union([
        z.lazy(() => OrderItemCreateWithoutOrderInputSchema),
        z.lazy(() => OrderItemUncheckedCreateWithoutOrderInputSchema),
      ]),
    })
    .strict() as z.ZodType<Prisma.OrderItemUpsertWithWhereUniqueWithoutOrderInput>;

export const OrderItemUpdateWithWhereUniqueWithoutOrderInputSchema: z.ZodType<Prisma.OrderItemUpdateWithWhereUniqueWithoutOrderInput> =
  z
    .object({
      where: z.lazy(() => OrderItemWhereUniqueInputSchema),
      data: z.union([
        z.lazy(() => OrderItemUpdateWithoutOrderInputSchema),
        z.lazy(() => OrderItemUncheckedUpdateWithoutOrderInputSchema),
      ]),
    })
    .strict() as z.ZodType<Prisma.OrderItemUpdateWithWhereUniqueWithoutOrderInput>;

export const OrderItemUpdateManyWithWhereWithoutOrderInputSchema: z.ZodType<Prisma.OrderItemUpdateManyWithWhereWithoutOrderInput> =
  z
    .object({
      where: z.lazy(() => OrderItemScalarWhereInputSchema),
      data: z.union([
        z.lazy(() => OrderItemUpdateManyMutationInputSchema),
        z.lazy(() => OrderItemUncheckedUpdateManyWithoutOrderInputSchema),
      ]),
    })
    .strict() as z.ZodType<Prisma.OrderItemUpdateManyWithWhereWithoutOrderInput>;

export const OrderAddressUpsertWithWhereUniqueWithoutOrderInputSchema: z.ZodType<Prisma.OrderAddressUpsertWithWhereUniqueWithoutOrderInput> =
  z
    .object({
      where: z.lazy(() => OrderAddressWhereUniqueInputSchema),
      update: z.union([
        z.lazy(() => OrderAddressUpdateWithoutOrderInputSchema),
        z.lazy(() => OrderAddressUncheckedUpdateWithoutOrderInputSchema),
      ]),
      create: z.union([
        z.lazy(() => OrderAddressCreateWithoutOrderInputSchema),
        z.lazy(() => OrderAddressUncheckedCreateWithoutOrderInputSchema),
      ]),
    })
    .strict() as z.ZodType<Prisma.OrderAddressUpsertWithWhereUniqueWithoutOrderInput>;

export const OrderAddressUpdateWithWhereUniqueWithoutOrderInputSchema: z.ZodType<Prisma.OrderAddressUpdateWithWhereUniqueWithoutOrderInput> =
  z
    .object({
      where: z.lazy(() => OrderAddressWhereUniqueInputSchema),
      data: z.union([
        z.lazy(() => OrderAddressUpdateWithoutOrderInputSchema),
        z.lazy(() => OrderAddressUncheckedUpdateWithoutOrderInputSchema),
      ]),
    })
    .strict() as z.ZodType<Prisma.OrderAddressUpdateWithWhereUniqueWithoutOrderInput>;

export const OrderAddressUpdateManyWithWhereWithoutOrderInputSchema: z.ZodType<Prisma.OrderAddressUpdateManyWithWhereWithoutOrderInput> =
  z
    .object({
      where: z.lazy(() => OrderAddressScalarWhereInputSchema),
      data: z.union([
        z.lazy(() => OrderAddressUpdateManyMutationInputSchema),
        z.lazy(() => OrderAddressUncheckedUpdateManyWithoutOrderInputSchema),
      ]),
    })
    .strict() as z.ZodType<Prisma.OrderAddressUpdateManyWithWhereWithoutOrderInput>;

export const OrderAddressScalarWhereInputSchema: z.ZodType<Prisma.OrderAddressScalarWhereInput> =
  z
    .object({
      AND: z
        .union([
          z.lazy(() => OrderAddressScalarWhereInputSchema),
          z.lazy(() => OrderAddressScalarWhereInputSchema).array(),
        ])
        .optional(),
      OR: z
        .lazy(() => OrderAddressScalarWhereInputSchema)
        .array()
        .optional(),
      NOT: z
        .union([
          z.lazy(() => OrderAddressScalarWhereInputSchema),
          z.lazy(() => OrderAddressScalarWhereInputSchema).array(),
        ])
        .optional(),
      id: z.union([z.lazy(() => StringFilterSchema), z.string()]).optional(),
      orderID: z
        .union([z.lazy(() => StringFilterSchema), z.string()])
        .optional(),
      type: z
        .union([
          z.lazy(() => EnumAddressTypeFilterSchema),
          z.lazy(() => AddressTypeSchema),
        ])
        .optional(),
      firstName: z
        .union([z.lazy(() => StringFilterSchema), z.string()])
        .optional(),
      lastName: z
        .union([z.lazy(() => StringNullableFilterSchema), z.string()])
        .optional()
        .nullable(),
      company: z
        .union([z.lazy(() => StringNullableFilterSchema), z.string()])
        .optional()
        .nullable(),
      fullAddress: z
        .union([z.lazy(() => StringFilterSchema), z.string()])
        .optional(),
      city: z
        .union([z.lazy(() => StringNullableFilterSchema), z.string()])
        .optional()
        .nullable(),
      province: z
        .union([z.lazy(() => StringNullableFilterSchema), z.string()])
        .optional()
        .nullable(),
      country: z
        .union([z.lazy(() => StringNullableFilterSchema), z.string()])
        .optional()
        .nullable(),
      phone: z.union([z.lazy(() => StringFilterSchema), z.string()]).optional(),
    })
    .strict() as z.ZodType<Prisma.OrderAddressScalarWhereInput>;

export const OrderPromotionUpsertWithWhereUniqueWithoutOrderInputSchema: z.ZodType<Prisma.OrderPromotionUpsertWithWhereUniqueWithoutOrderInput> =
  z
    .object({
      where: z.lazy(() => OrderPromotionWhereUniqueInputSchema),
      update: z.union([
        z.lazy(() => OrderPromotionUpdateWithoutOrderInputSchema),
        z.lazy(() => OrderPromotionUncheckedUpdateWithoutOrderInputSchema),
      ]),
      create: z.union([
        z.lazy(() => OrderPromotionCreateWithoutOrderInputSchema),
        z.lazy(() => OrderPromotionUncheckedCreateWithoutOrderInputSchema),
      ]),
    })
    .strict() as z.ZodType<Prisma.OrderPromotionUpsertWithWhereUniqueWithoutOrderInput>;

export const OrderPromotionUpdateWithWhereUniqueWithoutOrderInputSchema: z.ZodType<Prisma.OrderPromotionUpdateWithWhereUniqueWithoutOrderInput> =
  z
    .object({
      where: z.lazy(() => OrderPromotionWhereUniqueInputSchema),
      data: z.union([
        z.lazy(() => OrderPromotionUpdateWithoutOrderInputSchema),
        z.lazy(() => OrderPromotionUncheckedUpdateWithoutOrderInputSchema),
      ]),
    })
    .strict() as z.ZodType<Prisma.OrderPromotionUpdateWithWhereUniqueWithoutOrderInput>;

export const OrderPromotionUpdateManyWithWhereWithoutOrderInputSchema: z.ZodType<Prisma.OrderPromotionUpdateManyWithWhereWithoutOrderInput> =
  z
    .object({
      where: z.lazy(() => OrderPromotionScalarWhereInputSchema),
      data: z.union([
        z.lazy(() => OrderPromotionUpdateManyMutationInputSchema),
        z.lazy(() => OrderPromotionUncheckedUpdateManyWithoutOrderInputSchema),
      ]),
    })
    .strict() as z.ZodType<Prisma.OrderPromotionUpdateManyWithWhereWithoutOrderInput>;

export const OrderPromotionScalarWhereInputSchema: z.ZodType<Prisma.OrderPromotionScalarWhereInput> =
  z
    .object({
      AND: z
        .union([
          z.lazy(() => OrderPromotionScalarWhereInputSchema),
          z.lazy(() => OrderPromotionScalarWhereInputSchema).array(),
        ])
        .optional(),
      OR: z
        .lazy(() => OrderPromotionScalarWhereInputSchema)
        .array()
        .optional(),
      NOT: z
        .union([
          z.lazy(() => OrderPromotionScalarWhereInputSchema),
          z.lazy(() => OrderPromotionScalarWhereInputSchema).array(),
        ])
        .optional(),
      id: z.union([z.lazy(() => StringFilterSchema), z.string()]).optional(),
      orderID: z
        .union([z.lazy(() => StringFilterSchema), z.string()])
        .optional(),
      promotionID: z
        .union([z.lazy(() => StringFilterSchema), z.string()])
        .optional(),
      discountAmount: z
        .union([
          z.lazy(() => DecimalFilterSchema),
          z
            .union([
              z.number(),
              z.string(),
              z.instanceof(Decimal),
              z.instanceof(Prisma.Decimal),
              DecimalJsLikeSchema,
            ])
            .refine((v) => isValidDecimalInput(v), {
              message: 'Must be a Decimal',
            }),
        ])
        .optional(),
    })
    .strict() as z.ZodType<Prisma.OrderPromotionScalarWhereInput>;

export const PaymentUpsertWithWhereUniqueWithoutOrderInputSchema: z.ZodType<Prisma.PaymentUpsertWithWhereUniqueWithoutOrderInput> =
  z
    .object({
      where: z.lazy(() => PaymentWhereUniqueInputSchema),
      update: z.union([
        z.lazy(() => PaymentUpdateWithoutOrderInputSchema),
        z.lazy(() => PaymentUncheckedUpdateWithoutOrderInputSchema),
      ]),
      create: z.union([
        z.lazy(() => PaymentCreateWithoutOrderInputSchema),
        z.lazy(() => PaymentUncheckedCreateWithoutOrderInputSchema),
      ]),
    })
    .strict() as z.ZodType<Prisma.PaymentUpsertWithWhereUniqueWithoutOrderInput>;

export const PaymentUpdateWithWhereUniqueWithoutOrderInputSchema: z.ZodType<Prisma.PaymentUpdateWithWhereUniqueWithoutOrderInput> =
  z
    .object({
      where: z.lazy(() => PaymentWhereUniqueInputSchema),
      data: z.union([
        z.lazy(() => PaymentUpdateWithoutOrderInputSchema),
        z.lazy(() => PaymentUncheckedUpdateWithoutOrderInputSchema),
      ]),
    })
    .strict() as z.ZodType<Prisma.PaymentUpdateWithWhereUniqueWithoutOrderInput>;

export const PaymentUpdateManyWithWhereWithoutOrderInputSchema: z.ZodType<Prisma.PaymentUpdateManyWithWhereWithoutOrderInput> =
  z
    .object({
      where: z.lazy(() => PaymentScalarWhereInputSchema),
      data: z.union([
        z.lazy(() => PaymentUpdateManyMutationInputSchema),
        z.lazy(() => PaymentUncheckedUpdateManyWithoutOrderInputSchema),
      ]),
    })
    .strict() as z.ZodType<Prisma.PaymentUpdateManyWithWhereWithoutOrderInput>;

export const PaymentScalarWhereInputSchema: z.ZodType<Prisma.PaymentScalarWhereInput> =
  z
    .object({
      AND: z
        .union([
          z.lazy(() => PaymentScalarWhereInputSchema),
          z.lazy(() => PaymentScalarWhereInputSchema).array(),
        ])
        .optional(),
      OR: z
        .lazy(() => PaymentScalarWhereInputSchema)
        .array()
        .optional(),
      NOT: z
        .union([
          z.lazy(() => PaymentScalarWhereInputSchema),
          z.lazy(() => PaymentScalarWhereInputSchema).array(),
        ])
        .optional(),
      id: z.union([z.lazy(() => StringFilterSchema), z.string()]).optional(),
      orderID: z
        .union([z.lazy(() => StringFilterSchema), z.string()])
        .optional(),
      type: z
        .union([
          z.lazy(() => EnumPaymentTypeFilterSchema),
          z.lazy(() => PaymentTypeSchema),
        ])
        .optional(),
      status: z
        .union([
          z.lazy(() => EnumPaymentStatusFilterSchema),
          z.lazy(() => PaymentStatusSchema),
        ])
        .optional(),
      amount: z
        .union([
          z.lazy(() => DecimalFilterSchema),
          z
            .union([
              z.number(),
              z.string(),
              z.instanceof(Decimal),
              z.instanceof(Prisma.Decimal),
              DecimalJsLikeSchema,
            ])
            .refine((v) => isValidDecimalInput(v), {
              message: 'Must be a Decimal',
            }),
        ])
        .optional(),
      transactionID: z
        .union([z.lazy(() => StringNullableFilterSchema), z.string()])
        .optional()
        .nullable(),
      createdAt: z
        .union([z.lazy(() => DateTimeFilterSchema), z.coerce.date()])
        .optional(),
      createdBy: z
        .union([z.lazy(() => StringNullableFilterSchema), z.string()])
        .optional()
        .nullable(),
      updatedAt: z
        .union([z.lazy(() => DateTimeFilterSchema), z.coerce.date()])
        .optional(),
      deletedAt: z
        .union([z.lazy(() => DateTimeNullableFilterSchema), z.coerce.date()])
        .optional()
        .nullable(),
    })
    .strict() as z.ZodType<Prisma.PaymentScalarWhereInput>;

export const ProductVariantCreateWithoutOrderItemsInputSchema: z.ZodType<Prisma.ProductVariantCreateWithoutOrderItemsInput> =
  z
    .object({
      id: z.string().uuid().optional(),
      name: z.string().optional().nullable(),
      sku: z.string().optional().nullable(),
      price: z
        .union([
          z.number(),
          z.string(),
          z.instanceof(Decimal),
          z.instanceof(Prisma.Decimal),
          DecimalJsLikeSchema,
        ])
        .refine((v) => isValidDecimalInput(v), {
          message: 'Must be a Decimal',
        }),
      stockQuantity: z.number().int().optional(),
      attributes: z
        .union([
          z.lazy(() => NullableJsonNullValueInputSchema),
          InputJsonValueSchema,
        ])
        .optional(),
      createdAt: z.coerce.date().optional(),
      createdBy: z.string().optional().nullable(),
      updatedAt: z.coerce.date().optional(),
      deletedAt: z.coerce.date().optional().nullable(),
      product: z.lazy(
        () => ProductCreateNestedOneWithoutProductVariantsInputSchema,
      ),
      productImages: z
        .lazy(
          () => ProductImageCreateNestedManyWithoutProductVariantInputSchema,
        )
        .optional(),
      cartItems: z
        .lazy(() => CartItemCreateNestedManyWithoutProductVariantInputSchema)
        .optional(),
    })
    .strict() as z.ZodType<Prisma.ProductVariantCreateWithoutOrderItemsInput>;

export const ProductVariantUncheckedCreateWithoutOrderItemsInputSchema: z.ZodType<Prisma.ProductVariantUncheckedCreateWithoutOrderItemsInput> =
  z
    .object({
      id: z.string().uuid().optional(),
      productID: z.string(),
      name: z.string().optional().nullable(),
      sku: z.string().optional().nullable(),
      price: z
        .union([
          z.number(),
          z.string(),
          z.instanceof(Decimal),
          z.instanceof(Prisma.Decimal),
          DecimalJsLikeSchema,
        ])
        .refine((v) => isValidDecimalInput(v), {
          message: 'Must be a Decimal',
        }),
      stockQuantity: z.number().int().optional(),
      attributes: z
        .union([
          z.lazy(() => NullableJsonNullValueInputSchema),
          InputJsonValueSchema,
        ])
        .optional(),
      createdAt: z.coerce.date().optional(),
      createdBy: z.string().optional().nullable(),
      updatedAt: z.coerce.date().optional(),
      deletedAt: z.coerce.date().optional().nullable(),
      productImages: z
        .lazy(
          () =>
            ProductImageUncheckedCreateNestedManyWithoutProductVariantInputSchema,
        )
        .optional(),
      cartItems: z
        .lazy(
          () =>
            CartItemUncheckedCreateNestedManyWithoutProductVariantInputSchema,
        )
        .optional(),
    })
    .strict() as z.ZodType<Prisma.ProductVariantUncheckedCreateWithoutOrderItemsInput>;

export const ProductVariantCreateOrConnectWithoutOrderItemsInputSchema: z.ZodType<Prisma.ProductVariantCreateOrConnectWithoutOrderItemsInput> =
  z
    .object({
      where: z.lazy(() => ProductVariantWhereUniqueInputSchema),
      create: z.union([
        z.lazy(() => ProductVariantCreateWithoutOrderItemsInputSchema),
        z.lazy(() => ProductVariantUncheckedCreateWithoutOrderItemsInputSchema),
      ]),
    })
    .strict() as z.ZodType<Prisma.ProductVariantCreateOrConnectWithoutOrderItemsInput>;

export const OrderCreateWithoutOrderItemsInputSchema: z.ZodType<Prisma.OrderCreateWithoutOrderItemsInput> =
  z
    .object({
      id: z.string().uuid().optional(),
      orderNumber: z.string(),
      status: z.lazy(() => OrderStatusSchema).optional(),
      subtotal: z
        .union([
          z.number(),
          z.string(),
          z.instanceof(Decimal),
          z.instanceof(Prisma.Decimal),
          DecimalJsLikeSchema,
        ])
        .refine((v) => isValidDecimalInput(v), {
          message: 'Must be a Decimal',
        }),
      taxAmount: z
        .union([
          z.number(),
          z.string(),
          z.instanceof(Decimal),
          z.instanceof(Prisma.Decimal),
          DecimalJsLikeSchema,
        ])
        .refine((v) => isValidDecimalInput(v), { message: 'Must be a Decimal' })
        .optional(),
      shippingAmount: z
        .union([
          z.number(),
          z.string(),
          z.instanceof(Decimal),
          z.instanceof(Prisma.Decimal),
          DecimalJsLikeSchema,
        ])
        .refine((v) => isValidDecimalInput(v), { message: 'Must be a Decimal' })
        .optional(),
      discountAmount: z
        .union([
          z.number(),
          z.string(),
          z.instanceof(Decimal),
          z.instanceof(Prisma.Decimal),
          DecimalJsLikeSchema,
        ])
        .refine((v) => isValidDecimalInput(v), { message: 'Must be a Decimal' })
        .optional(),
      totalAmount: z
        .union([
          z.number(),
          z.string(),
          z.instanceof(Decimal),
          z.instanceof(Prisma.Decimal),
          DecimalJsLikeSchema,
        ])
        .refine((v) => isValidDecimalInput(v), {
          message: 'Must be a Decimal',
        }),
      currency: z.string().optional(),
      notes: z.string().optional().nullable(),
      shippedAt: z.coerce.date().optional().nullable(),
      deliveredAt: z.coerce.date().optional().nullable(),
      createdAt: z.coerce.date().optional(),
      createdBy: z.string().optional().nullable(),
      updatedAt: z.coerce.date().optional(),
      deletedAt: z.coerce.date().optional().nullable(),
      user: z.lazy(() => UserCreateNestedOneWithoutOrdersInputSchema),
      orderAddresses: z
        .lazy(() => OrderAddressCreateNestedManyWithoutOrderInputSchema)
        .optional(),
      orderPromotions: z
        .lazy(() => OrderPromotionCreateNestedManyWithoutOrderInputSchema)
        .optional(),
      payments: z
        .lazy(() => PaymentCreateNestedManyWithoutOrderInputSchema)
        .optional(),
    })
    .strict() as z.ZodType<Prisma.OrderCreateWithoutOrderItemsInput>;

export const OrderUncheckedCreateWithoutOrderItemsInputSchema: z.ZodType<Prisma.OrderUncheckedCreateWithoutOrderItemsInput> =
  z
    .object({
      id: z.string().uuid().optional(),
      orderNumber: z.string(),
      userID: z.string(),
      status: z.lazy(() => OrderStatusSchema).optional(),
      subtotal: z
        .union([
          z.number(),
          z.string(),
          z.instanceof(Decimal),
          z.instanceof(Prisma.Decimal),
          DecimalJsLikeSchema,
        ])
        .refine((v) => isValidDecimalInput(v), {
          message: 'Must be a Decimal',
        }),
      taxAmount: z
        .union([
          z.number(),
          z.string(),
          z.instanceof(Decimal),
          z.instanceof(Prisma.Decimal),
          DecimalJsLikeSchema,
        ])
        .refine((v) => isValidDecimalInput(v), { message: 'Must be a Decimal' })
        .optional(),
      shippingAmount: z
        .union([
          z.number(),
          z.string(),
          z.instanceof(Decimal),
          z.instanceof(Prisma.Decimal),
          DecimalJsLikeSchema,
        ])
        .refine((v) => isValidDecimalInput(v), { message: 'Must be a Decimal' })
        .optional(),
      discountAmount: z
        .union([
          z.number(),
          z.string(),
          z.instanceof(Decimal),
          z.instanceof(Prisma.Decimal),
          DecimalJsLikeSchema,
        ])
        .refine((v) => isValidDecimalInput(v), { message: 'Must be a Decimal' })
        .optional(),
      totalAmount: z
        .union([
          z.number(),
          z.string(),
          z.instanceof(Decimal),
          z.instanceof(Prisma.Decimal),
          DecimalJsLikeSchema,
        ])
        .refine((v) => isValidDecimalInput(v), {
          message: 'Must be a Decimal',
        }),
      currency: z.string().optional(),
      notes: z.string().optional().nullable(),
      shippedAt: z.coerce.date().optional().nullable(),
      deliveredAt: z.coerce.date().optional().nullable(),
      createdAt: z.coerce.date().optional(),
      createdBy: z.string().optional().nullable(),
      updatedAt: z.coerce.date().optional(),
      deletedAt: z.coerce.date().optional().nullable(),
      orderAddresses: z
        .lazy(
          () => OrderAddressUncheckedCreateNestedManyWithoutOrderInputSchema,
        )
        .optional(),
      orderPromotions: z
        .lazy(
          () => OrderPromotionUncheckedCreateNestedManyWithoutOrderInputSchema,
        )
        .optional(),
      payments: z
        .lazy(() => PaymentUncheckedCreateNestedManyWithoutOrderInputSchema)
        .optional(),
    })
    .strict() as z.ZodType<Prisma.OrderUncheckedCreateWithoutOrderItemsInput>;

export const OrderCreateOrConnectWithoutOrderItemsInputSchema: z.ZodType<Prisma.OrderCreateOrConnectWithoutOrderItemsInput> =
  z
    .object({
      where: z.lazy(() => OrderWhereUniqueInputSchema),
      create: z.union([
        z.lazy(() => OrderCreateWithoutOrderItemsInputSchema),
        z.lazy(() => OrderUncheckedCreateWithoutOrderItemsInputSchema),
      ]),
    })
    .strict() as z.ZodType<Prisma.OrderCreateOrConnectWithoutOrderItemsInput>;

export const ProductVariantUpsertWithoutOrderItemsInputSchema: z.ZodType<Prisma.ProductVariantUpsertWithoutOrderItemsInput> =
  z
    .object({
      update: z.union([
        z.lazy(() => ProductVariantUpdateWithoutOrderItemsInputSchema),
        z.lazy(() => ProductVariantUncheckedUpdateWithoutOrderItemsInputSchema),
      ]),
      create: z.union([
        z.lazy(() => ProductVariantCreateWithoutOrderItemsInputSchema),
        z.lazy(() => ProductVariantUncheckedCreateWithoutOrderItemsInputSchema),
      ]),
      where: z.lazy(() => ProductVariantWhereInputSchema).optional(),
    })
    .strict() as z.ZodType<Prisma.ProductVariantUpsertWithoutOrderItemsInput>;

export const ProductVariantUpdateToOneWithWhereWithoutOrderItemsInputSchema: z.ZodType<Prisma.ProductVariantUpdateToOneWithWhereWithoutOrderItemsInput> =
  z
    .object({
      where: z.lazy(() => ProductVariantWhereInputSchema).optional(),
      data: z.union([
        z.lazy(() => ProductVariantUpdateWithoutOrderItemsInputSchema),
        z.lazy(() => ProductVariantUncheckedUpdateWithoutOrderItemsInputSchema),
      ]),
    })
    .strict() as z.ZodType<Prisma.ProductVariantUpdateToOneWithWhereWithoutOrderItemsInput>;

export const ProductVariantUpdateWithoutOrderItemsInputSchema: z.ZodType<Prisma.ProductVariantUpdateWithoutOrderItemsInput> =
  z
    .object({
      id: z
        .union([
          z.string().uuid(),
          z.lazy(() => StringFieldUpdateOperationsInputSchema),
        ])
        .optional(),
      name: z
        .union([
          z.string(),
          z.lazy(() => NullableStringFieldUpdateOperationsInputSchema),
        ])
        .optional()
        .nullable(),
      sku: z
        .union([
          z.string(),
          z.lazy(() => NullableStringFieldUpdateOperationsInputSchema),
        ])
        .optional()
        .nullable(),
      price: z
        .union([
          z
            .union([
              z.number(),
              z.string(),
              z.instanceof(Decimal),
              z.instanceof(Prisma.Decimal),
              DecimalJsLikeSchema,
            ])
            .refine((v) => isValidDecimalInput(v), {
              message: 'Must be a Decimal',
            }),
          z.lazy(() => DecimalFieldUpdateOperationsInputSchema),
        ])
        .optional(),
      stockQuantity: z
        .union([
          z.number().int(),
          z.lazy(() => IntFieldUpdateOperationsInputSchema),
        ])
        .optional(),
      attributes: z
        .union([
          z.lazy(() => NullableJsonNullValueInputSchema),
          InputJsonValueSchema,
        ])
        .optional(),
      createdAt: z
        .union([
          z.coerce.date(),
          z.lazy(() => DateTimeFieldUpdateOperationsInputSchema),
        ])
        .optional(),
      createdBy: z
        .union([
          z.string(),
          z.lazy(() => NullableStringFieldUpdateOperationsInputSchema),
        ])
        .optional()
        .nullable(),
      updatedAt: z
        .union([
          z.coerce.date(),
          z.lazy(() => DateTimeFieldUpdateOperationsInputSchema),
        ])
        .optional(),
      deletedAt: z
        .union([
          z.coerce.date(),
          z.lazy(() => NullableDateTimeFieldUpdateOperationsInputSchema),
        ])
        .optional()
        .nullable(),
      product: z
        .lazy(
          () => ProductUpdateOneRequiredWithoutProductVariantsNestedInputSchema,
        )
        .optional(),
      productImages: z
        .lazy(
          () => ProductImageUpdateManyWithoutProductVariantNestedInputSchema,
        )
        .optional(),
      cartItems: z
        .lazy(() => CartItemUpdateManyWithoutProductVariantNestedInputSchema)
        .optional(),
    })
    .strict() as z.ZodType<Prisma.ProductVariantUpdateWithoutOrderItemsInput>;

export const ProductVariantUncheckedUpdateWithoutOrderItemsInputSchema: z.ZodType<Prisma.ProductVariantUncheckedUpdateWithoutOrderItemsInput> =
  z
    .object({
      id: z
        .union([
          z.string().uuid(),
          z.lazy(() => StringFieldUpdateOperationsInputSchema),
        ])
        .optional(),
      productID: z
        .union([
          z.string(),
          z.lazy(() => StringFieldUpdateOperationsInputSchema),
        ])
        .optional(),
      name: z
        .union([
          z.string(),
          z.lazy(() => NullableStringFieldUpdateOperationsInputSchema),
        ])
        .optional()
        .nullable(),
      sku: z
        .union([
          z.string(),
          z.lazy(() => NullableStringFieldUpdateOperationsInputSchema),
        ])
        .optional()
        .nullable(),
      price: z
        .union([
          z
            .union([
              z.number(),
              z.string(),
              z.instanceof(Decimal),
              z.instanceof(Prisma.Decimal),
              DecimalJsLikeSchema,
            ])
            .refine((v) => isValidDecimalInput(v), {
              message: 'Must be a Decimal',
            }),
          z.lazy(() => DecimalFieldUpdateOperationsInputSchema),
        ])
        .optional(),
      stockQuantity: z
        .union([
          z.number().int(),
          z.lazy(() => IntFieldUpdateOperationsInputSchema),
        ])
        .optional(),
      attributes: z
        .union([
          z.lazy(() => NullableJsonNullValueInputSchema),
          InputJsonValueSchema,
        ])
        .optional(),
      createdAt: z
        .union([
          z.coerce.date(),
          z.lazy(() => DateTimeFieldUpdateOperationsInputSchema),
        ])
        .optional(),
      createdBy: z
        .union([
          z.string(),
          z.lazy(() => NullableStringFieldUpdateOperationsInputSchema),
        ])
        .optional()
        .nullable(),
      updatedAt: z
        .union([
          z.coerce.date(),
          z.lazy(() => DateTimeFieldUpdateOperationsInputSchema),
        ])
        .optional(),
      deletedAt: z
        .union([
          z.coerce.date(),
          z.lazy(() => NullableDateTimeFieldUpdateOperationsInputSchema),
        ])
        .optional()
        .nullable(),
      productImages: z
        .lazy(
          () =>
            ProductImageUncheckedUpdateManyWithoutProductVariantNestedInputSchema,
        )
        .optional(),
      cartItems: z
        .lazy(
          () =>
            CartItemUncheckedUpdateManyWithoutProductVariantNestedInputSchema,
        )
        .optional(),
    })
    .strict() as z.ZodType<Prisma.ProductVariantUncheckedUpdateWithoutOrderItemsInput>;

export const OrderUpsertWithoutOrderItemsInputSchema: z.ZodType<Prisma.OrderUpsertWithoutOrderItemsInput> =
  z
    .object({
      update: z.union([
        z.lazy(() => OrderUpdateWithoutOrderItemsInputSchema),
        z.lazy(() => OrderUncheckedUpdateWithoutOrderItemsInputSchema),
      ]),
      create: z.union([
        z.lazy(() => OrderCreateWithoutOrderItemsInputSchema),
        z.lazy(() => OrderUncheckedCreateWithoutOrderItemsInputSchema),
      ]),
      where: z.lazy(() => OrderWhereInputSchema).optional(),
    })
    .strict() as z.ZodType<Prisma.OrderUpsertWithoutOrderItemsInput>;

export const OrderUpdateToOneWithWhereWithoutOrderItemsInputSchema: z.ZodType<Prisma.OrderUpdateToOneWithWhereWithoutOrderItemsInput> =
  z
    .object({
      where: z.lazy(() => OrderWhereInputSchema).optional(),
      data: z.union([
        z.lazy(() => OrderUpdateWithoutOrderItemsInputSchema),
        z.lazy(() => OrderUncheckedUpdateWithoutOrderItemsInputSchema),
      ]),
    })
    .strict() as z.ZodType<Prisma.OrderUpdateToOneWithWhereWithoutOrderItemsInput>;

export const OrderUpdateWithoutOrderItemsInputSchema: z.ZodType<Prisma.OrderUpdateWithoutOrderItemsInput> =
  z
    .object({
      id: z
        .union([
          z.string().uuid(),
          z.lazy(() => StringFieldUpdateOperationsInputSchema),
        ])
        .optional(),
      orderNumber: z
        .union([
          z.string(),
          z.lazy(() => StringFieldUpdateOperationsInputSchema),
        ])
        .optional(),
      status: z
        .union([
          z.lazy(() => OrderStatusSchema),
          z.lazy(() => EnumOrderStatusFieldUpdateOperationsInputSchema),
        ])
        .optional(),
      subtotal: z
        .union([
          z
            .union([
              z.number(),
              z.string(),
              z.instanceof(Decimal),
              z.instanceof(Prisma.Decimal),
              DecimalJsLikeSchema,
            ])
            .refine((v) => isValidDecimalInput(v), {
              message: 'Must be a Decimal',
            }),
          z.lazy(() => DecimalFieldUpdateOperationsInputSchema),
        ])
        .optional(),
      taxAmount: z
        .union([
          z
            .union([
              z.number(),
              z.string(),
              z.instanceof(Decimal),
              z.instanceof(Prisma.Decimal),
              DecimalJsLikeSchema,
            ])
            .refine((v) => isValidDecimalInput(v), {
              message: 'Must be a Decimal',
            }),
          z.lazy(() => DecimalFieldUpdateOperationsInputSchema),
        ])
        .optional(),
      shippingAmount: z
        .union([
          z
            .union([
              z.number(),
              z.string(),
              z.instanceof(Decimal),
              z.instanceof(Prisma.Decimal),
              DecimalJsLikeSchema,
            ])
            .refine((v) => isValidDecimalInput(v), {
              message: 'Must be a Decimal',
            }),
          z.lazy(() => DecimalFieldUpdateOperationsInputSchema),
        ])
        .optional(),
      discountAmount: z
        .union([
          z
            .union([
              z.number(),
              z.string(),
              z.instanceof(Decimal),
              z.instanceof(Prisma.Decimal),
              DecimalJsLikeSchema,
            ])
            .refine((v) => isValidDecimalInput(v), {
              message: 'Must be a Decimal',
            }),
          z.lazy(() => DecimalFieldUpdateOperationsInputSchema),
        ])
        .optional(),
      totalAmount: z
        .union([
          z
            .union([
              z.number(),
              z.string(),
              z.instanceof(Decimal),
              z.instanceof(Prisma.Decimal),
              DecimalJsLikeSchema,
            ])
            .refine((v) => isValidDecimalInput(v), {
              message: 'Must be a Decimal',
            }),
          z.lazy(() => DecimalFieldUpdateOperationsInputSchema),
        ])
        .optional(),
      currency: z
        .union([
          z.string(),
          z.lazy(() => StringFieldUpdateOperationsInputSchema),
        ])
        .optional(),
      notes: z
        .union([
          z.string(),
          z.lazy(() => NullableStringFieldUpdateOperationsInputSchema),
        ])
        .optional()
        .nullable(),
      shippedAt: z
        .union([
          z.coerce.date(),
          z.lazy(() => NullableDateTimeFieldUpdateOperationsInputSchema),
        ])
        .optional()
        .nullable(),
      deliveredAt: z
        .union([
          z.coerce.date(),
          z.lazy(() => NullableDateTimeFieldUpdateOperationsInputSchema),
        ])
        .optional()
        .nullable(),
      createdAt: z
        .union([
          z.coerce.date(),
          z.lazy(() => DateTimeFieldUpdateOperationsInputSchema),
        ])
        .optional(),
      createdBy: z
        .union([
          z.string(),
          z.lazy(() => NullableStringFieldUpdateOperationsInputSchema),
        ])
        .optional()
        .nullable(),
      updatedAt: z
        .union([
          z.coerce.date(),
          z.lazy(() => DateTimeFieldUpdateOperationsInputSchema),
        ])
        .optional(),
      deletedAt: z
        .union([
          z.coerce.date(),
          z.lazy(() => NullableDateTimeFieldUpdateOperationsInputSchema),
        ])
        .optional()
        .nullable(),
      user: z
        .lazy(() => UserUpdateOneRequiredWithoutOrdersNestedInputSchema)
        .optional(),
      orderAddresses: z
        .lazy(() => OrderAddressUpdateManyWithoutOrderNestedInputSchema)
        .optional(),
      orderPromotions: z
        .lazy(() => OrderPromotionUpdateManyWithoutOrderNestedInputSchema)
        .optional(),
      payments: z
        .lazy(() => PaymentUpdateManyWithoutOrderNestedInputSchema)
        .optional(),
    })
    .strict() as z.ZodType<Prisma.OrderUpdateWithoutOrderItemsInput>;

export const OrderUncheckedUpdateWithoutOrderItemsInputSchema: z.ZodType<Prisma.OrderUncheckedUpdateWithoutOrderItemsInput> =
  z
    .object({
      id: z
        .union([
          z.string().uuid(),
          z.lazy(() => StringFieldUpdateOperationsInputSchema),
        ])
        .optional(),
      orderNumber: z
        .union([
          z.string(),
          z.lazy(() => StringFieldUpdateOperationsInputSchema),
        ])
        .optional(),
      userID: z
        .union([
          z.string(),
          z.lazy(() => StringFieldUpdateOperationsInputSchema),
        ])
        .optional(),
      status: z
        .union([
          z.lazy(() => OrderStatusSchema),
          z.lazy(() => EnumOrderStatusFieldUpdateOperationsInputSchema),
        ])
        .optional(),
      subtotal: z
        .union([
          z
            .union([
              z.number(),
              z.string(),
              z.instanceof(Decimal),
              z.instanceof(Prisma.Decimal),
              DecimalJsLikeSchema,
            ])
            .refine((v) => isValidDecimalInput(v), {
              message: 'Must be a Decimal',
            }),
          z.lazy(() => DecimalFieldUpdateOperationsInputSchema),
        ])
        .optional(),
      taxAmount: z
        .union([
          z
            .union([
              z.number(),
              z.string(),
              z.instanceof(Decimal),
              z.instanceof(Prisma.Decimal),
              DecimalJsLikeSchema,
            ])
            .refine((v) => isValidDecimalInput(v), {
              message: 'Must be a Decimal',
            }),
          z.lazy(() => DecimalFieldUpdateOperationsInputSchema),
        ])
        .optional(),
      shippingAmount: z
        .union([
          z
            .union([
              z.number(),
              z.string(),
              z.instanceof(Decimal),
              z.instanceof(Prisma.Decimal),
              DecimalJsLikeSchema,
            ])
            .refine((v) => isValidDecimalInput(v), {
              message: 'Must be a Decimal',
            }),
          z.lazy(() => DecimalFieldUpdateOperationsInputSchema),
        ])
        .optional(),
      discountAmount: z
        .union([
          z
            .union([
              z.number(),
              z.string(),
              z.instanceof(Decimal),
              z.instanceof(Prisma.Decimal),
              DecimalJsLikeSchema,
            ])
            .refine((v) => isValidDecimalInput(v), {
              message: 'Must be a Decimal',
            }),
          z.lazy(() => DecimalFieldUpdateOperationsInputSchema),
        ])
        .optional(),
      totalAmount: z
        .union([
          z
            .union([
              z.number(),
              z.string(),
              z.instanceof(Decimal),
              z.instanceof(Prisma.Decimal),
              DecimalJsLikeSchema,
            ])
            .refine((v) => isValidDecimalInput(v), {
              message: 'Must be a Decimal',
            }),
          z.lazy(() => DecimalFieldUpdateOperationsInputSchema),
        ])
        .optional(),
      currency: z
        .union([
          z.string(),
          z.lazy(() => StringFieldUpdateOperationsInputSchema),
        ])
        .optional(),
      notes: z
        .union([
          z.string(),
          z.lazy(() => NullableStringFieldUpdateOperationsInputSchema),
        ])
        .optional()
        .nullable(),
      shippedAt: z
        .union([
          z.coerce.date(),
          z.lazy(() => NullableDateTimeFieldUpdateOperationsInputSchema),
        ])
        .optional()
        .nullable(),
      deliveredAt: z
        .union([
          z.coerce.date(),
          z.lazy(() => NullableDateTimeFieldUpdateOperationsInputSchema),
        ])
        .optional()
        .nullable(),
      createdAt: z
        .union([
          z.coerce.date(),
          z.lazy(() => DateTimeFieldUpdateOperationsInputSchema),
        ])
        .optional(),
      createdBy: z
        .union([
          z.string(),
          z.lazy(() => NullableStringFieldUpdateOperationsInputSchema),
        ])
        .optional()
        .nullable(),
      updatedAt: z
        .union([
          z.coerce.date(),
          z.lazy(() => DateTimeFieldUpdateOperationsInputSchema),
        ])
        .optional(),
      deletedAt: z
        .union([
          z.coerce.date(),
          z.lazy(() => NullableDateTimeFieldUpdateOperationsInputSchema),
        ])
        .optional()
        .nullable(),
      orderAddresses: z
        .lazy(
          () => OrderAddressUncheckedUpdateManyWithoutOrderNestedInputSchema,
        )
        .optional(),
      orderPromotions: z
        .lazy(
          () => OrderPromotionUncheckedUpdateManyWithoutOrderNestedInputSchema,
        )
        .optional(),
      payments: z
        .lazy(() => PaymentUncheckedUpdateManyWithoutOrderNestedInputSchema)
        .optional(),
    })
    .strict() as z.ZodType<Prisma.OrderUncheckedUpdateWithoutOrderItemsInput>;

export const OrderCreateWithoutOrderAddressesInputSchema: z.ZodType<Prisma.OrderCreateWithoutOrderAddressesInput> =
  z
    .object({
      id: z.string().uuid().optional(),
      orderNumber: z.string(),
      status: z.lazy(() => OrderStatusSchema).optional(),
      subtotal: z
        .union([
          z.number(),
          z.string(),
          z.instanceof(Decimal),
          z.instanceof(Prisma.Decimal),
          DecimalJsLikeSchema,
        ])
        .refine((v) => isValidDecimalInput(v), {
          message: 'Must be a Decimal',
        }),
      taxAmount: z
        .union([
          z.number(),
          z.string(),
          z.instanceof(Decimal),
          z.instanceof(Prisma.Decimal),
          DecimalJsLikeSchema,
        ])
        .refine((v) => isValidDecimalInput(v), { message: 'Must be a Decimal' })
        .optional(),
      shippingAmount: z
        .union([
          z.number(),
          z.string(),
          z.instanceof(Decimal),
          z.instanceof(Prisma.Decimal),
          DecimalJsLikeSchema,
        ])
        .refine((v) => isValidDecimalInput(v), { message: 'Must be a Decimal' })
        .optional(),
      discountAmount: z
        .union([
          z.number(),
          z.string(),
          z.instanceof(Decimal),
          z.instanceof(Prisma.Decimal),
          DecimalJsLikeSchema,
        ])
        .refine((v) => isValidDecimalInput(v), { message: 'Must be a Decimal' })
        .optional(),
      totalAmount: z
        .union([
          z.number(),
          z.string(),
          z.instanceof(Decimal),
          z.instanceof(Prisma.Decimal),
          DecimalJsLikeSchema,
        ])
        .refine((v) => isValidDecimalInput(v), {
          message: 'Must be a Decimal',
        }),
      currency: z.string().optional(),
      notes: z.string().optional().nullable(),
      shippedAt: z.coerce.date().optional().nullable(),
      deliveredAt: z.coerce.date().optional().nullable(),
      createdAt: z.coerce.date().optional(),
      createdBy: z.string().optional().nullable(),
      updatedAt: z.coerce.date().optional(),
      deletedAt: z.coerce.date().optional().nullable(),
      user: z.lazy(() => UserCreateNestedOneWithoutOrdersInputSchema),
      orderItems: z
        .lazy(() => OrderItemCreateNestedManyWithoutOrderInputSchema)
        .optional(),
      orderPromotions: z
        .lazy(() => OrderPromotionCreateNestedManyWithoutOrderInputSchema)
        .optional(),
      payments: z
        .lazy(() => PaymentCreateNestedManyWithoutOrderInputSchema)
        .optional(),
    })
    .strict() as z.ZodType<Prisma.OrderCreateWithoutOrderAddressesInput>;

export const OrderUncheckedCreateWithoutOrderAddressesInputSchema: z.ZodType<Prisma.OrderUncheckedCreateWithoutOrderAddressesInput> =
  z
    .object({
      id: z.string().uuid().optional(),
      orderNumber: z.string(),
      userID: z.string(),
      status: z.lazy(() => OrderStatusSchema).optional(),
      subtotal: z
        .union([
          z.number(),
          z.string(),
          z.instanceof(Decimal),
          z.instanceof(Prisma.Decimal),
          DecimalJsLikeSchema,
        ])
        .refine((v) => isValidDecimalInput(v), {
          message: 'Must be a Decimal',
        }),
      taxAmount: z
        .union([
          z.number(),
          z.string(),
          z.instanceof(Decimal),
          z.instanceof(Prisma.Decimal),
          DecimalJsLikeSchema,
        ])
        .refine((v) => isValidDecimalInput(v), { message: 'Must be a Decimal' })
        .optional(),
      shippingAmount: z
        .union([
          z.number(),
          z.string(),
          z.instanceof(Decimal),
          z.instanceof(Prisma.Decimal),
          DecimalJsLikeSchema,
        ])
        .refine((v) => isValidDecimalInput(v), { message: 'Must be a Decimal' })
        .optional(),
      discountAmount: z
        .union([
          z.number(),
          z.string(),
          z.instanceof(Decimal),
          z.instanceof(Prisma.Decimal),
          DecimalJsLikeSchema,
        ])
        .refine((v) => isValidDecimalInput(v), { message: 'Must be a Decimal' })
        .optional(),
      totalAmount: z
        .union([
          z.number(),
          z.string(),
          z.instanceof(Decimal),
          z.instanceof(Prisma.Decimal),
          DecimalJsLikeSchema,
        ])
        .refine((v) => isValidDecimalInput(v), {
          message: 'Must be a Decimal',
        }),
      currency: z.string().optional(),
      notes: z.string().optional().nullable(),
      shippedAt: z.coerce.date().optional().nullable(),
      deliveredAt: z.coerce.date().optional().nullable(),
      createdAt: z.coerce.date().optional(),
      createdBy: z.string().optional().nullable(),
      updatedAt: z.coerce.date().optional(),
      deletedAt: z.coerce.date().optional().nullable(),
      orderItems: z
        .lazy(() => OrderItemUncheckedCreateNestedManyWithoutOrderInputSchema)
        .optional(),
      orderPromotions: z
        .lazy(
          () => OrderPromotionUncheckedCreateNestedManyWithoutOrderInputSchema,
        )
        .optional(),
      payments: z
        .lazy(() => PaymentUncheckedCreateNestedManyWithoutOrderInputSchema)
        .optional(),
    })
    .strict() as z.ZodType<Prisma.OrderUncheckedCreateWithoutOrderAddressesInput>;

export const OrderCreateOrConnectWithoutOrderAddressesInputSchema: z.ZodType<Prisma.OrderCreateOrConnectWithoutOrderAddressesInput> =
  z
    .object({
      where: z.lazy(() => OrderWhereUniqueInputSchema),
      create: z.union([
        z.lazy(() => OrderCreateWithoutOrderAddressesInputSchema),
        z.lazy(() => OrderUncheckedCreateWithoutOrderAddressesInputSchema),
      ]),
    })
    .strict() as z.ZodType<Prisma.OrderCreateOrConnectWithoutOrderAddressesInput>;

export const OrderUpsertWithoutOrderAddressesInputSchema: z.ZodType<Prisma.OrderUpsertWithoutOrderAddressesInput> =
  z
    .object({
      update: z.union([
        z.lazy(() => OrderUpdateWithoutOrderAddressesInputSchema),
        z.lazy(() => OrderUncheckedUpdateWithoutOrderAddressesInputSchema),
      ]),
      create: z.union([
        z.lazy(() => OrderCreateWithoutOrderAddressesInputSchema),
        z.lazy(() => OrderUncheckedCreateWithoutOrderAddressesInputSchema),
      ]),
      where: z.lazy(() => OrderWhereInputSchema).optional(),
    })
    .strict() as z.ZodType<Prisma.OrderUpsertWithoutOrderAddressesInput>;

export const OrderUpdateToOneWithWhereWithoutOrderAddressesInputSchema: z.ZodType<Prisma.OrderUpdateToOneWithWhereWithoutOrderAddressesInput> =
  z
    .object({
      where: z.lazy(() => OrderWhereInputSchema).optional(),
      data: z.union([
        z.lazy(() => OrderUpdateWithoutOrderAddressesInputSchema),
        z.lazy(() => OrderUncheckedUpdateWithoutOrderAddressesInputSchema),
      ]),
    })
    .strict() as z.ZodType<Prisma.OrderUpdateToOneWithWhereWithoutOrderAddressesInput>;

export const OrderUpdateWithoutOrderAddressesInputSchema: z.ZodType<Prisma.OrderUpdateWithoutOrderAddressesInput> =
  z
    .object({
      id: z
        .union([
          z.string().uuid(),
          z.lazy(() => StringFieldUpdateOperationsInputSchema),
        ])
        .optional(),
      orderNumber: z
        .union([
          z.string(),
          z.lazy(() => StringFieldUpdateOperationsInputSchema),
        ])
        .optional(),
      status: z
        .union([
          z.lazy(() => OrderStatusSchema),
          z.lazy(() => EnumOrderStatusFieldUpdateOperationsInputSchema),
        ])
        .optional(),
      subtotal: z
        .union([
          z
            .union([
              z.number(),
              z.string(),
              z.instanceof(Decimal),
              z.instanceof(Prisma.Decimal),
              DecimalJsLikeSchema,
            ])
            .refine((v) => isValidDecimalInput(v), {
              message: 'Must be a Decimal',
            }),
          z.lazy(() => DecimalFieldUpdateOperationsInputSchema),
        ])
        .optional(),
      taxAmount: z
        .union([
          z
            .union([
              z.number(),
              z.string(),
              z.instanceof(Decimal),
              z.instanceof(Prisma.Decimal),
              DecimalJsLikeSchema,
            ])
            .refine((v) => isValidDecimalInput(v), {
              message: 'Must be a Decimal',
            }),
          z.lazy(() => DecimalFieldUpdateOperationsInputSchema),
        ])
        .optional(),
      shippingAmount: z
        .union([
          z
            .union([
              z.number(),
              z.string(),
              z.instanceof(Decimal),
              z.instanceof(Prisma.Decimal),
              DecimalJsLikeSchema,
            ])
            .refine((v) => isValidDecimalInput(v), {
              message: 'Must be a Decimal',
            }),
          z.lazy(() => DecimalFieldUpdateOperationsInputSchema),
        ])
        .optional(),
      discountAmount: z
        .union([
          z
            .union([
              z.number(),
              z.string(),
              z.instanceof(Decimal),
              z.instanceof(Prisma.Decimal),
              DecimalJsLikeSchema,
            ])
            .refine((v) => isValidDecimalInput(v), {
              message: 'Must be a Decimal',
            }),
          z.lazy(() => DecimalFieldUpdateOperationsInputSchema),
        ])
        .optional(),
      totalAmount: z
        .union([
          z
            .union([
              z.number(),
              z.string(),
              z.instanceof(Decimal),
              z.instanceof(Prisma.Decimal),
              DecimalJsLikeSchema,
            ])
            .refine((v) => isValidDecimalInput(v), {
              message: 'Must be a Decimal',
            }),
          z.lazy(() => DecimalFieldUpdateOperationsInputSchema),
        ])
        .optional(),
      currency: z
        .union([
          z.string(),
          z.lazy(() => StringFieldUpdateOperationsInputSchema),
        ])
        .optional(),
      notes: z
        .union([
          z.string(),
          z.lazy(() => NullableStringFieldUpdateOperationsInputSchema),
        ])
        .optional()
        .nullable(),
      shippedAt: z
        .union([
          z.coerce.date(),
          z.lazy(() => NullableDateTimeFieldUpdateOperationsInputSchema),
        ])
        .optional()
        .nullable(),
      deliveredAt: z
        .union([
          z.coerce.date(),
          z.lazy(() => NullableDateTimeFieldUpdateOperationsInputSchema),
        ])
        .optional()
        .nullable(),
      createdAt: z
        .union([
          z.coerce.date(),
          z.lazy(() => DateTimeFieldUpdateOperationsInputSchema),
        ])
        .optional(),
      createdBy: z
        .union([
          z.string(),
          z.lazy(() => NullableStringFieldUpdateOperationsInputSchema),
        ])
        .optional()
        .nullable(),
      updatedAt: z
        .union([
          z.coerce.date(),
          z.lazy(() => DateTimeFieldUpdateOperationsInputSchema),
        ])
        .optional(),
      deletedAt: z
        .union([
          z.coerce.date(),
          z.lazy(() => NullableDateTimeFieldUpdateOperationsInputSchema),
        ])
        .optional()
        .nullable(),
      user: z
        .lazy(() => UserUpdateOneRequiredWithoutOrdersNestedInputSchema)
        .optional(),
      orderItems: z
        .lazy(() => OrderItemUpdateManyWithoutOrderNestedInputSchema)
        .optional(),
      orderPromotions: z
        .lazy(() => OrderPromotionUpdateManyWithoutOrderNestedInputSchema)
        .optional(),
      payments: z
        .lazy(() => PaymentUpdateManyWithoutOrderNestedInputSchema)
        .optional(),
    })
    .strict() as z.ZodType<Prisma.OrderUpdateWithoutOrderAddressesInput>;

export const OrderUncheckedUpdateWithoutOrderAddressesInputSchema: z.ZodType<Prisma.OrderUncheckedUpdateWithoutOrderAddressesInput> =
  z
    .object({
      id: z
        .union([
          z.string().uuid(),
          z.lazy(() => StringFieldUpdateOperationsInputSchema),
        ])
        .optional(),
      orderNumber: z
        .union([
          z.string(),
          z.lazy(() => StringFieldUpdateOperationsInputSchema),
        ])
        .optional(),
      userID: z
        .union([
          z.string(),
          z.lazy(() => StringFieldUpdateOperationsInputSchema),
        ])
        .optional(),
      status: z
        .union([
          z.lazy(() => OrderStatusSchema),
          z.lazy(() => EnumOrderStatusFieldUpdateOperationsInputSchema),
        ])
        .optional(),
      subtotal: z
        .union([
          z
            .union([
              z.number(),
              z.string(),
              z.instanceof(Decimal),
              z.instanceof(Prisma.Decimal),
              DecimalJsLikeSchema,
            ])
            .refine((v) => isValidDecimalInput(v), {
              message: 'Must be a Decimal',
            }),
          z.lazy(() => DecimalFieldUpdateOperationsInputSchema),
        ])
        .optional(),
      taxAmount: z
        .union([
          z
            .union([
              z.number(),
              z.string(),
              z.instanceof(Decimal),
              z.instanceof(Prisma.Decimal),
              DecimalJsLikeSchema,
            ])
            .refine((v) => isValidDecimalInput(v), {
              message: 'Must be a Decimal',
            }),
          z.lazy(() => DecimalFieldUpdateOperationsInputSchema),
        ])
        .optional(),
      shippingAmount: z
        .union([
          z
            .union([
              z.number(),
              z.string(),
              z.instanceof(Decimal),
              z.instanceof(Prisma.Decimal),
              DecimalJsLikeSchema,
            ])
            .refine((v) => isValidDecimalInput(v), {
              message: 'Must be a Decimal',
            }),
          z.lazy(() => DecimalFieldUpdateOperationsInputSchema),
        ])
        .optional(),
      discountAmount: z
        .union([
          z
            .union([
              z.number(),
              z.string(),
              z.instanceof(Decimal),
              z.instanceof(Prisma.Decimal),
              DecimalJsLikeSchema,
            ])
            .refine((v) => isValidDecimalInput(v), {
              message: 'Must be a Decimal',
            }),
          z.lazy(() => DecimalFieldUpdateOperationsInputSchema),
        ])
        .optional(),
      totalAmount: z
        .union([
          z
            .union([
              z.number(),
              z.string(),
              z.instanceof(Decimal),
              z.instanceof(Prisma.Decimal),
              DecimalJsLikeSchema,
            ])
            .refine((v) => isValidDecimalInput(v), {
              message: 'Must be a Decimal',
            }),
          z.lazy(() => DecimalFieldUpdateOperationsInputSchema),
        ])
        .optional(),
      currency: z
        .union([
          z.string(),
          z.lazy(() => StringFieldUpdateOperationsInputSchema),
        ])
        .optional(),
      notes: z
        .union([
          z.string(),
          z.lazy(() => NullableStringFieldUpdateOperationsInputSchema),
        ])
        .optional()
        .nullable(),
      shippedAt: z
        .union([
          z.coerce.date(),
          z.lazy(() => NullableDateTimeFieldUpdateOperationsInputSchema),
        ])
        .optional()
        .nullable(),
      deliveredAt: z
        .union([
          z.coerce.date(),
          z.lazy(() => NullableDateTimeFieldUpdateOperationsInputSchema),
        ])
        .optional()
        .nullable(),
      createdAt: z
        .union([
          z.coerce.date(),
          z.lazy(() => DateTimeFieldUpdateOperationsInputSchema),
        ])
        .optional(),
      createdBy: z
        .union([
          z.string(),
          z.lazy(() => NullableStringFieldUpdateOperationsInputSchema),
        ])
        .optional()
        .nullable(),
      updatedAt: z
        .union([
          z.coerce.date(),
          z.lazy(() => DateTimeFieldUpdateOperationsInputSchema),
        ])
        .optional(),
      deletedAt: z
        .union([
          z.coerce.date(),
          z.lazy(() => NullableDateTimeFieldUpdateOperationsInputSchema),
        ])
        .optional()
        .nullable(),
      orderItems: z
        .lazy(() => OrderItemUncheckedUpdateManyWithoutOrderNestedInputSchema)
        .optional(),
      orderPromotions: z
        .lazy(
          () => OrderPromotionUncheckedUpdateManyWithoutOrderNestedInputSchema,
        )
        .optional(),
      payments: z
        .lazy(() => PaymentUncheckedUpdateManyWithoutOrderNestedInputSchema)
        .optional(),
    })
    .strict() as z.ZodType<Prisma.OrderUncheckedUpdateWithoutOrderAddressesInput>;

export const OrderPromotionCreateWithoutPromotionInputSchema: z.ZodType<Prisma.OrderPromotionCreateWithoutPromotionInput> =
  z
    .object({
      id: z.string().uuid().optional(),
      discountAmount: z
        .union([
          z.number(),
          z.string(),
          z.instanceof(Decimal),
          z.instanceof(Prisma.Decimal),
          DecimalJsLikeSchema,
        ])
        .refine((v) => isValidDecimalInput(v), { message: 'Must be a Decimal' })
        .optional(),
      order: z.lazy(
        () => OrderCreateNestedOneWithoutOrderPromotionsInputSchema,
      ),
    })
    .strict() as z.ZodType<Prisma.OrderPromotionCreateWithoutPromotionInput>;

export const OrderPromotionUncheckedCreateWithoutPromotionInputSchema: z.ZodType<Prisma.OrderPromotionUncheckedCreateWithoutPromotionInput> =
  z
    .object({
      id: z.string().uuid().optional(),
      orderID: z.string(),
      discountAmount: z
        .union([
          z.number(),
          z.string(),
          z.instanceof(Decimal),
          z.instanceof(Prisma.Decimal),
          DecimalJsLikeSchema,
        ])
        .refine((v) => isValidDecimalInput(v), { message: 'Must be a Decimal' })
        .optional(),
    })
    .strict() as z.ZodType<Prisma.OrderPromotionUncheckedCreateWithoutPromotionInput>;

export const OrderPromotionCreateOrConnectWithoutPromotionInputSchema: z.ZodType<Prisma.OrderPromotionCreateOrConnectWithoutPromotionInput> =
  z
    .object({
      where: z.lazy(() => OrderPromotionWhereUniqueInputSchema),
      create: z.union([
        z.lazy(() => OrderPromotionCreateWithoutPromotionInputSchema),
        z.lazy(() => OrderPromotionUncheckedCreateWithoutPromotionInputSchema),
      ]),
    })
    .strict() as z.ZodType<Prisma.OrderPromotionCreateOrConnectWithoutPromotionInput>;

export const OrderPromotionCreateManyPromotionInputEnvelopeSchema: z.ZodType<Prisma.OrderPromotionCreateManyPromotionInputEnvelope> =
  z
    .object({
      data: z.union([
        z.lazy(() => OrderPromotionCreateManyPromotionInputSchema),
        z.lazy(() => OrderPromotionCreateManyPromotionInputSchema).array(),
      ]),
      skipDuplicates: z.boolean().optional(),
    })
    .strict() as z.ZodType<Prisma.OrderPromotionCreateManyPromotionInputEnvelope>;

export const OrderPromotionUpsertWithWhereUniqueWithoutPromotionInputSchema: z.ZodType<Prisma.OrderPromotionUpsertWithWhereUniqueWithoutPromotionInput> =
  z
    .object({
      where: z.lazy(() => OrderPromotionWhereUniqueInputSchema),
      update: z.union([
        z.lazy(() => OrderPromotionUpdateWithoutPromotionInputSchema),
        z.lazy(() => OrderPromotionUncheckedUpdateWithoutPromotionInputSchema),
      ]),
      create: z.union([
        z.lazy(() => OrderPromotionCreateWithoutPromotionInputSchema),
        z.lazy(() => OrderPromotionUncheckedCreateWithoutPromotionInputSchema),
      ]),
    })
    .strict() as z.ZodType<Prisma.OrderPromotionUpsertWithWhereUniqueWithoutPromotionInput>;

export const OrderPromotionUpdateWithWhereUniqueWithoutPromotionInputSchema: z.ZodType<Prisma.OrderPromotionUpdateWithWhereUniqueWithoutPromotionInput> =
  z
    .object({
      where: z.lazy(() => OrderPromotionWhereUniqueInputSchema),
      data: z.union([
        z.lazy(() => OrderPromotionUpdateWithoutPromotionInputSchema),
        z.lazy(() => OrderPromotionUncheckedUpdateWithoutPromotionInputSchema),
      ]),
    })
    .strict() as z.ZodType<Prisma.OrderPromotionUpdateWithWhereUniqueWithoutPromotionInput>;

export const OrderPromotionUpdateManyWithWhereWithoutPromotionInputSchema: z.ZodType<Prisma.OrderPromotionUpdateManyWithWhereWithoutPromotionInput> =
  z
    .object({
      where: z.lazy(() => OrderPromotionScalarWhereInputSchema),
      data: z.union([
        z.lazy(() => OrderPromotionUpdateManyMutationInputSchema),
        z.lazy(
          () => OrderPromotionUncheckedUpdateManyWithoutPromotionInputSchema,
        ),
      ]),
    })
    .strict() as z.ZodType<Prisma.OrderPromotionUpdateManyWithWhereWithoutPromotionInput>;

export const OrderCreateWithoutOrderPromotionsInputSchema: z.ZodType<Prisma.OrderCreateWithoutOrderPromotionsInput> =
  z
    .object({
      id: z.string().uuid().optional(),
      orderNumber: z.string(),
      status: z.lazy(() => OrderStatusSchema).optional(),
      subtotal: z
        .union([
          z.number(),
          z.string(),
          z.instanceof(Decimal),
          z.instanceof(Prisma.Decimal),
          DecimalJsLikeSchema,
        ])
        .refine((v) => isValidDecimalInput(v), {
          message: 'Must be a Decimal',
        }),
      taxAmount: z
        .union([
          z.number(),
          z.string(),
          z.instanceof(Decimal),
          z.instanceof(Prisma.Decimal),
          DecimalJsLikeSchema,
        ])
        .refine((v) => isValidDecimalInput(v), { message: 'Must be a Decimal' })
        .optional(),
      shippingAmount: z
        .union([
          z.number(),
          z.string(),
          z.instanceof(Decimal),
          z.instanceof(Prisma.Decimal),
          DecimalJsLikeSchema,
        ])
        .refine((v) => isValidDecimalInput(v), { message: 'Must be a Decimal' })
        .optional(),
      discountAmount: z
        .union([
          z.number(),
          z.string(),
          z.instanceof(Decimal),
          z.instanceof(Prisma.Decimal),
          DecimalJsLikeSchema,
        ])
        .refine((v) => isValidDecimalInput(v), { message: 'Must be a Decimal' })
        .optional(),
      totalAmount: z
        .union([
          z.number(),
          z.string(),
          z.instanceof(Decimal),
          z.instanceof(Prisma.Decimal),
          DecimalJsLikeSchema,
        ])
        .refine((v) => isValidDecimalInput(v), {
          message: 'Must be a Decimal',
        }),
      currency: z.string().optional(),
      notes: z.string().optional().nullable(),
      shippedAt: z.coerce.date().optional().nullable(),
      deliveredAt: z.coerce.date().optional().nullable(),
      createdAt: z.coerce.date().optional(),
      createdBy: z.string().optional().nullable(),
      updatedAt: z.coerce.date().optional(),
      deletedAt: z.coerce.date().optional().nullable(),
      user: z.lazy(() => UserCreateNestedOneWithoutOrdersInputSchema),
      orderItems: z
        .lazy(() => OrderItemCreateNestedManyWithoutOrderInputSchema)
        .optional(),
      orderAddresses: z
        .lazy(() => OrderAddressCreateNestedManyWithoutOrderInputSchema)
        .optional(),
      payments: z
        .lazy(() => PaymentCreateNestedManyWithoutOrderInputSchema)
        .optional(),
    })
    .strict() as z.ZodType<Prisma.OrderCreateWithoutOrderPromotionsInput>;

export const OrderUncheckedCreateWithoutOrderPromotionsInputSchema: z.ZodType<Prisma.OrderUncheckedCreateWithoutOrderPromotionsInput> =
  z
    .object({
      id: z.string().uuid().optional(),
      orderNumber: z.string(),
      userID: z.string(),
      status: z.lazy(() => OrderStatusSchema).optional(),
      subtotal: z
        .union([
          z.number(),
          z.string(),
          z.instanceof(Decimal),
          z.instanceof(Prisma.Decimal),
          DecimalJsLikeSchema,
        ])
        .refine((v) => isValidDecimalInput(v), {
          message: 'Must be a Decimal',
        }),
      taxAmount: z
        .union([
          z.number(),
          z.string(),
          z.instanceof(Decimal),
          z.instanceof(Prisma.Decimal),
          DecimalJsLikeSchema,
        ])
        .refine((v) => isValidDecimalInput(v), { message: 'Must be a Decimal' })
        .optional(),
      shippingAmount: z
        .union([
          z.number(),
          z.string(),
          z.instanceof(Decimal),
          z.instanceof(Prisma.Decimal),
          DecimalJsLikeSchema,
        ])
        .refine((v) => isValidDecimalInput(v), { message: 'Must be a Decimal' })
        .optional(),
      discountAmount: z
        .union([
          z.number(),
          z.string(),
          z.instanceof(Decimal),
          z.instanceof(Prisma.Decimal),
          DecimalJsLikeSchema,
        ])
        .refine((v) => isValidDecimalInput(v), { message: 'Must be a Decimal' })
        .optional(),
      totalAmount: z
        .union([
          z.number(),
          z.string(),
          z.instanceof(Decimal),
          z.instanceof(Prisma.Decimal),
          DecimalJsLikeSchema,
        ])
        .refine((v) => isValidDecimalInput(v), {
          message: 'Must be a Decimal',
        }),
      currency: z.string().optional(),
      notes: z.string().optional().nullable(),
      shippedAt: z.coerce.date().optional().nullable(),
      deliveredAt: z.coerce.date().optional().nullable(),
      createdAt: z.coerce.date().optional(),
      createdBy: z.string().optional().nullable(),
      updatedAt: z.coerce.date().optional(),
      deletedAt: z.coerce.date().optional().nullable(),
      orderItems: z
        .lazy(() => OrderItemUncheckedCreateNestedManyWithoutOrderInputSchema)
        .optional(),
      orderAddresses: z
        .lazy(
          () => OrderAddressUncheckedCreateNestedManyWithoutOrderInputSchema,
        )
        .optional(),
      payments: z
        .lazy(() => PaymentUncheckedCreateNestedManyWithoutOrderInputSchema)
        .optional(),
    })
    .strict() as z.ZodType<Prisma.OrderUncheckedCreateWithoutOrderPromotionsInput>;

export const OrderCreateOrConnectWithoutOrderPromotionsInputSchema: z.ZodType<Prisma.OrderCreateOrConnectWithoutOrderPromotionsInput> =
  z
    .object({
      where: z.lazy(() => OrderWhereUniqueInputSchema),
      create: z.union([
        z.lazy(() => OrderCreateWithoutOrderPromotionsInputSchema),
        z.lazy(() => OrderUncheckedCreateWithoutOrderPromotionsInputSchema),
      ]),
    })
    .strict() as z.ZodType<Prisma.OrderCreateOrConnectWithoutOrderPromotionsInput>;

export const PromotionCreateWithoutOrderPromotionsInputSchema: z.ZodType<Prisma.PromotionCreateWithoutOrderPromotionsInput> =
  z
    .object({
      id: z.string().uuid().optional(),
      code: z.string(),
      name: z.string(),
      description: z.string().optional().nullable(),
      type: z.lazy(() => PromotionTypeSchema).optional(),
      value: z
        .union([
          z.number(),
          z.string(),
          z.instanceof(Decimal),
          z.instanceof(Prisma.Decimal),
          DecimalJsLikeSchema,
        ])
        .refine((v) => isValidDecimalInput(v), {
          message: 'Must be a Decimal',
        }),
      usageLimit: z.number().int().optional().nullable(),
      startDate: z.coerce.date().optional(),
      endDate: z.coerce.date().optional().nullable(),
      status: z.lazy(() => PromotionStatusSchema).optional(),
      createdAt: z.coerce.date().optional(),
      createdBy: z.string().optional().nullable(),
      updatedAt: z.coerce.date().optional(),
      deletedAt: z.coerce.date().optional().nullable(),
    })
    .strict() as z.ZodType<Prisma.PromotionCreateWithoutOrderPromotionsInput>;

export const PromotionUncheckedCreateWithoutOrderPromotionsInputSchema: z.ZodType<Prisma.PromotionUncheckedCreateWithoutOrderPromotionsInput> =
  z
    .object({
      id: z.string().uuid().optional(),
      code: z.string(),
      name: z.string(),
      description: z.string().optional().nullable(),
      type: z.lazy(() => PromotionTypeSchema).optional(),
      value: z
        .union([
          z.number(),
          z.string(),
          z.instanceof(Decimal),
          z.instanceof(Prisma.Decimal),
          DecimalJsLikeSchema,
        ])
        .refine((v) => isValidDecimalInput(v), {
          message: 'Must be a Decimal',
        }),
      usageLimit: z.number().int().optional().nullable(),
      startDate: z.coerce.date().optional(),
      endDate: z.coerce.date().optional().nullable(),
      status: z.lazy(() => PromotionStatusSchema).optional(),
      createdAt: z.coerce.date().optional(),
      createdBy: z.string().optional().nullable(),
      updatedAt: z.coerce.date().optional(),
      deletedAt: z.coerce.date().optional().nullable(),
    })
    .strict() as z.ZodType<Prisma.PromotionUncheckedCreateWithoutOrderPromotionsInput>;

export const PromotionCreateOrConnectWithoutOrderPromotionsInputSchema: z.ZodType<Prisma.PromotionCreateOrConnectWithoutOrderPromotionsInput> =
  z
    .object({
      where: z.lazy(() => PromotionWhereUniqueInputSchema),
      create: z.union([
        z.lazy(() => PromotionCreateWithoutOrderPromotionsInputSchema),
        z.lazy(() => PromotionUncheckedCreateWithoutOrderPromotionsInputSchema),
      ]),
    })
    .strict() as z.ZodType<Prisma.PromotionCreateOrConnectWithoutOrderPromotionsInput>;

export const OrderUpsertWithoutOrderPromotionsInputSchema: z.ZodType<Prisma.OrderUpsertWithoutOrderPromotionsInput> =
  z
    .object({
      update: z.union([
        z.lazy(() => OrderUpdateWithoutOrderPromotionsInputSchema),
        z.lazy(() => OrderUncheckedUpdateWithoutOrderPromotionsInputSchema),
      ]),
      create: z.union([
        z.lazy(() => OrderCreateWithoutOrderPromotionsInputSchema),
        z.lazy(() => OrderUncheckedCreateWithoutOrderPromotionsInputSchema),
      ]),
      where: z.lazy(() => OrderWhereInputSchema).optional(),
    })
    .strict() as z.ZodType<Prisma.OrderUpsertWithoutOrderPromotionsInput>;

export const OrderUpdateToOneWithWhereWithoutOrderPromotionsInputSchema: z.ZodType<Prisma.OrderUpdateToOneWithWhereWithoutOrderPromotionsInput> =
  z
    .object({
      where: z.lazy(() => OrderWhereInputSchema).optional(),
      data: z.union([
        z.lazy(() => OrderUpdateWithoutOrderPromotionsInputSchema),
        z.lazy(() => OrderUncheckedUpdateWithoutOrderPromotionsInputSchema),
      ]),
    })
    .strict() as z.ZodType<Prisma.OrderUpdateToOneWithWhereWithoutOrderPromotionsInput>;

export const OrderUpdateWithoutOrderPromotionsInputSchema: z.ZodType<Prisma.OrderUpdateWithoutOrderPromotionsInput> =
  z
    .object({
      id: z
        .union([
          z.string().uuid(),
          z.lazy(() => StringFieldUpdateOperationsInputSchema),
        ])
        .optional(),
      orderNumber: z
        .union([
          z.string(),
          z.lazy(() => StringFieldUpdateOperationsInputSchema),
        ])
        .optional(),
      status: z
        .union([
          z.lazy(() => OrderStatusSchema),
          z.lazy(() => EnumOrderStatusFieldUpdateOperationsInputSchema),
        ])
        .optional(),
      subtotal: z
        .union([
          z
            .union([
              z.number(),
              z.string(),
              z.instanceof(Decimal),
              z.instanceof(Prisma.Decimal),
              DecimalJsLikeSchema,
            ])
            .refine((v) => isValidDecimalInput(v), {
              message: 'Must be a Decimal',
            }),
          z.lazy(() => DecimalFieldUpdateOperationsInputSchema),
        ])
        .optional(),
      taxAmount: z
        .union([
          z
            .union([
              z.number(),
              z.string(),
              z.instanceof(Decimal),
              z.instanceof(Prisma.Decimal),
              DecimalJsLikeSchema,
            ])
            .refine((v) => isValidDecimalInput(v), {
              message: 'Must be a Decimal',
            }),
          z.lazy(() => DecimalFieldUpdateOperationsInputSchema),
        ])
        .optional(),
      shippingAmount: z
        .union([
          z
            .union([
              z.number(),
              z.string(),
              z.instanceof(Decimal),
              z.instanceof(Prisma.Decimal),
              DecimalJsLikeSchema,
            ])
            .refine((v) => isValidDecimalInput(v), {
              message: 'Must be a Decimal',
            }),
          z.lazy(() => DecimalFieldUpdateOperationsInputSchema),
        ])
        .optional(),
      discountAmount: z
        .union([
          z
            .union([
              z.number(),
              z.string(),
              z.instanceof(Decimal),
              z.instanceof(Prisma.Decimal),
              DecimalJsLikeSchema,
            ])
            .refine((v) => isValidDecimalInput(v), {
              message: 'Must be a Decimal',
            }),
          z.lazy(() => DecimalFieldUpdateOperationsInputSchema),
        ])
        .optional(),
      totalAmount: z
        .union([
          z
            .union([
              z.number(),
              z.string(),
              z.instanceof(Decimal),
              z.instanceof(Prisma.Decimal),
              DecimalJsLikeSchema,
            ])
            .refine((v) => isValidDecimalInput(v), {
              message: 'Must be a Decimal',
            }),
          z.lazy(() => DecimalFieldUpdateOperationsInputSchema),
        ])
        .optional(),
      currency: z
        .union([
          z.string(),
          z.lazy(() => StringFieldUpdateOperationsInputSchema),
        ])
        .optional(),
      notes: z
        .union([
          z.string(),
          z.lazy(() => NullableStringFieldUpdateOperationsInputSchema),
        ])
        .optional()
        .nullable(),
      shippedAt: z
        .union([
          z.coerce.date(),
          z.lazy(() => NullableDateTimeFieldUpdateOperationsInputSchema),
        ])
        .optional()
        .nullable(),
      deliveredAt: z
        .union([
          z.coerce.date(),
          z.lazy(() => NullableDateTimeFieldUpdateOperationsInputSchema),
        ])
        .optional()
        .nullable(),
      createdAt: z
        .union([
          z.coerce.date(),
          z.lazy(() => DateTimeFieldUpdateOperationsInputSchema),
        ])
        .optional(),
      createdBy: z
        .union([
          z.string(),
          z.lazy(() => NullableStringFieldUpdateOperationsInputSchema),
        ])
        .optional()
        .nullable(),
      updatedAt: z
        .union([
          z.coerce.date(),
          z.lazy(() => DateTimeFieldUpdateOperationsInputSchema),
        ])
        .optional(),
      deletedAt: z
        .union([
          z.coerce.date(),
          z.lazy(() => NullableDateTimeFieldUpdateOperationsInputSchema),
        ])
        .optional()
        .nullable(),
      user: z
        .lazy(() => UserUpdateOneRequiredWithoutOrdersNestedInputSchema)
        .optional(),
      orderItems: z
        .lazy(() => OrderItemUpdateManyWithoutOrderNestedInputSchema)
        .optional(),
      orderAddresses: z
        .lazy(() => OrderAddressUpdateManyWithoutOrderNestedInputSchema)
        .optional(),
      payments: z
        .lazy(() => PaymentUpdateManyWithoutOrderNestedInputSchema)
        .optional(),
    })
    .strict() as z.ZodType<Prisma.OrderUpdateWithoutOrderPromotionsInput>;

export const OrderUncheckedUpdateWithoutOrderPromotionsInputSchema: z.ZodType<Prisma.OrderUncheckedUpdateWithoutOrderPromotionsInput> =
  z
    .object({
      id: z
        .union([
          z.string().uuid(),
          z.lazy(() => StringFieldUpdateOperationsInputSchema),
        ])
        .optional(),
      orderNumber: z
        .union([
          z.string(),
          z.lazy(() => StringFieldUpdateOperationsInputSchema),
        ])
        .optional(),
      userID: z
        .union([
          z.string(),
          z.lazy(() => StringFieldUpdateOperationsInputSchema),
        ])
        .optional(),
      status: z
        .union([
          z.lazy(() => OrderStatusSchema),
          z.lazy(() => EnumOrderStatusFieldUpdateOperationsInputSchema),
        ])
        .optional(),
      subtotal: z
        .union([
          z
            .union([
              z.number(),
              z.string(),
              z.instanceof(Decimal),
              z.instanceof(Prisma.Decimal),
              DecimalJsLikeSchema,
            ])
            .refine((v) => isValidDecimalInput(v), {
              message: 'Must be a Decimal',
            }),
          z.lazy(() => DecimalFieldUpdateOperationsInputSchema),
        ])
        .optional(),
      taxAmount: z
        .union([
          z
            .union([
              z.number(),
              z.string(),
              z.instanceof(Decimal),
              z.instanceof(Prisma.Decimal),
              DecimalJsLikeSchema,
            ])
            .refine((v) => isValidDecimalInput(v), {
              message: 'Must be a Decimal',
            }),
          z.lazy(() => DecimalFieldUpdateOperationsInputSchema),
        ])
        .optional(),
      shippingAmount: z
        .union([
          z
            .union([
              z.number(),
              z.string(),
              z.instanceof(Decimal),
              z.instanceof(Prisma.Decimal),
              DecimalJsLikeSchema,
            ])
            .refine((v) => isValidDecimalInput(v), {
              message: 'Must be a Decimal',
            }),
          z.lazy(() => DecimalFieldUpdateOperationsInputSchema),
        ])
        .optional(),
      discountAmount: z
        .union([
          z
            .union([
              z.number(),
              z.string(),
              z.instanceof(Decimal),
              z.instanceof(Prisma.Decimal),
              DecimalJsLikeSchema,
            ])
            .refine((v) => isValidDecimalInput(v), {
              message: 'Must be a Decimal',
            }),
          z.lazy(() => DecimalFieldUpdateOperationsInputSchema),
        ])
        .optional(),
      totalAmount: z
        .union([
          z
            .union([
              z.number(),
              z.string(),
              z.instanceof(Decimal),
              z.instanceof(Prisma.Decimal),
              DecimalJsLikeSchema,
            ])
            .refine((v) => isValidDecimalInput(v), {
              message: 'Must be a Decimal',
            }),
          z.lazy(() => DecimalFieldUpdateOperationsInputSchema),
        ])
        .optional(),
      currency: z
        .union([
          z.string(),
          z.lazy(() => StringFieldUpdateOperationsInputSchema),
        ])
        .optional(),
      notes: z
        .union([
          z.string(),
          z.lazy(() => NullableStringFieldUpdateOperationsInputSchema),
        ])
        .optional()
        .nullable(),
      shippedAt: z
        .union([
          z.coerce.date(),
          z.lazy(() => NullableDateTimeFieldUpdateOperationsInputSchema),
        ])
        .optional()
        .nullable(),
      deliveredAt: z
        .union([
          z.coerce.date(),
          z.lazy(() => NullableDateTimeFieldUpdateOperationsInputSchema),
        ])
        .optional()
        .nullable(),
      createdAt: z
        .union([
          z.coerce.date(),
          z.lazy(() => DateTimeFieldUpdateOperationsInputSchema),
        ])
        .optional(),
      createdBy: z
        .union([
          z.string(),
          z.lazy(() => NullableStringFieldUpdateOperationsInputSchema),
        ])
        .optional()
        .nullable(),
      updatedAt: z
        .union([
          z.coerce.date(),
          z.lazy(() => DateTimeFieldUpdateOperationsInputSchema),
        ])
        .optional(),
      deletedAt: z
        .union([
          z.coerce.date(),
          z.lazy(() => NullableDateTimeFieldUpdateOperationsInputSchema),
        ])
        .optional()
        .nullable(),
      orderItems: z
        .lazy(() => OrderItemUncheckedUpdateManyWithoutOrderNestedInputSchema)
        .optional(),
      orderAddresses: z
        .lazy(
          () => OrderAddressUncheckedUpdateManyWithoutOrderNestedInputSchema,
        )
        .optional(),
      payments: z
        .lazy(() => PaymentUncheckedUpdateManyWithoutOrderNestedInputSchema)
        .optional(),
    })
    .strict() as z.ZodType<Prisma.OrderUncheckedUpdateWithoutOrderPromotionsInput>;

export const PromotionUpsertWithoutOrderPromotionsInputSchema: z.ZodType<Prisma.PromotionUpsertWithoutOrderPromotionsInput> =
  z
    .object({
      update: z.union([
        z.lazy(() => PromotionUpdateWithoutOrderPromotionsInputSchema),
        z.lazy(() => PromotionUncheckedUpdateWithoutOrderPromotionsInputSchema),
      ]),
      create: z.union([
        z.lazy(() => PromotionCreateWithoutOrderPromotionsInputSchema),
        z.lazy(() => PromotionUncheckedCreateWithoutOrderPromotionsInputSchema),
      ]),
      where: z.lazy(() => PromotionWhereInputSchema).optional(),
    })
    .strict() as z.ZodType<Prisma.PromotionUpsertWithoutOrderPromotionsInput>;

export const PromotionUpdateToOneWithWhereWithoutOrderPromotionsInputSchema: z.ZodType<Prisma.PromotionUpdateToOneWithWhereWithoutOrderPromotionsInput> =
  z
    .object({
      where: z.lazy(() => PromotionWhereInputSchema).optional(),
      data: z.union([
        z.lazy(() => PromotionUpdateWithoutOrderPromotionsInputSchema),
        z.lazy(() => PromotionUncheckedUpdateWithoutOrderPromotionsInputSchema),
      ]),
    })
    .strict() as z.ZodType<Prisma.PromotionUpdateToOneWithWhereWithoutOrderPromotionsInput>;

export const PromotionUpdateWithoutOrderPromotionsInputSchema: z.ZodType<Prisma.PromotionUpdateWithoutOrderPromotionsInput> =
  z
    .object({
      id: z
        .union([
          z.string().uuid(),
          z.lazy(() => StringFieldUpdateOperationsInputSchema),
        ])
        .optional(),
      code: z
        .union([
          z.string(),
          z.lazy(() => StringFieldUpdateOperationsInputSchema),
        ])
        .optional(),
      name: z
        .union([
          z.string(),
          z.lazy(() => StringFieldUpdateOperationsInputSchema),
        ])
        .optional(),
      description: z
        .union([
          z.string(),
          z.lazy(() => NullableStringFieldUpdateOperationsInputSchema),
        ])
        .optional()
        .nullable(),
      type: z
        .union([
          z.lazy(() => PromotionTypeSchema),
          z.lazy(() => EnumPromotionTypeFieldUpdateOperationsInputSchema),
        ])
        .optional(),
      value: z
        .union([
          z
            .union([
              z.number(),
              z.string(),
              z.instanceof(Decimal),
              z.instanceof(Prisma.Decimal),
              DecimalJsLikeSchema,
            ])
            .refine((v) => isValidDecimalInput(v), {
              message: 'Must be a Decimal',
            }),
          z.lazy(() => DecimalFieldUpdateOperationsInputSchema),
        ])
        .optional(),
      usageLimit: z
        .union([
          z.number().int(),
          z.lazy(() => NullableIntFieldUpdateOperationsInputSchema),
        ])
        .optional()
        .nullable(),
      startDate: z
        .union([
          z.coerce.date(),
          z.lazy(() => DateTimeFieldUpdateOperationsInputSchema),
        ])
        .optional(),
      endDate: z
        .union([
          z.coerce.date(),
          z.lazy(() => NullableDateTimeFieldUpdateOperationsInputSchema),
        ])
        .optional()
        .nullable(),
      status: z
        .union([
          z.lazy(() => PromotionStatusSchema),
          z.lazy(() => EnumPromotionStatusFieldUpdateOperationsInputSchema),
        ])
        .optional(),
      createdAt: z
        .union([
          z.coerce.date(),
          z.lazy(() => DateTimeFieldUpdateOperationsInputSchema),
        ])
        .optional(),
      createdBy: z
        .union([
          z.string(),
          z.lazy(() => NullableStringFieldUpdateOperationsInputSchema),
        ])
        .optional()
        .nullable(),
      updatedAt: z
        .union([
          z.coerce.date(),
          z.lazy(() => DateTimeFieldUpdateOperationsInputSchema),
        ])
        .optional(),
      deletedAt: z
        .union([
          z.coerce.date(),
          z.lazy(() => NullableDateTimeFieldUpdateOperationsInputSchema),
        ])
        .optional()
        .nullable(),
    })
    .strict() as z.ZodType<Prisma.PromotionUpdateWithoutOrderPromotionsInput>;

export const PromotionUncheckedUpdateWithoutOrderPromotionsInputSchema: z.ZodType<Prisma.PromotionUncheckedUpdateWithoutOrderPromotionsInput> =
  z
    .object({
      id: z
        .union([
          z.string().uuid(),
          z.lazy(() => StringFieldUpdateOperationsInputSchema),
        ])
        .optional(),
      code: z
        .union([
          z.string(),
          z.lazy(() => StringFieldUpdateOperationsInputSchema),
        ])
        .optional(),
      name: z
        .union([
          z.string(),
          z.lazy(() => StringFieldUpdateOperationsInputSchema),
        ])
        .optional(),
      description: z
        .union([
          z.string(),
          z.lazy(() => NullableStringFieldUpdateOperationsInputSchema),
        ])
        .optional()
        .nullable(),
      type: z
        .union([
          z.lazy(() => PromotionTypeSchema),
          z.lazy(() => EnumPromotionTypeFieldUpdateOperationsInputSchema),
        ])
        .optional(),
      value: z
        .union([
          z
            .union([
              z.number(),
              z.string(),
              z.instanceof(Decimal),
              z.instanceof(Prisma.Decimal),
              DecimalJsLikeSchema,
            ])
            .refine((v) => isValidDecimalInput(v), {
              message: 'Must be a Decimal',
            }),
          z.lazy(() => DecimalFieldUpdateOperationsInputSchema),
        ])
        .optional(),
      usageLimit: z
        .union([
          z.number().int(),
          z.lazy(() => NullableIntFieldUpdateOperationsInputSchema),
        ])
        .optional()
        .nullable(),
      startDate: z
        .union([
          z.coerce.date(),
          z.lazy(() => DateTimeFieldUpdateOperationsInputSchema),
        ])
        .optional(),
      endDate: z
        .union([
          z.coerce.date(),
          z.lazy(() => NullableDateTimeFieldUpdateOperationsInputSchema),
        ])
        .optional()
        .nullable(),
      status: z
        .union([
          z.lazy(() => PromotionStatusSchema),
          z.lazy(() => EnumPromotionStatusFieldUpdateOperationsInputSchema),
        ])
        .optional(),
      createdAt: z
        .union([
          z.coerce.date(),
          z.lazy(() => DateTimeFieldUpdateOperationsInputSchema),
        ])
        .optional(),
      createdBy: z
        .union([
          z.string(),
          z.lazy(() => NullableStringFieldUpdateOperationsInputSchema),
        ])
        .optional()
        .nullable(),
      updatedAt: z
        .union([
          z.coerce.date(),
          z.lazy(() => DateTimeFieldUpdateOperationsInputSchema),
        ])
        .optional(),
      deletedAt: z
        .union([
          z.coerce.date(),
          z.lazy(() => NullableDateTimeFieldUpdateOperationsInputSchema),
        ])
        .optional()
        .nullable(),
    })
    .strict() as z.ZodType<Prisma.PromotionUncheckedUpdateWithoutOrderPromotionsInput>;

export const UserCreateWithoutCartInputSchema: z.ZodType<Prisma.UserCreateWithoutCartInput> =
  z
    .object({
      id: z.string().uuid().optional(),
      email: z.string().email(),
      password: z.string(),
      firstName: z.string(),
      lastName: z.string().optional().nullable(),
      fullAddress: z.string(),
      city: z.string().optional().nullable(),
      province: z.string().optional().nullable(),
      country: z.string().optional().nullable(),
      phone: z.string().optional().nullable(),
      status: z.lazy(() => UserStatusSchema).optional(),
      createdAt: z.coerce.date().optional(),
      createdBy: z.string().optional().nullable(),
      updatedAt: z.coerce.date().optional(),
      deletedAt: z.coerce.date().optional().nullable(),
      vendors: z
        .lazy(() => VendorCreateNestedManyWithoutUserInputSchema)
        .optional(),
      userVendorRoles: z
        .lazy(() => UserVendorRoleCreateNestedManyWithoutUserInputSchema)
        .optional(),
      orders: z
        .lazy(() => OrderCreateNestedManyWithoutUserInputSchema)
        .optional(),
      notifications: z
        .lazy(() => NotificationCreateNestedManyWithoutUserInputSchema)
        .optional(),
    })
    .strict() as z.ZodType<Prisma.UserCreateWithoutCartInput>;

export const UserUncheckedCreateWithoutCartInputSchema: z.ZodType<Prisma.UserUncheckedCreateWithoutCartInput> =
  z
    .object({
      id: z.string().uuid().optional(),
      email: z.string().email(),
      password: z.string(),
      firstName: z.string(),
      lastName: z.string().optional().nullable(),
      fullAddress: z.string(),
      city: z.string().optional().nullable(),
      province: z.string().optional().nullable(),
      country: z.string().optional().nullable(),
      phone: z.string().optional().nullable(),
      status: z.lazy(() => UserStatusSchema).optional(),
      createdAt: z.coerce.date().optional(),
      createdBy: z.string().optional().nullable(),
      updatedAt: z.coerce.date().optional(),
      deletedAt: z.coerce.date().optional().nullable(),
      vendors: z
        .lazy(() => VendorUncheckedCreateNestedManyWithoutUserInputSchema)
        .optional(),
      userVendorRoles: z
        .lazy(
          () => UserVendorRoleUncheckedCreateNestedManyWithoutUserInputSchema,
        )
        .optional(),
      orders: z
        .lazy(() => OrderUncheckedCreateNestedManyWithoutUserInputSchema)
        .optional(),
      notifications: z
        .lazy(() => NotificationUncheckedCreateNestedManyWithoutUserInputSchema)
        .optional(),
    })
    .strict() as z.ZodType<Prisma.UserUncheckedCreateWithoutCartInput>;

export const UserCreateOrConnectWithoutCartInputSchema: z.ZodType<Prisma.UserCreateOrConnectWithoutCartInput> =
  z
    .object({
      where: z.lazy(() => UserWhereUniqueInputSchema),
      create: z.union([
        z.lazy(() => UserCreateWithoutCartInputSchema),
        z.lazy(() => UserUncheckedCreateWithoutCartInputSchema),
      ]),
    })
    .strict() as z.ZodType<Prisma.UserCreateOrConnectWithoutCartInput>;

export const CartItemCreateWithoutCartInputSchema: z.ZodType<Prisma.CartItemCreateWithoutCartInput> =
  z
    .object({
      id: z.string().uuid().optional(),
      quantity: z.number().int().optional(),
      createdAt: z.coerce.date().optional(),
      updatedAt: z.coerce.date().optional(),
      productVariant: z.lazy(
        () => ProductVariantCreateNestedOneWithoutCartItemsInputSchema,
      ),
    })
    .strict() as z.ZodType<Prisma.CartItemCreateWithoutCartInput>;

export const CartItemUncheckedCreateWithoutCartInputSchema: z.ZodType<Prisma.CartItemUncheckedCreateWithoutCartInput> =
  z
    .object({
      id: z.string().uuid().optional(),
      productVariantID: z.string(),
      quantity: z.number().int().optional(),
      createdAt: z.coerce.date().optional(),
      updatedAt: z.coerce.date().optional(),
    })
    .strict() as z.ZodType<Prisma.CartItemUncheckedCreateWithoutCartInput>;

export const CartItemCreateOrConnectWithoutCartInputSchema: z.ZodType<Prisma.CartItemCreateOrConnectWithoutCartInput> =
  z
    .object({
      where: z.lazy(() => CartItemWhereUniqueInputSchema),
      create: z.union([
        z.lazy(() => CartItemCreateWithoutCartInputSchema),
        z.lazy(() => CartItemUncheckedCreateWithoutCartInputSchema),
      ]),
    })
    .strict() as z.ZodType<Prisma.CartItemCreateOrConnectWithoutCartInput>;

export const CartItemCreateManyCartInputEnvelopeSchema: z.ZodType<Prisma.CartItemCreateManyCartInputEnvelope> =
  z
    .object({
      data: z.union([
        z.lazy(() => CartItemCreateManyCartInputSchema),
        z.lazy(() => CartItemCreateManyCartInputSchema).array(),
      ]),
      skipDuplicates: z.boolean().optional(),
    })
    .strict() as z.ZodType<Prisma.CartItemCreateManyCartInputEnvelope>;

export const UserUpsertWithoutCartInputSchema: z.ZodType<Prisma.UserUpsertWithoutCartInput> =
  z
    .object({
      update: z.union([
        z.lazy(() => UserUpdateWithoutCartInputSchema),
        z.lazy(() => UserUncheckedUpdateWithoutCartInputSchema),
      ]),
      create: z.union([
        z.lazy(() => UserCreateWithoutCartInputSchema),
        z.lazy(() => UserUncheckedCreateWithoutCartInputSchema),
      ]),
      where: z.lazy(() => UserWhereInputSchema).optional(),
    })
    .strict() as z.ZodType<Prisma.UserUpsertWithoutCartInput>;

export const UserUpdateToOneWithWhereWithoutCartInputSchema: z.ZodType<Prisma.UserUpdateToOneWithWhereWithoutCartInput> =
  z
    .object({
      where: z.lazy(() => UserWhereInputSchema).optional(),
      data: z.union([
        z.lazy(() => UserUpdateWithoutCartInputSchema),
        z.lazy(() => UserUncheckedUpdateWithoutCartInputSchema),
      ]),
    })
    .strict() as z.ZodType<Prisma.UserUpdateToOneWithWhereWithoutCartInput>;

export const UserUpdateWithoutCartInputSchema: z.ZodType<Prisma.UserUpdateWithoutCartInput> =
  z
    .object({
      id: z
        .union([
          z.string().uuid(),
          z.lazy(() => StringFieldUpdateOperationsInputSchema),
        ])
        .optional(),
      email: z
        .union([
          z.string().email(),
          z.lazy(() => StringFieldUpdateOperationsInputSchema),
        ])
        .optional(),
      password: z
        .union([
          z.string(),
          z.lazy(() => StringFieldUpdateOperationsInputSchema),
        ])
        .optional(),
      firstName: z
        .union([
          z.string(),
          z.lazy(() => StringFieldUpdateOperationsInputSchema),
        ])
        .optional(),
      lastName: z
        .union([
          z.string(),
          z.lazy(() => NullableStringFieldUpdateOperationsInputSchema),
        ])
        .optional()
        .nullable(),
      fullAddress: z
        .union([
          z.string(),
          z.lazy(() => StringFieldUpdateOperationsInputSchema),
        ])
        .optional(),
      city: z
        .union([
          z.string(),
          z.lazy(() => NullableStringFieldUpdateOperationsInputSchema),
        ])
        .optional()
        .nullable(),
      province: z
        .union([
          z.string(),
          z.lazy(() => NullableStringFieldUpdateOperationsInputSchema),
        ])
        .optional()
        .nullable(),
      country: z
        .union([
          z.string(),
          z.lazy(() => NullableStringFieldUpdateOperationsInputSchema),
        ])
        .optional()
        .nullable(),
      phone: z
        .union([
          z.string(),
          z.lazy(() => NullableStringFieldUpdateOperationsInputSchema),
        ])
        .optional()
        .nullable(),
      status: z
        .union([
          z.lazy(() => UserStatusSchema),
          z.lazy(() => EnumUserStatusFieldUpdateOperationsInputSchema),
        ])
        .optional(),
      createdAt: z
        .union([
          z.coerce.date(),
          z.lazy(() => DateTimeFieldUpdateOperationsInputSchema),
        ])
        .optional(),
      createdBy: z
        .union([
          z.string(),
          z.lazy(() => NullableStringFieldUpdateOperationsInputSchema),
        ])
        .optional()
        .nullable(),
      updatedAt: z
        .union([
          z.coerce.date(),
          z.lazy(() => DateTimeFieldUpdateOperationsInputSchema),
        ])
        .optional(),
      deletedAt: z
        .union([
          z.coerce.date(),
          z.lazy(() => NullableDateTimeFieldUpdateOperationsInputSchema),
        ])
        .optional()
        .nullable(),
      vendors: z
        .lazy(() => VendorUpdateManyWithoutUserNestedInputSchema)
        .optional(),
      userVendorRoles: z
        .lazy(() => UserVendorRoleUpdateManyWithoutUserNestedInputSchema)
        .optional(),
      orders: z
        .lazy(() => OrderUpdateManyWithoutUserNestedInputSchema)
        .optional(),
      notifications: z
        .lazy(() => NotificationUpdateManyWithoutUserNestedInputSchema)
        .optional(),
    })
    .strict() as z.ZodType<Prisma.UserUpdateWithoutCartInput>;

export const UserUncheckedUpdateWithoutCartInputSchema: z.ZodType<Prisma.UserUncheckedUpdateWithoutCartInput> =
  z
    .object({
      id: z
        .union([
          z.string().uuid(),
          z.lazy(() => StringFieldUpdateOperationsInputSchema),
        ])
        .optional(),
      email: z
        .union([
          z.string().email(),
          z.lazy(() => StringFieldUpdateOperationsInputSchema),
        ])
        .optional(),
      password: z
        .union([
          z.string(),
          z.lazy(() => StringFieldUpdateOperationsInputSchema),
        ])
        .optional(),
      firstName: z
        .union([
          z.string(),
          z.lazy(() => StringFieldUpdateOperationsInputSchema),
        ])
        .optional(),
      lastName: z
        .union([
          z.string(),
          z.lazy(() => NullableStringFieldUpdateOperationsInputSchema),
        ])
        .optional()
        .nullable(),
      fullAddress: z
        .union([
          z.string(),
          z.lazy(() => StringFieldUpdateOperationsInputSchema),
        ])
        .optional(),
      city: z
        .union([
          z.string(),
          z.lazy(() => NullableStringFieldUpdateOperationsInputSchema),
        ])
        .optional()
        .nullable(),
      province: z
        .union([
          z.string(),
          z.lazy(() => NullableStringFieldUpdateOperationsInputSchema),
        ])
        .optional()
        .nullable(),
      country: z
        .union([
          z.string(),
          z.lazy(() => NullableStringFieldUpdateOperationsInputSchema),
        ])
        .optional()
        .nullable(),
      phone: z
        .union([
          z.string(),
          z.lazy(() => NullableStringFieldUpdateOperationsInputSchema),
        ])
        .optional()
        .nullable(),
      status: z
        .union([
          z.lazy(() => UserStatusSchema),
          z.lazy(() => EnumUserStatusFieldUpdateOperationsInputSchema),
        ])
        .optional(),
      createdAt: z
        .union([
          z.coerce.date(),
          z.lazy(() => DateTimeFieldUpdateOperationsInputSchema),
        ])
        .optional(),
      createdBy: z
        .union([
          z.string(),
          z.lazy(() => NullableStringFieldUpdateOperationsInputSchema),
        ])
        .optional()
        .nullable(),
      updatedAt: z
        .union([
          z.coerce.date(),
          z.lazy(() => DateTimeFieldUpdateOperationsInputSchema),
        ])
        .optional(),
      deletedAt: z
        .union([
          z.coerce.date(),
          z.lazy(() => NullableDateTimeFieldUpdateOperationsInputSchema),
        ])
        .optional()
        .nullable(),
      vendors: z
        .lazy(() => VendorUncheckedUpdateManyWithoutUserNestedInputSchema)
        .optional(),
      userVendorRoles: z
        .lazy(
          () => UserVendorRoleUncheckedUpdateManyWithoutUserNestedInputSchema,
        )
        .optional(),
      orders: z
        .lazy(() => OrderUncheckedUpdateManyWithoutUserNestedInputSchema)
        .optional(),
      notifications: z
        .lazy(() => NotificationUncheckedUpdateManyWithoutUserNestedInputSchema)
        .optional(),
    })
    .strict() as z.ZodType<Prisma.UserUncheckedUpdateWithoutCartInput>;

export const CartItemUpsertWithWhereUniqueWithoutCartInputSchema: z.ZodType<Prisma.CartItemUpsertWithWhereUniqueWithoutCartInput> =
  z
    .object({
      where: z.lazy(() => CartItemWhereUniqueInputSchema),
      update: z.union([
        z.lazy(() => CartItemUpdateWithoutCartInputSchema),
        z.lazy(() => CartItemUncheckedUpdateWithoutCartInputSchema),
      ]),
      create: z.union([
        z.lazy(() => CartItemCreateWithoutCartInputSchema),
        z.lazy(() => CartItemUncheckedCreateWithoutCartInputSchema),
      ]),
    })
    .strict() as z.ZodType<Prisma.CartItemUpsertWithWhereUniqueWithoutCartInput>;

export const CartItemUpdateWithWhereUniqueWithoutCartInputSchema: z.ZodType<Prisma.CartItemUpdateWithWhereUniqueWithoutCartInput> =
  z
    .object({
      where: z.lazy(() => CartItemWhereUniqueInputSchema),
      data: z.union([
        z.lazy(() => CartItemUpdateWithoutCartInputSchema),
        z.lazy(() => CartItemUncheckedUpdateWithoutCartInputSchema),
      ]),
    })
    .strict() as z.ZodType<Prisma.CartItemUpdateWithWhereUniqueWithoutCartInput>;

export const CartItemUpdateManyWithWhereWithoutCartInputSchema: z.ZodType<Prisma.CartItemUpdateManyWithWhereWithoutCartInput> =
  z
    .object({
      where: z.lazy(() => CartItemScalarWhereInputSchema),
      data: z.union([
        z.lazy(() => CartItemUpdateManyMutationInputSchema),
        z.lazy(() => CartItemUncheckedUpdateManyWithoutCartInputSchema),
      ]),
    })
    .strict() as z.ZodType<Prisma.CartItemUpdateManyWithWhereWithoutCartInput>;

export const CartCreateWithoutCartItemsInputSchema: z.ZodType<Prisma.CartCreateWithoutCartItemsInput> =
  z
    .object({
      id: z.string().uuid().optional(),
      createdAt: z.coerce.date().optional(),
      updatedAt: z.coerce.date().optional(),
      user: z.lazy(() => UserCreateNestedOneWithoutCartInputSchema),
    })
    .strict() as z.ZodType<Prisma.CartCreateWithoutCartItemsInput>;

export const CartUncheckedCreateWithoutCartItemsInputSchema: z.ZodType<Prisma.CartUncheckedCreateWithoutCartItemsInput> =
  z
    .object({
      id: z.string().uuid().optional(),
      userID: z.string(),
      createdAt: z.coerce.date().optional(),
      updatedAt: z.coerce.date().optional(),
    })
    .strict() as z.ZodType<Prisma.CartUncheckedCreateWithoutCartItemsInput>;

export const CartCreateOrConnectWithoutCartItemsInputSchema: z.ZodType<Prisma.CartCreateOrConnectWithoutCartItemsInput> =
  z
    .object({
      where: z.lazy(() => CartWhereUniqueInputSchema),
      create: z.union([
        z.lazy(() => CartCreateWithoutCartItemsInputSchema),
        z.lazy(() => CartUncheckedCreateWithoutCartItemsInputSchema),
      ]),
    })
    .strict() as z.ZodType<Prisma.CartCreateOrConnectWithoutCartItemsInput>;

export const ProductVariantCreateWithoutCartItemsInputSchema: z.ZodType<Prisma.ProductVariantCreateWithoutCartItemsInput> =
  z
    .object({
      id: z.string().uuid().optional(),
      name: z.string().optional().nullable(),
      sku: z.string().optional().nullable(),
      price: z
        .union([
          z.number(),
          z.string(),
          z.instanceof(Decimal),
          z.instanceof(Prisma.Decimal),
          DecimalJsLikeSchema,
        ])
        .refine((v) => isValidDecimalInput(v), {
          message: 'Must be a Decimal',
        }),
      stockQuantity: z.number().int().optional(),
      attributes: z
        .union([
          z.lazy(() => NullableJsonNullValueInputSchema),
          InputJsonValueSchema,
        ])
        .optional(),
      createdAt: z.coerce.date().optional(),
      createdBy: z.string().optional().nullable(),
      updatedAt: z.coerce.date().optional(),
      deletedAt: z.coerce.date().optional().nullable(),
      product: z.lazy(
        () => ProductCreateNestedOneWithoutProductVariantsInputSchema,
      ),
      productImages: z
        .lazy(
          () => ProductImageCreateNestedManyWithoutProductVariantInputSchema,
        )
        .optional(),
      orderItems: z
        .lazy(() => OrderItemCreateNestedManyWithoutProductVariantInputSchema)
        .optional(),
    })
    .strict() as z.ZodType<Prisma.ProductVariantCreateWithoutCartItemsInput>;

export const ProductVariantUncheckedCreateWithoutCartItemsInputSchema: z.ZodType<Prisma.ProductVariantUncheckedCreateWithoutCartItemsInput> =
  z
    .object({
      id: z.string().uuid().optional(),
      productID: z.string(),
      name: z.string().optional().nullable(),
      sku: z.string().optional().nullable(),
      price: z
        .union([
          z.number(),
          z.string(),
          z.instanceof(Decimal),
          z.instanceof(Prisma.Decimal),
          DecimalJsLikeSchema,
        ])
        .refine((v) => isValidDecimalInput(v), {
          message: 'Must be a Decimal',
        }),
      stockQuantity: z.number().int().optional(),
      attributes: z
        .union([
          z.lazy(() => NullableJsonNullValueInputSchema),
          InputJsonValueSchema,
        ])
        .optional(),
      createdAt: z.coerce.date().optional(),
      createdBy: z.string().optional().nullable(),
      updatedAt: z.coerce.date().optional(),
      deletedAt: z.coerce.date().optional().nullable(),
      productImages: z
        .lazy(
          () =>
            ProductImageUncheckedCreateNestedManyWithoutProductVariantInputSchema,
        )
        .optional(),
      orderItems: z
        .lazy(
          () =>
            OrderItemUncheckedCreateNestedManyWithoutProductVariantInputSchema,
        )
        .optional(),
    })
    .strict() as z.ZodType<Prisma.ProductVariantUncheckedCreateWithoutCartItemsInput>;

export const ProductVariantCreateOrConnectWithoutCartItemsInputSchema: z.ZodType<Prisma.ProductVariantCreateOrConnectWithoutCartItemsInput> =
  z
    .object({
      where: z.lazy(() => ProductVariantWhereUniqueInputSchema),
      create: z.union([
        z.lazy(() => ProductVariantCreateWithoutCartItemsInputSchema),
        z.lazy(() => ProductVariantUncheckedCreateWithoutCartItemsInputSchema),
      ]),
    })
    .strict() as z.ZodType<Prisma.ProductVariantCreateOrConnectWithoutCartItemsInput>;

export const CartUpsertWithoutCartItemsInputSchema: z.ZodType<Prisma.CartUpsertWithoutCartItemsInput> =
  z
    .object({
      update: z.union([
        z.lazy(() => CartUpdateWithoutCartItemsInputSchema),
        z.lazy(() => CartUncheckedUpdateWithoutCartItemsInputSchema),
      ]),
      create: z.union([
        z.lazy(() => CartCreateWithoutCartItemsInputSchema),
        z.lazy(() => CartUncheckedCreateWithoutCartItemsInputSchema),
      ]),
      where: z.lazy(() => CartWhereInputSchema).optional(),
    })
    .strict() as z.ZodType<Prisma.CartUpsertWithoutCartItemsInput>;

export const CartUpdateToOneWithWhereWithoutCartItemsInputSchema: z.ZodType<Prisma.CartUpdateToOneWithWhereWithoutCartItemsInput> =
  z
    .object({
      where: z.lazy(() => CartWhereInputSchema).optional(),
      data: z.union([
        z.lazy(() => CartUpdateWithoutCartItemsInputSchema),
        z.lazy(() => CartUncheckedUpdateWithoutCartItemsInputSchema),
      ]),
    })
    .strict() as z.ZodType<Prisma.CartUpdateToOneWithWhereWithoutCartItemsInput>;

export const CartUpdateWithoutCartItemsInputSchema: z.ZodType<Prisma.CartUpdateWithoutCartItemsInput> =
  z
    .object({
      id: z
        .union([
          z.string().uuid(),
          z.lazy(() => StringFieldUpdateOperationsInputSchema),
        ])
        .optional(),
      createdAt: z
        .union([
          z.coerce.date(),
          z.lazy(() => DateTimeFieldUpdateOperationsInputSchema),
        ])
        .optional(),
      updatedAt: z
        .union([
          z.coerce.date(),
          z.lazy(() => DateTimeFieldUpdateOperationsInputSchema),
        ])
        .optional(),
      user: z
        .lazy(() => UserUpdateOneRequiredWithoutCartNestedInputSchema)
        .optional(),
    })
    .strict() as z.ZodType<Prisma.CartUpdateWithoutCartItemsInput>;

export const CartUncheckedUpdateWithoutCartItemsInputSchema: z.ZodType<Prisma.CartUncheckedUpdateWithoutCartItemsInput> =
  z
    .object({
      id: z
        .union([
          z.string().uuid(),
          z.lazy(() => StringFieldUpdateOperationsInputSchema),
        ])
        .optional(),
      userID: z
        .union([
          z.string(),
          z.lazy(() => StringFieldUpdateOperationsInputSchema),
        ])
        .optional(),
      createdAt: z
        .union([
          z.coerce.date(),
          z.lazy(() => DateTimeFieldUpdateOperationsInputSchema),
        ])
        .optional(),
      updatedAt: z
        .union([
          z.coerce.date(),
          z.lazy(() => DateTimeFieldUpdateOperationsInputSchema),
        ])
        .optional(),
    })
    .strict() as z.ZodType<Prisma.CartUncheckedUpdateWithoutCartItemsInput>;

export const ProductVariantUpsertWithoutCartItemsInputSchema: z.ZodType<Prisma.ProductVariantUpsertWithoutCartItemsInput> =
  z
    .object({
      update: z.union([
        z.lazy(() => ProductVariantUpdateWithoutCartItemsInputSchema),
        z.lazy(() => ProductVariantUncheckedUpdateWithoutCartItemsInputSchema),
      ]),
      create: z.union([
        z.lazy(() => ProductVariantCreateWithoutCartItemsInputSchema),
        z.lazy(() => ProductVariantUncheckedCreateWithoutCartItemsInputSchema),
      ]),
      where: z.lazy(() => ProductVariantWhereInputSchema).optional(),
    })
    .strict() as z.ZodType<Prisma.ProductVariantUpsertWithoutCartItemsInput>;

export const ProductVariantUpdateToOneWithWhereWithoutCartItemsInputSchema: z.ZodType<Prisma.ProductVariantUpdateToOneWithWhereWithoutCartItemsInput> =
  z
    .object({
      where: z.lazy(() => ProductVariantWhereInputSchema).optional(),
      data: z.union([
        z.lazy(() => ProductVariantUpdateWithoutCartItemsInputSchema),
        z.lazy(() => ProductVariantUncheckedUpdateWithoutCartItemsInputSchema),
      ]),
    })
    .strict() as z.ZodType<Prisma.ProductVariantUpdateToOneWithWhereWithoutCartItemsInput>;

export const ProductVariantUpdateWithoutCartItemsInputSchema: z.ZodType<Prisma.ProductVariantUpdateWithoutCartItemsInput> =
  z
    .object({
      id: z
        .union([
          z.string().uuid(),
          z.lazy(() => StringFieldUpdateOperationsInputSchema),
        ])
        .optional(),
      name: z
        .union([
          z.string(),
          z.lazy(() => NullableStringFieldUpdateOperationsInputSchema),
        ])
        .optional()
        .nullable(),
      sku: z
        .union([
          z.string(),
          z.lazy(() => NullableStringFieldUpdateOperationsInputSchema),
        ])
        .optional()
        .nullable(),
      price: z
        .union([
          z
            .union([
              z.number(),
              z.string(),
              z.instanceof(Decimal),
              z.instanceof(Prisma.Decimal),
              DecimalJsLikeSchema,
            ])
            .refine((v) => isValidDecimalInput(v), {
              message: 'Must be a Decimal',
            }),
          z.lazy(() => DecimalFieldUpdateOperationsInputSchema),
        ])
        .optional(),
      stockQuantity: z
        .union([
          z.number().int(),
          z.lazy(() => IntFieldUpdateOperationsInputSchema),
        ])
        .optional(),
      attributes: z
        .union([
          z.lazy(() => NullableJsonNullValueInputSchema),
          InputJsonValueSchema,
        ])
        .optional(),
      createdAt: z
        .union([
          z.coerce.date(),
          z.lazy(() => DateTimeFieldUpdateOperationsInputSchema),
        ])
        .optional(),
      createdBy: z
        .union([
          z.string(),
          z.lazy(() => NullableStringFieldUpdateOperationsInputSchema),
        ])
        .optional()
        .nullable(),
      updatedAt: z
        .union([
          z.coerce.date(),
          z.lazy(() => DateTimeFieldUpdateOperationsInputSchema),
        ])
        .optional(),
      deletedAt: z
        .union([
          z.coerce.date(),
          z.lazy(() => NullableDateTimeFieldUpdateOperationsInputSchema),
        ])
        .optional()
        .nullable(),
      product: z
        .lazy(
          () => ProductUpdateOneRequiredWithoutProductVariantsNestedInputSchema,
        )
        .optional(),
      productImages: z
        .lazy(
          () => ProductImageUpdateManyWithoutProductVariantNestedInputSchema,
        )
        .optional(),
      orderItems: z
        .lazy(() => OrderItemUpdateManyWithoutProductVariantNestedInputSchema)
        .optional(),
    })
    .strict() as z.ZodType<Prisma.ProductVariantUpdateWithoutCartItemsInput>;

export const ProductVariantUncheckedUpdateWithoutCartItemsInputSchema: z.ZodType<Prisma.ProductVariantUncheckedUpdateWithoutCartItemsInput> =
  z
    .object({
      id: z
        .union([
          z.string().uuid(),
          z.lazy(() => StringFieldUpdateOperationsInputSchema),
        ])
        .optional(),
      productID: z
        .union([
          z.string(),
          z.lazy(() => StringFieldUpdateOperationsInputSchema),
        ])
        .optional(),
      name: z
        .union([
          z.string(),
          z.lazy(() => NullableStringFieldUpdateOperationsInputSchema),
        ])
        .optional()
        .nullable(),
      sku: z
        .union([
          z.string(),
          z.lazy(() => NullableStringFieldUpdateOperationsInputSchema),
        ])
        .optional()
        .nullable(),
      price: z
        .union([
          z
            .union([
              z.number(),
              z.string(),
              z.instanceof(Decimal),
              z.instanceof(Prisma.Decimal),
              DecimalJsLikeSchema,
            ])
            .refine((v) => isValidDecimalInput(v), {
              message: 'Must be a Decimal',
            }),
          z.lazy(() => DecimalFieldUpdateOperationsInputSchema),
        ])
        .optional(),
      stockQuantity: z
        .union([
          z.number().int(),
          z.lazy(() => IntFieldUpdateOperationsInputSchema),
        ])
        .optional(),
      attributes: z
        .union([
          z.lazy(() => NullableJsonNullValueInputSchema),
          InputJsonValueSchema,
        ])
        .optional(),
      createdAt: z
        .union([
          z.coerce.date(),
          z.lazy(() => DateTimeFieldUpdateOperationsInputSchema),
        ])
        .optional(),
      createdBy: z
        .union([
          z.string(),
          z.lazy(() => NullableStringFieldUpdateOperationsInputSchema),
        ])
        .optional()
        .nullable(),
      updatedAt: z
        .union([
          z.coerce.date(),
          z.lazy(() => DateTimeFieldUpdateOperationsInputSchema),
        ])
        .optional(),
      deletedAt: z
        .union([
          z.coerce.date(),
          z.lazy(() => NullableDateTimeFieldUpdateOperationsInputSchema),
        ])
        .optional()
        .nullable(),
      productImages: z
        .lazy(
          () =>
            ProductImageUncheckedUpdateManyWithoutProductVariantNestedInputSchema,
        )
        .optional(),
      orderItems: z
        .lazy(
          () =>
            OrderItemUncheckedUpdateManyWithoutProductVariantNestedInputSchema,
        )
        .optional(),
    })
    .strict() as z.ZodType<Prisma.ProductVariantUncheckedUpdateWithoutCartItemsInput>;

export const UserCreateWithoutNotificationsInputSchema: z.ZodType<Prisma.UserCreateWithoutNotificationsInput> =
  z
    .object({
      id: z.string().uuid().optional(),
      email: z.string().email(),
      password: z.string(),
      firstName: z.string(),
      lastName: z.string().optional().nullable(),
      fullAddress: z.string(),
      city: z.string().optional().nullable(),
      province: z.string().optional().nullable(),
      country: z.string().optional().nullable(),
      phone: z.string().optional().nullable(),
      status: z.lazy(() => UserStatusSchema).optional(),
      createdAt: z.coerce.date().optional(),
      createdBy: z.string().optional().nullable(),
      updatedAt: z.coerce.date().optional(),
      deletedAt: z.coerce.date().optional().nullable(),
      vendors: z
        .lazy(() => VendorCreateNestedManyWithoutUserInputSchema)
        .optional(),
      userVendorRoles: z
        .lazy(() => UserVendorRoleCreateNestedManyWithoutUserInputSchema)
        .optional(),
      orders: z
        .lazy(() => OrderCreateNestedManyWithoutUserInputSchema)
        .optional(),
      cart: z.lazy(() => CartCreateNestedOneWithoutUserInputSchema).optional(),
    })
    .strict() as z.ZodType<Prisma.UserCreateWithoutNotificationsInput>;

export const UserUncheckedCreateWithoutNotificationsInputSchema: z.ZodType<Prisma.UserUncheckedCreateWithoutNotificationsInput> =
  z
    .object({
      id: z.string().uuid().optional(),
      email: z.string().email(),
      password: z.string(),
      firstName: z.string(),
      lastName: z.string().optional().nullable(),
      fullAddress: z.string(),
      city: z.string().optional().nullable(),
      province: z.string().optional().nullable(),
      country: z.string().optional().nullable(),
      phone: z.string().optional().nullable(),
      status: z.lazy(() => UserStatusSchema).optional(),
      createdAt: z.coerce.date().optional(),
      createdBy: z.string().optional().nullable(),
      updatedAt: z.coerce.date().optional(),
      deletedAt: z.coerce.date().optional().nullable(),
      vendors: z
        .lazy(() => VendorUncheckedCreateNestedManyWithoutUserInputSchema)
        .optional(),
      userVendorRoles: z
        .lazy(
          () => UserVendorRoleUncheckedCreateNestedManyWithoutUserInputSchema,
        )
        .optional(),
      orders: z
        .lazy(() => OrderUncheckedCreateNestedManyWithoutUserInputSchema)
        .optional(),
      cart: z
        .lazy(() => CartUncheckedCreateNestedOneWithoutUserInputSchema)
        .optional(),
    })
    .strict() as z.ZodType<Prisma.UserUncheckedCreateWithoutNotificationsInput>;

export const UserCreateOrConnectWithoutNotificationsInputSchema: z.ZodType<Prisma.UserCreateOrConnectWithoutNotificationsInput> =
  z
    .object({
      where: z.lazy(() => UserWhereUniqueInputSchema),
      create: z.union([
        z.lazy(() => UserCreateWithoutNotificationsInputSchema),
        z.lazy(() => UserUncheckedCreateWithoutNotificationsInputSchema),
      ]),
    })
    .strict() as z.ZodType<Prisma.UserCreateOrConnectWithoutNotificationsInput>;

export const UserUpsertWithoutNotificationsInputSchema: z.ZodType<Prisma.UserUpsertWithoutNotificationsInput> =
  z
    .object({
      update: z.union([
        z.lazy(() => UserUpdateWithoutNotificationsInputSchema),
        z.lazy(() => UserUncheckedUpdateWithoutNotificationsInputSchema),
      ]),
      create: z.union([
        z.lazy(() => UserCreateWithoutNotificationsInputSchema),
        z.lazy(() => UserUncheckedCreateWithoutNotificationsInputSchema),
      ]),
      where: z.lazy(() => UserWhereInputSchema).optional(),
    })
    .strict() as z.ZodType<Prisma.UserUpsertWithoutNotificationsInput>;

export const UserUpdateToOneWithWhereWithoutNotificationsInputSchema: z.ZodType<Prisma.UserUpdateToOneWithWhereWithoutNotificationsInput> =
  z
    .object({
      where: z.lazy(() => UserWhereInputSchema).optional(),
      data: z.union([
        z.lazy(() => UserUpdateWithoutNotificationsInputSchema),
        z.lazy(() => UserUncheckedUpdateWithoutNotificationsInputSchema),
      ]),
    })
    .strict() as z.ZodType<Prisma.UserUpdateToOneWithWhereWithoutNotificationsInput>;

export const UserUpdateWithoutNotificationsInputSchema: z.ZodType<Prisma.UserUpdateWithoutNotificationsInput> =
  z
    .object({
      id: z
        .union([
          z.string().uuid(),
          z.lazy(() => StringFieldUpdateOperationsInputSchema),
        ])
        .optional(),
      email: z
        .union([
          z.string().email(),
          z.lazy(() => StringFieldUpdateOperationsInputSchema),
        ])
        .optional(),
      password: z
        .union([
          z.string(),
          z.lazy(() => StringFieldUpdateOperationsInputSchema),
        ])
        .optional(),
      firstName: z
        .union([
          z.string(),
          z.lazy(() => StringFieldUpdateOperationsInputSchema),
        ])
        .optional(),
      lastName: z
        .union([
          z.string(),
          z.lazy(() => NullableStringFieldUpdateOperationsInputSchema),
        ])
        .optional()
        .nullable(),
      fullAddress: z
        .union([
          z.string(),
          z.lazy(() => StringFieldUpdateOperationsInputSchema),
        ])
        .optional(),
      city: z
        .union([
          z.string(),
          z.lazy(() => NullableStringFieldUpdateOperationsInputSchema),
        ])
        .optional()
        .nullable(),
      province: z
        .union([
          z.string(),
          z.lazy(() => NullableStringFieldUpdateOperationsInputSchema),
        ])
        .optional()
        .nullable(),
      country: z
        .union([
          z.string(),
          z.lazy(() => NullableStringFieldUpdateOperationsInputSchema),
        ])
        .optional()
        .nullable(),
      phone: z
        .union([
          z.string(),
          z.lazy(() => NullableStringFieldUpdateOperationsInputSchema),
        ])
        .optional()
        .nullable(),
      status: z
        .union([
          z.lazy(() => UserStatusSchema),
          z.lazy(() => EnumUserStatusFieldUpdateOperationsInputSchema),
        ])
        .optional(),
      createdAt: z
        .union([
          z.coerce.date(),
          z.lazy(() => DateTimeFieldUpdateOperationsInputSchema),
        ])
        .optional(),
      createdBy: z
        .union([
          z.string(),
          z.lazy(() => NullableStringFieldUpdateOperationsInputSchema),
        ])
        .optional()
        .nullable(),
      updatedAt: z
        .union([
          z.coerce.date(),
          z.lazy(() => DateTimeFieldUpdateOperationsInputSchema),
        ])
        .optional(),
      deletedAt: z
        .union([
          z.coerce.date(),
          z.lazy(() => NullableDateTimeFieldUpdateOperationsInputSchema),
        ])
        .optional()
        .nullable(),
      vendors: z
        .lazy(() => VendorUpdateManyWithoutUserNestedInputSchema)
        .optional(),
      userVendorRoles: z
        .lazy(() => UserVendorRoleUpdateManyWithoutUserNestedInputSchema)
        .optional(),
      orders: z
        .lazy(() => OrderUpdateManyWithoutUserNestedInputSchema)
        .optional(),
      cart: z.lazy(() => CartUpdateOneWithoutUserNestedInputSchema).optional(),
    })
    .strict() as z.ZodType<Prisma.UserUpdateWithoutNotificationsInput>;

export const UserUncheckedUpdateWithoutNotificationsInputSchema: z.ZodType<Prisma.UserUncheckedUpdateWithoutNotificationsInput> =
  z
    .object({
      id: z
        .union([
          z.string().uuid(),
          z.lazy(() => StringFieldUpdateOperationsInputSchema),
        ])
        .optional(),
      email: z
        .union([
          z.string().email(),
          z.lazy(() => StringFieldUpdateOperationsInputSchema),
        ])
        .optional(),
      password: z
        .union([
          z.string(),
          z.lazy(() => StringFieldUpdateOperationsInputSchema),
        ])
        .optional(),
      firstName: z
        .union([
          z.string(),
          z.lazy(() => StringFieldUpdateOperationsInputSchema),
        ])
        .optional(),
      lastName: z
        .union([
          z.string(),
          z.lazy(() => NullableStringFieldUpdateOperationsInputSchema),
        ])
        .optional()
        .nullable(),
      fullAddress: z
        .union([
          z.string(),
          z.lazy(() => StringFieldUpdateOperationsInputSchema),
        ])
        .optional(),
      city: z
        .union([
          z.string(),
          z.lazy(() => NullableStringFieldUpdateOperationsInputSchema),
        ])
        .optional()
        .nullable(),
      province: z
        .union([
          z.string(),
          z.lazy(() => NullableStringFieldUpdateOperationsInputSchema),
        ])
        .optional()
        .nullable(),
      country: z
        .union([
          z.string(),
          z.lazy(() => NullableStringFieldUpdateOperationsInputSchema),
        ])
        .optional()
        .nullable(),
      phone: z
        .union([
          z.string(),
          z.lazy(() => NullableStringFieldUpdateOperationsInputSchema),
        ])
        .optional()
        .nullable(),
      status: z
        .union([
          z.lazy(() => UserStatusSchema),
          z.lazy(() => EnumUserStatusFieldUpdateOperationsInputSchema),
        ])
        .optional(),
      createdAt: z
        .union([
          z.coerce.date(),
          z.lazy(() => DateTimeFieldUpdateOperationsInputSchema),
        ])
        .optional(),
      createdBy: z
        .union([
          z.string(),
          z.lazy(() => NullableStringFieldUpdateOperationsInputSchema),
        ])
        .optional()
        .nullable(),
      updatedAt: z
        .union([
          z.coerce.date(),
          z.lazy(() => DateTimeFieldUpdateOperationsInputSchema),
        ])
        .optional(),
      deletedAt: z
        .union([
          z.coerce.date(),
          z.lazy(() => NullableDateTimeFieldUpdateOperationsInputSchema),
        ])
        .optional()
        .nullable(),
      vendors: z
        .lazy(() => VendorUncheckedUpdateManyWithoutUserNestedInputSchema)
        .optional(),
      userVendorRoles: z
        .lazy(
          () => UserVendorRoleUncheckedUpdateManyWithoutUserNestedInputSchema,
        )
        .optional(),
      orders: z
        .lazy(() => OrderUncheckedUpdateManyWithoutUserNestedInputSchema)
        .optional(),
      cart: z
        .lazy(() => CartUncheckedUpdateOneWithoutUserNestedInputSchema)
        .optional(),
    })
    .strict() as z.ZodType<Prisma.UserUncheckedUpdateWithoutNotificationsInput>;

export const OrderCreateWithoutPaymentsInputSchema: z.ZodType<Prisma.OrderCreateWithoutPaymentsInput> =
  z
    .object({
      id: z.string().uuid().optional(),
      orderNumber: z.string(),
      status: z.lazy(() => OrderStatusSchema).optional(),
      subtotal: z
        .union([
          z.number(),
          z.string(),
          z.instanceof(Decimal),
          z.instanceof(Prisma.Decimal),
          DecimalJsLikeSchema,
        ])
        .refine((v) => isValidDecimalInput(v), {
          message: 'Must be a Decimal',
        }),
      taxAmount: z
        .union([
          z.number(),
          z.string(),
          z.instanceof(Decimal),
          z.instanceof(Prisma.Decimal),
          DecimalJsLikeSchema,
        ])
        .refine((v) => isValidDecimalInput(v), { message: 'Must be a Decimal' })
        .optional(),
      shippingAmount: z
        .union([
          z.number(),
          z.string(),
          z.instanceof(Decimal),
          z.instanceof(Prisma.Decimal),
          DecimalJsLikeSchema,
        ])
        .refine((v) => isValidDecimalInput(v), { message: 'Must be a Decimal' })
        .optional(),
      discountAmount: z
        .union([
          z.number(),
          z.string(),
          z.instanceof(Decimal),
          z.instanceof(Prisma.Decimal),
          DecimalJsLikeSchema,
        ])
        .refine((v) => isValidDecimalInput(v), { message: 'Must be a Decimal' })
        .optional(),
      totalAmount: z
        .union([
          z.number(),
          z.string(),
          z.instanceof(Decimal),
          z.instanceof(Prisma.Decimal),
          DecimalJsLikeSchema,
        ])
        .refine((v) => isValidDecimalInput(v), {
          message: 'Must be a Decimal',
        }),
      currency: z.string().optional(),
      notes: z.string().optional().nullable(),
      shippedAt: z.coerce.date().optional().nullable(),
      deliveredAt: z.coerce.date().optional().nullable(),
      createdAt: z.coerce.date().optional(),
      createdBy: z.string().optional().nullable(),
      updatedAt: z.coerce.date().optional(),
      deletedAt: z.coerce.date().optional().nullable(),
      user: z.lazy(() => UserCreateNestedOneWithoutOrdersInputSchema),
      orderItems: z
        .lazy(() => OrderItemCreateNestedManyWithoutOrderInputSchema)
        .optional(),
      orderAddresses: z
        .lazy(() => OrderAddressCreateNestedManyWithoutOrderInputSchema)
        .optional(),
      orderPromotions: z
        .lazy(() => OrderPromotionCreateNestedManyWithoutOrderInputSchema)
        .optional(),
    })
    .strict() as z.ZodType<Prisma.OrderCreateWithoutPaymentsInput>;

export const OrderUncheckedCreateWithoutPaymentsInputSchema: z.ZodType<Prisma.OrderUncheckedCreateWithoutPaymentsInput> =
  z
    .object({
      id: z.string().uuid().optional(),
      orderNumber: z.string(),
      userID: z.string(),
      status: z.lazy(() => OrderStatusSchema).optional(),
      subtotal: z
        .union([
          z.number(),
          z.string(),
          z.instanceof(Decimal),
          z.instanceof(Prisma.Decimal),
          DecimalJsLikeSchema,
        ])
        .refine((v) => isValidDecimalInput(v), {
          message: 'Must be a Decimal',
        }),
      taxAmount: z
        .union([
          z.number(),
          z.string(),
          z.instanceof(Decimal),
          z.instanceof(Prisma.Decimal),
          DecimalJsLikeSchema,
        ])
        .refine((v) => isValidDecimalInput(v), { message: 'Must be a Decimal' })
        .optional(),
      shippingAmount: z
        .union([
          z.number(),
          z.string(),
          z.instanceof(Decimal),
          z.instanceof(Prisma.Decimal),
          DecimalJsLikeSchema,
        ])
        .refine((v) => isValidDecimalInput(v), { message: 'Must be a Decimal' })
        .optional(),
      discountAmount: z
        .union([
          z.number(),
          z.string(),
          z.instanceof(Decimal),
          z.instanceof(Prisma.Decimal),
          DecimalJsLikeSchema,
        ])
        .refine((v) => isValidDecimalInput(v), { message: 'Must be a Decimal' })
        .optional(),
      totalAmount: z
        .union([
          z.number(),
          z.string(),
          z.instanceof(Decimal),
          z.instanceof(Prisma.Decimal),
          DecimalJsLikeSchema,
        ])
        .refine((v) => isValidDecimalInput(v), {
          message: 'Must be a Decimal',
        }),
      currency: z.string().optional(),
      notes: z.string().optional().nullable(),
      shippedAt: z.coerce.date().optional().nullable(),
      deliveredAt: z.coerce.date().optional().nullable(),
      createdAt: z.coerce.date().optional(),
      createdBy: z.string().optional().nullable(),
      updatedAt: z.coerce.date().optional(),
      deletedAt: z.coerce.date().optional().nullable(),
      orderItems: z
        .lazy(() => OrderItemUncheckedCreateNestedManyWithoutOrderInputSchema)
        .optional(),
      orderAddresses: z
        .lazy(
          () => OrderAddressUncheckedCreateNestedManyWithoutOrderInputSchema,
        )
        .optional(),
      orderPromotions: z
        .lazy(
          () => OrderPromotionUncheckedCreateNestedManyWithoutOrderInputSchema,
        )
        .optional(),
    })
    .strict() as z.ZodType<Prisma.OrderUncheckedCreateWithoutPaymentsInput>;

export const OrderCreateOrConnectWithoutPaymentsInputSchema: z.ZodType<Prisma.OrderCreateOrConnectWithoutPaymentsInput> =
  z
    .object({
      where: z.lazy(() => OrderWhereUniqueInputSchema),
      create: z.union([
        z.lazy(() => OrderCreateWithoutPaymentsInputSchema),
        z.lazy(() => OrderUncheckedCreateWithoutPaymentsInputSchema),
      ]),
    })
    .strict() as z.ZodType<Prisma.OrderCreateOrConnectWithoutPaymentsInput>;

export const OrderUpsertWithoutPaymentsInputSchema: z.ZodType<Prisma.OrderUpsertWithoutPaymentsInput> =
  z
    .object({
      update: z.union([
        z.lazy(() => OrderUpdateWithoutPaymentsInputSchema),
        z.lazy(() => OrderUncheckedUpdateWithoutPaymentsInputSchema),
      ]),
      create: z.union([
        z.lazy(() => OrderCreateWithoutPaymentsInputSchema),
        z.lazy(() => OrderUncheckedCreateWithoutPaymentsInputSchema),
      ]),
      where: z.lazy(() => OrderWhereInputSchema).optional(),
    })
    .strict() as z.ZodType<Prisma.OrderUpsertWithoutPaymentsInput>;

export const OrderUpdateToOneWithWhereWithoutPaymentsInputSchema: z.ZodType<Prisma.OrderUpdateToOneWithWhereWithoutPaymentsInput> =
  z
    .object({
      where: z.lazy(() => OrderWhereInputSchema).optional(),
      data: z.union([
        z.lazy(() => OrderUpdateWithoutPaymentsInputSchema),
        z.lazy(() => OrderUncheckedUpdateWithoutPaymentsInputSchema),
      ]),
    })
    .strict() as z.ZodType<Prisma.OrderUpdateToOneWithWhereWithoutPaymentsInput>;

export const OrderUpdateWithoutPaymentsInputSchema: z.ZodType<Prisma.OrderUpdateWithoutPaymentsInput> =
  z
    .object({
      id: z
        .union([
          z.string().uuid(),
          z.lazy(() => StringFieldUpdateOperationsInputSchema),
        ])
        .optional(),
      orderNumber: z
        .union([
          z.string(),
          z.lazy(() => StringFieldUpdateOperationsInputSchema),
        ])
        .optional(),
      status: z
        .union([
          z.lazy(() => OrderStatusSchema),
          z.lazy(() => EnumOrderStatusFieldUpdateOperationsInputSchema),
        ])
        .optional(),
      subtotal: z
        .union([
          z
            .union([
              z.number(),
              z.string(),
              z.instanceof(Decimal),
              z.instanceof(Prisma.Decimal),
              DecimalJsLikeSchema,
            ])
            .refine((v) => isValidDecimalInput(v), {
              message: 'Must be a Decimal',
            }),
          z.lazy(() => DecimalFieldUpdateOperationsInputSchema),
        ])
        .optional(),
      taxAmount: z
        .union([
          z
            .union([
              z.number(),
              z.string(),
              z.instanceof(Decimal),
              z.instanceof(Prisma.Decimal),
              DecimalJsLikeSchema,
            ])
            .refine((v) => isValidDecimalInput(v), {
              message: 'Must be a Decimal',
            }),
          z.lazy(() => DecimalFieldUpdateOperationsInputSchema),
        ])
        .optional(),
      shippingAmount: z
        .union([
          z
            .union([
              z.number(),
              z.string(),
              z.instanceof(Decimal),
              z.instanceof(Prisma.Decimal),
              DecimalJsLikeSchema,
            ])
            .refine((v) => isValidDecimalInput(v), {
              message: 'Must be a Decimal',
            }),
          z.lazy(() => DecimalFieldUpdateOperationsInputSchema),
        ])
        .optional(),
      discountAmount: z
        .union([
          z
            .union([
              z.number(),
              z.string(),
              z.instanceof(Decimal),
              z.instanceof(Prisma.Decimal),
              DecimalJsLikeSchema,
            ])
            .refine((v) => isValidDecimalInput(v), {
              message: 'Must be a Decimal',
            }),
          z.lazy(() => DecimalFieldUpdateOperationsInputSchema),
        ])
        .optional(),
      totalAmount: z
        .union([
          z
            .union([
              z.number(),
              z.string(),
              z.instanceof(Decimal),
              z.instanceof(Prisma.Decimal),
              DecimalJsLikeSchema,
            ])
            .refine((v) => isValidDecimalInput(v), {
              message: 'Must be a Decimal',
            }),
          z.lazy(() => DecimalFieldUpdateOperationsInputSchema),
        ])
        .optional(),
      currency: z
        .union([
          z.string(),
          z.lazy(() => StringFieldUpdateOperationsInputSchema),
        ])
        .optional(),
      notes: z
        .union([
          z.string(),
          z.lazy(() => NullableStringFieldUpdateOperationsInputSchema),
        ])
        .optional()
        .nullable(),
      shippedAt: z
        .union([
          z.coerce.date(),
          z.lazy(() => NullableDateTimeFieldUpdateOperationsInputSchema),
        ])
        .optional()
        .nullable(),
      deliveredAt: z
        .union([
          z.coerce.date(),
          z.lazy(() => NullableDateTimeFieldUpdateOperationsInputSchema),
        ])
        .optional()
        .nullable(),
      createdAt: z
        .union([
          z.coerce.date(),
          z.lazy(() => DateTimeFieldUpdateOperationsInputSchema),
        ])
        .optional(),
      createdBy: z
        .union([
          z.string(),
          z.lazy(() => NullableStringFieldUpdateOperationsInputSchema),
        ])
        .optional()
        .nullable(),
      updatedAt: z
        .union([
          z.coerce.date(),
          z.lazy(() => DateTimeFieldUpdateOperationsInputSchema),
        ])
        .optional(),
      deletedAt: z
        .union([
          z.coerce.date(),
          z.lazy(() => NullableDateTimeFieldUpdateOperationsInputSchema),
        ])
        .optional()
        .nullable(),
      user: z
        .lazy(() => UserUpdateOneRequiredWithoutOrdersNestedInputSchema)
        .optional(),
      orderItems: z
        .lazy(() => OrderItemUpdateManyWithoutOrderNestedInputSchema)
        .optional(),
      orderAddresses: z
        .lazy(() => OrderAddressUpdateManyWithoutOrderNestedInputSchema)
        .optional(),
      orderPromotions: z
        .lazy(() => OrderPromotionUpdateManyWithoutOrderNestedInputSchema)
        .optional(),
    })
    .strict() as z.ZodType<Prisma.OrderUpdateWithoutPaymentsInput>;

export const OrderUncheckedUpdateWithoutPaymentsInputSchema: z.ZodType<Prisma.OrderUncheckedUpdateWithoutPaymentsInput> =
  z
    .object({
      id: z
        .union([
          z.string().uuid(),
          z.lazy(() => StringFieldUpdateOperationsInputSchema),
        ])
        .optional(),
      orderNumber: z
        .union([
          z.string(),
          z.lazy(() => StringFieldUpdateOperationsInputSchema),
        ])
        .optional(),
      userID: z
        .union([
          z.string(),
          z.lazy(() => StringFieldUpdateOperationsInputSchema),
        ])
        .optional(),
      status: z
        .union([
          z.lazy(() => OrderStatusSchema),
          z.lazy(() => EnumOrderStatusFieldUpdateOperationsInputSchema),
        ])
        .optional(),
      subtotal: z
        .union([
          z
            .union([
              z.number(),
              z.string(),
              z.instanceof(Decimal),
              z.instanceof(Prisma.Decimal),
              DecimalJsLikeSchema,
            ])
            .refine((v) => isValidDecimalInput(v), {
              message: 'Must be a Decimal',
            }),
          z.lazy(() => DecimalFieldUpdateOperationsInputSchema),
        ])
        .optional(),
      taxAmount: z
        .union([
          z
            .union([
              z.number(),
              z.string(),
              z.instanceof(Decimal),
              z.instanceof(Prisma.Decimal),
              DecimalJsLikeSchema,
            ])
            .refine((v) => isValidDecimalInput(v), {
              message: 'Must be a Decimal',
            }),
          z.lazy(() => DecimalFieldUpdateOperationsInputSchema),
        ])
        .optional(),
      shippingAmount: z
        .union([
          z
            .union([
              z.number(),
              z.string(),
              z.instanceof(Decimal),
              z.instanceof(Prisma.Decimal),
              DecimalJsLikeSchema,
            ])
            .refine((v) => isValidDecimalInput(v), {
              message: 'Must be a Decimal',
            }),
          z.lazy(() => DecimalFieldUpdateOperationsInputSchema),
        ])
        .optional(),
      discountAmount: z
        .union([
          z
            .union([
              z.number(),
              z.string(),
              z.instanceof(Decimal),
              z.instanceof(Prisma.Decimal),
              DecimalJsLikeSchema,
            ])
            .refine((v) => isValidDecimalInput(v), {
              message: 'Must be a Decimal',
            }),
          z.lazy(() => DecimalFieldUpdateOperationsInputSchema),
        ])
        .optional(),
      totalAmount: z
        .union([
          z
            .union([
              z.number(),
              z.string(),
              z.instanceof(Decimal),
              z.instanceof(Prisma.Decimal),
              DecimalJsLikeSchema,
            ])
            .refine((v) => isValidDecimalInput(v), {
              message: 'Must be a Decimal',
            }),
          z.lazy(() => DecimalFieldUpdateOperationsInputSchema),
        ])
        .optional(),
      currency: z
        .union([
          z.string(),
          z.lazy(() => StringFieldUpdateOperationsInputSchema),
        ])
        .optional(),
      notes: z
        .union([
          z.string(),
          z.lazy(() => NullableStringFieldUpdateOperationsInputSchema),
        ])
        .optional()
        .nullable(),
      shippedAt: z
        .union([
          z.coerce.date(),
          z.lazy(() => NullableDateTimeFieldUpdateOperationsInputSchema),
        ])
        .optional()
        .nullable(),
      deliveredAt: z
        .union([
          z.coerce.date(),
          z.lazy(() => NullableDateTimeFieldUpdateOperationsInputSchema),
        ])
        .optional()
        .nullable(),
      createdAt: z
        .union([
          z.coerce.date(),
          z.lazy(() => DateTimeFieldUpdateOperationsInputSchema),
        ])
        .optional(),
      createdBy: z
        .union([
          z.string(),
          z.lazy(() => NullableStringFieldUpdateOperationsInputSchema),
        ])
        .optional()
        .nullable(),
      updatedAt: z
        .union([
          z.coerce.date(),
          z.lazy(() => DateTimeFieldUpdateOperationsInputSchema),
        ])
        .optional(),
      deletedAt: z
        .union([
          z.coerce.date(),
          z.lazy(() => NullableDateTimeFieldUpdateOperationsInputSchema),
        ])
        .optional()
        .nullable(),
      orderItems: z
        .lazy(() => OrderItemUncheckedUpdateManyWithoutOrderNestedInputSchema)
        .optional(),
      orderAddresses: z
        .lazy(
          () => OrderAddressUncheckedUpdateManyWithoutOrderNestedInputSchema,
        )
        .optional(),
      orderPromotions: z
        .lazy(
          () => OrderPromotionUncheckedUpdateManyWithoutOrderNestedInputSchema,
        )
        .optional(),
    })
    .strict() as z.ZodType<Prisma.OrderUncheckedUpdateWithoutPaymentsInput>;

export const VendorCreateManyUserInputSchema: z.ZodType<Prisma.VendorCreateManyUserInput> =
  z
    .object({
      id: z.string().uuid().optional(),
      name: z.string(),
      slug: z.string(),
      description: z.string().optional().nullable(),
      logoUrl: z.string().optional().nullable(),
      taxCode: z.string().optional().nullable(),
      totalProducts: z.number().int().optional(),
      totalOrders: z.number().int().optional(),
      status: z.lazy(() => VendorStatusSchema).optional(),
      createdAt: z.coerce.date().optional(),
      createdBy: z.string().optional().nullable(),
      updatedAt: z.coerce.date().optional(),
      deletedAt: z.coerce.date().optional().nullable(),
    })
    .strict() as z.ZodType<Prisma.VendorCreateManyUserInput>;

export const UserVendorRoleCreateManyUserInputSchema: z.ZodType<Prisma.UserVendorRoleCreateManyUserInput> =
  z
    .object({
      id: z.string().uuid().optional(),
      vendorID: z.string(),
      roleID: z.string(),
      status: z.lazy(() => UserVendorRoleStatusSchema).optional(),
      createdAt: z.coerce.date().optional(),
      createdBy: z.string().optional().nullable(),
    })
    .strict() as z.ZodType<Prisma.UserVendorRoleCreateManyUserInput>;

export const OrderCreateManyUserInputSchema: z.ZodType<Prisma.OrderCreateManyUserInput> =
  z
    .object({
      id: z.string().uuid().optional(),
      orderNumber: z.string(),
      status: z.lazy(() => OrderStatusSchema).optional(),
      subtotal: z
        .union([
          z.number(),
          z.string(),
          z.instanceof(Decimal),
          z.instanceof(Prisma.Decimal),
          DecimalJsLikeSchema,
        ])
        .refine((v) => isValidDecimalInput(v), {
          message: 'Must be a Decimal',
        }),
      taxAmount: z
        .union([
          z.number(),
          z.string(),
          z.instanceof(Decimal),
          z.instanceof(Prisma.Decimal),
          DecimalJsLikeSchema,
        ])
        .refine((v) => isValidDecimalInput(v), { message: 'Must be a Decimal' })
        .optional(),
      shippingAmount: z
        .union([
          z.number(),
          z.string(),
          z.instanceof(Decimal),
          z.instanceof(Prisma.Decimal),
          DecimalJsLikeSchema,
        ])
        .refine((v) => isValidDecimalInput(v), { message: 'Must be a Decimal' })
        .optional(),
      discountAmount: z
        .union([
          z.number(),
          z.string(),
          z.instanceof(Decimal),
          z.instanceof(Prisma.Decimal),
          DecimalJsLikeSchema,
        ])
        .refine((v) => isValidDecimalInput(v), { message: 'Must be a Decimal' })
        .optional(),
      totalAmount: z
        .union([
          z.number(),
          z.string(),
          z.instanceof(Decimal),
          z.instanceof(Prisma.Decimal),
          DecimalJsLikeSchema,
        ])
        .refine((v) => isValidDecimalInput(v), {
          message: 'Must be a Decimal',
        }),
      currency: z.string().optional(),
      notes: z.string().optional().nullable(),
      shippedAt: z.coerce.date().optional().nullable(),
      deliveredAt: z.coerce.date().optional().nullable(),
      createdAt: z.coerce.date().optional(),
      createdBy: z.string().optional().nullable(),
      updatedAt: z.coerce.date().optional(),
      deletedAt: z.coerce.date().optional().nullable(),
    })
    .strict() as z.ZodType<Prisma.OrderCreateManyUserInput>;

export const NotificationCreateManyUserInputSchema: z.ZodType<Prisma.NotificationCreateManyUserInput> =
  z
    .object({
      id: z.string().uuid().optional(),
      title: z.string(),
      message: z.string(),
      isRead: z.boolean().optional(),
    })
    .strict() as z.ZodType<Prisma.NotificationCreateManyUserInput>;

export const VendorUpdateWithoutUserInputSchema: z.ZodType<Prisma.VendorUpdateWithoutUserInput> =
  z
    .object({
      id: z
        .union([
          z.string().uuid(),
          z.lazy(() => StringFieldUpdateOperationsInputSchema),
        ])
        .optional(),
      name: z
        .union([
          z.string(),
          z.lazy(() => StringFieldUpdateOperationsInputSchema),
        ])
        .optional(),
      slug: z
        .union([
          z.string(),
          z.lazy(() => StringFieldUpdateOperationsInputSchema),
        ])
        .optional(),
      description: z
        .union([
          z.string(),
          z.lazy(() => NullableStringFieldUpdateOperationsInputSchema),
        ])
        .optional()
        .nullable(),
      logoUrl: z
        .union([
          z.string(),
          z.lazy(() => NullableStringFieldUpdateOperationsInputSchema),
        ])
        .optional()
        .nullable(),
      taxCode: z
        .union([
          z.string(),
          z.lazy(() => NullableStringFieldUpdateOperationsInputSchema),
        ])
        .optional()
        .nullable(),
      totalProducts: z
        .union([
          z.number().int(),
          z.lazy(() => IntFieldUpdateOperationsInputSchema),
        ])
        .optional(),
      totalOrders: z
        .union([
          z.number().int(),
          z.lazy(() => IntFieldUpdateOperationsInputSchema),
        ])
        .optional(),
      status: z
        .union([
          z.lazy(() => VendorStatusSchema),
          z.lazy(() => EnumVendorStatusFieldUpdateOperationsInputSchema),
        ])
        .optional(),
      createdAt: z
        .union([
          z.coerce.date(),
          z.lazy(() => DateTimeFieldUpdateOperationsInputSchema),
        ])
        .optional(),
      createdBy: z
        .union([
          z.string(),
          z.lazy(() => NullableStringFieldUpdateOperationsInputSchema),
        ])
        .optional()
        .nullable(),
      updatedAt: z
        .union([
          z.coerce.date(),
          z.lazy(() => DateTimeFieldUpdateOperationsInputSchema),
        ])
        .optional(),
      deletedAt: z
        .union([
          z.coerce.date(),
          z.lazy(() => NullableDateTimeFieldUpdateOperationsInputSchema),
        ])
        .optional()
        .nullable(),
      products: z
        .lazy(() => ProductUpdateManyWithoutVendorNestedInputSchema)
        .optional(),
      userVendorRoles: z
        .lazy(() => UserVendorRoleUpdateManyWithoutVendorNestedInputSchema)
        .optional(),
    })
    .strict() as z.ZodType<Prisma.VendorUpdateWithoutUserInput>;

export const VendorUncheckedUpdateWithoutUserInputSchema: z.ZodType<Prisma.VendorUncheckedUpdateWithoutUserInput> =
  z
    .object({
      id: z
        .union([
          z.string().uuid(),
          z.lazy(() => StringFieldUpdateOperationsInputSchema),
        ])
        .optional(),
      name: z
        .union([
          z.string(),
          z.lazy(() => StringFieldUpdateOperationsInputSchema),
        ])
        .optional(),
      slug: z
        .union([
          z.string(),
          z.lazy(() => StringFieldUpdateOperationsInputSchema),
        ])
        .optional(),
      description: z
        .union([
          z.string(),
          z.lazy(() => NullableStringFieldUpdateOperationsInputSchema),
        ])
        .optional()
        .nullable(),
      logoUrl: z
        .union([
          z.string(),
          z.lazy(() => NullableStringFieldUpdateOperationsInputSchema),
        ])
        .optional()
        .nullable(),
      taxCode: z
        .union([
          z.string(),
          z.lazy(() => NullableStringFieldUpdateOperationsInputSchema),
        ])
        .optional()
        .nullable(),
      totalProducts: z
        .union([
          z.number().int(),
          z.lazy(() => IntFieldUpdateOperationsInputSchema),
        ])
        .optional(),
      totalOrders: z
        .union([
          z.number().int(),
          z.lazy(() => IntFieldUpdateOperationsInputSchema),
        ])
        .optional(),
      status: z
        .union([
          z.lazy(() => VendorStatusSchema),
          z.lazy(() => EnumVendorStatusFieldUpdateOperationsInputSchema),
        ])
        .optional(),
      createdAt: z
        .union([
          z.coerce.date(),
          z.lazy(() => DateTimeFieldUpdateOperationsInputSchema),
        ])
        .optional(),
      createdBy: z
        .union([
          z.string(),
          z.lazy(() => NullableStringFieldUpdateOperationsInputSchema),
        ])
        .optional()
        .nullable(),
      updatedAt: z
        .union([
          z.coerce.date(),
          z.lazy(() => DateTimeFieldUpdateOperationsInputSchema),
        ])
        .optional(),
      deletedAt: z
        .union([
          z.coerce.date(),
          z.lazy(() => NullableDateTimeFieldUpdateOperationsInputSchema),
        ])
        .optional()
        .nullable(),
      products: z
        .lazy(() => ProductUncheckedUpdateManyWithoutVendorNestedInputSchema)
        .optional(),
      userVendorRoles: z
        .lazy(
          () => UserVendorRoleUncheckedUpdateManyWithoutVendorNestedInputSchema,
        )
        .optional(),
    })
    .strict() as z.ZodType<Prisma.VendorUncheckedUpdateWithoutUserInput>;

export const VendorUncheckedUpdateManyWithoutUserInputSchema: z.ZodType<Prisma.VendorUncheckedUpdateManyWithoutUserInput> =
  z
    .object({
      id: z
        .union([
          z.string().uuid(),
          z.lazy(() => StringFieldUpdateOperationsInputSchema),
        ])
        .optional(),
      name: z
        .union([
          z.string(),
          z.lazy(() => StringFieldUpdateOperationsInputSchema),
        ])
        .optional(),
      slug: z
        .union([
          z.string(),
          z.lazy(() => StringFieldUpdateOperationsInputSchema),
        ])
        .optional(),
      description: z
        .union([
          z.string(),
          z.lazy(() => NullableStringFieldUpdateOperationsInputSchema),
        ])
        .optional()
        .nullable(),
      logoUrl: z
        .union([
          z.string(),
          z.lazy(() => NullableStringFieldUpdateOperationsInputSchema),
        ])
        .optional()
        .nullable(),
      taxCode: z
        .union([
          z.string(),
          z.lazy(() => NullableStringFieldUpdateOperationsInputSchema),
        ])
        .optional()
        .nullable(),
      totalProducts: z
        .union([
          z.number().int(),
          z.lazy(() => IntFieldUpdateOperationsInputSchema),
        ])
        .optional(),
      totalOrders: z
        .union([
          z.number().int(),
          z.lazy(() => IntFieldUpdateOperationsInputSchema),
        ])
        .optional(),
      status: z
        .union([
          z.lazy(() => VendorStatusSchema),
          z.lazy(() => EnumVendorStatusFieldUpdateOperationsInputSchema),
        ])
        .optional(),
      createdAt: z
        .union([
          z.coerce.date(),
          z.lazy(() => DateTimeFieldUpdateOperationsInputSchema),
        ])
        .optional(),
      createdBy: z
        .union([
          z.string(),
          z.lazy(() => NullableStringFieldUpdateOperationsInputSchema),
        ])
        .optional()
        .nullable(),
      updatedAt: z
        .union([
          z.coerce.date(),
          z.lazy(() => DateTimeFieldUpdateOperationsInputSchema),
        ])
        .optional(),
      deletedAt: z
        .union([
          z.coerce.date(),
          z.lazy(() => NullableDateTimeFieldUpdateOperationsInputSchema),
        ])
        .optional()
        .nullable(),
    })
    .strict() as z.ZodType<Prisma.VendorUncheckedUpdateManyWithoutUserInput>;

export const UserVendorRoleUpdateWithoutUserInputSchema: z.ZodType<Prisma.UserVendorRoleUpdateWithoutUserInput> =
  z
    .object({
      id: z
        .union([
          z.string().uuid(),
          z.lazy(() => StringFieldUpdateOperationsInputSchema),
        ])
        .optional(),
      status: z
        .union([
          z.lazy(() => UserVendorRoleStatusSchema),
          z.lazy(
            () => EnumUserVendorRoleStatusFieldUpdateOperationsInputSchema,
          ),
        ])
        .optional(),
      createdAt: z
        .union([
          z.coerce.date(),
          z.lazy(() => DateTimeFieldUpdateOperationsInputSchema),
        ])
        .optional(),
      createdBy: z
        .union([
          z.string(),
          z.lazy(() => NullableStringFieldUpdateOperationsInputSchema),
        ])
        .optional()
        .nullable(),
      vendor: z
        .lazy(
          () => VendorUpdateOneRequiredWithoutUserVendorRolesNestedInputSchema,
        )
        .optional(),
      role: z
        .lazy(
          () => RoleUpdateOneRequiredWithoutUserVendorRolesNestedInputSchema,
        )
        .optional(),
    })
    .strict() as z.ZodType<Prisma.UserVendorRoleUpdateWithoutUserInput>;

export const UserVendorRoleUncheckedUpdateWithoutUserInputSchema: z.ZodType<Prisma.UserVendorRoleUncheckedUpdateWithoutUserInput> =
  z
    .object({
      id: z
        .union([
          z.string().uuid(),
          z.lazy(() => StringFieldUpdateOperationsInputSchema),
        ])
        .optional(),
      vendorID: z
        .union([
          z.string(),
          z.lazy(() => StringFieldUpdateOperationsInputSchema),
        ])
        .optional(),
      roleID: z
        .union([
          z.string(),
          z.lazy(() => StringFieldUpdateOperationsInputSchema),
        ])
        .optional(),
      status: z
        .union([
          z.lazy(() => UserVendorRoleStatusSchema),
          z.lazy(
            () => EnumUserVendorRoleStatusFieldUpdateOperationsInputSchema,
          ),
        ])
        .optional(),
      createdAt: z
        .union([
          z.coerce.date(),
          z.lazy(() => DateTimeFieldUpdateOperationsInputSchema),
        ])
        .optional(),
      createdBy: z
        .union([
          z.string(),
          z.lazy(() => NullableStringFieldUpdateOperationsInputSchema),
        ])
        .optional()
        .nullable(),
    })
    .strict() as z.ZodType<Prisma.UserVendorRoleUncheckedUpdateWithoutUserInput>;

export const UserVendorRoleUncheckedUpdateManyWithoutUserInputSchema: z.ZodType<Prisma.UserVendorRoleUncheckedUpdateManyWithoutUserInput> =
  z
    .object({
      id: z
        .union([
          z.string().uuid(),
          z.lazy(() => StringFieldUpdateOperationsInputSchema),
        ])
        .optional(),
      vendorID: z
        .union([
          z.string(),
          z.lazy(() => StringFieldUpdateOperationsInputSchema),
        ])
        .optional(),
      roleID: z
        .union([
          z.string(),
          z.lazy(() => StringFieldUpdateOperationsInputSchema),
        ])
        .optional(),
      status: z
        .union([
          z.lazy(() => UserVendorRoleStatusSchema),
          z.lazy(
            () => EnumUserVendorRoleStatusFieldUpdateOperationsInputSchema,
          ),
        ])
        .optional(),
      createdAt: z
        .union([
          z.coerce.date(),
          z.lazy(() => DateTimeFieldUpdateOperationsInputSchema),
        ])
        .optional(),
      createdBy: z
        .union([
          z.string(),
          z.lazy(() => NullableStringFieldUpdateOperationsInputSchema),
        ])
        .optional()
        .nullable(),
    })
    .strict() as z.ZodType<Prisma.UserVendorRoleUncheckedUpdateManyWithoutUserInput>;

export const OrderUpdateWithoutUserInputSchema: z.ZodType<Prisma.OrderUpdateWithoutUserInput> =
  z
    .object({
      id: z
        .union([
          z.string().uuid(),
          z.lazy(() => StringFieldUpdateOperationsInputSchema),
        ])
        .optional(),
      orderNumber: z
        .union([
          z.string(),
          z.lazy(() => StringFieldUpdateOperationsInputSchema),
        ])
        .optional(),
      status: z
        .union([
          z.lazy(() => OrderStatusSchema),
          z.lazy(() => EnumOrderStatusFieldUpdateOperationsInputSchema),
        ])
        .optional(),
      subtotal: z
        .union([
          z
            .union([
              z.number(),
              z.string(),
              z.instanceof(Decimal),
              z.instanceof(Prisma.Decimal),
              DecimalJsLikeSchema,
            ])
            .refine((v) => isValidDecimalInput(v), {
              message: 'Must be a Decimal',
            }),
          z.lazy(() => DecimalFieldUpdateOperationsInputSchema),
        ])
        .optional(),
      taxAmount: z
        .union([
          z
            .union([
              z.number(),
              z.string(),
              z.instanceof(Decimal),
              z.instanceof(Prisma.Decimal),
              DecimalJsLikeSchema,
            ])
            .refine((v) => isValidDecimalInput(v), {
              message: 'Must be a Decimal',
            }),
          z.lazy(() => DecimalFieldUpdateOperationsInputSchema),
        ])
        .optional(),
      shippingAmount: z
        .union([
          z
            .union([
              z.number(),
              z.string(),
              z.instanceof(Decimal),
              z.instanceof(Prisma.Decimal),
              DecimalJsLikeSchema,
            ])
            .refine((v) => isValidDecimalInput(v), {
              message: 'Must be a Decimal',
            }),
          z.lazy(() => DecimalFieldUpdateOperationsInputSchema),
        ])
        .optional(),
      discountAmount: z
        .union([
          z
            .union([
              z.number(),
              z.string(),
              z.instanceof(Decimal),
              z.instanceof(Prisma.Decimal),
              DecimalJsLikeSchema,
            ])
            .refine((v) => isValidDecimalInput(v), {
              message: 'Must be a Decimal',
            }),
          z.lazy(() => DecimalFieldUpdateOperationsInputSchema),
        ])
        .optional(),
      totalAmount: z
        .union([
          z
            .union([
              z.number(),
              z.string(),
              z.instanceof(Decimal),
              z.instanceof(Prisma.Decimal),
              DecimalJsLikeSchema,
            ])
            .refine((v) => isValidDecimalInput(v), {
              message: 'Must be a Decimal',
            }),
          z.lazy(() => DecimalFieldUpdateOperationsInputSchema),
        ])
        .optional(),
      currency: z
        .union([
          z.string(),
          z.lazy(() => StringFieldUpdateOperationsInputSchema),
        ])
        .optional(),
      notes: z
        .union([
          z.string(),
          z.lazy(() => NullableStringFieldUpdateOperationsInputSchema),
        ])
        .optional()
        .nullable(),
      shippedAt: z
        .union([
          z.coerce.date(),
          z.lazy(() => NullableDateTimeFieldUpdateOperationsInputSchema),
        ])
        .optional()
        .nullable(),
      deliveredAt: z
        .union([
          z.coerce.date(),
          z.lazy(() => NullableDateTimeFieldUpdateOperationsInputSchema),
        ])
        .optional()
        .nullable(),
      createdAt: z
        .union([
          z.coerce.date(),
          z.lazy(() => DateTimeFieldUpdateOperationsInputSchema),
        ])
        .optional(),
      createdBy: z
        .union([
          z.string(),
          z.lazy(() => NullableStringFieldUpdateOperationsInputSchema),
        ])
        .optional()
        .nullable(),
      updatedAt: z
        .union([
          z.coerce.date(),
          z.lazy(() => DateTimeFieldUpdateOperationsInputSchema),
        ])
        .optional(),
      deletedAt: z
        .union([
          z.coerce.date(),
          z.lazy(() => NullableDateTimeFieldUpdateOperationsInputSchema),
        ])
        .optional()
        .nullable(),
      orderItems: z
        .lazy(() => OrderItemUpdateManyWithoutOrderNestedInputSchema)
        .optional(),
      orderAddresses: z
        .lazy(() => OrderAddressUpdateManyWithoutOrderNestedInputSchema)
        .optional(),
      orderPromotions: z
        .lazy(() => OrderPromotionUpdateManyWithoutOrderNestedInputSchema)
        .optional(),
      payments: z
        .lazy(() => PaymentUpdateManyWithoutOrderNestedInputSchema)
        .optional(),
    })
    .strict() as z.ZodType<Prisma.OrderUpdateWithoutUserInput>;

export const OrderUncheckedUpdateWithoutUserInputSchema: z.ZodType<Prisma.OrderUncheckedUpdateWithoutUserInput> =
  z
    .object({
      id: z
        .union([
          z.string().uuid(),
          z.lazy(() => StringFieldUpdateOperationsInputSchema),
        ])
        .optional(),
      orderNumber: z
        .union([
          z.string(),
          z.lazy(() => StringFieldUpdateOperationsInputSchema),
        ])
        .optional(),
      status: z
        .union([
          z.lazy(() => OrderStatusSchema),
          z.lazy(() => EnumOrderStatusFieldUpdateOperationsInputSchema),
        ])
        .optional(),
      subtotal: z
        .union([
          z
            .union([
              z.number(),
              z.string(),
              z.instanceof(Decimal),
              z.instanceof(Prisma.Decimal),
              DecimalJsLikeSchema,
            ])
            .refine((v) => isValidDecimalInput(v), {
              message: 'Must be a Decimal',
            }),
          z.lazy(() => DecimalFieldUpdateOperationsInputSchema),
        ])
        .optional(),
      taxAmount: z
        .union([
          z
            .union([
              z.number(),
              z.string(),
              z.instanceof(Decimal),
              z.instanceof(Prisma.Decimal),
              DecimalJsLikeSchema,
            ])
            .refine((v) => isValidDecimalInput(v), {
              message: 'Must be a Decimal',
            }),
          z.lazy(() => DecimalFieldUpdateOperationsInputSchema),
        ])
        .optional(),
      shippingAmount: z
        .union([
          z
            .union([
              z.number(),
              z.string(),
              z.instanceof(Decimal),
              z.instanceof(Prisma.Decimal),
              DecimalJsLikeSchema,
            ])
            .refine((v) => isValidDecimalInput(v), {
              message: 'Must be a Decimal',
            }),
          z.lazy(() => DecimalFieldUpdateOperationsInputSchema),
        ])
        .optional(),
      discountAmount: z
        .union([
          z
            .union([
              z.number(),
              z.string(),
              z.instanceof(Decimal),
              z.instanceof(Prisma.Decimal),
              DecimalJsLikeSchema,
            ])
            .refine((v) => isValidDecimalInput(v), {
              message: 'Must be a Decimal',
            }),
          z.lazy(() => DecimalFieldUpdateOperationsInputSchema),
        ])
        .optional(),
      totalAmount: z
        .union([
          z
            .union([
              z.number(),
              z.string(),
              z.instanceof(Decimal),
              z.instanceof(Prisma.Decimal),
              DecimalJsLikeSchema,
            ])
            .refine((v) => isValidDecimalInput(v), {
              message: 'Must be a Decimal',
            }),
          z.lazy(() => DecimalFieldUpdateOperationsInputSchema),
        ])
        .optional(),
      currency: z
        .union([
          z.string(),
          z.lazy(() => StringFieldUpdateOperationsInputSchema),
        ])
        .optional(),
      notes: z
        .union([
          z.string(),
          z.lazy(() => NullableStringFieldUpdateOperationsInputSchema),
        ])
        .optional()
        .nullable(),
      shippedAt: z
        .union([
          z.coerce.date(),
          z.lazy(() => NullableDateTimeFieldUpdateOperationsInputSchema),
        ])
        .optional()
        .nullable(),
      deliveredAt: z
        .union([
          z.coerce.date(),
          z.lazy(() => NullableDateTimeFieldUpdateOperationsInputSchema),
        ])
        .optional()
        .nullable(),
      createdAt: z
        .union([
          z.coerce.date(),
          z.lazy(() => DateTimeFieldUpdateOperationsInputSchema),
        ])
        .optional(),
      createdBy: z
        .union([
          z.string(),
          z.lazy(() => NullableStringFieldUpdateOperationsInputSchema),
        ])
        .optional()
        .nullable(),
      updatedAt: z
        .union([
          z.coerce.date(),
          z.lazy(() => DateTimeFieldUpdateOperationsInputSchema),
        ])
        .optional(),
      deletedAt: z
        .union([
          z.coerce.date(),
          z.lazy(() => NullableDateTimeFieldUpdateOperationsInputSchema),
        ])
        .optional()
        .nullable(),
      orderItems: z
        .lazy(() => OrderItemUncheckedUpdateManyWithoutOrderNestedInputSchema)
        .optional(),
      orderAddresses: z
        .lazy(
          () => OrderAddressUncheckedUpdateManyWithoutOrderNestedInputSchema,
        )
        .optional(),
      orderPromotions: z
        .lazy(
          () => OrderPromotionUncheckedUpdateManyWithoutOrderNestedInputSchema,
        )
        .optional(),
      payments: z
        .lazy(() => PaymentUncheckedUpdateManyWithoutOrderNestedInputSchema)
        .optional(),
    })
    .strict() as z.ZodType<Prisma.OrderUncheckedUpdateWithoutUserInput>;

export const OrderUncheckedUpdateManyWithoutUserInputSchema: z.ZodType<Prisma.OrderUncheckedUpdateManyWithoutUserInput> =
  z
    .object({
      id: z
        .union([
          z.string().uuid(),
          z.lazy(() => StringFieldUpdateOperationsInputSchema),
        ])
        .optional(),
      orderNumber: z
        .union([
          z.string(),
          z.lazy(() => StringFieldUpdateOperationsInputSchema),
        ])
        .optional(),
      status: z
        .union([
          z.lazy(() => OrderStatusSchema),
          z.lazy(() => EnumOrderStatusFieldUpdateOperationsInputSchema),
        ])
        .optional(),
      subtotal: z
        .union([
          z
            .union([
              z.number(),
              z.string(),
              z.instanceof(Decimal),
              z.instanceof(Prisma.Decimal),
              DecimalJsLikeSchema,
            ])
            .refine((v) => isValidDecimalInput(v), {
              message: 'Must be a Decimal',
            }),
          z.lazy(() => DecimalFieldUpdateOperationsInputSchema),
        ])
        .optional(),
      taxAmount: z
        .union([
          z
            .union([
              z.number(),
              z.string(),
              z.instanceof(Decimal),
              z.instanceof(Prisma.Decimal),
              DecimalJsLikeSchema,
            ])
            .refine((v) => isValidDecimalInput(v), {
              message: 'Must be a Decimal',
            }),
          z.lazy(() => DecimalFieldUpdateOperationsInputSchema),
        ])
        .optional(),
      shippingAmount: z
        .union([
          z
            .union([
              z.number(),
              z.string(),
              z.instanceof(Decimal),
              z.instanceof(Prisma.Decimal),
              DecimalJsLikeSchema,
            ])
            .refine((v) => isValidDecimalInput(v), {
              message: 'Must be a Decimal',
            }),
          z.lazy(() => DecimalFieldUpdateOperationsInputSchema),
        ])
        .optional(),
      discountAmount: z
        .union([
          z
            .union([
              z.number(),
              z.string(),
              z.instanceof(Decimal),
              z.instanceof(Prisma.Decimal),
              DecimalJsLikeSchema,
            ])
            .refine((v) => isValidDecimalInput(v), {
              message: 'Must be a Decimal',
            }),
          z.lazy(() => DecimalFieldUpdateOperationsInputSchema),
        ])
        .optional(),
      totalAmount: z
        .union([
          z
            .union([
              z.number(),
              z.string(),
              z.instanceof(Decimal),
              z.instanceof(Prisma.Decimal),
              DecimalJsLikeSchema,
            ])
            .refine((v) => isValidDecimalInput(v), {
              message: 'Must be a Decimal',
            }),
          z.lazy(() => DecimalFieldUpdateOperationsInputSchema),
        ])
        .optional(),
      currency: z
        .union([
          z.string(),
          z.lazy(() => StringFieldUpdateOperationsInputSchema),
        ])
        .optional(),
      notes: z
        .union([
          z.string(),
          z.lazy(() => NullableStringFieldUpdateOperationsInputSchema),
        ])
        .optional()
        .nullable(),
      shippedAt: z
        .union([
          z.coerce.date(),
          z.lazy(() => NullableDateTimeFieldUpdateOperationsInputSchema),
        ])
        .optional()
        .nullable(),
      deliveredAt: z
        .union([
          z.coerce.date(),
          z.lazy(() => NullableDateTimeFieldUpdateOperationsInputSchema),
        ])
        .optional()
        .nullable(),
      createdAt: z
        .union([
          z.coerce.date(),
          z.lazy(() => DateTimeFieldUpdateOperationsInputSchema),
        ])
        .optional(),
      createdBy: z
        .union([
          z.string(),
          z.lazy(() => NullableStringFieldUpdateOperationsInputSchema),
        ])
        .optional()
        .nullable(),
      updatedAt: z
        .union([
          z.coerce.date(),
          z.lazy(() => DateTimeFieldUpdateOperationsInputSchema),
        ])
        .optional(),
      deletedAt: z
        .union([
          z.coerce.date(),
          z.lazy(() => NullableDateTimeFieldUpdateOperationsInputSchema),
        ])
        .optional()
        .nullable(),
    })
    .strict() as z.ZodType<Prisma.OrderUncheckedUpdateManyWithoutUserInput>;

export const NotificationUpdateWithoutUserInputSchema: z.ZodType<Prisma.NotificationUpdateWithoutUserInput> =
  z
    .object({
      id: z
        .union([
          z.string().uuid(),
          z.lazy(() => StringFieldUpdateOperationsInputSchema),
        ])
        .optional(),
      title: z
        .union([
          z.string(),
          z.lazy(() => StringFieldUpdateOperationsInputSchema),
        ])
        .optional(),
      message: z
        .union([
          z.string(),
          z.lazy(() => StringFieldUpdateOperationsInputSchema),
        ])
        .optional(),
      isRead: z
        .union([
          z.boolean(),
          z.lazy(() => BoolFieldUpdateOperationsInputSchema),
        ])
        .optional(),
    })
    .strict() as z.ZodType<Prisma.NotificationUpdateWithoutUserInput>;

export const NotificationUncheckedUpdateWithoutUserInputSchema: z.ZodType<Prisma.NotificationUncheckedUpdateWithoutUserInput> =
  z
    .object({
      id: z
        .union([
          z.string().uuid(),
          z.lazy(() => StringFieldUpdateOperationsInputSchema),
        ])
        .optional(),
      title: z
        .union([
          z.string(),
          z.lazy(() => StringFieldUpdateOperationsInputSchema),
        ])
        .optional(),
      message: z
        .union([
          z.string(),
          z.lazy(() => StringFieldUpdateOperationsInputSchema),
        ])
        .optional(),
      isRead: z
        .union([
          z.boolean(),
          z.lazy(() => BoolFieldUpdateOperationsInputSchema),
        ])
        .optional(),
    })
    .strict() as z.ZodType<Prisma.NotificationUncheckedUpdateWithoutUserInput>;

export const NotificationUncheckedUpdateManyWithoutUserInputSchema: z.ZodType<Prisma.NotificationUncheckedUpdateManyWithoutUserInput> =
  z
    .object({
      id: z
        .union([
          z.string().uuid(),
          z.lazy(() => StringFieldUpdateOperationsInputSchema),
        ])
        .optional(),
      title: z
        .union([
          z.string(),
          z.lazy(() => StringFieldUpdateOperationsInputSchema),
        ])
        .optional(),
      message: z
        .union([
          z.string(),
          z.lazy(() => StringFieldUpdateOperationsInputSchema),
        ])
        .optional(),
      isRead: z
        .union([
          z.boolean(),
          z.lazy(() => BoolFieldUpdateOperationsInputSchema),
        ])
        .optional(),
    })
    .strict() as z.ZodType<Prisma.NotificationUncheckedUpdateManyWithoutUserInput>;

export const ProductCreateManyVendorInputSchema: z.ZodType<Prisma.ProductCreateManyVendorInput> =
  z
    .object({
      id: z.string().uuid().optional(),
      name: z.string(),
      slug: z.string(),
      description: z.string().optional().nullable(),
      sku: z.string().optional().nullable(),
      price: z
        .union([
          z.number(),
          z.string(),
          z.instanceof(Decimal),
          z.instanceof(Prisma.Decimal),
          DecimalJsLikeSchema,
        ])
        .refine((v) => isValidDecimalInput(v), {
          message: 'Must be a Decimal',
        }),
      stockQuantity: z.number().int().optional(),
      status: z.lazy(() => ProductStatusSchema).optional(),
      createdAt: z.coerce.date().optional(),
      createdBy: z.string().optional().nullable(),
      updatedAt: z.coerce.date().optional(),
      deletedAt: z.coerce.date().optional().nullable(),
    })
    .strict() as z.ZodType<Prisma.ProductCreateManyVendorInput>;

export const UserVendorRoleCreateManyVendorInputSchema: z.ZodType<Prisma.UserVendorRoleCreateManyVendorInput> =
  z
    .object({
      id: z.string().uuid().optional(),
      userID: z.string(),
      roleID: z.string(),
      status: z.lazy(() => UserVendorRoleStatusSchema).optional(),
      createdAt: z.coerce.date().optional(),
      createdBy: z.string().optional().nullable(),
    })
    .strict() as z.ZodType<Prisma.UserVendorRoleCreateManyVendorInput>;

export const ProductUpdateWithoutVendorInputSchema: z.ZodType<Prisma.ProductUpdateWithoutVendorInput> =
  z
    .object({
      id: z
        .union([
          z.string().uuid(),
          z.lazy(() => StringFieldUpdateOperationsInputSchema),
        ])
        .optional(),
      name: z
        .union([
          z.string(),
          z.lazy(() => StringFieldUpdateOperationsInputSchema),
        ])
        .optional(),
      slug: z
        .union([
          z.string(),
          z.lazy(() => StringFieldUpdateOperationsInputSchema),
        ])
        .optional(),
      description: z
        .union([
          z.string(),
          z.lazy(() => NullableStringFieldUpdateOperationsInputSchema),
        ])
        .optional()
        .nullable(),
      sku: z
        .union([
          z.string(),
          z.lazy(() => NullableStringFieldUpdateOperationsInputSchema),
        ])
        .optional()
        .nullable(),
      price: z
        .union([
          z
            .union([
              z.number(),
              z.string(),
              z.instanceof(Decimal),
              z.instanceof(Prisma.Decimal),
              DecimalJsLikeSchema,
            ])
            .refine((v) => isValidDecimalInput(v), {
              message: 'Must be a Decimal',
            }),
          z.lazy(() => DecimalFieldUpdateOperationsInputSchema),
        ])
        .optional(),
      stockQuantity: z
        .union([
          z.number().int(),
          z.lazy(() => IntFieldUpdateOperationsInputSchema),
        ])
        .optional(),
      status: z
        .union([
          z.lazy(() => ProductStatusSchema),
          z.lazy(() => EnumProductStatusFieldUpdateOperationsInputSchema),
        ])
        .optional(),
      createdAt: z
        .union([
          z.coerce.date(),
          z.lazy(() => DateTimeFieldUpdateOperationsInputSchema),
        ])
        .optional(),
      createdBy: z
        .union([
          z.string(),
          z.lazy(() => NullableStringFieldUpdateOperationsInputSchema),
        ])
        .optional()
        .nullable(),
      updatedAt: z
        .union([
          z.coerce.date(),
          z.lazy(() => DateTimeFieldUpdateOperationsInputSchema),
        ])
        .optional(),
      deletedAt: z
        .union([
          z.coerce.date(),
          z.lazy(() => NullableDateTimeFieldUpdateOperationsInputSchema),
        ])
        .optional()
        .nullable(),
      productCategories: z
        .lazy(() => ProductCategoryUpdateManyWithoutProductNestedInputSchema)
        .optional(),
      productImages: z
        .lazy(() => ProductImageUpdateManyWithoutProductNestedInputSchema)
        .optional(),
      productVariants: z
        .lazy(() => ProductVariantUpdateManyWithoutProductNestedInputSchema)
        .optional(),
    })
    .strict() as z.ZodType<Prisma.ProductUpdateWithoutVendorInput>;

export const ProductUncheckedUpdateWithoutVendorInputSchema: z.ZodType<Prisma.ProductUncheckedUpdateWithoutVendorInput> =
  z
    .object({
      id: z
        .union([
          z.string().uuid(),
          z.lazy(() => StringFieldUpdateOperationsInputSchema),
        ])
        .optional(),
      name: z
        .union([
          z.string(),
          z.lazy(() => StringFieldUpdateOperationsInputSchema),
        ])
        .optional(),
      slug: z
        .union([
          z.string(),
          z.lazy(() => StringFieldUpdateOperationsInputSchema),
        ])
        .optional(),
      description: z
        .union([
          z.string(),
          z.lazy(() => NullableStringFieldUpdateOperationsInputSchema),
        ])
        .optional()
        .nullable(),
      sku: z
        .union([
          z.string(),
          z.lazy(() => NullableStringFieldUpdateOperationsInputSchema),
        ])
        .optional()
        .nullable(),
      price: z
        .union([
          z
            .union([
              z.number(),
              z.string(),
              z.instanceof(Decimal),
              z.instanceof(Prisma.Decimal),
              DecimalJsLikeSchema,
            ])
            .refine((v) => isValidDecimalInput(v), {
              message: 'Must be a Decimal',
            }),
          z.lazy(() => DecimalFieldUpdateOperationsInputSchema),
        ])
        .optional(),
      stockQuantity: z
        .union([
          z.number().int(),
          z.lazy(() => IntFieldUpdateOperationsInputSchema),
        ])
        .optional(),
      status: z
        .union([
          z.lazy(() => ProductStatusSchema),
          z.lazy(() => EnumProductStatusFieldUpdateOperationsInputSchema),
        ])
        .optional(),
      createdAt: z
        .union([
          z.coerce.date(),
          z.lazy(() => DateTimeFieldUpdateOperationsInputSchema),
        ])
        .optional(),
      createdBy: z
        .union([
          z.string(),
          z.lazy(() => NullableStringFieldUpdateOperationsInputSchema),
        ])
        .optional()
        .nullable(),
      updatedAt: z
        .union([
          z.coerce.date(),
          z.lazy(() => DateTimeFieldUpdateOperationsInputSchema),
        ])
        .optional(),
      deletedAt: z
        .union([
          z.coerce.date(),
          z.lazy(() => NullableDateTimeFieldUpdateOperationsInputSchema),
        ])
        .optional()
        .nullable(),
      productCategories: z
        .lazy(
          () =>
            ProductCategoryUncheckedUpdateManyWithoutProductNestedInputSchema,
        )
        .optional(),
      productImages: z
        .lazy(
          () => ProductImageUncheckedUpdateManyWithoutProductNestedInputSchema,
        )
        .optional(),
      productVariants: z
        .lazy(
          () =>
            ProductVariantUncheckedUpdateManyWithoutProductNestedInputSchema,
        )
        .optional(),
    })
    .strict() as z.ZodType<Prisma.ProductUncheckedUpdateWithoutVendorInput>;

export const ProductUncheckedUpdateManyWithoutVendorInputSchema: z.ZodType<Prisma.ProductUncheckedUpdateManyWithoutVendorInput> =
  z
    .object({
      id: z
        .union([
          z.string().uuid(),
          z.lazy(() => StringFieldUpdateOperationsInputSchema),
        ])
        .optional(),
      name: z
        .union([
          z.string(),
          z.lazy(() => StringFieldUpdateOperationsInputSchema),
        ])
        .optional(),
      slug: z
        .union([
          z.string(),
          z.lazy(() => StringFieldUpdateOperationsInputSchema),
        ])
        .optional(),
      description: z
        .union([
          z.string(),
          z.lazy(() => NullableStringFieldUpdateOperationsInputSchema),
        ])
        .optional()
        .nullable(),
      sku: z
        .union([
          z.string(),
          z.lazy(() => NullableStringFieldUpdateOperationsInputSchema),
        ])
        .optional()
        .nullable(),
      price: z
        .union([
          z
            .union([
              z.number(),
              z.string(),
              z.instanceof(Decimal),
              z.instanceof(Prisma.Decimal),
              DecimalJsLikeSchema,
            ])
            .refine((v) => isValidDecimalInput(v), {
              message: 'Must be a Decimal',
            }),
          z.lazy(() => DecimalFieldUpdateOperationsInputSchema),
        ])
        .optional(),
      stockQuantity: z
        .union([
          z.number().int(),
          z.lazy(() => IntFieldUpdateOperationsInputSchema),
        ])
        .optional(),
      status: z
        .union([
          z.lazy(() => ProductStatusSchema),
          z.lazy(() => EnumProductStatusFieldUpdateOperationsInputSchema),
        ])
        .optional(),
      createdAt: z
        .union([
          z.coerce.date(),
          z.lazy(() => DateTimeFieldUpdateOperationsInputSchema),
        ])
        .optional(),
      createdBy: z
        .union([
          z.string(),
          z.lazy(() => NullableStringFieldUpdateOperationsInputSchema),
        ])
        .optional()
        .nullable(),
      updatedAt: z
        .union([
          z.coerce.date(),
          z.lazy(() => DateTimeFieldUpdateOperationsInputSchema),
        ])
        .optional(),
      deletedAt: z
        .union([
          z.coerce.date(),
          z.lazy(() => NullableDateTimeFieldUpdateOperationsInputSchema),
        ])
        .optional()
        .nullable(),
    })
    .strict() as z.ZodType<Prisma.ProductUncheckedUpdateManyWithoutVendorInput>;

export const UserVendorRoleUpdateWithoutVendorInputSchema: z.ZodType<Prisma.UserVendorRoleUpdateWithoutVendorInput> =
  z
    .object({
      id: z
        .union([
          z.string().uuid(),
          z.lazy(() => StringFieldUpdateOperationsInputSchema),
        ])
        .optional(),
      status: z
        .union([
          z.lazy(() => UserVendorRoleStatusSchema),
          z.lazy(
            () => EnumUserVendorRoleStatusFieldUpdateOperationsInputSchema,
          ),
        ])
        .optional(),
      createdAt: z
        .union([
          z.coerce.date(),
          z.lazy(() => DateTimeFieldUpdateOperationsInputSchema),
        ])
        .optional(),
      createdBy: z
        .union([
          z.string(),
          z.lazy(() => NullableStringFieldUpdateOperationsInputSchema),
        ])
        .optional()
        .nullable(),
      user: z
        .lazy(
          () => UserUpdateOneRequiredWithoutUserVendorRolesNestedInputSchema,
        )
        .optional(),
      role: z
        .lazy(
          () => RoleUpdateOneRequiredWithoutUserVendorRolesNestedInputSchema,
        )
        .optional(),
    })
    .strict() as z.ZodType<Prisma.UserVendorRoleUpdateWithoutVendorInput>;

export const UserVendorRoleUncheckedUpdateWithoutVendorInputSchema: z.ZodType<Prisma.UserVendorRoleUncheckedUpdateWithoutVendorInput> =
  z
    .object({
      id: z
        .union([
          z.string().uuid(),
          z.lazy(() => StringFieldUpdateOperationsInputSchema),
        ])
        .optional(),
      userID: z
        .union([
          z.string(),
          z.lazy(() => StringFieldUpdateOperationsInputSchema),
        ])
        .optional(),
      roleID: z
        .union([
          z.string(),
          z.lazy(() => StringFieldUpdateOperationsInputSchema),
        ])
        .optional(),
      status: z
        .union([
          z.lazy(() => UserVendorRoleStatusSchema),
          z.lazy(
            () => EnumUserVendorRoleStatusFieldUpdateOperationsInputSchema,
          ),
        ])
        .optional(),
      createdAt: z
        .union([
          z.coerce.date(),
          z.lazy(() => DateTimeFieldUpdateOperationsInputSchema),
        ])
        .optional(),
      createdBy: z
        .union([
          z.string(),
          z.lazy(() => NullableStringFieldUpdateOperationsInputSchema),
        ])
        .optional()
        .nullable(),
    })
    .strict() as z.ZodType<Prisma.UserVendorRoleUncheckedUpdateWithoutVendorInput>;

export const UserVendorRoleUncheckedUpdateManyWithoutVendorInputSchema: z.ZodType<Prisma.UserVendorRoleUncheckedUpdateManyWithoutVendorInput> =
  z
    .object({
      id: z
        .union([
          z.string().uuid(),
          z.lazy(() => StringFieldUpdateOperationsInputSchema),
        ])
        .optional(),
      userID: z
        .union([
          z.string(),
          z.lazy(() => StringFieldUpdateOperationsInputSchema),
        ])
        .optional(),
      roleID: z
        .union([
          z.string(),
          z.lazy(() => StringFieldUpdateOperationsInputSchema),
        ])
        .optional(),
      status: z
        .union([
          z.lazy(() => UserVendorRoleStatusSchema),
          z.lazy(
            () => EnumUserVendorRoleStatusFieldUpdateOperationsInputSchema,
          ),
        ])
        .optional(),
      createdAt: z
        .union([
          z.coerce.date(),
          z.lazy(() => DateTimeFieldUpdateOperationsInputSchema),
        ])
        .optional(),
      createdBy: z
        .union([
          z.string(),
          z.lazy(() => NullableStringFieldUpdateOperationsInputSchema),
        ])
        .optional()
        .nullable(),
    })
    .strict() as z.ZodType<Prisma.UserVendorRoleUncheckedUpdateManyWithoutVendorInput>;

export const UserVendorRoleCreateManyRoleInputSchema: z.ZodType<Prisma.UserVendorRoleCreateManyRoleInput> =
  z
    .object({
      id: z.string().uuid().optional(),
      userID: z.string(),
      vendorID: z.string(),
      status: z.lazy(() => UserVendorRoleStatusSchema).optional(),
      createdAt: z.coerce.date().optional(),
      createdBy: z.string().optional().nullable(),
    })
    .strict() as z.ZodType<Prisma.UserVendorRoleCreateManyRoleInput>;

export const RolePermissionCreateManyRoleInputSchema: z.ZodType<Prisma.RolePermissionCreateManyRoleInput> =
  z
    .object({
      permissionID: z.string(),
      createdAt: z.coerce.date().optional(),
      createdBy: z.string().optional().nullable(),
    })
    .strict() as z.ZodType<Prisma.RolePermissionCreateManyRoleInput>;

export const UserVendorRoleUpdateWithoutRoleInputSchema: z.ZodType<Prisma.UserVendorRoleUpdateWithoutRoleInput> =
  z
    .object({
      id: z
        .union([
          z.string().uuid(),
          z.lazy(() => StringFieldUpdateOperationsInputSchema),
        ])
        .optional(),
      status: z
        .union([
          z.lazy(() => UserVendorRoleStatusSchema),
          z.lazy(
            () => EnumUserVendorRoleStatusFieldUpdateOperationsInputSchema,
          ),
        ])
        .optional(),
      createdAt: z
        .union([
          z.coerce.date(),
          z.lazy(() => DateTimeFieldUpdateOperationsInputSchema),
        ])
        .optional(),
      createdBy: z
        .union([
          z.string(),
          z.lazy(() => NullableStringFieldUpdateOperationsInputSchema),
        ])
        .optional()
        .nullable(),
      user: z
        .lazy(
          () => UserUpdateOneRequiredWithoutUserVendorRolesNestedInputSchema,
        )
        .optional(),
      vendor: z
        .lazy(
          () => VendorUpdateOneRequiredWithoutUserVendorRolesNestedInputSchema,
        )
        .optional(),
    })
    .strict() as z.ZodType<Prisma.UserVendorRoleUpdateWithoutRoleInput>;

export const UserVendorRoleUncheckedUpdateWithoutRoleInputSchema: z.ZodType<Prisma.UserVendorRoleUncheckedUpdateWithoutRoleInput> =
  z
    .object({
      id: z
        .union([
          z.string().uuid(),
          z.lazy(() => StringFieldUpdateOperationsInputSchema),
        ])
        .optional(),
      userID: z
        .union([
          z.string(),
          z.lazy(() => StringFieldUpdateOperationsInputSchema),
        ])
        .optional(),
      vendorID: z
        .union([
          z.string(),
          z.lazy(() => StringFieldUpdateOperationsInputSchema),
        ])
        .optional(),
      status: z
        .union([
          z.lazy(() => UserVendorRoleStatusSchema),
          z.lazy(
            () => EnumUserVendorRoleStatusFieldUpdateOperationsInputSchema,
          ),
        ])
        .optional(),
      createdAt: z
        .union([
          z.coerce.date(),
          z.lazy(() => DateTimeFieldUpdateOperationsInputSchema),
        ])
        .optional(),
      createdBy: z
        .union([
          z.string(),
          z.lazy(() => NullableStringFieldUpdateOperationsInputSchema),
        ])
        .optional()
        .nullable(),
    })
    .strict() as z.ZodType<Prisma.UserVendorRoleUncheckedUpdateWithoutRoleInput>;

export const UserVendorRoleUncheckedUpdateManyWithoutRoleInputSchema: z.ZodType<Prisma.UserVendorRoleUncheckedUpdateManyWithoutRoleInput> =
  z
    .object({
      id: z
        .union([
          z.string().uuid(),
          z.lazy(() => StringFieldUpdateOperationsInputSchema),
        ])
        .optional(),
      userID: z
        .union([
          z.string(),
          z.lazy(() => StringFieldUpdateOperationsInputSchema),
        ])
        .optional(),
      vendorID: z
        .union([
          z.string(),
          z.lazy(() => StringFieldUpdateOperationsInputSchema),
        ])
        .optional(),
      status: z
        .union([
          z.lazy(() => UserVendorRoleStatusSchema),
          z.lazy(
            () => EnumUserVendorRoleStatusFieldUpdateOperationsInputSchema,
          ),
        ])
        .optional(),
      createdAt: z
        .union([
          z.coerce.date(),
          z.lazy(() => DateTimeFieldUpdateOperationsInputSchema),
        ])
        .optional(),
      createdBy: z
        .union([
          z.string(),
          z.lazy(() => NullableStringFieldUpdateOperationsInputSchema),
        ])
        .optional()
        .nullable(),
    })
    .strict() as z.ZodType<Prisma.UserVendorRoleUncheckedUpdateManyWithoutRoleInput>;

export const RolePermissionUpdateWithoutRoleInputSchema: z.ZodType<Prisma.RolePermissionUpdateWithoutRoleInput> =
  z
    .object({
      createdAt: z
        .union([
          z.coerce.date(),
          z.lazy(() => DateTimeFieldUpdateOperationsInputSchema),
        ])
        .optional(),
      createdBy: z
        .union([
          z.string(),
          z.lazy(() => NullableStringFieldUpdateOperationsInputSchema),
        ])
        .optional()
        .nullable(),
      permission: z
        .lazy(
          () =>
            PermissionUpdateOneRequiredWithoutRolePermissionsNestedInputSchema,
        )
        .optional(),
    })
    .strict() as z.ZodType<Prisma.RolePermissionUpdateWithoutRoleInput>;

export const RolePermissionUncheckedUpdateWithoutRoleInputSchema: z.ZodType<Prisma.RolePermissionUncheckedUpdateWithoutRoleInput> =
  z
    .object({
      permissionID: z
        .union([
          z.string(),
          z.lazy(() => StringFieldUpdateOperationsInputSchema),
        ])
        .optional(),
      createdAt: z
        .union([
          z.coerce.date(),
          z.lazy(() => DateTimeFieldUpdateOperationsInputSchema),
        ])
        .optional(),
      createdBy: z
        .union([
          z.string(),
          z.lazy(() => NullableStringFieldUpdateOperationsInputSchema),
        ])
        .optional()
        .nullable(),
    })
    .strict() as z.ZodType<Prisma.RolePermissionUncheckedUpdateWithoutRoleInput>;

export const RolePermissionUncheckedUpdateManyWithoutRoleInputSchema: z.ZodType<Prisma.RolePermissionUncheckedUpdateManyWithoutRoleInput> =
  z
    .object({
      permissionID: z
        .union([
          z.string(),
          z.lazy(() => StringFieldUpdateOperationsInputSchema),
        ])
        .optional(),
      createdAt: z
        .union([
          z.coerce.date(),
          z.lazy(() => DateTimeFieldUpdateOperationsInputSchema),
        ])
        .optional(),
      createdBy: z
        .union([
          z.string(),
          z.lazy(() => NullableStringFieldUpdateOperationsInputSchema),
        ])
        .optional()
        .nullable(),
    })
    .strict() as z.ZodType<Prisma.RolePermissionUncheckedUpdateManyWithoutRoleInput>;

export const RolePermissionCreateManyPermissionInputSchema: z.ZodType<Prisma.RolePermissionCreateManyPermissionInput> =
  z
    .object({
      roleID: z.string(),
      createdAt: z.coerce.date().optional(),
      createdBy: z.string().optional().nullable(),
    })
    .strict() as z.ZodType<Prisma.RolePermissionCreateManyPermissionInput>;

export const RolePermissionUpdateWithoutPermissionInputSchema: z.ZodType<Prisma.RolePermissionUpdateWithoutPermissionInput> =
  z
    .object({
      createdAt: z
        .union([
          z.coerce.date(),
          z.lazy(() => DateTimeFieldUpdateOperationsInputSchema),
        ])
        .optional(),
      createdBy: z
        .union([
          z.string(),
          z.lazy(() => NullableStringFieldUpdateOperationsInputSchema),
        ])
        .optional()
        .nullable(),
      role: z
        .lazy(
          () => RoleUpdateOneRequiredWithoutRolePermissionsNestedInputSchema,
        )
        .optional(),
    })
    .strict() as z.ZodType<Prisma.RolePermissionUpdateWithoutPermissionInput>;

export const RolePermissionUncheckedUpdateWithoutPermissionInputSchema: z.ZodType<Prisma.RolePermissionUncheckedUpdateWithoutPermissionInput> =
  z
    .object({
      roleID: z
        .union([
          z.string(),
          z.lazy(() => StringFieldUpdateOperationsInputSchema),
        ])
        .optional(),
      createdAt: z
        .union([
          z.coerce.date(),
          z.lazy(() => DateTimeFieldUpdateOperationsInputSchema),
        ])
        .optional(),
      createdBy: z
        .union([
          z.string(),
          z.lazy(() => NullableStringFieldUpdateOperationsInputSchema),
        ])
        .optional()
        .nullable(),
    })
    .strict() as z.ZodType<Prisma.RolePermissionUncheckedUpdateWithoutPermissionInput>;

export const RolePermissionUncheckedUpdateManyWithoutPermissionInputSchema: z.ZodType<Prisma.RolePermissionUncheckedUpdateManyWithoutPermissionInput> =
  z
    .object({
      roleID: z
        .union([
          z.string(),
          z.lazy(() => StringFieldUpdateOperationsInputSchema),
        ])
        .optional(),
      createdAt: z
        .union([
          z.coerce.date(),
          z.lazy(() => DateTimeFieldUpdateOperationsInputSchema),
        ])
        .optional(),
      createdBy: z
        .union([
          z.string(),
          z.lazy(() => NullableStringFieldUpdateOperationsInputSchema),
        ])
        .optional()
        .nullable(),
    })
    .strict() as z.ZodType<Prisma.RolePermissionUncheckedUpdateManyWithoutPermissionInput>;

export const CategoryCreateManyParentInputSchema: z.ZodType<Prisma.CategoryCreateManyParentInput> =
  z
    .object({
      id: z.string().uuid().optional(),
      name: z.string(),
      slug: z.string(),
      description: z.string().optional().nullable(),
      imageUrl: z.string().optional().nullable(),
      createdAt: z.coerce.date().optional(),
      createdBy: z.string().optional().nullable(),
      updatedAt: z.coerce.date().optional(),
      deletedAt: z.coerce.date().optional().nullable(),
    })
    .strict() as z.ZodType<Prisma.CategoryCreateManyParentInput>;

export const ProductCategoryCreateManyCategoryInputSchema: z.ZodType<Prisma.ProductCategoryCreateManyCategoryInput> =
  z
    .object({
      productID: z.string(),
    })
    .strict() as z.ZodType<Prisma.ProductCategoryCreateManyCategoryInput>;

export const CategoryUpdateWithoutParentInputSchema: z.ZodType<Prisma.CategoryUpdateWithoutParentInput> =
  z
    .object({
      id: z
        .union([
          z.string().uuid(),
          z.lazy(() => StringFieldUpdateOperationsInputSchema),
        ])
        .optional(),
      name: z
        .union([
          z.string(),
          z.lazy(() => StringFieldUpdateOperationsInputSchema),
        ])
        .optional(),
      slug: z
        .union([
          z.string(),
          z.lazy(() => StringFieldUpdateOperationsInputSchema),
        ])
        .optional(),
      description: z
        .union([
          z.string(),
          z.lazy(() => NullableStringFieldUpdateOperationsInputSchema),
        ])
        .optional()
        .nullable(),
      imageUrl: z
        .union([
          z.string(),
          z.lazy(() => NullableStringFieldUpdateOperationsInputSchema),
        ])
        .optional()
        .nullable(),
      createdAt: z
        .union([
          z.coerce.date(),
          z.lazy(() => DateTimeFieldUpdateOperationsInputSchema),
        ])
        .optional(),
      createdBy: z
        .union([
          z.string(),
          z.lazy(() => NullableStringFieldUpdateOperationsInputSchema),
        ])
        .optional()
        .nullable(),
      updatedAt: z
        .union([
          z.coerce.date(),
          z.lazy(() => DateTimeFieldUpdateOperationsInputSchema),
        ])
        .optional(),
      deletedAt: z
        .union([
          z.coerce.date(),
          z.lazy(() => NullableDateTimeFieldUpdateOperationsInputSchema),
        ])
        .optional()
        .nullable(),
      children: z
        .lazy(() => CategoryUpdateManyWithoutParentNestedInputSchema)
        .optional(),
      productCategories: z
        .lazy(() => ProductCategoryUpdateManyWithoutCategoryNestedInputSchema)
        .optional(),
    })
    .strict() as z.ZodType<Prisma.CategoryUpdateWithoutParentInput>;

export const CategoryUncheckedUpdateWithoutParentInputSchema: z.ZodType<Prisma.CategoryUncheckedUpdateWithoutParentInput> =
  z
    .object({
      id: z
        .union([
          z.string().uuid(),
          z.lazy(() => StringFieldUpdateOperationsInputSchema),
        ])
        .optional(),
      name: z
        .union([
          z.string(),
          z.lazy(() => StringFieldUpdateOperationsInputSchema),
        ])
        .optional(),
      slug: z
        .union([
          z.string(),
          z.lazy(() => StringFieldUpdateOperationsInputSchema),
        ])
        .optional(),
      description: z
        .union([
          z.string(),
          z.lazy(() => NullableStringFieldUpdateOperationsInputSchema),
        ])
        .optional()
        .nullable(),
      imageUrl: z
        .union([
          z.string(),
          z.lazy(() => NullableStringFieldUpdateOperationsInputSchema),
        ])
        .optional()
        .nullable(),
      createdAt: z
        .union([
          z.coerce.date(),
          z.lazy(() => DateTimeFieldUpdateOperationsInputSchema),
        ])
        .optional(),
      createdBy: z
        .union([
          z.string(),
          z.lazy(() => NullableStringFieldUpdateOperationsInputSchema),
        ])
        .optional()
        .nullable(),
      updatedAt: z
        .union([
          z.coerce.date(),
          z.lazy(() => DateTimeFieldUpdateOperationsInputSchema),
        ])
        .optional(),
      deletedAt: z
        .union([
          z.coerce.date(),
          z.lazy(() => NullableDateTimeFieldUpdateOperationsInputSchema),
        ])
        .optional()
        .nullable(),
      children: z
        .lazy(() => CategoryUncheckedUpdateManyWithoutParentNestedInputSchema)
        .optional(),
      productCategories: z
        .lazy(
          () =>
            ProductCategoryUncheckedUpdateManyWithoutCategoryNestedInputSchema,
        )
        .optional(),
    })
    .strict() as z.ZodType<Prisma.CategoryUncheckedUpdateWithoutParentInput>;

export const CategoryUncheckedUpdateManyWithoutParentInputSchema: z.ZodType<Prisma.CategoryUncheckedUpdateManyWithoutParentInput> =
  z
    .object({
      id: z
        .union([
          z.string().uuid(),
          z.lazy(() => StringFieldUpdateOperationsInputSchema),
        ])
        .optional(),
      name: z
        .union([
          z.string(),
          z.lazy(() => StringFieldUpdateOperationsInputSchema),
        ])
        .optional(),
      slug: z
        .union([
          z.string(),
          z.lazy(() => StringFieldUpdateOperationsInputSchema),
        ])
        .optional(),
      description: z
        .union([
          z.string(),
          z.lazy(() => NullableStringFieldUpdateOperationsInputSchema),
        ])
        .optional()
        .nullable(),
      imageUrl: z
        .union([
          z.string(),
          z.lazy(() => NullableStringFieldUpdateOperationsInputSchema),
        ])
        .optional()
        .nullable(),
      createdAt: z
        .union([
          z.coerce.date(),
          z.lazy(() => DateTimeFieldUpdateOperationsInputSchema),
        ])
        .optional(),
      createdBy: z
        .union([
          z.string(),
          z.lazy(() => NullableStringFieldUpdateOperationsInputSchema),
        ])
        .optional()
        .nullable(),
      updatedAt: z
        .union([
          z.coerce.date(),
          z.lazy(() => DateTimeFieldUpdateOperationsInputSchema),
        ])
        .optional(),
      deletedAt: z
        .union([
          z.coerce.date(),
          z.lazy(() => NullableDateTimeFieldUpdateOperationsInputSchema),
        ])
        .optional()
        .nullable(),
    })
    .strict() as z.ZodType<Prisma.CategoryUncheckedUpdateManyWithoutParentInput>;

export const ProductCategoryUpdateWithoutCategoryInputSchema: z.ZodType<Prisma.ProductCategoryUpdateWithoutCategoryInput> =
  z
    .object({
      product: z
        .lazy(
          () =>
            ProductUpdateOneRequiredWithoutProductCategoriesNestedInputSchema,
        )
        .optional(),
    })
    .strict() as z.ZodType<Prisma.ProductCategoryUpdateWithoutCategoryInput>;

export const ProductCategoryUncheckedUpdateWithoutCategoryInputSchema: z.ZodType<Prisma.ProductCategoryUncheckedUpdateWithoutCategoryInput> =
  z
    .object({
      productID: z
        .union([
          z.string(),
          z.lazy(() => StringFieldUpdateOperationsInputSchema),
        ])
        .optional(),
    })
    .strict() as z.ZodType<Prisma.ProductCategoryUncheckedUpdateWithoutCategoryInput>;

export const ProductCategoryUncheckedUpdateManyWithoutCategoryInputSchema: z.ZodType<Prisma.ProductCategoryUncheckedUpdateManyWithoutCategoryInput> =
  z
    .object({
      productID: z
        .union([
          z.string(),
          z.lazy(() => StringFieldUpdateOperationsInputSchema),
        ])
        .optional(),
    })
    .strict() as z.ZodType<Prisma.ProductCategoryUncheckedUpdateManyWithoutCategoryInput>;

export const ProductCategoryCreateManyProductInputSchema: z.ZodType<Prisma.ProductCategoryCreateManyProductInput> =
  z
    .object({
      categoryID: z.string(),
    })
    .strict() as z.ZodType<Prisma.ProductCategoryCreateManyProductInput>;

export const ProductImageCreateManyProductInputSchema: z.ZodType<Prisma.ProductImageCreateManyProductInput> =
  z
    .object({
      id: z.string().uuid().optional(),
      name: z.string(),
      description: z.string().optional().nullable(),
      productVariantID: z.string().optional().nullable(),
      imageUrl: z.string(),
      sortOrder: z.number().int().optional(),
      createdAt: z.coerce.date().optional(),
      createdBy: z.string().optional().nullable(),
      updatedAt: z.coerce.date().optional(),
      deletedAt: z.coerce.date().optional().nullable(),
    })
    .strict() as z.ZodType<Prisma.ProductImageCreateManyProductInput>;

export const ProductVariantCreateManyProductInputSchema: z.ZodType<Prisma.ProductVariantCreateManyProductInput> =
  z
    .object({
      id: z.string().uuid().optional(),
      name: z.string().optional().nullable(),
      sku: z.string().optional().nullable(),
      price: z
        .union([
          z.number(),
          z.string(),
          z.instanceof(Decimal),
          z.instanceof(Prisma.Decimal),
          DecimalJsLikeSchema,
        ])
        .refine((v) => isValidDecimalInput(v), {
          message: 'Must be a Decimal',
        }),
      stockQuantity: z.number().int().optional(),
      attributes: z
        .union([
          z.lazy(() => NullableJsonNullValueInputSchema),
          InputJsonValueSchema,
        ])
        .optional(),
      createdAt: z.coerce.date().optional(),
      createdBy: z.string().optional().nullable(),
      updatedAt: z.coerce.date().optional(),
      deletedAt: z.coerce.date().optional().nullable(),
    })
    .strict() as z.ZodType<Prisma.ProductVariantCreateManyProductInput>;

export const ProductCategoryUpdateWithoutProductInputSchema: z.ZodType<Prisma.ProductCategoryUpdateWithoutProductInput> =
  z
    .object({
      category: z
        .lazy(
          () =>
            CategoryUpdateOneRequiredWithoutProductCategoriesNestedInputSchema,
        )
        .optional(),
    })
    .strict() as z.ZodType<Prisma.ProductCategoryUpdateWithoutProductInput>;

export const ProductCategoryUncheckedUpdateWithoutProductInputSchema: z.ZodType<Prisma.ProductCategoryUncheckedUpdateWithoutProductInput> =
  z
    .object({
      categoryID: z
        .union([
          z.string(),
          z.lazy(() => StringFieldUpdateOperationsInputSchema),
        ])
        .optional(),
    })
    .strict() as z.ZodType<Prisma.ProductCategoryUncheckedUpdateWithoutProductInput>;

export const ProductCategoryUncheckedUpdateManyWithoutProductInputSchema: z.ZodType<Prisma.ProductCategoryUncheckedUpdateManyWithoutProductInput> =
  z
    .object({
      categoryID: z
        .union([
          z.string(),
          z.lazy(() => StringFieldUpdateOperationsInputSchema),
        ])
        .optional(),
    })
    .strict() as z.ZodType<Prisma.ProductCategoryUncheckedUpdateManyWithoutProductInput>;

export const ProductImageUpdateWithoutProductInputSchema: z.ZodType<Prisma.ProductImageUpdateWithoutProductInput> =
  z
    .object({
      id: z
        .union([
          z.string().uuid(),
          z.lazy(() => StringFieldUpdateOperationsInputSchema),
        ])
        .optional(),
      name: z
        .union([
          z.string(),
          z.lazy(() => StringFieldUpdateOperationsInputSchema),
        ])
        .optional(),
      description: z
        .union([
          z.string(),
          z.lazy(() => NullableStringFieldUpdateOperationsInputSchema),
        ])
        .optional()
        .nullable(),
      imageUrl: z
        .union([
          z.string(),
          z.lazy(() => StringFieldUpdateOperationsInputSchema),
        ])
        .optional(),
      sortOrder: z
        .union([
          z.number().int(),
          z.lazy(() => IntFieldUpdateOperationsInputSchema),
        ])
        .optional(),
      createdAt: z
        .union([
          z.coerce.date(),
          z.lazy(() => DateTimeFieldUpdateOperationsInputSchema),
        ])
        .optional(),
      createdBy: z
        .union([
          z.string(),
          z.lazy(() => NullableStringFieldUpdateOperationsInputSchema),
        ])
        .optional()
        .nullable(),
      updatedAt: z
        .union([
          z.coerce.date(),
          z.lazy(() => DateTimeFieldUpdateOperationsInputSchema),
        ])
        .optional(),
      deletedAt: z
        .union([
          z.coerce.date(),
          z.lazy(() => NullableDateTimeFieldUpdateOperationsInputSchema),
        ])
        .optional()
        .nullable(),
      productVariant: z
        .lazy(
          () => ProductVariantUpdateOneWithoutProductImagesNestedInputSchema,
        )
        .optional(),
    })
    .strict() as z.ZodType<Prisma.ProductImageUpdateWithoutProductInput>;

export const ProductImageUncheckedUpdateWithoutProductInputSchema: z.ZodType<Prisma.ProductImageUncheckedUpdateWithoutProductInput> =
  z
    .object({
      id: z
        .union([
          z.string().uuid(),
          z.lazy(() => StringFieldUpdateOperationsInputSchema),
        ])
        .optional(),
      name: z
        .union([
          z.string(),
          z.lazy(() => StringFieldUpdateOperationsInputSchema),
        ])
        .optional(),
      description: z
        .union([
          z.string(),
          z.lazy(() => NullableStringFieldUpdateOperationsInputSchema),
        ])
        .optional()
        .nullable(),
      productVariantID: z
        .union([
          z.string(),
          z.lazy(() => NullableStringFieldUpdateOperationsInputSchema),
        ])
        .optional()
        .nullable(),
      imageUrl: z
        .union([
          z.string(),
          z.lazy(() => StringFieldUpdateOperationsInputSchema),
        ])
        .optional(),
      sortOrder: z
        .union([
          z.number().int(),
          z.lazy(() => IntFieldUpdateOperationsInputSchema),
        ])
        .optional(),
      createdAt: z
        .union([
          z.coerce.date(),
          z.lazy(() => DateTimeFieldUpdateOperationsInputSchema),
        ])
        .optional(),
      createdBy: z
        .union([
          z.string(),
          z.lazy(() => NullableStringFieldUpdateOperationsInputSchema),
        ])
        .optional()
        .nullable(),
      updatedAt: z
        .union([
          z.coerce.date(),
          z.lazy(() => DateTimeFieldUpdateOperationsInputSchema),
        ])
        .optional(),
      deletedAt: z
        .union([
          z.coerce.date(),
          z.lazy(() => NullableDateTimeFieldUpdateOperationsInputSchema),
        ])
        .optional()
        .nullable(),
    })
    .strict() as z.ZodType<Prisma.ProductImageUncheckedUpdateWithoutProductInput>;

export const ProductImageUncheckedUpdateManyWithoutProductInputSchema: z.ZodType<Prisma.ProductImageUncheckedUpdateManyWithoutProductInput> =
  z
    .object({
      id: z
        .union([
          z.string().uuid(),
          z.lazy(() => StringFieldUpdateOperationsInputSchema),
        ])
        .optional(),
      name: z
        .union([
          z.string(),
          z.lazy(() => StringFieldUpdateOperationsInputSchema),
        ])
        .optional(),
      description: z
        .union([
          z.string(),
          z.lazy(() => NullableStringFieldUpdateOperationsInputSchema),
        ])
        .optional()
        .nullable(),
      productVariantID: z
        .union([
          z.string(),
          z.lazy(() => NullableStringFieldUpdateOperationsInputSchema),
        ])
        .optional()
        .nullable(),
      imageUrl: z
        .union([
          z.string(),
          z.lazy(() => StringFieldUpdateOperationsInputSchema),
        ])
        .optional(),
      sortOrder: z
        .union([
          z.number().int(),
          z.lazy(() => IntFieldUpdateOperationsInputSchema),
        ])
        .optional(),
      createdAt: z
        .union([
          z.coerce.date(),
          z.lazy(() => DateTimeFieldUpdateOperationsInputSchema),
        ])
        .optional(),
      createdBy: z
        .union([
          z.string(),
          z.lazy(() => NullableStringFieldUpdateOperationsInputSchema),
        ])
        .optional()
        .nullable(),
      updatedAt: z
        .union([
          z.coerce.date(),
          z.lazy(() => DateTimeFieldUpdateOperationsInputSchema),
        ])
        .optional(),
      deletedAt: z
        .union([
          z.coerce.date(),
          z.lazy(() => NullableDateTimeFieldUpdateOperationsInputSchema),
        ])
        .optional()
        .nullable(),
    })
    .strict() as z.ZodType<Prisma.ProductImageUncheckedUpdateManyWithoutProductInput>;

export const ProductVariantUpdateWithoutProductInputSchema: z.ZodType<Prisma.ProductVariantUpdateWithoutProductInput> =
  z
    .object({
      id: z
        .union([
          z.string().uuid(),
          z.lazy(() => StringFieldUpdateOperationsInputSchema),
        ])
        .optional(),
      name: z
        .union([
          z.string(),
          z.lazy(() => NullableStringFieldUpdateOperationsInputSchema),
        ])
        .optional()
        .nullable(),
      sku: z
        .union([
          z.string(),
          z.lazy(() => NullableStringFieldUpdateOperationsInputSchema),
        ])
        .optional()
        .nullable(),
      price: z
        .union([
          z
            .union([
              z.number(),
              z.string(),
              z.instanceof(Decimal),
              z.instanceof(Prisma.Decimal),
              DecimalJsLikeSchema,
            ])
            .refine((v) => isValidDecimalInput(v), {
              message: 'Must be a Decimal',
            }),
          z.lazy(() => DecimalFieldUpdateOperationsInputSchema),
        ])
        .optional(),
      stockQuantity: z
        .union([
          z.number().int(),
          z.lazy(() => IntFieldUpdateOperationsInputSchema),
        ])
        .optional(),
      attributes: z
        .union([
          z.lazy(() => NullableJsonNullValueInputSchema),
          InputJsonValueSchema,
        ])
        .optional(),
      createdAt: z
        .union([
          z.coerce.date(),
          z.lazy(() => DateTimeFieldUpdateOperationsInputSchema),
        ])
        .optional(),
      createdBy: z
        .union([
          z.string(),
          z.lazy(() => NullableStringFieldUpdateOperationsInputSchema),
        ])
        .optional()
        .nullable(),
      updatedAt: z
        .union([
          z.coerce.date(),
          z.lazy(() => DateTimeFieldUpdateOperationsInputSchema),
        ])
        .optional(),
      deletedAt: z
        .union([
          z.coerce.date(),
          z.lazy(() => NullableDateTimeFieldUpdateOperationsInputSchema),
        ])
        .optional()
        .nullable(),
      productImages: z
        .lazy(
          () => ProductImageUpdateManyWithoutProductVariantNestedInputSchema,
        )
        .optional(),
      orderItems: z
        .lazy(() => OrderItemUpdateManyWithoutProductVariantNestedInputSchema)
        .optional(),
      cartItems: z
        .lazy(() => CartItemUpdateManyWithoutProductVariantNestedInputSchema)
        .optional(),
    })
    .strict() as z.ZodType<Prisma.ProductVariantUpdateWithoutProductInput>;

export const ProductVariantUncheckedUpdateWithoutProductInputSchema: z.ZodType<Prisma.ProductVariantUncheckedUpdateWithoutProductInput> =
  z
    .object({
      id: z
        .union([
          z.string().uuid(),
          z.lazy(() => StringFieldUpdateOperationsInputSchema),
        ])
        .optional(),
      name: z
        .union([
          z.string(),
          z.lazy(() => NullableStringFieldUpdateOperationsInputSchema),
        ])
        .optional()
        .nullable(),
      sku: z
        .union([
          z.string(),
          z.lazy(() => NullableStringFieldUpdateOperationsInputSchema),
        ])
        .optional()
        .nullable(),
      price: z
        .union([
          z
            .union([
              z.number(),
              z.string(),
              z.instanceof(Decimal),
              z.instanceof(Prisma.Decimal),
              DecimalJsLikeSchema,
            ])
            .refine((v) => isValidDecimalInput(v), {
              message: 'Must be a Decimal',
            }),
          z.lazy(() => DecimalFieldUpdateOperationsInputSchema),
        ])
        .optional(),
      stockQuantity: z
        .union([
          z.number().int(),
          z.lazy(() => IntFieldUpdateOperationsInputSchema),
        ])
        .optional(),
      attributes: z
        .union([
          z.lazy(() => NullableJsonNullValueInputSchema),
          InputJsonValueSchema,
        ])
        .optional(),
      createdAt: z
        .union([
          z.coerce.date(),
          z.lazy(() => DateTimeFieldUpdateOperationsInputSchema),
        ])
        .optional(),
      createdBy: z
        .union([
          z.string(),
          z.lazy(() => NullableStringFieldUpdateOperationsInputSchema),
        ])
        .optional()
        .nullable(),
      updatedAt: z
        .union([
          z.coerce.date(),
          z.lazy(() => DateTimeFieldUpdateOperationsInputSchema),
        ])
        .optional(),
      deletedAt: z
        .union([
          z.coerce.date(),
          z.lazy(() => NullableDateTimeFieldUpdateOperationsInputSchema),
        ])
        .optional()
        .nullable(),
      productImages: z
        .lazy(
          () =>
            ProductImageUncheckedUpdateManyWithoutProductVariantNestedInputSchema,
        )
        .optional(),
      orderItems: z
        .lazy(
          () =>
            OrderItemUncheckedUpdateManyWithoutProductVariantNestedInputSchema,
        )
        .optional(),
      cartItems: z
        .lazy(
          () =>
            CartItemUncheckedUpdateManyWithoutProductVariantNestedInputSchema,
        )
        .optional(),
    })
    .strict() as z.ZodType<Prisma.ProductVariantUncheckedUpdateWithoutProductInput>;

export const ProductVariantUncheckedUpdateManyWithoutProductInputSchema: z.ZodType<Prisma.ProductVariantUncheckedUpdateManyWithoutProductInput> =
  z
    .object({
      id: z
        .union([
          z.string().uuid(),
          z.lazy(() => StringFieldUpdateOperationsInputSchema),
        ])
        .optional(),
      name: z
        .union([
          z.string(),
          z.lazy(() => NullableStringFieldUpdateOperationsInputSchema),
        ])
        .optional()
        .nullable(),
      sku: z
        .union([
          z.string(),
          z.lazy(() => NullableStringFieldUpdateOperationsInputSchema),
        ])
        .optional()
        .nullable(),
      price: z
        .union([
          z
            .union([
              z.number(),
              z.string(),
              z.instanceof(Decimal),
              z.instanceof(Prisma.Decimal),
              DecimalJsLikeSchema,
            ])
            .refine((v) => isValidDecimalInput(v), {
              message: 'Must be a Decimal',
            }),
          z.lazy(() => DecimalFieldUpdateOperationsInputSchema),
        ])
        .optional(),
      stockQuantity: z
        .union([
          z.number().int(),
          z.lazy(() => IntFieldUpdateOperationsInputSchema),
        ])
        .optional(),
      attributes: z
        .union([
          z.lazy(() => NullableJsonNullValueInputSchema),
          InputJsonValueSchema,
        ])
        .optional(),
      createdAt: z
        .union([
          z.coerce.date(),
          z.lazy(() => DateTimeFieldUpdateOperationsInputSchema),
        ])
        .optional(),
      createdBy: z
        .union([
          z.string(),
          z.lazy(() => NullableStringFieldUpdateOperationsInputSchema),
        ])
        .optional()
        .nullable(),
      updatedAt: z
        .union([
          z.coerce.date(),
          z.lazy(() => DateTimeFieldUpdateOperationsInputSchema),
        ])
        .optional(),
      deletedAt: z
        .union([
          z.coerce.date(),
          z.lazy(() => NullableDateTimeFieldUpdateOperationsInputSchema),
        ])
        .optional()
        .nullable(),
    })
    .strict() as z.ZodType<Prisma.ProductVariantUncheckedUpdateManyWithoutProductInput>;

export const ProductImageCreateManyProductVariantInputSchema: z.ZodType<Prisma.ProductImageCreateManyProductVariantInput> =
  z
    .object({
      id: z.string().uuid().optional(),
      name: z.string(),
      description: z.string().optional().nullable(),
      productID: z.string().optional().nullable(),
      imageUrl: z.string(),
      sortOrder: z.number().int().optional(),
      createdAt: z.coerce.date().optional(),
      createdBy: z.string().optional().nullable(),
      updatedAt: z.coerce.date().optional(),
      deletedAt: z.coerce.date().optional().nullable(),
    })
    .strict() as z.ZodType<Prisma.ProductImageCreateManyProductVariantInput>;

export const OrderItemCreateManyProductVariantInputSchema: z.ZodType<Prisma.OrderItemCreateManyProductVariantInput> =
  z
    .object({
      id: z.string().uuid().optional(),
      orderID: z.string(),
      quantity: z.number().int().optional(),
      unitPrice: z
        .union([
          z.number(),
          z.string(),
          z.instanceof(Decimal),
          z.instanceof(Prisma.Decimal),
          DecimalJsLikeSchema,
        ])
        .refine((v) => isValidDecimalInput(v), {
          message: 'Must be a Decimal',
        }),
      totalPrice: z
        .union([
          z.number(),
          z.string(),
          z.instanceof(Decimal),
          z.instanceof(Prisma.Decimal),
          DecimalJsLikeSchema,
        ])
        .refine((v) => isValidDecimalInput(v), {
          message: 'Must be a Decimal',
        }),
      productVariantSnapshot: z
        .union([
          z.lazy(() => NullableJsonNullValueInputSchema),
          InputJsonValueSchema,
        ])
        .optional(),
    })
    .strict() as z.ZodType<Prisma.OrderItemCreateManyProductVariantInput>;

export const CartItemCreateManyProductVariantInputSchema: z.ZodType<Prisma.CartItemCreateManyProductVariantInput> =
  z
    .object({
      id: z.string().uuid().optional(),
      cartID: z.string(),
      quantity: z.number().int().optional(),
      createdAt: z.coerce.date().optional(),
      updatedAt: z.coerce.date().optional(),
    })
    .strict() as z.ZodType<Prisma.CartItemCreateManyProductVariantInput>;

export const ProductImageUpdateWithoutProductVariantInputSchema: z.ZodType<Prisma.ProductImageUpdateWithoutProductVariantInput> =
  z
    .object({
      id: z
        .union([
          z.string().uuid(),
          z.lazy(() => StringFieldUpdateOperationsInputSchema),
        ])
        .optional(),
      name: z
        .union([
          z.string(),
          z.lazy(() => StringFieldUpdateOperationsInputSchema),
        ])
        .optional(),
      description: z
        .union([
          z.string(),
          z.lazy(() => NullableStringFieldUpdateOperationsInputSchema),
        ])
        .optional()
        .nullable(),
      imageUrl: z
        .union([
          z.string(),
          z.lazy(() => StringFieldUpdateOperationsInputSchema),
        ])
        .optional(),
      sortOrder: z
        .union([
          z.number().int(),
          z.lazy(() => IntFieldUpdateOperationsInputSchema),
        ])
        .optional(),
      createdAt: z
        .union([
          z.coerce.date(),
          z.lazy(() => DateTimeFieldUpdateOperationsInputSchema),
        ])
        .optional(),
      createdBy: z
        .union([
          z.string(),
          z.lazy(() => NullableStringFieldUpdateOperationsInputSchema),
        ])
        .optional()
        .nullable(),
      updatedAt: z
        .union([
          z.coerce.date(),
          z.lazy(() => DateTimeFieldUpdateOperationsInputSchema),
        ])
        .optional(),
      deletedAt: z
        .union([
          z.coerce.date(),
          z.lazy(() => NullableDateTimeFieldUpdateOperationsInputSchema),
        ])
        .optional()
        .nullable(),
      product: z
        .lazy(() => ProductUpdateOneWithoutProductImagesNestedInputSchema)
        .optional(),
    })
    .strict() as z.ZodType<Prisma.ProductImageUpdateWithoutProductVariantInput>;

export const ProductImageUncheckedUpdateWithoutProductVariantInputSchema: z.ZodType<Prisma.ProductImageUncheckedUpdateWithoutProductVariantInput> =
  z
    .object({
      id: z
        .union([
          z.string().uuid(),
          z.lazy(() => StringFieldUpdateOperationsInputSchema),
        ])
        .optional(),
      name: z
        .union([
          z.string(),
          z.lazy(() => StringFieldUpdateOperationsInputSchema),
        ])
        .optional(),
      description: z
        .union([
          z.string(),
          z.lazy(() => NullableStringFieldUpdateOperationsInputSchema),
        ])
        .optional()
        .nullable(),
      productID: z
        .union([
          z.string(),
          z.lazy(() => NullableStringFieldUpdateOperationsInputSchema),
        ])
        .optional()
        .nullable(),
      imageUrl: z
        .union([
          z.string(),
          z.lazy(() => StringFieldUpdateOperationsInputSchema),
        ])
        .optional(),
      sortOrder: z
        .union([
          z.number().int(),
          z.lazy(() => IntFieldUpdateOperationsInputSchema),
        ])
        .optional(),
      createdAt: z
        .union([
          z.coerce.date(),
          z.lazy(() => DateTimeFieldUpdateOperationsInputSchema),
        ])
        .optional(),
      createdBy: z
        .union([
          z.string(),
          z.lazy(() => NullableStringFieldUpdateOperationsInputSchema),
        ])
        .optional()
        .nullable(),
      updatedAt: z
        .union([
          z.coerce.date(),
          z.lazy(() => DateTimeFieldUpdateOperationsInputSchema),
        ])
        .optional(),
      deletedAt: z
        .union([
          z.coerce.date(),
          z.lazy(() => NullableDateTimeFieldUpdateOperationsInputSchema),
        ])
        .optional()
        .nullable(),
    })
    .strict() as z.ZodType<Prisma.ProductImageUncheckedUpdateWithoutProductVariantInput>;

export const ProductImageUncheckedUpdateManyWithoutProductVariantInputSchema: z.ZodType<Prisma.ProductImageUncheckedUpdateManyWithoutProductVariantInput> =
  z
    .object({
      id: z
        .union([
          z.string().uuid(),
          z.lazy(() => StringFieldUpdateOperationsInputSchema),
        ])
        .optional(),
      name: z
        .union([
          z.string(),
          z.lazy(() => StringFieldUpdateOperationsInputSchema),
        ])
        .optional(),
      description: z
        .union([
          z.string(),
          z.lazy(() => NullableStringFieldUpdateOperationsInputSchema),
        ])
        .optional()
        .nullable(),
      productID: z
        .union([
          z.string(),
          z.lazy(() => NullableStringFieldUpdateOperationsInputSchema),
        ])
        .optional()
        .nullable(),
      imageUrl: z
        .union([
          z.string(),
          z.lazy(() => StringFieldUpdateOperationsInputSchema),
        ])
        .optional(),
      sortOrder: z
        .union([
          z.number().int(),
          z.lazy(() => IntFieldUpdateOperationsInputSchema),
        ])
        .optional(),
      createdAt: z
        .union([
          z.coerce.date(),
          z.lazy(() => DateTimeFieldUpdateOperationsInputSchema),
        ])
        .optional(),
      createdBy: z
        .union([
          z.string(),
          z.lazy(() => NullableStringFieldUpdateOperationsInputSchema),
        ])
        .optional()
        .nullable(),
      updatedAt: z
        .union([
          z.coerce.date(),
          z.lazy(() => DateTimeFieldUpdateOperationsInputSchema),
        ])
        .optional(),
      deletedAt: z
        .union([
          z.coerce.date(),
          z.lazy(() => NullableDateTimeFieldUpdateOperationsInputSchema),
        ])
        .optional()
        .nullable(),
    })
    .strict() as z.ZodType<Prisma.ProductImageUncheckedUpdateManyWithoutProductVariantInput>;

export const OrderItemUpdateWithoutProductVariantInputSchema: z.ZodType<Prisma.OrderItemUpdateWithoutProductVariantInput> =
  z
    .object({
      id: z
        .union([
          z.string().uuid(),
          z.lazy(() => StringFieldUpdateOperationsInputSchema),
        ])
        .optional(),
      quantity: z
        .union([
          z.number().int(),
          z.lazy(() => IntFieldUpdateOperationsInputSchema),
        ])
        .optional(),
      unitPrice: z
        .union([
          z
            .union([
              z.number(),
              z.string(),
              z.instanceof(Decimal),
              z.instanceof(Prisma.Decimal),
              DecimalJsLikeSchema,
            ])
            .refine((v) => isValidDecimalInput(v), {
              message: 'Must be a Decimal',
            }),
          z.lazy(() => DecimalFieldUpdateOperationsInputSchema),
        ])
        .optional(),
      totalPrice: z
        .union([
          z
            .union([
              z.number(),
              z.string(),
              z.instanceof(Decimal),
              z.instanceof(Prisma.Decimal),
              DecimalJsLikeSchema,
            ])
            .refine((v) => isValidDecimalInput(v), {
              message: 'Must be a Decimal',
            }),
          z.lazy(() => DecimalFieldUpdateOperationsInputSchema),
        ])
        .optional(),
      productVariantSnapshot: z
        .union([
          z.lazy(() => NullableJsonNullValueInputSchema),
          InputJsonValueSchema,
        ])
        .optional(),
      order: z
        .lazy(() => OrderUpdateOneRequiredWithoutOrderItemsNestedInputSchema)
        .optional(),
    })
    .strict() as z.ZodType<Prisma.OrderItemUpdateWithoutProductVariantInput>;

export const OrderItemUncheckedUpdateWithoutProductVariantInputSchema: z.ZodType<Prisma.OrderItemUncheckedUpdateWithoutProductVariantInput> =
  z
    .object({
      id: z
        .union([
          z.string().uuid(),
          z.lazy(() => StringFieldUpdateOperationsInputSchema),
        ])
        .optional(),
      orderID: z
        .union([
          z.string(),
          z.lazy(() => StringFieldUpdateOperationsInputSchema),
        ])
        .optional(),
      quantity: z
        .union([
          z.number().int(),
          z.lazy(() => IntFieldUpdateOperationsInputSchema),
        ])
        .optional(),
      unitPrice: z
        .union([
          z
            .union([
              z.number(),
              z.string(),
              z.instanceof(Decimal),
              z.instanceof(Prisma.Decimal),
              DecimalJsLikeSchema,
            ])
            .refine((v) => isValidDecimalInput(v), {
              message: 'Must be a Decimal',
            }),
          z.lazy(() => DecimalFieldUpdateOperationsInputSchema),
        ])
        .optional(),
      totalPrice: z
        .union([
          z
            .union([
              z.number(),
              z.string(),
              z.instanceof(Decimal),
              z.instanceof(Prisma.Decimal),
              DecimalJsLikeSchema,
            ])
            .refine((v) => isValidDecimalInput(v), {
              message: 'Must be a Decimal',
            }),
          z.lazy(() => DecimalFieldUpdateOperationsInputSchema),
        ])
        .optional(),
      productVariantSnapshot: z
        .union([
          z.lazy(() => NullableJsonNullValueInputSchema),
          InputJsonValueSchema,
        ])
        .optional(),
    })
    .strict() as z.ZodType<Prisma.OrderItemUncheckedUpdateWithoutProductVariantInput>;

export const OrderItemUncheckedUpdateManyWithoutProductVariantInputSchema: z.ZodType<Prisma.OrderItemUncheckedUpdateManyWithoutProductVariantInput> =
  z
    .object({
      id: z
        .union([
          z.string().uuid(),
          z.lazy(() => StringFieldUpdateOperationsInputSchema),
        ])
        .optional(),
      orderID: z
        .union([
          z.string(),
          z.lazy(() => StringFieldUpdateOperationsInputSchema),
        ])
        .optional(),
      quantity: z
        .union([
          z.number().int(),
          z.lazy(() => IntFieldUpdateOperationsInputSchema),
        ])
        .optional(),
      unitPrice: z
        .union([
          z
            .union([
              z.number(),
              z.string(),
              z.instanceof(Decimal),
              z.instanceof(Prisma.Decimal),
              DecimalJsLikeSchema,
            ])
            .refine((v) => isValidDecimalInput(v), {
              message: 'Must be a Decimal',
            }),
          z.lazy(() => DecimalFieldUpdateOperationsInputSchema),
        ])
        .optional(),
      totalPrice: z
        .union([
          z
            .union([
              z.number(),
              z.string(),
              z.instanceof(Decimal),
              z.instanceof(Prisma.Decimal),
              DecimalJsLikeSchema,
            ])
            .refine((v) => isValidDecimalInput(v), {
              message: 'Must be a Decimal',
            }),
          z.lazy(() => DecimalFieldUpdateOperationsInputSchema),
        ])
        .optional(),
      productVariantSnapshot: z
        .union([
          z.lazy(() => NullableJsonNullValueInputSchema),
          InputJsonValueSchema,
        ])
        .optional(),
    })
    .strict() as z.ZodType<Prisma.OrderItemUncheckedUpdateManyWithoutProductVariantInput>;

export const CartItemUpdateWithoutProductVariantInputSchema: z.ZodType<Prisma.CartItemUpdateWithoutProductVariantInput> =
  z
    .object({
      id: z
        .union([
          z.string().uuid(),
          z.lazy(() => StringFieldUpdateOperationsInputSchema),
        ])
        .optional(),
      quantity: z
        .union([
          z.number().int(),
          z.lazy(() => IntFieldUpdateOperationsInputSchema),
        ])
        .optional(),
      createdAt: z
        .union([
          z.coerce.date(),
          z.lazy(() => DateTimeFieldUpdateOperationsInputSchema),
        ])
        .optional(),
      updatedAt: z
        .union([
          z.coerce.date(),
          z.lazy(() => DateTimeFieldUpdateOperationsInputSchema),
        ])
        .optional(),
      cart: z
        .lazy(() => CartUpdateOneRequiredWithoutCartItemsNestedInputSchema)
        .optional(),
    })
    .strict() as z.ZodType<Prisma.CartItemUpdateWithoutProductVariantInput>;

export const CartItemUncheckedUpdateWithoutProductVariantInputSchema: z.ZodType<Prisma.CartItemUncheckedUpdateWithoutProductVariantInput> =
  z
    .object({
      id: z
        .union([
          z.string().uuid(),
          z.lazy(() => StringFieldUpdateOperationsInputSchema),
        ])
        .optional(),
      cartID: z
        .union([
          z.string(),
          z.lazy(() => StringFieldUpdateOperationsInputSchema),
        ])
        .optional(),
      quantity: z
        .union([
          z.number().int(),
          z.lazy(() => IntFieldUpdateOperationsInputSchema),
        ])
        .optional(),
      createdAt: z
        .union([
          z.coerce.date(),
          z.lazy(() => DateTimeFieldUpdateOperationsInputSchema),
        ])
        .optional(),
      updatedAt: z
        .union([
          z.coerce.date(),
          z.lazy(() => DateTimeFieldUpdateOperationsInputSchema),
        ])
        .optional(),
    })
    .strict() as z.ZodType<Prisma.CartItemUncheckedUpdateWithoutProductVariantInput>;

export const CartItemUncheckedUpdateManyWithoutProductVariantInputSchema: z.ZodType<Prisma.CartItemUncheckedUpdateManyWithoutProductVariantInput> =
  z
    .object({
      id: z
        .union([
          z.string().uuid(),
          z.lazy(() => StringFieldUpdateOperationsInputSchema),
        ])
        .optional(),
      cartID: z
        .union([
          z.string(),
          z.lazy(() => StringFieldUpdateOperationsInputSchema),
        ])
        .optional(),
      quantity: z
        .union([
          z.number().int(),
          z.lazy(() => IntFieldUpdateOperationsInputSchema),
        ])
        .optional(),
      createdAt: z
        .union([
          z.coerce.date(),
          z.lazy(() => DateTimeFieldUpdateOperationsInputSchema),
        ])
        .optional(),
      updatedAt: z
        .union([
          z.coerce.date(),
          z.lazy(() => DateTimeFieldUpdateOperationsInputSchema),
        ])
        .optional(),
    })
    .strict() as z.ZodType<Prisma.CartItemUncheckedUpdateManyWithoutProductVariantInput>;

export const OrderItemCreateManyOrderInputSchema: z.ZodType<Prisma.OrderItemCreateManyOrderInput> =
  z
    .object({
      id: z.string().uuid().optional(),
      productVariantID: z.string(),
      quantity: z.number().int().optional(),
      unitPrice: z
        .union([
          z.number(),
          z.string(),
          z.instanceof(Decimal),
          z.instanceof(Prisma.Decimal),
          DecimalJsLikeSchema,
        ])
        .refine((v) => isValidDecimalInput(v), {
          message: 'Must be a Decimal',
        }),
      totalPrice: z
        .union([
          z.number(),
          z.string(),
          z.instanceof(Decimal),
          z.instanceof(Prisma.Decimal),
          DecimalJsLikeSchema,
        ])
        .refine((v) => isValidDecimalInput(v), {
          message: 'Must be a Decimal',
        }),
      productVariantSnapshot: z
        .union([
          z.lazy(() => NullableJsonNullValueInputSchema),
          InputJsonValueSchema,
        ])
        .optional(),
    })
    .strict() as z.ZodType<Prisma.OrderItemCreateManyOrderInput>;

export const OrderAddressCreateManyOrderInputSchema: z.ZodType<Prisma.OrderAddressCreateManyOrderInput> =
  z
    .object({
      id: z.string().uuid().optional(),
      type: z.lazy(() => AddressTypeSchema).optional(),
      firstName: z.string(),
      lastName: z.string().optional().nullable(),
      company: z.string().optional().nullable(),
      fullAddress: z.string(),
      city: z.string().optional().nullable(),
      province: z.string().optional().nullable(),
      country: z.string().optional().nullable(),
      phone: z.string(),
    })
    .strict() as z.ZodType<Prisma.OrderAddressCreateManyOrderInput>;

export const OrderPromotionCreateManyOrderInputSchema: z.ZodType<Prisma.OrderPromotionCreateManyOrderInput> =
  z
    .object({
      id: z.string().uuid().optional(),
      promotionID: z.string(),
      discountAmount: z
        .union([
          z.number(),
          z.string(),
          z.instanceof(Decimal),
          z.instanceof(Prisma.Decimal),
          DecimalJsLikeSchema,
        ])
        .refine((v) => isValidDecimalInput(v), { message: 'Must be a Decimal' })
        .optional(),
    })
    .strict() as z.ZodType<Prisma.OrderPromotionCreateManyOrderInput>;

export const PaymentCreateManyOrderInputSchema: z.ZodType<Prisma.PaymentCreateManyOrderInput> =
  z
    .object({
      id: z.string().uuid().optional(),
      type: z.lazy(() => PaymentTypeSchema),
      status: z.lazy(() => PaymentStatusSchema),
      amount: z
        .union([
          z.number(),
          z.string(),
          z.instanceof(Decimal),
          z.instanceof(Prisma.Decimal),
          DecimalJsLikeSchema,
        ])
        .refine((v) => isValidDecimalInput(v), {
          message: 'Must be a Decimal',
        }),
      transactionID: z.string().optional().nullable(),
      createdAt: z.coerce.date().optional(),
      createdBy: z.string().optional().nullable(),
      updatedAt: z.coerce.date().optional(),
      deletedAt: z.coerce.date().optional().nullable(),
    })
    .strict() as z.ZodType<Prisma.PaymentCreateManyOrderInput>;

export const OrderItemUpdateWithoutOrderInputSchema: z.ZodType<Prisma.OrderItemUpdateWithoutOrderInput> =
  z
    .object({
      id: z
        .union([
          z.string().uuid(),
          z.lazy(() => StringFieldUpdateOperationsInputSchema),
        ])
        .optional(),
      quantity: z
        .union([
          z.number().int(),
          z.lazy(() => IntFieldUpdateOperationsInputSchema),
        ])
        .optional(),
      unitPrice: z
        .union([
          z
            .union([
              z.number(),
              z.string(),
              z.instanceof(Decimal),
              z.instanceof(Prisma.Decimal),
              DecimalJsLikeSchema,
            ])
            .refine((v) => isValidDecimalInput(v), {
              message: 'Must be a Decimal',
            }),
          z.lazy(() => DecimalFieldUpdateOperationsInputSchema),
        ])
        .optional(),
      totalPrice: z
        .union([
          z
            .union([
              z.number(),
              z.string(),
              z.instanceof(Decimal),
              z.instanceof(Prisma.Decimal),
              DecimalJsLikeSchema,
            ])
            .refine((v) => isValidDecimalInput(v), {
              message: 'Must be a Decimal',
            }),
          z.lazy(() => DecimalFieldUpdateOperationsInputSchema),
        ])
        .optional(),
      productVariantSnapshot: z
        .union([
          z.lazy(() => NullableJsonNullValueInputSchema),
          InputJsonValueSchema,
        ])
        .optional(),
      productVariant: z
        .lazy(
          () =>
            ProductVariantUpdateOneRequiredWithoutOrderItemsNestedInputSchema,
        )
        .optional(),
    })
    .strict() as z.ZodType<Prisma.OrderItemUpdateWithoutOrderInput>;

export const OrderItemUncheckedUpdateWithoutOrderInputSchema: z.ZodType<Prisma.OrderItemUncheckedUpdateWithoutOrderInput> =
  z
    .object({
      id: z
        .union([
          z.string().uuid(),
          z.lazy(() => StringFieldUpdateOperationsInputSchema),
        ])
        .optional(),
      productVariantID: z
        .union([
          z.string(),
          z.lazy(() => StringFieldUpdateOperationsInputSchema),
        ])
        .optional(),
      quantity: z
        .union([
          z.number().int(),
          z.lazy(() => IntFieldUpdateOperationsInputSchema),
        ])
        .optional(),
      unitPrice: z
        .union([
          z
            .union([
              z.number(),
              z.string(),
              z.instanceof(Decimal),
              z.instanceof(Prisma.Decimal),
              DecimalJsLikeSchema,
            ])
            .refine((v) => isValidDecimalInput(v), {
              message: 'Must be a Decimal',
            }),
          z.lazy(() => DecimalFieldUpdateOperationsInputSchema),
        ])
        .optional(),
      totalPrice: z
        .union([
          z
            .union([
              z.number(),
              z.string(),
              z.instanceof(Decimal),
              z.instanceof(Prisma.Decimal),
              DecimalJsLikeSchema,
            ])
            .refine((v) => isValidDecimalInput(v), {
              message: 'Must be a Decimal',
            }),
          z.lazy(() => DecimalFieldUpdateOperationsInputSchema),
        ])
        .optional(),
      productVariantSnapshot: z
        .union([
          z.lazy(() => NullableJsonNullValueInputSchema),
          InputJsonValueSchema,
        ])
        .optional(),
    })
    .strict() as z.ZodType<Prisma.OrderItemUncheckedUpdateWithoutOrderInput>;

export const OrderItemUncheckedUpdateManyWithoutOrderInputSchema: z.ZodType<Prisma.OrderItemUncheckedUpdateManyWithoutOrderInput> =
  z
    .object({
      id: z
        .union([
          z.string().uuid(),
          z.lazy(() => StringFieldUpdateOperationsInputSchema),
        ])
        .optional(),
      productVariantID: z
        .union([
          z.string(),
          z.lazy(() => StringFieldUpdateOperationsInputSchema),
        ])
        .optional(),
      quantity: z
        .union([
          z.number().int(),
          z.lazy(() => IntFieldUpdateOperationsInputSchema),
        ])
        .optional(),
      unitPrice: z
        .union([
          z
            .union([
              z.number(),
              z.string(),
              z.instanceof(Decimal),
              z.instanceof(Prisma.Decimal),
              DecimalJsLikeSchema,
            ])
            .refine((v) => isValidDecimalInput(v), {
              message: 'Must be a Decimal',
            }),
          z.lazy(() => DecimalFieldUpdateOperationsInputSchema),
        ])
        .optional(),
      totalPrice: z
        .union([
          z
            .union([
              z.number(),
              z.string(),
              z.instanceof(Decimal),
              z.instanceof(Prisma.Decimal),
              DecimalJsLikeSchema,
            ])
            .refine((v) => isValidDecimalInput(v), {
              message: 'Must be a Decimal',
            }),
          z.lazy(() => DecimalFieldUpdateOperationsInputSchema),
        ])
        .optional(),
      productVariantSnapshot: z
        .union([
          z.lazy(() => NullableJsonNullValueInputSchema),
          InputJsonValueSchema,
        ])
        .optional(),
    })
    .strict() as z.ZodType<Prisma.OrderItemUncheckedUpdateManyWithoutOrderInput>;

export const OrderAddressUpdateWithoutOrderInputSchema: z.ZodType<Prisma.OrderAddressUpdateWithoutOrderInput> =
  z
    .object({
      id: z
        .union([
          z.string().uuid(),
          z.lazy(() => StringFieldUpdateOperationsInputSchema),
        ])
        .optional(),
      type: z
        .union([
          z.lazy(() => AddressTypeSchema),
          z.lazy(() => EnumAddressTypeFieldUpdateOperationsInputSchema),
        ])
        .optional(),
      firstName: z
        .union([
          z.string(),
          z.lazy(() => StringFieldUpdateOperationsInputSchema),
        ])
        .optional(),
      lastName: z
        .union([
          z.string(),
          z.lazy(() => NullableStringFieldUpdateOperationsInputSchema),
        ])
        .optional()
        .nullable(),
      company: z
        .union([
          z.string(),
          z.lazy(() => NullableStringFieldUpdateOperationsInputSchema),
        ])
        .optional()
        .nullable(),
      fullAddress: z
        .union([
          z.string(),
          z.lazy(() => StringFieldUpdateOperationsInputSchema),
        ])
        .optional(),
      city: z
        .union([
          z.string(),
          z.lazy(() => NullableStringFieldUpdateOperationsInputSchema),
        ])
        .optional()
        .nullable(),
      province: z
        .union([
          z.string(),
          z.lazy(() => NullableStringFieldUpdateOperationsInputSchema),
        ])
        .optional()
        .nullable(),
      country: z
        .union([
          z.string(),
          z.lazy(() => NullableStringFieldUpdateOperationsInputSchema),
        ])
        .optional()
        .nullable(),
      phone: z
        .union([
          z.string(),
          z.lazy(() => StringFieldUpdateOperationsInputSchema),
        ])
        .optional(),
    })
    .strict() as z.ZodType<Prisma.OrderAddressUpdateWithoutOrderInput>;

export const OrderAddressUncheckedUpdateWithoutOrderInputSchema: z.ZodType<Prisma.OrderAddressUncheckedUpdateWithoutOrderInput> =
  z
    .object({
      id: z
        .union([
          z.string().uuid(),
          z.lazy(() => StringFieldUpdateOperationsInputSchema),
        ])
        .optional(),
      type: z
        .union([
          z.lazy(() => AddressTypeSchema),
          z.lazy(() => EnumAddressTypeFieldUpdateOperationsInputSchema),
        ])
        .optional(),
      firstName: z
        .union([
          z.string(),
          z.lazy(() => StringFieldUpdateOperationsInputSchema),
        ])
        .optional(),
      lastName: z
        .union([
          z.string(),
          z.lazy(() => NullableStringFieldUpdateOperationsInputSchema),
        ])
        .optional()
        .nullable(),
      company: z
        .union([
          z.string(),
          z.lazy(() => NullableStringFieldUpdateOperationsInputSchema),
        ])
        .optional()
        .nullable(),
      fullAddress: z
        .union([
          z.string(),
          z.lazy(() => StringFieldUpdateOperationsInputSchema),
        ])
        .optional(),
      city: z
        .union([
          z.string(),
          z.lazy(() => NullableStringFieldUpdateOperationsInputSchema),
        ])
        .optional()
        .nullable(),
      province: z
        .union([
          z.string(),
          z.lazy(() => NullableStringFieldUpdateOperationsInputSchema),
        ])
        .optional()
        .nullable(),
      country: z
        .union([
          z.string(),
          z.lazy(() => NullableStringFieldUpdateOperationsInputSchema),
        ])
        .optional()
        .nullable(),
      phone: z
        .union([
          z.string(),
          z.lazy(() => StringFieldUpdateOperationsInputSchema),
        ])
        .optional(),
    })
    .strict() as z.ZodType<Prisma.OrderAddressUncheckedUpdateWithoutOrderInput>;

export const OrderAddressUncheckedUpdateManyWithoutOrderInputSchema: z.ZodType<Prisma.OrderAddressUncheckedUpdateManyWithoutOrderInput> =
  z
    .object({
      id: z
        .union([
          z.string().uuid(),
          z.lazy(() => StringFieldUpdateOperationsInputSchema),
        ])
        .optional(),
      type: z
        .union([
          z.lazy(() => AddressTypeSchema),
          z.lazy(() => EnumAddressTypeFieldUpdateOperationsInputSchema),
        ])
        .optional(),
      firstName: z
        .union([
          z.string(),
          z.lazy(() => StringFieldUpdateOperationsInputSchema),
        ])
        .optional(),
      lastName: z
        .union([
          z.string(),
          z.lazy(() => NullableStringFieldUpdateOperationsInputSchema),
        ])
        .optional()
        .nullable(),
      company: z
        .union([
          z.string(),
          z.lazy(() => NullableStringFieldUpdateOperationsInputSchema),
        ])
        .optional()
        .nullable(),
      fullAddress: z
        .union([
          z.string(),
          z.lazy(() => StringFieldUpdateOperationsInputSchema),
        ])
        .optional(),
      city: z
        .union([
          z.string(),
          z.lazy(() => NullableStringFieldUpdateOperationsInputSchema),
        ])
        .optional()
        .nullable(),
      province: z
        .union([
          z.string(),
          z.lazy(() => NullableStringFieldUpdateOperationsInputSchema),
        ])
        .optional()
        .nullable(),
      country: z
        .union([
          z.string(),
          z.lazy(() => NullableStringFieldUpdateOperationsInputSchema),
        ])
        .optional()
        .nullable(),
      phone: z
        .union([
          z.string(),
          z.lazy(() => StringFieldUpdateOperationsInputSchema),
        ])
        .optional(),
    })
    .strict() as z.ZodType<Prisma.OrderAddressUncheckedUpdateManyWithoutOrderInput>;

export const OrderPromotionUpdateWithoutOrderInputSchema: z.ZodType<Prisma.OrderPromotionUpdateWithoutOrderInput> =
  z
    .object({
      id: z
        .union([
          z.string().uuid(),
          z.lazy(() => StringFieldUpdateOperationsInputSchema),
        ])
        .optional(),
      discountAmount: z
        .union([
          z
            .union([
              z.number(),
              z.string(),
              z.instanceof(Decimal),
              z.instanceof(Prisma.Decimal),
              DecimalJsLikeSchema,
            ])
            .refine((v) => isValidDecimalInput(v), {
              message: 'Must be a Decimal',
            }),
          z.lazy(() => DecimalFieldUpdateOperationsInputSchema),
        ])
        .optional(),
      promotion: z
        .lazy(
          () =>
            PromotionUpdateOneRequiredWithoutOrderPromotionsNestedInputSchema,
        )
        .optional(),
    })
    .strict() as z.ZodType<Prisma.OrderPromotionUpdateWithoutOrderInput>;

export const OrderPromotionUncheckedUpdateWithoutOrderInputSchema: z.ZodType<Prisma.OrderPromotionUncheckedUpdateWithoutOrderInput> =
  z
    .object({
      id: z
        .union([
          z.string().uuid(),
          z.lazy(() => StringFieldUpdateOperationsInputSchema),
        ])
        .optional(),
      promotionID: z
        .union([
          z.string(),
          z.lazy(() => StringFieldUpdateOperationsInputSchema),
        ])
        .optional(),
      discountAmount: z
        .union([
          z
            .union([
              z.number(),
              z.string(),
              z.instanceof(Decimal),
              z.instanceof(Prisma.Decimal),
              DecimalJsLikeSchema,
            ])
            .refine((v) => isValidDecimalInput(v), {
              message: 'Must be a Decimal',
            }),
          z.lazy(() => DecimalFieldUpdateOperationsInputSchema),
        ])
        .optional(),
    })
    .strict() as z.ZodType<Prisma.OrderPromotionUncheckedUpdateWithoutOrderInput>;

export const OrderPromotionUncheckedUpdateManyWithoutOrderInputSchema: z.ZodType<Prisma.OrderPromotionUncheckedUpdateManyWithoutOrderInput> =
  z
    .object({
      id: z
        .union([
          z.string().uuid(),
          z.lazy(() => StringFieldUpdateOperationsInputSchema),
        ])
        .optional(),
      promotionID: z
        .union([
          z.string(),
          z.lazy(() => StringFieldUpdateOperationsInputSchema),
        ])
        .optional(),
      discountAmount: z
        .union([
          z
            .union([
              z.number(),
              z.string(),
              z.instanceof(Decimal),
              z.instanceof(Prisma.Decimal),
              DecimalJsLikeSchema,
            ])
            .refine((v) => isValidDecimalInput(v), {
              message: 'Must be a Decimal',
            }),
          z.lazy(() => DecimalFieldUpdateOperationsInputSchema),
        ])
        .optional(),
    })
    .strict() as z.ZodType<Prisma.OrderPromotionUncheckedUpdateManyWithoutOrderInput>;

export const PaymentUpdateWithoutOrderInputSchema: z.ZodType<Prisma.PaymentUpdateWithoutOrderInput> =
  z
    .object({
      id: z
        .union([
          z.string().uuid(),
          z.lazy(() => StringFieldUpdateOperationsInputSchema),
        ])
        .optional(),
      type: z
        .union([
          z.lazy(() => PaymentTypeSchema),
          z.lazy(() => EnumPaymentTypeFieldUpdateOperationsInputSchema),
        ])
        .optional(),
      status: z
        .union([
          z.lazy(() => PaymentStatusSchema),
          z.lazy(() => EnumPaymentStatusFieldUpdateOperationsInputSchema),
        ])
        .optional(),
      amount: z
        .union([
          z
            .union([
              z.number(),
              z.string(),
              z.instanceof(Decimal),
              z.instanceof(Prisma.Decimal),
              DecimalJsLikeSchema,
            ])
            .refine((v) => isValidDecimalInput(v), {
              message: 'Must be a Decimal',
            }),
          z.lazy(() => DecimalFieldUpdateOperationsInputSchema),
        ])
        .optional(),
      transactionID: z
        .union([
          z.string(),
          z.lazy(() => NullableStringFieldUpdateOperationsInputSchema),
        ])
        .optional()
        .nullable(),
      createdAt: z
        .union([
          z.coerce.date(),
          z.lazy(() => DateTimeFieldUpdateOperationsInputSchema),
        ])
        .optional(),
      createdBy: z
        .union([
          z.string(),
          z.lazy(() => NullableStringFieldUpdateOperationsInputSchema),
        ])
        .optional()
        .nullable(),
      updatedAt: z
        .union([
          z.coerce.date(),
          z.lazy(() => DateTimeFieldUpdateOperationsInputSchema),
        ])
        .optional(),
      deletedAt: z
        .union([
          z.coerce.date(),
          z.lazy(() => NullableDateTimeFieldUpdateOperationsInputSchema),
        ])
        .optional()
        .nullable(),
    })
    .strict() as z.ZodType<Prisma.PaymentUpdateWithoutOrderInput>;

export const PaymentUncheckedUpdateWithoutOrderInputSchema: z.ZodType<Prisma.PaymentUncheckedUpdateWithoutOrderInput> =
  z
    .object({
      id: z
        .union([
          z.string().uuid(),
          z.lazy(() => StringFieldUpdateOperationsInputSchema),
        ])
        .optional(),
      type: z
        .union([
          z.lazy(() => PaymentTypeSchema),
          z.lazy(() => EnumPaymentTypeFieldUpdateOperationsInputSchema),
        ])
        .optional(),
      status: z
        .union([
          z.lazy(() => PaymentStatusSchema),
          z.lazy(() => EnumPaymentStatusFieldUpdateOperationsInputSchema),
        ])
        .optional(),
      amount: z
        .union([
          z
            .union([
              z.number(),
              z.string(),
              z.instanceof(Decimal),
              z.instanceof(Prisma.Decimal),
              DecimalJsLikeSchema,
            ])
            .refine((v) => isValidDecimalInput(v), {
              message: 'Must be a Decimal',
            }),
          z.lazy(() => DecimalFieldUpdateOperationsInputSchema),
        ])
        .optional(),
      transactionID: z
        .union([
          z.string(),
          z.lazy(() => NullableStringFieldUpdateOperationsInputSchema),
        ])
        .optional()
        .nullable(),
      createdAt: z
        .union([
          z.coerce.date(),
          z.lazy(() => DateTimeFieldUpdateOperationsInputSchema),
        ])
        .optional(),
      createdBy: z
        .union([
          z.string(),
          z.lazy(() => NullableStringFieldUpdateOperationsInputSchema),
        ])
        .optional()
        .nullable(),
      updatedAt: z
        .union([
          z.coerce.date(),
          z.lazy(() => DateTimeFieldUpdateOperationsInputSchema),
        ])
        .optional(),
      deletedAt: z
        .union([
          z.coerce.date(),
          z.lazy(() => NullableDateTimeFieldUpdateOperationsInputSchema),
        ])
        .optional()
        .nullable(),
    })
    .strict() as z.ZodType<Prisma.PaymentUncheckedUpdateWithoutOrderInput>;

export const PaymentUncheckedUpdateManyWithoutOrderInputSchema: z.ZodType<Prisma.PaymentUncheckedUpdateManyWithoutOrderInput> =
  z
    .object({
      id: z
        .union([
          z.string().uuid(),
          z.lazy(() => StringFieldUpdateOperationsInputSchema),
        ])
        .optional(),
      type: z
        .union([
          z.lazy(() => PaymentTypeSchema),
          z.lazy(() => EnumPaymentTypeFieldUpdateOperationsInputSchema),
        ])
        .optional(),
      status: z
        .union([
          z.lazy(() => PaymentStatusSchema),
          z.lazy(() => EnumPaymentStatusFieldUpdateOperationsInputSchema),
        ])
        .optional(),
      amount: z
        .union([
          z
            .union([
              z.number(),
              z.string(),
              z.instanceof(Decimal),
              z.instanceof(Prisma.Decimal),
              DecimalJsLikeSchema,
            ])
            .refine((v) => isValidDecimalInput(v), {
              message: 'Must be a Decimal',
            }),
          z.lazy(() => DecimalFieldUpdateOperationsInputSchema),
        ])
        .optional(),
      transactionID: z
        .union([
          z.string(),
          z.lazy(() => NullableStringFieldUpdateOperationsInputSchema),
        ])
        .optional()
        .nullable(),
      createdAt: z
        .union([
          z.coerce.date(),
          z.lazy(() => DateTimeFieldUpdateOperationsInputSchema),
        ])
        .optional(),
      createdBy: z
        .union([
          z.string(),
          z.lazy(() => NullableStringFieldUpdateOperationsInputSchema),
        ])
        .optional()
        .nullable(),
      updatedAt: z
        .union([
          z.coerce.date(),
          z.lazy(() => DateTimeFieldUpdateOperationsInputSchema),
        ])
        .optional(),
      deletedAt: z
        .union([
          z.coerce.date(),
          z.lazy(() => NullableDateTimeFieldUpdateOperationsInputSchema),
        ])
        .optional()
        .nullable(),
    })
    .strict() as z.ZodType<Prisma.PaymentUncheckedUpdateManyWithoutOrderInput>;

export const OrderPromotionCreateManyPromotionInputSchema: z.ZodType<Prisma.OrderPromotionCreateManyPromotionInput> =
  z
    .object({
      id: z.string().uuid().optional(),
      orderID: z.string(),
      discountAmount: z
        .union([
          z.number(),
          z.string(),
          z.instanceof(Decimal),
          z.instanceof(Prisma.Decimal),
          DecimalJsLikeSchema,
        ])
        .refine((v) => isValidDecimalInput(v), { message: 'Must be a Decimal' })
        .optional(),
    })
    .strict() as z.ZodType<Prisma.OrderPromotionCreateManyPromotionInput>;

export const OrderPromotionUpdateWithoutPromotionInputSchema: z.ZodType<Prisma.OrderPromotionUpdateWithoutPromotionInput> =
  z
    .object({
      id: z
        .union([
          z.string().uuid(),
          z.lazy(() => StringFieldUpdateOperationsInputSchema),
        ])
        .optional(),
      discountAmount: z
        .union([
          z
            .union([
              z.number(),
              z.string(),
              z.instanceof(Decimal),
              z.instanceof(Prisma.Decimal),
              DecimalJsLikeSchema,
            ])
            .refine((v) => isValidDecimalInput(v), {
              message: 'Must be a Decimal',
            }),
          z.lazy(() => DecimalFieldUpdateOperationsInputSchema),
        ])
        .optional(),
      order: z
        .lazy(
          () => OrderUpdateOneRequiredWithoutOrderPromotionsNestedInputSchema,
        )
        .optional(),
    })
    .strict() as z.ZodType<Prisma.OrderPromotionUpdateWithoutPromotionInput>;

export const OrderPromotionUncheckedUpdateWithoutPromotionInputSchema: z.ZodType<Prisma.OrderPromotionUncheckedUpdateWithoutPromotionInput> =
  z
    .object({
      id: z
        .union([
          z.string().uuid(),
          z.lazy(() => StringFieldUpdateOperationsInputSchema),
        ])
        .optional(),
      orderID: z
        .union([
          z.string(),
          z.lazy(() => StringFieldUpdateOperationsInputSchema),
        ])
        .optional(),
      discountAmount: z
        .union([
          z
            .union([
              z.number(),
              z.string(),
              z.instanceof(Decimal),
              z.instanceof(Prisma.Decimal),
              DecimalJsLikeSchema,
            ])
            .refine((v) => isValidDecimalInput(v), {
              message: 'Must be a Decimal',
            }),
          z.lazy(() => DecimalFieldUpdateOperationsInputSchema),
        ])
        .optional(),
    })
    .strict() as z.ZodType<Prisma.OrderPromotionUncheckedUpdateWithoutPromotionInput>;

export const OrderPromotionUncheckedUpdateManyWithoutPromotionInputSchema: z.ZodType<Prisma.OrderPromotionUncheckedUpdateManyWithoutPromotionInput> =
  z
    .object({
      id: z
        .union([
          z.string().uuid(),
          z.lazy(() => StringFieldUpdateOperationsInputSchema),
        ])
        .optional(),
      orderID: z
        .union([
          z.string(),
          z.lazy(() => StringFieldUpdateOperationsInputSchema),
        ])
        .optional(),
      discountAmount: z
        .union([
          z
            .union([
              z.number(),
              z.string(),
              z.instanceof(Decimal),
              z.instanceof(Prisma.Decimal),
              DecimalJsLikeSchema,
            ])
            .refine((v) => isValidDecimalInput(v), {
              message: 'Must be a Decimal',
            }),
          z.lazy(() => DecimalFieldUpdateOperationsInputSchema),
        ])
        .optional(),
    })
    .strict() as z.ZodType<Prisma.OrderPromotionUncheckedUpdateManyWithoutPromotionInput>;

export const CartItemCreateManyCartInputSchema: z.ZodType<Prisma.CartItemCreateManyCartInput> =
  z
    .object({
      id: z.string().uuid().optional(),
      productVariantID: z.string(),
      quantity: z.number().int().optional(),
      createdAt: z.coerce.date().optional(),
      updatedAt: z.coerce.date().optional(),
    })
    .strict() as z.ZodType<Prisma.CartItemCreateManyCartInput>;

export const CartItemUpdateWithoutCartInputSchema: z.ZodType<Prisma.CartItemUpdateWithoutCartInput> =
  z
    .object({
      id: z
        .union([
          z.string().uuid(),
          z.lazy(() => StringFieldUpdateOperationsInputSchema),
        ])
        .optional(),
      quantity: z
        .union([
          z.number().int(),
          z.lazy(() => IntFieldUpdateOperationsInputSchema),
        ])
        .optional(),
      createdAt: z
        .union([
          z.coerce.date(),
          z.lazy(() => DateTimeFieldUpdateOperationsInputSchema),
        ])
        .optional(),
      updatedAt: z
        .union([
          z.coerce.date(),
          z.lazy(() => DateTimeFieldUpdateOperationsInputSchema),
        ])
        .optional(),
      productVariant: z
        .lazy(
          () =>
            ProductVariantUpdateOneRequiredWithoutCartItemsNestedInputSchema,
        )
        .optional(),
    })
    .strict() as z.ZodType<Prisma.CartItemUpdateWithoutCartInput>;

export const CartItemUncheckedUpdateWithoutCartInputSchema: z.ZodType<Prisma.CartItemUncheckedUpdateWithoutCartInput> =
  z
    .object({
      id: z
        .union([
          z.string().uuid(),
          z.lazy(() => StringFieldUpdateOperationsInputSchema),
        ])
        .optional(),
      productVariantID: z
        .union([
          z.string(),
          z.lazy(() => StringFieldUpdateOperationsInputSchema),
        ])
        .optional(),
      quantity: z
        .union([
          z.number().int(),
          z.lazy(() => IntFieldUpdateOperationsInputSchema),
        ])
        .optional(),
      createdAt: z
        .union([
          z.coerce.date(),
          z.lazy(() => DateTimeFieldUpdateOperationsInputSchema),
        ])
        .optional(),
      updatedAt: z
        .union([
          z.coerce.date(),
          z.lazy(() => DateTimeFieldUpdateOperationsInputSchema),
        ])
        .optional(),
    })
    .strict() as z.ZodType<Prisma.CartItemUncheckedUpdateWithoutCartInput>;

export const CartItemUncheckedUpdateManyWithoutCartInputSchema: z.ZodType<Prisma.CartItemUncheckedUpdateManyWithoutCartInput> =
  z
    .object({
      id: z
        .union([
          z.string().uuid(),
          z.lazy(() => StringFieldUpdateOperationsInputSchema),
        ])
        .optional(),
      productVariantID: z
        .union([
          z.string(),
          z.lazy(() => StringFieldUpdateOperationsInputSchema),
        ])
        .optional(),
      quantity: z
        .union([
          z.number().int(),
          z.lazy(() => IntFieldUpdateOperationsInputSchema),
        ])
        .optional(),
      createdAt: z
        .union([
          z.coerce.date(),
          z.lazy(() => DateTimeFieldUpdateOperationsInputSchema),
        ])
        .optional(),
      updatedAt: z
        .union([
          z.coerce.date(),
          z.lazy(() => DateTimeFieldUpdateOperationsInputSchema),
        ])
        .optional(),
    })
    .strict() as z.ZodType<Prisma.CartItemUncheckedUpdateManyWithoutCartInput>;

/////////////////////////////////////////
// ARGS
/////////////////////////////////////////

export const UserFindFirstArgsSchema: z.ZodType<Prisma.UserFindFirstArgs> = z
  .object({
    select: UserSelectSchema.optional(),
    include: UserIncludeSchema.optional(),
    where: UserWhereInputSchema.optional(),
    orderBy: z
      .union([
        UserOrderByWithRelationInputSchema.array(),
        UserOrderByWithRelationInputSchema,
      ])
      .optional(),
    cursor: UserWhereUniqueInputSchema.optional(),
    take: z.number().optional(),
    skip: z.number().optional(),
    distinct: z
      .union([UserScalarFieldEnumSchema, UserScalarFieldEnumSchema.array()])
      .optional(),
  })
  .strict() as z.ZodType<Prisma.UserFindFirstArgs>;

export const UserFindFirstOrThrowArgsSchema: z.ZodType<Prisma.UserFindFirstOrThrowArgs> =
  z
    .object({
      select: UserSelectSchema.optional(),
      include: UserIncludeSchema.optional(),
      where: UserWhereInputSchema.optional(),
      orderBy: z
        .union([
          UserOrderByWithRelationInputSchema.array(),
          UserOrderByWithRelationInputSchema,
        ])
        .optional(),
      cursor: UserWhereUniqueInputSchema.optional(),
      take: z.number().optional(),
      skip: z.number().optional(),
      distinct: z
        .union([UserScalarFieldEnumSchema, UserScalarFieldEnumSchema.array()])
        .optional(),
    })
    .strict() as z.ZodType<Prisma.UserFindFirstOrThrowArgs>;

export const UserFindManyArgsSchema: z.ZodType<Prisma.UserFindManyArgs> = z
  .object({
    select: UserSelectSchema.optional(),
    include: UserIncludeSchema.optional(),
    where: UserWhereInputSchema.optional(),
    orderBy: z
      .union([
        UserOrderByWithRelationInputSchema.array(),
        UserOrderByWithRelationInputSchema,
      ])
      .optional(),
    cursor: UserWhereUniqueInputSchema.optional(),
    take: z.number().optional(),
    skip: z.number().optional(),
    distinct: z
      .union([UserScalarFieldEnumSchema, UserScalarFieldEnumSchema.array()])
      .optional(),
  })
  .strict() as z.ZodType<Prisma.UserFindManyArgs>;

export const UserAggregateArgsSchema: z.ZodType<Prisma.UserAggregateArgs> = z
  .object({
    where: UserWhereInputSchema.optional(),
    orderBy: z
      .union([
        UserOrderByWithRelationInputSchema.array(),
        UserOrderByWithRelationInputSchema,
      ])
      .optional(),
    cursor: UserWhereUniqueInputSchema.optional(),
    take: z.number().optional(),
    skip: z.number().optional(),
  })
  .strict() as z.ZodType<Prisma.UserAggregateArgs>;

export const UserGroupByArgsSchema: z.ZodType<Prisma.UserGroupByArgs> = z
  .object({
    where: UserWhereInputSchema.optional(),
    orderBy: z
      .union([
        UserOrderByWithAggregationInputSchema.array(),
        UserOrderByWithAggregationInputSchema,
      ])
      .optional(),
    by: UserScalarFieldEnumSchema.array(),
    having: UserScalarWhereWithAggregatesInputSchema.optional(),
    take: z.number().optional(),
    skip: z.number().optional(),
  })
  .strict() as z.ZodType<Prisma.UserGroupByArgs>;

export const UserFindUniqueArgsSchema: z.ZodType<Prisma.UserFindUniqueArgs> = z
  .object({
    select: UserSelectSchema.optional(),
    include: UserIncludeSchema.optional(),
    where: UserWhereUniqueInputSchema,
  })
  .strict() as z.ZodType<Prisma.UserFindUniqueArgs>;

export const UserFindUniqueOrThrowArgsSchema: z.ZodType<Prisma.UserFindUniqueOrThrowArgs> =
  z
    .object({
      select: UserSelectSchema.optional(),
      include: UserIncludeSchema.optional(),
      where: UserWhereUniqueInputSchema,
    })
    .strict() as z.ZodType<Prisma.UserFindUniqueOrThrowArgs>;

export const VendorFindFirstArgsSchema: z.ZodType<Prisma.VendorFindFirstArgs> =
  z
    .object({
      select: VendorSelectSchema.optional(),
      include: VendorIncludeSchema.optional(),
      where: VendorWhereInputSchema.optional(),
      orderBy: z
        .union([
          VendorOrderByWithRelationInputSchema.array(),
          VendorOrderByWithRelationInputSchema,
        ])
        .optional(),
      cursor: VendorWhereUniqueInputSchema.optional(),
      take: z.number().optional(),
      skip: z.number().optional(),
      distinct: z
        .union([
          VendorScalarFieldEnumSchema,
          VendorScalarFieldEnumSchema.array(),
        ])
        .optional(),
    })
    .strict() as z.ZodType<Prisma.VendorFindFirstArgs>;

export const VendorFindFirstOrThrowArgsSchema: z.ZodType<Prisma.VendorFindFirstOrThrowArgs> =
  z
    .object({
      select: VendorSelectSchema.optional(),
      include: VendorIncludeSchema.optional(),
      where: VendorWhereInputSchema.optional(),
      orderBy: z
        .union([
          VendorOrderByWithRelationInputSchema.array(),
          VendorOrderByWithRelationInputSchema,
        ])
        .optional(),
      cursor: VendorWhereUniqueInputSchema.optional(),
      take: z.number().optional(),
      skip: z.number().optional(),
      distinct: z
        .union([
          VendorScalarFieldEnumSchema,
          VendorScalarFieldEnumSchema.array(),
        ])
        .optional(),
    })
    .strict() as z.ZodType<Prisma.VendorFindFirstOrThrowArgs>;

export const VendorFindManyArgsSchema: z.ZodType<Prisma.VendorFindManyArgs> = z
  .object({
    select: VendorSelectSchema.optional(),
    include: VendorIncludeSchema.optional(),
    where: VendorWhereInputSchema.optional(),
    orderBy: z
      .union([
        VendorOrderByWithRelationInputSchema.array(),
        VendorOrderByWithRelationInputSchema,
      ])
      .optional(),
    cursor: VendorWhereUniqueInputSchema.optional(),
    take: z.number().optional(),
    skip: z.number().optional(),
    distinct: z
      .union([VendorScalarFieldEnumSchema, VendorScalarFieldEnumSchema.array()])
      .optional(),
  })
  .strict() as z.ZodType<Prisma.VendorFindManyArgs>;

export const VendorAggregateArgsSchema: z.ZodType<Prisma.VendorAggregateArgs> =
  z
    .object({
      where: VendorWhereInputSchema.optional(),
      orderBy: z
        .union([
          VendorOrderByWithRelationInputSchema.array(),
          VendorOrderByWithRelationInputSchema,
        ])
        .optional(),
      cursor: VendorWhereUniqueInputSchema.optional(),
      take: z.number().optional(),
      skip: z.number().optional(),
    })
    .strict() as z.ZodType<Prisma.VendorAggregateArgs>;

export const VendorGroupByArgsSchema: z.ZodType<Prisma.VendorGroupByArgs> = z
  .object({
    where: VendorWhereInputSchema.optional(),
    orderBy: z
      .union([
        VendorOrderByWithAggregationInputSchema.array(),
        VendorOrderByWithAggregationInputSchema,
      ])
      .optional(),
    by: VendorScalarFieldEnumSchema.array(),
    having: VendorScalarWhereWithAggregatesInputSchema.optional(),
    take: z.number().optional(),
    skip: z.number().optional(),
  })
  .strict() as z.ZodType<Prisma.VendorGroupByArgs>;

export const VendorFindUniqueArgsSchema: z.ZodType<Prisma.VendorFindUniqueArgs> =
  z
    .object({
      select: VendorSelectSchema.optional(),
      include: VendorIncludeSchema.optional(),
      where: VendorWhereUniqueInputSchema,
    })
    .strict() as z.ZodType<Prisma.VendorFindUniqueArgs>;

export const VendorFindUniqueOrThrowArgsSchema: z.ZodType<Prisma.VendorFindUniqueOrThrowArgs> =
  z
    .object({
      select: VendorSelectSchema.optional(),
      include: VendorIncludeSchema.optional(),
      where: VendorWhereUniqueInputSchema,
    })
    .strict() as z.ZodType<Prisma.VendorFindUniqueOrThrowArgs>;

export const RoleFindFirstArgsSchema: z.ZodType<Prisma.RoleFindFirstArgs> = z
  .object({
    select: RoleSelectSchema.optional(),
    include: RoleIncludeSchema.optional(),
    where: RoleWhereInputSchema.optional(),
    orderBy: z
      .union([
        RoleOrderByWithRelationInputSchema.array(),
        RoleOrderByWithRelationInputSchema,
      ])
      .optional(),
    cursor: RoleWhereUniqueInputSchema.optional(),
    take: z.number().optional(),
    skip: z.number().optional(),
    distinct: z
      .union([RoleScalarFieldEnumSchema, RoleScalarFieldEnumSchema.array()])
      .optional(),
  })
  .strict() as z.ZodType<Prisma.RoleFindFirstArgs>;

export const RoleFindFirstOrThrowArgsSchema: z.ZodType<Prisma.RoleFindFirstOrThrowArgs> =
  z
    .object({
      select: RoleSelectSchema.optional(),
      include: RoleIncludeSchema.optional(),
      where: RoleWhereInputSchema.optional(),
      orderBy: z
        .union([
          RoleOrderByWithRelationInputSchema.array(),
          RoleOrderByWithRelationInputSchema,
        ])
        .optional(),
      cursor: RoleWhereUniqueInputSchema.optional(),
      take: z.number().optional(),
      skip: z.number().optional(),
      distinct: z
        .union([RoleScalarFieldEnumSchema, RoleScalarFieldEnumSchema.array()])
        .optional(),
    })
    .strict() as z.ZodType<Prisma.RoleFindFirstOrThrowArgs>;

export const RoleFindManyArgsSchema: z.ZodType<Prisma.RoleFindManyArgs> = z
  .object({
    select: RoleSelectSchema.optional(),
    include: RoleIncludeSchema.optional(),
    where: RoleWhereInputSchema.optional(),
    orderBy: z
      .union([
        RoleOrderByWithRelationInputSchema.array(),
        RoleOrderByWithRelationInputSchema,
      ])
      .optional(),
    cursor: RoleWhereUniqueInputSchema.optional(),
    take: z.number().optional(),
    skip: z.number().optional(),
    distinct: z
      .union([RoleScalarFieldEnumSchema, RoleScalarFieldEnumSchema.array()])
      .optional(),
  })
  .strict() as z.ZodType<Prisma.RoleFindManyArgs>;

export const RoleAggregateArgsSchema: z.ZodType<Prisma.RoleAggregateArgs> = z
  .object({
    where: RoleWhereInputSchema.optional(),
    orderBy: z
      .union([
        RoleOrderByWithRelationInputSchema.array(),
        RoleOrderByWithRelationInputSchema,
      ])
      .optional(),
    cursor: RoleWhereUniqueInputSchema.optional(),
    take: z.number().optional(),
    skip: z.number().optional(),
  })
  .strict() as z.ZodType<Prisma.RoleAggregateArgs>;

export const RoleGroupByArgsSchema: z.ZodType<Prisma.RoleGroupByArgs> = z
  .object({
    where: RoleWhereInputSchema.optional(),
    orderBy: z
      .union([
        RoleOrderByWithAggregationInputSchema.array(),
        RoleOrderByWithAggregationInputSchema,
      ])
      .optional(),
    by: RoleScalarFieldEnumSchema.array(),
    having: RoleScalarWhereWithAggregatesInputSchema.optional(),
    take: z.number().optional(),
    skip: z.number().optional(),
  })
  .strict() as z.ZodType<Prisma.RoleGroupByArgs>;

export const RoleFindUniqueArgsSchema: z.ZodType<Prisma.RoleFindUniqueArgs> = z
  .object({
    select: RoleSelectSchema.optional(),
    include: RoleIncludeSchema.optional(),
    where: RoleWhereUniqueInputSchema,
  })
  .strict() as z.ZodType<Prisma.RoleFindUniqueArgs>;

export const RoleFindUniqueOrThrowArgsSchema: z.ZodType<Prisma.RoleFindUniqueOrThrowArgs> =
  z
    .object({
      select: RoleSelectSchema.optional(),
      include: RoleIncludeSchema.optional(),
      where: RoleWhereUniqueInputSchema,
    })
    .strict() as z.ZodType<Prisma.RoleFindUniqueOrThrowArgs>;

export const PermissionFindFirstArgsSchema: z.ZodType<Prisma.PermissionFindFirstArgs> =
  z
    .object({
      select: PermissionSelectSchema.optional(),
      include: PermissionIncludeSchema.optional(),
      where: PermissionWhereInputSchema.optional(),
      orderBy: z
        .union([
          PermissionOrderByWithRelationInputSchema.array(),
          PermissionOrderByWithRelationInputSchema,
        ])
        .optional(),
      cursor: PermissionWhereUniqueInputSchema.optional(),
      take: z.number().optional(),
      skip: z.number().optional(),
      distinct: z
        .union([
          PermissionScalarFieldEnumSchema,
          PermissionScalarFieldEnumSchema.array(),
        ])
        .optional(),
    })
    .strict() as z.ZodType<Prisma.PermissionFindFirstArgs>;

export const PermissionFindFirstOrThrowArgsSchema: z.ZodType<Prisma.PermissionFindFirstOrThrowArgs> =
  z
    .object({
      select: PermissionSelectSchema.optional(),
      include: PermissionIncludeSchema.optional(),
      where: PermissionWhereInputSchema.optional(),
      orderBy: z
        .union([
          PermissionOrderByWithRelationInputSchema.array(),
          PermissionOrderByWithRelationInputSchema,
        ])
        .optional(),
      cursor: PermissionWhereUniqueInputSchema.optional(),
      take: z.number().optional(),
      skip: z.number().optional(),
      distinct: z
        .union([
          PermissionScalarFieldEnumSchema,
          PermissionScalarFieldEnumSchema.array(),
        ])
        .optional(),
    })
    .strict() as z.ZodType<Prisma.PermissionFindFirstOrThrowArgs>;

export const PermissionFindManyArgsSchema: z.ZodType<Prisma.PermissionFindManyArgs> =
  z
    .object({
      select: PermissionSelectSchema.optional(),
      include: PermissionIncludeSchema.optional(),
      where: PermissionWhereInputSchema.optional(),
      orderBy: z
        .union([
          PermissionOrderByWithRelationInputSchema.array(),
          PermissionOrderByWithRelationInputSchema,
        ])
        .optional(),
      cursor: PermissionWhereUniqueInputSchema.optional(),
      take: z.number().optional(),
      skip: z.number().optional(),
      distinct: z
        .union([
          PermissionScalarFieldEnumSchema,
          PermissionScalarFieldEnumSchema.array(),
        ])
        .optional(),
    })
    .strict() as z.ZodType<Prisma.PermissionFindManyArgs>;

export const PermissionAggregateArgsSchema: z.ZodType<Prisma.PermissionAggregateArgs> =
  z
    .object({
      where: PermissionWhereInputSchema.optional(),
      orderBy: z
        .union([
          PermissionOrderByWithRelationInputSchema.array(),
          PermissionOrderByWithRelationInputSchema,
        ])
        .optional(),
      cursor: PermissionWhereUniqueInputSchema.optional(),
      take: z.number().optional(),
      skip: z.number().optional(),
    })
    .strict() as z.ZodType<Prisma.PermissionAggregateArgs>;

export const PermissionGroupByArgsSchema: z.ZodType<Prisma.PermissionGroupByArgs> =
  z
    .object({
      where: PermissionWhereInputSchema.optional(),
      orderBy: z
        .union([
          PermissionOrderByWithAggregationInputSchema.array(),
          PermissionOrderByWithAggregationInputSchema,
        ])
        .optional(),
      by: PermissionScalarFieldEnumSchema.array(),
      having: PermissionScalarWhereWithAggregatesInputSchema.optional(),
      take: z.number().optional(),
      skip: z.number().optional(),
    })
    .strict() as z.ZodType<Prisma.PermissionGroupByArgs>;

export const PermissionFindUniqueArgsSchema: z.ZodType<Prisma.PermissionFindUniqueArgs> =
  z
    .object({
      select: PermissionSelectSchema.optional(),
      include: PermissionIncludeSchema.optional(),
      where: PermissionWhereUniqueInputSchema,
    })
    .strict() as z.ZodType<Prisma.PermissionFindUniqueArgs>;

export const PermissionFindUniqueOrThrowArgsSchema: z.ZodType<Prisma.PermissionFindUniqueOrThrowArgs> =
  z
    .object({
      select: PermissionSelectSchema.optional(),
      include: PermissionIncludeSchema.optional(),
      where: PermissionWhereUniqueInputSchema,
    })
    .strict() as z.ZodType<Prisma.PermissionFindUniqueOrThrowArgs>;

export const RolePermissionFindFirstArgsSchema: z.ZodType<Prisma.RolePermissionFindFirstArgs> =
  z
    .object({
      select: RolePermissionSelectSchema.optional(),
      include: RolePermissionIncludeSchema.optional(),
      where: RolePermissionWhereInputSchema.optional(),
      orderBy: z
        .union([
          RolePermissionOrderByWithRelationInputSchema.array(),
          RolePermissionOrderByWithRelationInputSchema,
        ])
        .optional(),
      cursor: RolePermissionWhereUniqueInputSchema.optional(),
      take: z.number().optional(),
      skip: z.number().optional(),
      distinct: z
        .union([
          RolePermissionScalarFieldEnumSchema,
          RolePermissionScalarFieldEnumSchema.array(),
        ])
        .optional(),
    })
    .strict() as z.ZodType<Prisma.RolePermissionFindFirstArgs>;

export const RolePermissionFindFirstOrThrowArgsSchema: z.ZodType<Prisma.RolePermissionFindFirstOrThrowArgs> =
  z
    .object({
      select: RolePermissionSelectSchema.optional(),
      include: RolePermissionIncludeSchema.optional(),
      where: RolePermissionWhereInputSchema.optional(),
      orderBy: z
        .union([
          RolePermissionOrderByWithRelationInputSchema.array(),
          RolePermissionOrderByWithRelationInputSchema,
        ])
        .optional(),
      cursor: RolePermissionWhereUniqueInputSchema.optional(),
      take: z.number().optional(),
      skip: z.number().optional(),
      distinct: z
        .union([
          RolePermissionScalarFieldEnumSchema,
          RolePermissionScalarFieldEnumSchema.array(),
        ])
        .optional(),
    })
    .strict() as z.ZodType<Prisma.RolePermissionFindFirstOrThrowArgs>;

export const RolePermissionFindManyArgsSchema: z.ZodType<Prisma.RolePermissionFindManyArgs> =
  z
    .object({
      select: RolePermissionSelectSchema.optional(),
      include: RolePermissionIncludeSchema.optional(),
      where: RolePermissionWhereInputSchema.optional(),
      orderBy: z
        .union([
          RolePermissionOrderByWithRelationInputSchema.array(),
          RolePermissionOrderByWithRelationInputSchema,
        ])
        .optional(),
      cursor: RolePermissionWhereUniqueInputSchema.optional(),
      take: z.number().optional(),
      skip: z.number().optional(),
      distinct: z
        .union([
          RolePermissionScalarFieldEnumSchema,
          RolePermissionScalarFieldEnumSchema.array(),
        ])
        .optional(),
    })
    .strict() as z.ZodType<Prisma.RolePermissionFindManyArgs>;

export const RolePermissionAggregateArgsSchema: z.ZodType<Prisma.RolePermissionAggregateArgs> =
  z
    .object({
      where: RolePermissionWhereInputSchema.optional(),
      orderBy: z
        .union([
          RolePermissionOrderByWithRelationInputSchema.array(),
          RolePermissionOrderByWithRelationInputSchema,
        ])
        .optional(),
      cursor: RolePermissionWhereUniqueInputSchema.optional(),
      take: z.number().optional(),
      skip: z.number().optional(),
    })
    .strict() as z.ZodType<Prisma.RolePermissionAggregateArgs>;

export const RolePermissionGroupByArgsSchema: z.ZodType<Prisma.RolePermissionGroupByArgs> =
  z
    .object({
      where: RolePermissionWhereInputSchema.optional(),
      orderBy: z
        .union([
          RolePermissionOrderByWithAggregationInputSchema.array(),
          RolePermissionOrderByWithAggregationInputSchema,
        ])
        .optional(),
      by: RolePermissionScalarFieldEnumSchema.array(),
      having: RolePermissionScalarWhereWithAggregatesInputSchema.optional(),
      take: z.number().optional(),
      skip: z.number().optional(),
    })
    .strict() as z.ZodType<Prisma.RolePermissionGroupByArgs>;

export const RolePermissionFindUniqueArgsSchema: z.ZodType<Prisma.RolePermissionFindUniqueArgs> =
  z
    .object({
      select: RolePermissionSelectSchema.optional(),
      include: RolePermissionIncludeSchema.optional(),
      where: RolePermissionWhereUniqueInputSchema,
    })
    .strict() as z.ZodType<Prisma.RolePermissionFindUniqueArgs>;

export const RolePermissionFindUniqueOrThrowArgsSchema: z.ZodType<Prisma.RolePermissionFindUniqueOrThrowArgs> =
  z
    .object({
      select: RolePermissionSelectSchema.optional(),
      include: RolePermissionIncludeSchema.optional(),
      where: RolePermissionWhereUniqueInputSchema,
    })
    .strict() as z.ZodType<Prisma.RolePermissionFindUniqueOrThrowArgs>;

export const UserVendorRoleFindFirstArgsSchema: z.ZodType<Prisma.UserVendorRoleFindFirstArgs> =
  z
    .object({
      select: UserVendorRoleSelectSchema.optional(),
      include: UserVendorRoleIncludeSchema.optional(),
      where: UserVendorRoleWhereInputSchema.optional(),
      orderBy: z
        .union([
          UserVendorRoleOrderByWithRelationInputSchema.array(),
          UserVendorRoleOrderByWithRelationInputSchema,
        ])
        .optional(),
      cursor: UserVendorRoleWhereUniqueInputSchema.optional(),
      take: z.number().optional(),
      skip: z.number().optional(),
      distinct: z
        .union([
          UserVendorRoleScalarFieldEnumSchema,
          UserVendorRoleScalarFieldEnumSchema.array(),
        ])
        .optional(),
    })
    .strict() as z.ZodType<Prisma.UserVendorRoleFindFirstArgs>;

export const UserVendorRoleFindFirstOrThrowArgsSchema: z.ZodType<Prisma.UserVendorRoleFindFirstOrThrowArgs> =
  z
    .object({
      select: UserVendorRoleSelectSchema.optional(),
      include: UserVendorRoleIncludeSchema.optional(),
      where: UserVendorRoleWhereInputSchema.optional(),
      orderBy: z
        .union([
          UserVendorRoleOrderByWithRelationInputSchema.array(),
          UserVendorRoleOrderByWithRelationInputSchema,
        ])
        .optional(),
      cursor: UserVendorRoleWhereUniqueInputSchema.optional(),
      take: z.number().optional(),
      skip: z.number().optional(),
      distinct: z
        .union([
          UserVendorRoleScalarFieldEnumSchema,
          UserVendorRoleScalarFieldEnumSchema.array(),
        ])
        .optional(),
    })
    .strict() as z.ZodType<Prisma.UserVendorRoleFindFirstOrThrowArgs>;

export const UserVendorRoleFindManyArgsSchema: z.ZodType<Prisma.UserVendorRoleFindManyArgs> =
  z
    .object({
      select: UserVendorRoleSelectSchema.optional(),
      include: UserVendorRoleIncludeSchema.optional(),
      where: UserVendorRoleWhereInputSchema.optional(),
      orderBy: z
        .union([
          UserVendorRoleOrderByWithRelationInputSchema.array(),
          UserVendorRoleOrderByWithRelationInputSchema,
        ])
        .optional(),
      cursor: UserVendorRoleWhereUniqueInputSchema.optional(),
      take: z.number().optional(),
      skip: z.number().optional(),
      distinct: z
        .union([
          UserVendorRoleScalarFieldEnumSchema,
          UserVendorRoleScalarFieldEnumSchema.array(),
        ])
        .optional(),
    })
    .strict() as z.ZodType<Prisma.UserVendorRoleFindManyArgs>;

export const UserVendorRoleAggregateArgsSchema: z.ZodType<Prisma.UserVendorRoleAggregateArgs> =
  z
    .object({
      where: UserVendorRoleWhereInputSchema.optional(),
      orderBy: z
        .union([
          UserVendorRoleOrderByWithRelationInputSchema.array(),
          UserVendorRoleOrderByWithRelationInputSchema,
        ])
        .optional(),
      cursor: UserVendorRoleWhereUniqueInputSchema.optional(),
      take: z.number().optional(),
      skip: z.number().optional(),
    })
    .strict() as z.ZodType<Prisma.UserVendorRoleAggregateArgs>;

export const UserVendorRoleGroupByArgsSchema: z.ZodType<Prisma.UserVendorRoleGroupByArgs> =
  z
    .object({
      where: UserVendorRoleWhereInputSchema.optional(),
      orderBy: z
        .union([
          UserVendorRoleOrderByWithAggregationInputSchema.array(),
          UserVendorRoleOrderByWithAggregationInputSchema,
        ])
        .optional(),
      by: UserVendorRoleScalarFieldEnumSchema.array(),
      having: UserVendorRoleScalarWhereWithAggregatesInputSchema.optional(),
      take: z.number().optional(),
      skip: z.number().optional(),
    })
    .strict() as z.ZodType<Prisma.UserVendorRoleGroupByArgs>;

export const UserVendorRoleFindUniqueArgsSchema: z.ZodType<Prisma.UserVendorRoleFindUniqueArgs> =
  z
    .object({
      select: UserVendorRoleSelectSchema.optional(),
      include: UserVendorRoleIncludeSchema.optional(),
      where: UserVendorRoleWhereUniqueInputSchema,
    })
    .strict() as z.ZodType<Prisma.UserVendorRoleFindUniqueArgs>;

export const UserVendorRoleFindUniqueOrThrowArgsSchema: z.ZodType<Prisma.UserVendorRoleFindUniqueOrThrowArgs> =
  z
    .object({
      select: UserVendorRoleSelectSchema.optional(),
      include: UserVendorRoleIncludeSchema.optional(),
      where: UserVendorRoleWhereUniqueInputSchema,
    })
    .strict() as z.ZodType<Prisma.UserVendorRoleFindUniqueOrThrowArgs>;

export const CategoryFindFirstArgsSchema: z.ZodType<Prisma.CategoryFindFirstArgs> =
  z
    .object({
      select: CategorySelectSchema.optional(),
      include: CategoryIncludeSchema.optional(),
      where: CategoryWhereInputSchema.optional(),
      orderBy: z
        .union([
          CategoryOrderByWithRelationInputSchema.array(),
          CategoryOrderByWithRelationInputSchema,
        ])
        .optional(),
      cursor: CategoryWhereUniqueInputSchema.optional(),
      take: z.number().optional(),
      skip: z.number().optional(),
      distinct: z
        .union([
          CategoryScalarFieldEnumSchema,
          CategoryScalarFieldEnumSchema.array(),
        ])
        .optional(),
    })
    .strict() as z.ZodType<Prisma.CategoryFindFirstArgs>;

export const CategoryFindFirstOrThrowArgsSchema: z.ZodType<Prisma.CategoryFindFirstOrThrowArgs> =
  z
    .object({
      select: CategorySelectSchema.optional(),
      include: CategoryIncludeSchema.optional(),
      where: CategoryWhereInputSchema.optional(),
      orderBy: z
        .union([
          CategoryOrderByWithRelationInputSchema.array(),
          CategoryOrderByWithRelationInputSchema,
        ])
        .optional(),
      cursor: CategoryWhereUniqueInputSchema.optional(),
      take: z.number().optional(),
      skip: z.number().optional(),
      distinct: z
        .union([
          CategoryScalarFieldEnumSchema,
          CategoryScalarFieldEnumSchema.array(),
        ])
        .optional(),
    })
    .strict() as z.ZodType<Prisma.CategoryFindFirstOrThrowArgs>;

export const CategoryFindManyArgsSchema: z.ZodType<Prisma.CategoryFindManyArgs> =
  z
    .object({
      select: CategorySelectSchema.optional(),
      include: CategoryIncludeSchema.optional(),
      where: CategoryWhereInputSchema.optional(),
      orderBy: z
        .union([
          CategoryOrderByWithRelationInputSchema.array(),
          CategoryOrderByWithRelationInputSchema,
        ])
        .optional(),
      cursor: CategoryWhereUniqueInputSchema.optional(),
      take: z.number().optional(),
      skip: z.number().optional(),
      distinct: z
        .union([
          CategoryScalarFieldEnumSchema,
          CategoryScalarFieldEnumSchema.array(),
        ])
        .optional(),
    })
    .strict() as z.ZodType<Prisma.CategoryFindManyArgs>;

export const CategoryAggregateArgsSchema: z.ZodType<Prisma.CategoryAggregateArgs> =
  z
    .object({
      where: CategoryWhereInputSchema.optional(),
      orderBy: z
        .union([
          CategoryOrderByWithRelationInputSchema.array(),
          CategoryOrderByWithRelationInputSchema,
        ])
        .optional(),
      cursor: CategoryWhereUniqueInputSchema.optional(),
      take: z.number().optional(),
      skip: z.number().optional(),
    })
    .strict() as z.ZodType<Prisma.CategoryAggregateArgs>;

export const CategoryGroupByArgsSchema: z.ZodType<Prisma.CategoryGroupByArgs> =
  z
    .object({
      where: CategoryWhereInputSchema.optional(),
      orderBy: z
        .union([
          CategoryOrderByWithAggregationInputSchema.array(),
          CategoryOrderByWithAggregationInputSchema,
        ])
        .optional(),
      by: CategoryScalarFieldEnumSchema.array(),
      having: CategoryScalarWhereWithAggregatesInputSchema.optional(),
      take: z.number().optional(),
      skip: z.number().optional(),
    })
    .strict() as z.ZodType<Prisma.CategoryGroupByArgs>;

export const CategoryFindUniqueArgsSchema: z.ZodType<Prisma.CategoryFindUniqueArgs> =
  z
    .object({
      select: CategorySelectSchema.optional(),
      include: CategoryIncludeSchema.optional(),
      where: CategoryWhereUniqueInputSchema,
    })
    .strict() as z.ZodType<Prisma.CategoryFindUniqueArgs>;

export const CategoryFindUniqueOrThrowArgsSchema: z.ZodType<Prisma.CategoryFindUniqueOrThrowArgs> =
  z
    .object({
      select: CategorySelectSchema.optional(),
      include: CategoryIncludeSchema.optional(),
      where: CategoryWhereUniqueInputSchema,
    })
    .strict() as z.ZodType<Prisma.CategoryFindUniqueOrThrowArgs>;

export const ProductFindFirstArgsSchema: z.ZodType<Prisma.ProductFindFirstArgs> =
  z
    .object({
      select: ProductSelectSchema.optional(),
      include: ProductIncludeSchema.optional(),
      where: ProductWhereInputSchema.optional(),
      orderBy: z
        .union([
          ProductOrderByWithRelationInputSchema.array(),
          ProductOrderByWithRelationInputSchema,
        ])
        .optional(),
      cursor: ProductWhereUniqueInputSchema.optional(),
      take: z.number().optional(),
      skip: z.number().optional(),
      distinct: z
        .union([
          ProductScalarFieldEnumSchema,
          ProductScalarFieldEnumSchema.array(),
        ])
        .optional(),
    })
    .strict() as z.ZodType<Prisma.ProductFindFirstArgs>;

export const ProductFindFirstOrThrowArgsSchema: z.ZodType<Prisma.ProductFindFirstOrThrowArgs> =
  z
    .object({
      select: ProductSelectSchema.optional(),
      include: ProductIncludeSchema.optional(),
      where: ProductWhereInputSchema.optional(),
      orderBy: z
        .union([
          ProductOrderByWithRelationInputSchema.array(),
          ProductOrderByWithRelationInputSchema,
        ])
        .optional(),
      cursor: ProductWhereUniqueInputSchema.optional(),
      take: z.number().optional(),
      skip: z.number().optional(),
      distinct: z
        .union([
          ProductScalarFieldEnumSchema,
          ProductScalarFieldEnumSchema.array(),
        ])
        .optional(),
    })
    .strict() as z.ZodType<Prisma.ProductFindFirstOrThrowArgs>;

export const ProductFindManyArgsSchema: z.ZodType<Prisma.ProductFindManyArgs> =
  z
    .object({
      select: ProductSelectSchema.optional(),
      include: ProductIncludeSchema.optional(),
      where: ProductWhereInputSchema.optional(),
      orderBy: z
        .union([
          ProductOrderByWithRelationInputSchema.array(),
          ProductOrderByWithRelationInputSchema,
        ])
        .optional(),
      cursor: ProductWhereUniqueInputSchema.optional(),
      take: z.number().optional(),
      skip: z.number().optional(),
      distinct: z
        .union([
          ProductScalarFieldEnumSchema,
          ProductScalarFieldEnumSchema.array(),
        ])
        .optional(),
    })
    .strict() as z.ZodType<Prisma.ProductFindManyArgs>;

export const ProductAggregateArgsSchema: z.ZodType<Prisma.ProductAggregateArgs> =
  z
    .object({
      where: ProductWhereInputSchema.optional(),
      orderBy: z
        .union([
          ProductOrderByWithRelationInputSchema.array(),
          ProductOrderByWithRelationInputSchema,
        ])
        .optional(),
      cursor: ProductWhereUniqueInputSchema.optional(),
      take: z.number().optional(),
      skip: z.number().optional(),
    })
    .strict() as z.ZodType<Prisma.ProductAggregateArgs>;

export const ProductGroupByArgsSchema: z.ZodType<Prisma.ProductGroupByArgs> = z
  .object({
    where: ProductWhereInputSchema.optional(),
    orderBy: z
      .union([
        ProductOrderByWithAggregationInputSchema.array(),
        ProductOrderByWithAggregationInputSchema,
      ])
      .optional(),
    by: ProductScalarFieldEnumSchema.array(),
    having: ProductScalarWhereWithAggregatesInputSchema.optional(),
    take: z.number().optional(),
    skip: z.number().optional(),
  })
  .strict() as z.ZodType<Prisma.ProductGroupByArgs>;

export const ProductFindUniqueArgsSchema: z.ZodType<Prisma.ProductFindUniqueArgs> =
  z
    .object({
      select: ProductSelectSchema.optional(),
      include: ProductIncludeSchema.optional(),
      where: ProductWhereUniqueInputSchema,
    })
    .strict() as z.ZodType<Prisma.ProductFindUniqueArgs>;

export const ProductFindUniqueOrThrowArgsSchema: z.ZodType<Prisma.ProductFindUniqueOrThrowArgs> =
  z
    .object({
      select: ProductSelectSchema.optional(),
      include: ProductIncludeSchema.optional(),
      where: ProductWhereUniqueInputSchema,
    })
    .strict() as z.ZodType<Prisma.ProductFindUniqueOrThrowArgs>;

export const ProductVariantFindFirstArgsSchema: z.ZodType<Prisma.ProductVariantFindFirstArgs> =
  z
    .object({
      select: ProductVariantSelectSchema.optional(),
      include: ProductVariantIncludeSchema.optional(),
      where: ProductVariantWhereInputSchema.optional(),
      orderBy: z
        .union([
          ProductVariantOrderByWithRelationInputSchema.array(),
          ProductVariantOrderByWithRelationInputSchema,
        ])
        .optional(),
      cursor: ProductVariantWhereUniqueInputSchema.optional(),
      take: z.number().optional(),
      skip: z.number().optional(),
      distinct: z
        .union([
          ProductVariantScalarFieldEnumSchema,
          ProductVariantScalarFieldEnumSchema.array(),
        ])
        .optional(),
    })
    .strict() as z.ZodType<Prisma.ProductVariantFindFirstArgs>;

export const ProductVariantFindFirstOrThrowArgsSchema: z.ZodType<Prisma.ProductVariantFindFirstOrThrowArgs> =
  z
    .object({
      select: ProductVariantSelectSchema.optional(),
      include: ProductVariantIncludeSchema.optional(),
      where: ProductVariantWhereInputSchema.optional(),
      orderBy: z
        .union([
          ProductVariantOrderByWithRelationInputSchema.array(),
          ProductVariantOrderByWithRelationInputSchema,
        ])
        .optional(),
      cursor: ProductVariantWhereUniqueInputSchema.optional(),
      take: z.number().optional(),
      skip: z.number().optional(),
      distinct: z
        .union([
          ProductVariantScalarFieldEnumSchema,
          ProductVariantScalarFieldEnumSchema.array(),
        ])
        .optional(),
    })
    .strict() as z.ZodType<Prisma.ProductVariantFindFirstOrThrowArgs>;

export const ProductVariantFindManyArgsSchema: z.ZodType<Prisma.ProductVariantFindManyArgs> =
  z
    .object({
      select: ProductVariantSelectSchema.optional(),
      include: ProductVariantIncludeSchema.optional(),
      where: ProductVariantWhereInputSchema.optional(),
      orderBy: z
        .union([
          ProductVariantOrderByWithRelationInputSchema.array(),
          ProductVariantOrderByWithRelationInputSchema,
        ])
        .optional(),
      cursor: ProductVariantWhereUniqueInputSchema.optional(),
      take: z.number().optional(),
      skip: z.number().optional(),
      distinct: z
        .union([
          ProductVariantScalarFieldEnumSchema,
          ProductVariantScalarFieldEnumSchema.array(),
        ])
        .optional(),
    })
    .strict() as z.ZodType<Prisma.ProductVariantFindManyArgs>;

export const ProductVariantAggregateArgsSchema: z.ZodType<Prisma.ProductVariantAggregateArgs> =
  z
    .object({
      where: ProductVariantWhereInputSchema.optional(),
      orderBy: z
        .union([
          ProductVariantOrderByWithRelationInputSchema.array(),
          ProductVariantOrderByWithRelationInputSchema,
        ])
        .optional(),
      cursor: ProductVariantWhereUniqueInputSchema.optional(),
      take: z.number().optional(),
      skip: z.number().optional(),
    })
    .strict() as z.ZodType<Prisma.ProductVariantAggregateArgs>;

export const ProductVariantGroupByArgsSchema: z.ZodType<Prisma.ProductVariantGroupByArgs> =
  z
    .object({
      where: ProductVariantWhereInputSchema.optional(),
      orderBy: z
        .union([
          ProductVariantOrderByWithAggregationInputSchema.array(),
          ProductVariantOrderByWithAggregationInputSchema,
        ])
        .optional(),
      by: ProductVariantScalarFieldEnumSchema.array(),
      having: ProductVariantScalarWhereWithAggregatesInputSchema.optional(),
      take: z.number().optional(),
      skip: z.number().optional(),
    })
    .strict() as z.ZodType<Prisma.ProductVariantGroupByArgs>;

export const ProductVariantFindUniqueArgsSchema: z.ZodType<Prisma.ProductVariantFindUniqueArgs> =
  z
    .object({
      select: ProductVariantSelectSchema.optional(),
      include: ProductVariantIncludeSchema.optional(),
      where: ProductVariantWhereUniqueInputSchema,
    })
    .strict() as z.ZodType<Prisma.ProductVariantFindUniqueArgs>;

export const ProductVariantFindUniqueOrThrowArgsSchema: z.ZodType<Prisma.ProductVariantFindUniqueOrThrowArgs> =
  z
    .object({
      select: ProductVariantSelectSchema.optional(),
      include: ProductVariantIncludeSchema.optional(),
      where: ProductVariantWhereUniqueInputSchema,
    })
    .strict() as z.ZodType<Prisma.ProductVariantFindUniqueOrThrowArgs>;

export const ProductCategoryFindFirstArgsSchema: z.ZodType<Prisma.ProductCategoryFindFirstArgs> =
  z
    .object({
      select: ProductCategorySelectSchema.optional(),
      include: ProductCategoryIncludeSchema.optional(),
      where: ProductCategoryWhereInputSchema.optional(),
      orderBy: z
        .union([
          ProductCategoryOrderByWithRelationInputSchema.array(),
          ProductCategoryOrderByWithRelationInputSchema,
        ])
        .optional(),
      cursor: ProductCategoryWhereUniqueInputSchema.optional(),
      take: z.number().optional(),
      skip: z.number().optional(),
      distinct: z
        .union([
          ProductCategoryScalarFieldEnumSchema,
          ProductCategoryScalarFieldEnumSchema.array(),
        ])
        .optional(),
    })
    .strict() as z.ZodType<Prisma.ProductCategoryFindFirstArgs>;

export const ProductCategoryFindFirstOrThrowArgsSchema: z.ZodType<Prisma.ProductCategoryFindFirstOrThrowArgs> =
  z
    .object({
      select: ProductCategorySelectSchema.optional(),
      include: ProductCategoryIncludeSchema.optional(),
      where: ProductCategoryWhereInputSchema.optional(),
      orderBy: z
        .union([
          ProductCategoryOrderByWithRelationInputSchema.array(),
          ProductCategoryOrderByWithRelationInputSchema,
        ])
        .optional(),
      cursor: ProductCategoryWhereUniqueInputSchema.optional(),
      take: z.number().optional(),
      skip: z.number().optional(),
      distinct: z
        .union([
          ProductCategoryScalarFieldEnumSchema,
          ProductCategoryScalarFieldEnumSchema.array(),
        ])
        .optional(),
    })
    .strict() as z.ZodType<Prisma.ProductCategoryFindFirstOrThrowArgs>;

export const ProductCategoryFindManyArgsSchema: z.ZodType<Prisma.ProductCategoryFindManyArgs> =
  z
    .object({
      select: ProductCategorySelectSchema.optional(),
      include: ProductCategoryIncludeSchema.optional(),
      where: ProductCategoryWhereInputSchema.optional(),
      orderBy: z
        .union([
          ProductCategoryOrderByWithRelationInputSchema.array(),
          ProductCategoryOrderByWithRelationInputSchema,
        ])
        .optional(),
      cursor: ProductCategoryWhereUniqueInputSchema.optional(),
      take: z.number().optional(),
      skip: z.number().optional(),
      distinct: z
        .union([
          ProductCategoryScalarFieldEnumSchema,
          ProductCategoryScalarFieldEnumSchema.array(),
        ])
        .optional(),
    })
    .strict() as z.ZodType<Prisma.ProductCategoryFindManyArgs>;

export const ProductCategoryAggregateArgsSchema: z.ZodType<Prisma.ProductCategoryAggregateArgs> =
  z
    .object({
      where: ProductCategoryWhereInputSchema.optional(),
      orderBy: z
        .union([
          ProductCategoryOrderByWithRelationInputSchema.array(),
          ProductCategoryOrderByWithRelationInputSchema,
        ])
        .optional(),
      cursor: ProductCategoryWhereUniqueInputSchema.optional(),
      take: z.number().optional(),
      skip: z.number().optional(),
    })
    .strict() as z.ZodType<Prisma.ProductCategoryAggregateArgs>;

export const ProductCategoryGroupByArgsSchema: z.ZodType<Prisma.ProductCategoryGroupByArgs> =
  z
    .object({
      where: ProductCategoryWhereInputSchema.optional(),
      orderBy: z
        .union([
          ProductCategoryOrderByWithAggregationInputSchema.array(),
          ProductCategoryOrderByWithAggregationInputSchema,
        ])
        .optional(),
      by: ProductCategoryScalarFieldEnumSchema.array(),
      having: ProductCategoryScalarWhereWithAggregatesInputSchema.optional(),
      take: z.number().optional(),
      skip: z.number().optional(),
    })
    .strict() as z.ZodType<Prisma.ProductCategoryGroupByArgs>;

export const ProductCategoryFindUniqueArgsSchema: z.ZodType<Prisma.ProductCategoryFindUniqueArgs> =
  z
    .object({
      select: ProductCategorySelectSchema.optional(),
      include: ProductCategoryIncludeSchema.optional(),
      where: ProductCategoryWhereUniqueInputSchema,
    })
    .strict() as z.ZodType<Prisma.ProductCategoryFindUniqueArgs>;

export const ProductCategoryFindUniqueOrThrowArgsSchema: z.ZodType<Prisma.ProductCategoryFindUniqueOrThrowArgs> =
  z
    .object({
      select: ProductCategorySelectSchema.optional(),
      include: ProductCategoryIncludeSchema.optional(),
      where: ProductCategoryWhereUniqueInputSchema,
    })
    .strict() as z.ZodType<Prisma.ProductCategoryFindUniqueOrThrowArgs>;

export const ProductImageFindFirstArgsSchema: z.ZodType<Prisma.ProductImageFindFirstArgs> =
  z
    .object({
      select: ProductImageSelectSchema.optional(),
      include: ProductImageIncludeSchema.optional(),
      where: ProductImageWhereInputSchema.optional(),
      orderBy: z
        .union([
          ProductImageOrderByWithRelationInputSchema.array(),
          ProductImageOrderByWithRelationInputSchema,
        ])
        .optional(),
      cursor: ProductImageWhereUniqueInputSchema.optional(),
      take: z.number().optional(),
      skip: z.number().optional(),
      distinct: z
        .union([
          ProductImageScalarFieldEnumSchema,
          ProductImageScalarFieldEnumSchema.array(),
        ])
        .optional(),
    })
    .strict() as z.ZodType<Prisma.ProductImageFindFirstArgs>;

export const ProductImageFindFirstOrThrowArgsSchema: z.ZodType<Prisma.ProductImageFindFirstOrThrowArgs> =
  z
    .object({
      select: ProductImageSelectSchema.optional(),
      include: ProductImageIncludeSchema.optional(),
      where: ProductImageWhereInputSchema.optional(),
      orderBy: z
        .union([
          ProductImageOrderByWithRelationInputSchema.array(),
          ProductImageOrderByWithRelationInputSchema,
        ])
        .optional(),
      cursor: ProductImageWhereUniqueInputSchema.optional(),
      take: z.number().optional(),
      skip: z.number().optional(),
      distinct: z
        .union([
          ProductImageScalarFieldEnumSchema,
          ProductImageScalarFieldEnumSchema.array(),
        ])
        .optional(),
    })
    .strict() as z.ZodType<Prisma.ProductImageFindFirstOrThrowArgs>;

export const ProductImageFindManyArgsSchema: z.ZodType<Prisma.ProductImageFindManyArgs> =
  z
    .object({
      select: ProductImageSelectSchema.optional(),
      include: ProductImageIncludeSchema.optional(),
      where: ProductImageWhereInputSchema.optional(),
      orderBy: z
        .union([
          ProductImageOrderByWithRelationInputSchema.array(),
          ProductImageOrderByWithRelationInputSchema,
        ])
        .optional(),
      cursor: ProductImageWhereUniqueInputSchema.optional(),
      take: z.number().optional(),
      skip: z.number().optional(),
      distinct: z
        .union([
          ProductImageScalarFieldEnumSchema,
          ProductImageScalarFieldEnumSchema.array(),
        ])
        .optional(),
    })
    .strict() as z.ZodType<Prisma.ProductImageFindManyArgs>;

export const ProductImageAggregateArgsSchema: z.ZodType<Prisma.ProductImageAggregateArgs> =
  z
    .object({
      where: ProductImageWhereInputSchema.optional(),
      orderBy: z
        .union([
          ProductImageOrderByWithRelationInputSchema.array(),
          ProductImageOrderByWithRelationInputSchema,
        ])
        .optional(),
      cursor: ProductImageWhereUniqueInputSchema.optional(),
      take: z.number().optional(),
      skip: z.number().optional(),
    })
    .strict() as z.ZodType<Prisma.ProductImageAggregateArgs>;

export const ProductImageGroupByArgsSchema: z.ZodType<Prisma.ProductImageGroupByArgs> =
  z
    .object({
      where: ProductImageWhereInputSchema.optional(),
      orderBy: z
        .union([
          ProductImageOrderByWithAggregationInputSchema.array(),
          ProductImageOrderByWithAggregationInputSchema,
        ])
        .optional(),
      by: ProductImageScalarFieldEnumSchema.array(),
      having: ProductImageScalarWhereWithAggregatesInputSchema.optional(),
      take: z.number().optional(),
      skip: z.number().optional(),
    })
    .strict() as z.ZodType<Prisma.ProductImageGroupByArgs>;

export const ProductImageFindUniqueArgsSchema: z.ZodType<Prisma.ProductImageFindUniqueArgs> =
  z
    .object({
      select: ProductImageSelectSchema.optional(),
      include: ProductImageIncludeSchema.optional(),
      where: ProductImageWhereUniqueInputSchema,
    })
    .strict() as z.ZodType<Prisma.ProductImageFindUniqueArgs>;

export const ProductImageFindUniqueOrThrowArgsSchema: z.ZodType<Prisma.ProductImageFindUniqueOrThrowArgs> =
  z
    .object({
      select: ProductImageSelectSchema.optional(),
      include: ProductImageIncludeSchema.optional(),
      where: ProductImageWhereUniqueInputSchema,
    })
    .strict() as z.ZodType<Prisma.ProductImageFindUniqueOrThrowArgs>;

export const OrderFindFirstArgsSchema: z.ZodType<Prisma.OrderFindFirstArgs> = z
  .object({
    select: OrderSelectSchema.optional(),
    include: OrderIncludeSchema.optional(),
    where: OrderWhereInputSchema.optional(),
    orderBy: z
      .union([
        OrderOrderByWithRelationInputSchema.array(),
        OrderOrderByWithRelationInputSchema,
      ])
      .optional(),
    cursor: OrderWhereUniqueInputSchema.optional(),
    take: z.number().optional(),
    skip: z.number().optional(),
    distinct: z
      .union([OrderScalarFieldEnumSchema, OrderScalarFieldEnumSchema.array()])
      .optional(),
  })
  .strict() as z.ZodType<Prisma.OrderFindFirstArgs>;

export const OrderFindFirstOrThrowArgsSchema: z.ZodType<Prisma.OrderFindFirstOrThrowArgs> =
  z
    .object({
      select: OrderSelectSchema.optional(),
      include: OrderIncludeSchema.optional(),
      where: OrderWhereInputSchema.optional(),
      orderBy: z
        .union([
          OrderOrderByWithRelationInputSchema.array(),
          OrderOrderByWithRelationInputSchema,
        ])
        .optional(),
      cursor: OrderWhereUniqueInputSchema.optional(),
      take: z.number().optional(),
      skip: z.number().optional(),
      distinct: z
        .union([OrderScalarFieldEnumSchema, OrderScalarFieldEnumSchema.array()])
        .optional(),
    })
    .strict() as z.ZodType<Prisma.OrderFindFirstOrThrowArgs>;

export const OrderFindManyArgsSchema: z.ZodType<Prisma.OrderFindManyArgs> = z
  .object({
    select: OrderSelectSchema.optional(),
    include: OrderIncludeSchema.optional(),
    where: OrderWhereInputSchema.optional(),
    orderBy: z
      .union([
        OrderOrderByWithRelationInputSchema.array(),
        OrderOrderByWithRelationInputSchema,
      ])
      .optional(),
    cursor: OrderWhereUniqueInputSchema.optional(),
    take: z.number().optional(),
    skip: z.number().optional(),
    distinct: z
      .union([OrderScalarFieldEnumSchema, OrderScalarFieldEnumSchema.array()])
      .optional(),
  })
  .strict() as z.ZodType<Prisma.OrderFindManyArgs>;

export const OrderAggregateArgsSchema: z.ZodType<Prisma.OrderAggregateArgs> = z
  .object({
    where: OrderWhereInputSchema.optional(),
    orderBy: z
      .union([
        OrderOrderByWithRelationInputSchema.array(),
        OrderOrderByWithRelationInputSchema,
      ])
      .optional(),
    cursor: OrderWhereUniqueInputSchema.optional(),
    take: z.number().optional(),
    skip: z.number().optional(),
  })
  .strict() as z.ZodType<Prisma.OrderAggregateArgs>;

export const OrderGroupByArgsSchema: z.ZodType<Prisma.OrderGroupByArgs> = z
  .object({
    where: OrderWhereInputSchema.optional(),
    orderBy: z
      .union([
        OrderOrderByWithAggregationInputSchema.array(),
        OrderOrderByWithAggregationInputSchema,
      ])
      .optional(),
    by: OrderScalarFieldEnumSchema.array(),
    having: OrderScalarWhereWithAggregatesInputSchema.optional(),
    take: z.number().optional(),
    skip: z.number().optional(),
  })
  .strict() as z.ZodType<Prisma.OrderGroupByArgs>;

export const OrderFindUniqueArgsSchema: z.ZodType<Prisma.OrderFindUniqueArgs> =
  z
    .object({
      select: OrderSelectSchema.optional(),
      include: OrderIncludeSchema.optional(),
      where: OrderWhereUniqueInputSchema,
    })
    .strict() as z.ZodType<Prisma.OrderFindUniqueArgs>;

export const OrderFindUniqueOrThrowArgsSchema: z.ZodType<Prisma.OrderFindUniqueOrThrowArgs> =
  z
    .object({
      select: OrderSelectSchema.optional(),
      include: OrderIncludeSchema.optional(),
      where: OrderWhereUniqueInputSchema,
    })
    .strict() as z.ZodType<Prisma.OrderFindUniqueOrThrowArgs>;

export const OrderItemFindFirstArgsSchema: z.ZodType<Prisma.OrderItemFindFirstArgs> =
  z
    .object({
      select: OrderItemSelectSchema.optional(),
      include: OrderItemIncludeSchema.optional(),
      where: OrderItemWhereInputSchema.optional(),
      orderBy: z
        .union([
          OrderItemOrderByWithRelationInputSchema.array(),
          OrderItemOrderByWithRelationInputSchema,
        ])
        .optional(),
      cursor: OrderItemWhereUniqueInputSchema.optional(),
      take: z.number().optional(),
      skip: z.number().optional(),
      distinct: z
        .union([
          OrderItemScalarFieldEnumSchema,
          OrderItemScalarFieldEnumSchema.array(),
        ])
        .optional(),
    })
    .strict() as z.ZodType<Prisma.OrderItemFindFirstArgs>;

export const OrderItemFindFirstOrThrowArgsSchema: z.ZodType<Prisma.OrderItemFindFirstOrThrowArgs> =
  z
    .object({
      select: OrderItemSelectSchema.optional(),
      include: OrderItemIncludeSchema.optional(),
      where: OrderItemWhereInputSchema.optional(),
      orderBy: z
        .union([
          OrderItemOrderByWithRelationInputSchema.array(),
          OrderItemOrderByWithRelationInputSchema,
        ])
        .optional(),
      cursor: OrderItemWhereUniqueInputSchema.optional(),
      take: z.number().optional(),
      skip: z.number().optional(),
      distinct: z
        .union([
          OrderItemScalarFieldEnumSchema,
          OrderItemScalarFieldEnumSchema.array(),
        ])
        .optional(),
    })
    .strict() as z.ZodType<Prisma.OrderItemFindFirstOrThrowArgs>;

export const OrderItemFindManyArgsSchema: z.ZodType<Prisma.OrderItemFindManyArgs> =
  z
    .object({
      select: OrderItemSelectSchema.optional(),
      include: OrderItemIncludeSchema.optional(),
      where: OrderItemWhereInputSchema.optional(),
      orderBy: z
        .union([
          OrderItemOrderByWithRelationInputSchema.array(),
          OrderItemOrderByWithRelationInputSchema,
        ])
        .optional(),
      cursor: OrderItemWhereUniqueInputSchema.optional(),
      take: z.number().optional(),
      skip: z.number().optional(),
      distinct: z
        .union([
          OrderItemScalarFieldEnumSchema,
          OrderItemScalarFieldEnumSchema.array(),
        ])
        .optional(),
    })
    .strict() as z.ZodType<Prisma.OrderItemFindManyArgs>;

export const OrderItemAggregateArgsSchema: z.ZodType<Prisma.OrderItemAggregateArgs> =
  z
    .object({
      where: OrderItemWhereInputSchema.optional(),
      orderBy: z
        .union([
          OrderItemOrderByWithRelationInputSchema.array(),
          OrderItemOrderByWithRelationInputSchema,
        ])
        .optional(),
      cursor: OrderItemWhereUniqueInputSchema.optional(),
      take: z.number().optional(),
      skip: z.number().optional(),
    })
    .strict() as z.ZodType<Prisma.OrderItemAggregateArgs>;

export const OrderItemGroupByArgsSchema: z.ZodType<Prisma.OrderItemGroupByArgs> =
  z
    .object({
      where: OrderItemWhereInputSchema.optional(),
      orderBy: z
        .union([
          OrderItemOrderByWithAggregationInputSchema.array(),
          OrderItemOrderByWithAggregationInputSchema,
        ])
        .optional(),
      by: OrderItemScalarFieldEnumSchema.array(),
      having: OrderItemScalarWhereWithAggregatesInputSchema.optional(),
      take: z.number().optional(),
      skip: z.number().optional(),
    })
    .strict() as z.ZodType<Prisma.OrderItemGroupByArgs>;

export const OrderItemFindUniqueArgsSchema: z.ZodType<Prisma.OrderItemFindUniqueArgs> =
  z
    .object({
      select: OrderItemSelectSchema.optional(),
      include: OrderItemIncludeSchema.optional(),
      where: OrderItemWhereUniqueInputSchema,
    })
    .strict() as z.ZodType<Prisma.OrderItemFindUniqueArgs>;

export const OrderItemFindUniqueOrThrowArgsSchema: z.ZodType<Prisma.OrderItemFindUniqueOrThrowArgs> =
  z
    .object({
      select: OrderItemSelectSchema.optional(),
      include: OrderItemIncludeSchema.optional(),
      where: OrderItemWhereUniqueInputSchema,
    })
    .strict() as z.ZodType<Prisma.OrderItemFindUniqueOrThrowArgs>;

export const OrderAddressFindFirstArgsSchema: z.ZodType<Prisma.OrderAddressFindFirstArgs> =
  z
    .object({
      select: OrderAddressSelectSchema.optional(),
      include: OrderAddressIncludeSchema.optional(),
      where: OrderAddressWhereInputSchema.optional(),
      orderBy: z
        .union([
          OrderAddressOrderByWithRelationInputSchema.array(),
          OrderAddressOrderByWithRelationInputSchema,
        ])
        .optional(),
      cursor: OrderAddressWhereUniqueInputSchema.optional(),
      take: z.number().optional(),
      skip: z.number().optional(),
      distinct: z
        .union([
          OrderAddressScalarFieldEnumSchema,
          OrderAddressScalarFieldEnumSchema.array(),
        ])
        .optional(),
    })
    .strict() as z.ZodType<Prisma.OrderAddressFindFirstArgs>;

export const OrderAddressFindFirstOrThrowArgsSchema: z.ZodType<Prisma.OrderAddressFindFirstOrThrowArgs> =
  z
    .object({
      select: OrderAddressSelectSchema.optional(),
      include: OrderAddressIncludeSchema.optional(),
      where: OrderAddressWhereInputSchema.optional(),
      orderBy: z
        .union([
          OrderAddressOrderByWithRelationInputSchema.array(),
          OrderAddressOrderByWithRelationInputSchema,
        ])
        .optional(),
      cursor: OrderAddressWhereUniqueInputSchema.optional(),
      take: z.number().optional(),
      skip: z.number().optional(),
      distinct: z
        .union([
          OrderAddressScalarFieldEnumSchema,
          OrderAddressScalarFieldEnumSchema.array(),
        ])
        .optional(),
    })
    .strict() as z.ZodType<Prisma.OrderAddressFindFirstOrThrowArgs>;

export const OrderAddressFindManyArgsSchema: z.ZodType<Prisma.OrderAddressFindManyArgs> =
  z
    .object({
      select: OrderAddressSelectSchema.optional(),
      include: OrderAddressIncludeSchema.optional(),
      where: OrderAddressWhereInputSchema.optional(),
      orderBy: z
        .union([
          OrderAddressOrderByWithRelationInputSchema.array(),
          OrderAddressOrderByWithRelationInputSchema,
        ])
        .optional(),
      cursor: OrderAddressWhereUniqueInputSchema.optional(),
      take: z.number().optional(),
      skip: z.number().optional(),
      distinct: z
        .union([
          OrderAddressScalarFieldEnumSchema,
          OrderAddressScalarFieldEnumSchema.array(),
        ])
        .optional(),
    })
    .strict() as z.ZodType<Prisma.OrderAddressFindManyArgs>;

export const OrderAddressAggregateArgsSchema: z.ZodType<Prisma.OrderAddressAggregateArgs> =
  z
    .object({
      where: OrderAddressWhereInputSchema.optional(),
      orderBy: z
        .union([
          OrderAddressOrderByWithRelationInputSchema.array(),
          OrderAddressOrderByWithRelationInputSchema,
        ])
        .optional(),
      cursor: OrderAddressWhereUniqueInputSchema.optional(),
      take: z.number().optional(),
      skip: z.number().optional(),
    })
    .strict() as z.ZodType<Prisma.OrderAddressAggregateArgs>;

export const OrderAddressGroupByArgsSchema: z.ZodType<Prisma.OrderAddressGroupByArgs> =
  z
    .object({
      where: OrderAddressWhereInputSchema.optional(),
      orderBy: z
        .union([
          OrderAddressOrderByWithAggregationInputSchema.array(),
          OrderAddressOrderByWithAggregationInputSchema,
        ])
        .optional(),
      by: OrderAddressScalarFieldEnumSchema.array(),
      having: OrderAddressScalarWhereWithAggregatesInputSchema.optional(),
      take: z.number().optional(),
      skip: z.number().optional(),
    })
    .strict() as z.ZodType<Prisma.OrderAddressGroupByArgs>;

export const OrderAddressFindUniqueArgsSchema: z.ZodType<Prisma.OrderAddressFindUniqueArgs> =
  z
    .object({
      select: OrderAddressSelectSchema.optional(),
      include: OrderAddressIncludeSchema.optional(),
      where: OrderAddressWhereUniqueInputSchema,
    })
    .strict() as z.ZodType<Prisma.OrderAddressFindUniqueArgs>;

export const OrderAddressFindUniqueOrThrowArgsSchema: z.ZodType<Prisma.OrderAddressFindUniqueOrThrowArgs> =
  z
    .object({
      select: OrderAddressSelectSchema.optional(),
      include: OrderAddressIncludeSchema.optional(),
      where: OrderAddressWhereUniqueInputSchema,
    })
    .strict() as z.ZodType<Prisma.OrderAddressFindUniqueOrThrowArgs>;

export const PromotionFindFirstArgsSchema: z.ZodType<Prisma.PromotionFindFirstArgs> =
  z
    .object({
      select: PromotionSelectSchema.optional(),
      include: PromotionIncludeSchema.optional(),
      where: PromotionWhereInputSchema.optional(),
      orderBy: z
        .union([
          PromotionOrderByWithRelationInputSchema.array(),
          PromotionOrderByWithRelationInputSchema,
        ])
        .optional(),
      cursor: PromotionWhereUniqueInputSchema.optional(),
      take: z.number().optional(),
      skip: z.number().optional(),
      distinct: z
        .union([
          PromotionScalarFieldEnumSchema,
          PromotionScalarFieldEnumSchema.array(),
        ])
        .optional(),
    })
    .strict() as z.ZodType<Prisma.PromotionFindFirstArgs>;

export const PromotionFindFirstOrThrowArgsSchema: z.ZodType<Prisma.PromotionFindFirstOrThrowArgs> =
  z
    .object({
      select: PromotionSelectSchema.optional(),
      include: PromotionIncludeSchema.optional(),
      where: PromotionWhereInputSchema.optional(),
      orderBy: z
        .union([
          PromotionOrderByWithRelationInputSchema.array(),
          PromotionOrderByWithRelationInputSchema,
        ])
        .optional(),
      cursor: PromotionWhereUniqueInputSchema.optional(),
      take: z.number().optional(),
      skip: z.number().optional(),
      distinct: z
        .union([
          PromotionScalarFieldEnumSchema,
          PromotionScalarFieldEnumSchema.array(),
        ])
        .optional(),
    })
    .strict() as z.ZodType<Prisma.PromotionFindFirstOrThrowArgs>;

export const PromotionFindManyArgsSchema: z.ZodType<Prisma.PromotionFindManyArgs> =
  z
    .object({
      select: PromotionSelectSchema.optional(),
      include: PromotionIncludeSchema.optional(),
      where: PromotionWhereInputSchema.optional(),
      orderBy: z
        .union([
          PromotionOrderByWithRelationInputSchema.array(),
          PromotionOrderByWithRelationInputSchema,
        ])
        .optional(),
      cursor: PromotionWhereUniqueInputSchema.optional(),
      take: z.number().optional(),
      skip: z.number().optional(),
      distinct: z
        .union([
          PromotionScalarFieldEnumSchema,
          PromotionScalarFieldEnumSchema.array(),
        ])
        .optional(),
    })
    .strict() as z.ZodType<Prisma.PromotionFindManyArgs>;

export const PromotionAggregateArgsSchema: z.ZodType<Prisma.PromotionAggregateArgs> =
  z
    .object({
      where: PromotionWhereInputSchema.optional(),
      orderBy: z
        .union([
          PromotionOrderByWithRelationInputSchema.array(),
          PromotionOrderByWithRelationInputSchema,
        ])
        .optional(),
      cursor: PromotionWhereUniqueInputSchema.optional(),
      take: z.number().optional(),
      skip: z.number().optional(),
    })
    .strict() as z.ZodType<Prisma.PromotionAggregateArgs>;

export const PromotionGroupByArgsSchema: z.ZodType<Prisma.PromotionGroupByArgs> =
  z
    .object({
      where: PromotionWhereInputSchema.optional(),
      orderBy: z
        .union([
          PromotionOrderByWithAggregationInputSchema.array(),
          PromotionOrderByWithAggregationInputSchema,
        ])
        .optional(),
      by: PromotionScalarFieldEnumSchema.array(),
      having: PromotionScalarWhereWithAggregatesInputSchema.optional(),
      take: z.number().optional(),
      skip: z.number().optional(),
    })
    .strict() as z.ZodType<Prisma.PromotionGroupByArgs>;

export const PromotionFindUniqueArgsSchema: z.ZodType<Prisma.PromotionFindUniqueArgs> =
  z
    .object({
      select: PromotionSelectSchema.optional(),
      include: PromotionIncludeSchema.optional(),
      where: PromotionWhereUniqueInputSchema,
    })
    .strict() as z.ZodType<Prisma.PromotionFindUniqueArgs>;

export const PromotionFindUniqueOrThrowArgsSchema: z.ZodType<Prisma.PromotionFindUniqueOrThrowArgs> =
  z
    .object({
      select: PromotionSelectSchema.optional(),
      include: PromotionIncludeSchema.optional(),
      where: PromotionWhereUniqueInputSchema,
    })
    .strict() as z.ZodType<Prisma.PromotionFindUniqueOrThrowArgs>;

export const OrderPromotionFindFirstArgsSchema: z.ZodType<Prisma.OrderPromotionFindFirstArgs> =
  z
    .object({
      select: OrderPromotionSelectSchema.optional(),
      include: OrderPromotionIncludeSchema.optional(),
      where: OrderPromotionWhereInputSchema.optional(),
      orderBy: z
        .union([
          OrderPromotionOrderByWithRelationInputSchema.array(),
          OrderPromotionOrderByWithRelationInputSchema,
        ])
        .optional(),
      cursor: OrderPromotionWhereUniqueInputSchema.optional(),
      take: z.number().optional(),
      skip: z.number().optional(),
      distinct: z
        .union([
          OrderPromotionScalarFieldEnumSchema,
          OrderPromotionScalarFieldEnumSchema.array(),
        ])
        .optional(),
    })
    .strict() as z.ZodType<Prisma.OrderPromotionFindFirstArgs>;

export const OrderPromotionFindFirstOrThrowArgsSchema: z.ZodType<Prisma.OrderPromotionFindFirstOrThrowArgs> =
  z
    .object({
      select: OrderPromotionSelectSchema.optional(),
      include: OrderPromotionIncludeSchema.optional(),
      where: OrderPromotionWhereInputSchema.optional(),
      orderBy: z
        .union([
          OrderPromotionOrderByWithRelationInputSchema.array(),
          OrderPromotionOrderByWithRelationInputSchema,
        ])
        .optional(),
      cursor: OrderPromotionWhereUniqueInputSchema.optional(),
      take: z.number().optional(),
      skip: z.number().optional(),
      distinct: z
        .union([
          OrderPromotionScalarFieldEnumSchema,
          OrderPromotionScalarFieldEnumSchema.array(),
        ])
        .optional(),
    })
    .strict() as z.ZodType<Prisma.OrderPromotionFindFirstOrThrowArgs>;

export const OrderPromotionFindManyArgsSchema: z.ZodType<Prisma.OrderPromotionFindManyArgs> =
  z
    .object({
      select: OrderPromotionSelectSchema.optional(),
      include: OrderPromotionIncludeSchema.optional(),
      where: OrderPromotionWhereInputSchema.optional(),
      orderBy: z
        .union([
          OrderPromotionOrderByWithRelationInputSchema.array(),
          OrderPromotionOrderByWithRelationInputSchema,
        ])
        .optional(),
      cursor: OrderPromotionWhereUniqueInputSchema.optional(),
      take: z.number().optional(),
      skip: z.number().optional(),
      distinct: z
        .union([
          OrderPromotionScalarFieldEnumSchema,
          OrderPromotionScalarFieldEnumSchema.array(),
        ])
        .optional(),
    })
    .strict() as z.ZodType<Prisma.OrderPromotionFindManyArgs>;

export const OrderPromotionAggregateArgsSchema: z.ZodType<Prisma.OrderPromotionAggregateArgs> =
  z
    .object({
      where: OrderPromotionWhereInputSchema.optional(),
      orderBy: z
        .union([
          OrderPromotionOrderByWithRelationInputSchema.array(),
          OrderPromotionOrderByWithRelationInputSchema,
        ])
        .optional(),
      cursor: OrderPromotionWhereUniqueInputSchema.optional(),
      take: z.number().optional(),
      skip: z.number().optional(),
    })
    .strict() as z.ZodType<Prisma.OrderPromotionAggregateArgs>;

export const OrderPromotionGroupByArgsSchema: z.ZodType<Prisma.OrderPromotionGroupByArgs> =
  z
    .object({
      where: OrderPromotionWhereInputSchema.optional(),
      orderBy: z
        .union([
          OrderPromotionOrderByWithAggregationInputSchema.array(),
          OrderPromotionOrderByWithAggregationInputSchema,
        ])
        .optional(),
      by: OrderPromotionScalarFieldEnumSchema.array(),
      having: OrderPromotionScalarWhereWithAggregatesInputSchema.optional(),
      take: z.number().optional(),
      skip: z.number().optional(),
    })
    .strict() as z.ZodType<Prisma.OrderPromotionGroupByArgs>;

export const OrderPromotionFindUniqueArgsSchema: z.ZodType<Prisma.OrderPromotionFindUniqueArgs> =
  z
    .object({
      select: OrderPromotionSelectSchema.optional(),
      include: OrderPromotionIncludeSchema.optional(),
      where: OrderPromotionWhereUniqueInputSchema,
    })
    .strict() as z.ZodType<Prisma.OrderPromotionFindUniqueArgs>;

export const OrderPromotionFindUniqueOrThrowArgsSchema: z.ZodType<Prisma.OrderPromotionFindUniqueOrThrowArgs> =
  z
    .object({
      select: OrderPromotionSelectSchema.optional(),
      include: OrderPromotionIncludeSchema.optional(),
      where: OrderPromotionWhereUniqueInputSchema,
    })
    .strict() as z.ZodType<Prisma.OrderPromotionFindUniqueOrThrowArgs>;

export const CartFindFirstArgsSchema: z.ZodType<Prisma.CartFindFirstArgs> = z
  .object({
    select: CartSelectSchema.optional(),
    include: CartIncludeSchema.optional(),
    where: CartWhereInputSchema.optional(),
    orderBy: z
      .union([
        CartOrderByWithRelationInputSchema.array(),
        CartOrderByWithRelationInputSchema,
      ])
      .optional(),
    cursor: CartWhereUniqueInputSchema.optional(),
    take: z.number().optional(),
    skip: z.number().optional(),
    distinct: z
      .union([CartScalarFieldEnumSchema, CartScalarFieldEnumSchema.array()])
      .optional(),
  })
  .strict() as z.ZodType<Prisma.CartFindFirstArgs>;

export const CartFindFirstOrThrowArgsSchema: z.ZodType<Prisma.CartFindFirstOrThrowArgs> =
  z
    .object({
      select: CartSelectSchema.optional(),
      include: CartIncludeSchema.optional(),
      where: CartWhereInputSchema.optional(),
      orderBy: z
        .union([
          CartOrderByWithRelationInputSchema.array(),
          CartOrderByWithRelationInputSchema,
        ])
        .optional(),
      cursor: CartWhereUniqueInputSchema.optional(),
      take: z.number().optional(),
      skip: z.number().optional(),
      distinct: z
        .union([CartScalarFieldEnumSchema, CartScalarFieldEnumSchema.array()])
        .optional(),
    })
    .strict() as z.ZodType<Prisma.CartFindFirstOrThrowArgs>;

export const CartFindManyArgsSchema: z.ZodType<Prisma.CartFindManyArgs> = z
  .object({
    select: CartSelectSchema.optional(),
    include: CartIncludeSchema.optional(),
    where: CartWhereInputSchema.optional(),
    orderBy: z
      .union([
        CartOrderByWithRelationInputSchema.array(),
        CartOrderByWithRelationInputSchema,
      ])
      .optional(),
    cursor: CartWhereUniqueInputSchema.optional(),
    take: z.number().optional(),
    skip: z.number().optional(),
    distinct: z
      .union([CartScalarFieldEnumSchema, CartScalarFieldEnumSchema.array()])
      .optional(),
  })
  .strict() as z.ZodType<Prisma.CartFindManyArgs>;

export const CartAggregateArgsSchema: z.ZodType<Prisma.CartAggregateArgs> = z
  .object({
    where: CartWhereInputSchema.optional(),
    orderBy: z
      .union([
        CartOrderByWithRelationInputSchema.array(),
        CartOrderByWithRelationInputSchema,
      ])
      .optional(),
    cursor: CartWhereUniqueInputSchema.optional(),
    take: z.number().optional(),
    skip: z.number().optional(),
  })
  .strict() as z.ZodType<Prisma.CartAggregateArgs>;

export const CartGroupByArgsSchema: z.ZodType<Prisma.CartGroupByArgs> = z
  .object({
    where: CartWhereInputSchema.optional(),
    orderBy: z
      .union([
        CartOrderByWithAggregationInputSchema.array(),
        CartOrderByWithAggregationInputSchema,
      ])
      .optional(),
    by: CartScalarFieldEnumSchema.array(),
    having: CartScalarWhereWithAggregatesInputSchema.optional(),
    take: z.number().optional(),
    skip: z.number().optional(),
  })
  .strict() as z.ZodType<Prisma.CartGroupByArgs>;

export const CartFindUniqueArgsSchema: z.ZodType<Prisma.CartFindUniqueArgs> = z
  .object({
    select: CartSelectSchema.optional(),
    include: CartIncludeSchema.optional(),
    where: CartWhereUniqueInputSchema,
  })
  .strict() as z.ZodType<Prisma.CartFindUniqueArgs>;

export const CartFindUniqueOrThrowArgsSchema: z.ZodType<Prisma.CartFindUniqueOrThrowArgs> =
  z
    .object({
      select: CartSelectSchema.optional(),
      include: CartIncludeSchema.optional(),
      where: CartWhereUniqueInputSchema,
    })
    .strict() as z.ZodType<Prisma.CartFindUniqueOrThrowArgs>;

export const CartItemFindFirstArgsSchema: z.ZodType<Prisma.CartItemFindFirstArgs> =
  z
    .object({
      select: CartItemSelectSchema.optional(),
      include: CartItemIncludeSchema.optional(),
      where: CartItemWhereInputSchema.optional(),
      orderBy: z
        .union([
          CartItemOrderByWithRelationInputSchema.array(),
          CartItemOrderByWithRelationInputSchema,
        ])
        .optional(),
      cursor: CartItemWhereUniqueInputSchema.optional(),
      take: z.number().optional(),
      skip: z.number().optional(),
      distinct: z
        .union([
          CartItemScalarFieldEnumSchema,
          CartItemScalarFieldEnumSchema.array(),
        ])
        .optional(),
    })
    .strict() as z.ZodType<Prisma.CartItemFindFirstArgs>;

export const CartItemFindFirstOrThrowArgsSchema: z.ZodType<Prisma.CartItemFindFirstOrThrowArgs> =
  z
    .object({
      select: CartItemSelectSchema.optional(),
      include: CartItemIncludeSchema.optional(),
      where: CartItemWhereInputSchema.optional(),
      orderBy: z
        .union([
          CartItemOrderByWithRelationInputSchema.array(),
          CartItemOrderByWithRelationInputSchema,
        ])
        .optional(),
      cursor: CartItemWhereUniqueInputSchema.optional(),
      take: z.number().optional(),
      skip: z.number().optional(),
      distinct: z
        .union([
          CartItemScalarFieldEnumSchema,
          CartItemScalarFieldEnumSchema.array(),
        ])
        .optional(),
    })
    .strict() as z.ZodType<Prisma.CartItemFindFirstOrThrowArgs>;

export const CartItemFindManyArgsSchema: z.ZodType<Prisma.CartItemFindManyArgs> =
  z
    .object({
      select: CartItemSelectSchema.optional(),
      include: CartItemIncludeSchema.optional(),
      where: CartItemWhereInputSchema.optional(),
      orderBy: z
        .union([
          CartItemOrderByWithRelationInputSchema.array(),
          CartItemOrderByWithRelationInputSchema,
        ])
        .optional(),
      cursor: CartItemWhereUniqueInputSchema.optional(),
      take: z.number().optional(),
      skip: z.number().optional(),
      distinct: z
        .union([
          CartItemScalarFieldEnumSchema,
          CartItemScalarFieldEnumSchema.array(),
        ])
        .optional(),
    })
    .strict() as z.ZodType<Prisma.CartItemFindManyArgs>;

export const CartItemAggregateArgsSchema: z.ZodType<Prisma.CartItemAggregateArgs> =
  z
    .object({
      where: CartItemWhereInputSchema.optional(),
      orderBy: z
        .union([
          CartItemOrderByWithRelationInputSchema.array(),
          CartItemOrderByWithRelationInputSchema,
        ])
        .optional(),
      cursor: CartItemWhereUniqueInputSchema.optional(),
      take: z.number().optional(),
      skip: z.number().optional(),
    })
    .strict() as z.ZodType<Prisma.CartItemAggregateArgs>;

export const CartItemGroupByArgsSchema: z.ZodType<Prisma.CartItemGroupByArgs> =
  z
    .object({
      where: CartItemWhereInputSchema.optional(),
      orderBy: z
        .union([
          CartItemOrderByWithAggregationInputSchema.array(),
          CartItemOrderByWithAggregationInputSchema,
        ])
        .optional(),
      by: CartItemScalarFieldEnumSchema.array(),
      having: CartItemScalarWhereWithAggregatesInputSchema.optional(),
      take: z.number().optional(),
      skip: z.number().optional(),
    })
    .strict() as z.ZodType<Prisma.CartItemGroupByArgs>;

export const CartItemFindUniqueArgsSchema: z.ZodType<Prisma.CartItemFindUniqueArgs> =
  z
    .object({
      select: CartItemSelectSchema.optional(),
      include: CartItemIncludeSchema.optional(),
      where: CartItemWhereUniqueInputSchema,
    })
    .strict() as z.ZodType<Prisma.CartItemFindUniqueArgs>;

export const CartItemFindUniqueOrThrowArgsSchema: z.ZodType<Prisma.CartItemFindUniqueOrThrowArgs> =
  z
    .object({
      select: CartItemSelectSchema.optional(),
      include: CartItemIncludeSchema.optional(),
      where: CartItemWhereUniqueInputSchema,
    })
    .strict() as z.ZodType<Prisma.CartItemFindUniqueOrThrowArgs>;

export const NotificationFindFirstArgsSchema: z.ZodType<Prisma.NotificationFindFirstArgs> =
  z
    .object({
      select: NotificationSelectSchema.optional(),
      include: NotificationIncludeSchema.optional(),
      where: NotificationWhereInputSchema.optional(),
      orderBy: z
        .union([
          NotificationOrderByWithRelationInputSchema.array(),
          NotificationOrderByWithRelationInputSchema,
        ])
        .optional(),
      cursor: NotificationWhereUniqueInputSchema.optional(),
      take: z.number().optional(),
      skip: z.number().optional(),
      distinct: z
        .union([
          NotificationScalarFieldEnumSchema,
          NotificationScalarFieldEnumSchema.array(),
        ])
        .optional(),
    })
    .strict() as z.ZodType<Prisma.NotificationFindFirstArgs>;

export const NotificationFindFirstOrThrowArgsSchema: z.ZodType<Prisma.NotificationFindFirstOrThrowArgs> =
  z
    .object({
      select: NotificationSelectSchema.optional(),
      include: NotificationIncludeSchema.optional(),
      where: NotificationWhereInputSchema.optional(),
      orderBy: z
        .union([
          NotificationOrderByWithRelationInputSchema.array(),
          NotificationOrderByWithRelationInputSchema,
        ])
        .optional(),
      cursor: NotificationWhereUniqueInputSchema.optional(),
      take: z.number().optional(),
      skip: z.number().optional(),
      distinct: z
        .union([
          NotificationScalarFieldEnumSchema,
          NotificationScalarFieldEnumSchema.array(),
        ])
        .optional(),
    })
    .strict() as z.ZodType<Prisma.NotificationFindFirstOrThrowArgs>;

export const NotificationFindManyArgsSchema: z.ZodType<Prisma.NotificationFindManyArgs> =
  z
    .object({
      select: NotificationSelectSchema.optional(),
      include: NotificationIncludeSchema.optional(),
      where: NotificationWhereInputSchema.optional(),
      orderBy: z
        .union([
          NotificationOrderByWithRelationInputSchema.array(),
          NotificationOrderByWithRelationInputSchema,
        ])
        .optional(),
      cursor: NotificationWhereUniqueInputSchema.optional(),
      take: z.number().optional(),
      skip: z.number().optional(),
      distinct: z
        .union([
          NotificationScalarFieldEnumSchema,
          NotificationScalarFieldEnumSchema.array(),
        ])
        .optional(),
    })
    .strict() as z.ZodType<Prisma.NotificationFindManyArgs>;

export const NotificationAggregateArgsSchema: z.ZodType<Prisma.NotificationAggregateArgs> =
  z
    .object({
      where: NotificationWhereInputSchema.optional(),
      orderBy: z
        .union([
          NotificationOrderByWithRelationInputSchema.array(),
          NotificationOrderByWithRelationInputSchema,
        ])
        .optional(),
      cursor: NotificationWhereUniqueInputSchema.optional(),
      take: z.number().optional(),
      skip: z.number().optional(),
    })
    .strict() as z.ZodType<Prisma.NotificationAggregateArgs>;

export const NotificationGroupByArgsSchema: z.ZodType<Prisma.NotificationGroupByArgs> =
  z
    .object({
      where: NotificationWhereInputSchema.optional(),
      orderBy: z
        .union([
          NotificationOrderByWithAggregationInputSchema.array(),
          NotificationOrderByWithAggregationInputSchema,
        ])
        .optional(),
      by: NotificationScalarFieldEnumSchema.array(),
      having: NotificationScalarWhereWithAggregatesInputSchema.optional(),
      take: z.number().optional(),
      skip: z.number().optional(),
    })
    .strict() as z.ZodType<Prisma.NotificationGroupByArgs>;

export const NotificationFindUniqueArgsSchema: z.ZodType<Prisma.NotificationFindUniqueArgs> =
  z
    .object({
      select: NotificationSelectSchema.optional(),
      include: NotificationIncludeSchema.optional(),
      where: NotificationWhereUniqueInputSchema,
    })
    .strict() as z.ZodType<Prisma.NotificationFindUniqueArgs>;

export const NotificationFindUniqueOrThrowArgsSchema: z.ZodType<Prisma.NotificationFindUniqueOrThrowArgs> =
  z
    .object({
      select: NotificationSelectSchema.optional(),
      include: NotificationIncludeSchema.optional(),
      where: NotificationWhereUniqueInputSchema,
    })
    .strict() as z.ZodType<Prisma.NotificationFindUniqueOrThrowArgs>;

export const PaymentFindFirstArgsSchema: z.ZodType<Prisma.PaymentFindFirstArgs> =
  z
    .object({
      select: PaymentSelectSchema.optional(),
      include: PaymentIncludeSchema.optional(),
      where: PaymentWhereInputSchema.optional(),
      orderBy: z
        .union([
          PaymentOrderByWithRelationInputSchema.array(),
          PaymentOrderByWithRelationInputSchema,
        ])
        .optional(),
      cursor: PaymentWhereUniqueInputSchema.optional(),
      take: z.number().optional(),
      skip: z.number().optional(),
      distinct: z
        .union([
          PaymentScalarFieldEnumSchema,
          PaymentScalarFieldEnumSchema.array(),
        ])
        .optional(),
    })
    .strict() as z.ZodType<Prisma.PaymentFindFirstArgs>;

export const PaymentFindFirstOrThrowArgsSchema: z.ZodType<Prisma.PaymentFindFirstOrThrowArgs> =
  z
    .object({
      select: PaymentSelectSchema.optional(),
      include: PaymentIncludeSchema.optional(),
      where: PaymentWhereInputSchema.optional(),
      orderBy: z
        .union([
          PaymentOrderByWithRelationInputSchema.array(),
          PaymentOrderByWithRelationInputSchema,
        ])
        .optional(),
      cursor: PaymentWhereUniqueInputSchema.optional(),
      take: z.number().optional(),
      skip: z.number().optional(),
      distinct: z
        .union([
          PaymentScalarFieldEnumSchema,
          PaymentScalarFieldEnumSchema.array(),
        ])
        .optional(),
    })
    .strict() as z.ZodType<Prisma.PaymentFindFirstOrThrowArgs>;

export const PaymentFindManyArgsSchema: z.ZodType<Prisma.PaymentFindManyArgs> =
  z
    .object({
      select: PaymentSelectSchema.optional(),
      include: PaymentIncludeSchema.optional(),
      where: PaymentWhereInputSchema.optional(),
      orderBy: z
        .union([
          PaymentOrderByWithRelationInputSchema.array(),
          PaymentOrderByWithRelationInputSchema,
        ])
        .optional(),
      cursor: PaymentWhereUniqueInputSchema.optional(),
      take: z.number().optional(),
      skip: z.number().optional(),
      distinct: z
        .union([
          PaymentScalarFieldEnumSchema,
          PaymentScalarFieldEnumSchema.array(),
        ])
        .optional(),
    })
    .strict() as z.ZodType<Prisma.PaymentFindManyArgs>;

export const PaymentAggregateArgsSchema: z.ZodType<Prisma.PaymentAggregateArgs> =
  z
    .object({
      where: PaymentWhereInputSchema.optional(),
      orderBy: z
        .union([
          PaymentOrderByWithRelationInputSchema.array(),
          PaymentOrderByWithRelationInputSchema,
        ])
        .optional(),
      cursor: PaymentWhereUniqueInputSchema.optional(),
      take: z.number().optional(),
      skip: z.number().optional(),
    })
    .strict() as z.ZodType<Prisma.PaymentAggregateArgs>;

export const PaymentGroupByArgsSchema: z.ZodType<Prisma.PaymentGroupByArgs> = z
  .object({
    where: PaymentWhereInputSchema.optional(),
    orderBy: z
      .union([
        PaymentOrderByWithAggregationInputSchema.array(),
        PaymentOrderByWithAggregationInputSchema,
      ])
      .optional(),
    by: PaymentScalarFieldEnumSchema.array(),
    having: PaymentScalarWhereWithAggregatesInputSchema.optional(),
    take: z.number().optional(),
    skip: z.number().optional(),
  })
  .strict() as z.ZodType<Prisma.PaymentGroupByArgs>;

export const PaymentFindUniqueArgsSchema: z.ZodType<Prisma.PaymentFindUniqueArgs> =
  z
    .object({
      select: PaymentSelectSchema.optional(),
      include: PaymentIncludeSchema.optional(),
      where: PaymentWhereUniqueInputSchema,
    })
    .strict() as z.ZodType<Prisma.PaymentFindUniqueArgs>;

export const PaymentFindUniqueOrThrowArgsSchema: z.ZodType<Prisma.PaymentFindUniqueOrThrowArgs> =
  z
    .object({
      select: PaymentSelectSchema.optional(),
      include: PaymentIncludeSchema.optional(),
      where: PaymentWhereUniqueInputSchema,
    })
    .strict() as z.ZodType<Prisma.PaymentFindUniqueOrThrowArgs>;

export const UserCreateArgsSchema: z.ZodType<Prisma.UserCreateArgs> = z
  .object({
    select: UserSelectSchema.optional(),
    include: UserIncludeSchema.optional(),
    data: z.union([UserCreateInputSchema, UserUncheckedCreateInputSchema]),
  })
  .strict() as z.ZodType<Prisma.UserCreateArgs>;

export const UserUpsertArgsSchema: z.ZodType<Prisma.UserUpsertArgs> = z
  .object({
    select: UserSelectSchema.optional(),
    include: UserIncludeSchema.optional(),
    where: UserWhereUniqueInputSchema,
    create: z.union([UserCreateInputSchema, UserUncheckedCreateInputSchema]),
    update: z.union([UserUpdateInputSchema, UserUncheckedUpdateInputSchema]),
  })
  .strict() as z.ZodType<Prisma.UserUpsertArgs>;

export const UserCreateManyArgsSchema: z.ZodType<Prisma.UserCreateManyArgs> = z
  .object({
    data: z.union([
      UserCreateManyInputSchema,
      UserCreateManyInputSchema.array(),
    ]),
    skipDuplicates: z.boolean().optional(),
  })
  .strict() as z.ZodType<Prisma.UserCreateManyArgs>;

export const UserCreateManyAndReturnArgsSchema: z.ZodType<Prisma.UserCreateManyAndReturnArgs> =
  z
    .object({
      data: z.union([
        UserCreateManyInputSchema,
        UserCreateManyInputSchema.array(),
      ]),
      skipDuplicates: z.boolean().optional(),
    })
    .strict() as z.ZodType<Prisma.UserCreateManyAndReturnArgs>;

export const UserDeleteArgsSchema: z.ZodType<Prisma.UserDeleteArgs> = z
  .object({
    select: UserSelectSchema.optional(),
    include: UserIncludeSchema.optional(),
    where: UserWhereUniqueInputSchema,
  })
  .strict() as z.ZodType<Prisma.UserDeleteArgs>;

export const UserUpdateArgsSchema: z.ZodType<Prisma.UserUpdateArgs> = z
  .object({
    select: UserSelectSchema.optional(),
    include: UserIncludeSchema.optional(),
    data: z.union([UserUpdateInputSchema, UserUncheckedUpdateInputSchema]),
    where: UserWhereUniqueInputSchema,
  })
  .strict() as z.ZodType<Prisma.UserUpdateArgs>;

export const UserUpdateManyArgsSchema: z.ZodType<Prisma.UserUpdateManyArgs> = z
  .object({
    data: z.union([
      UserUpdateManyMutationInputSchema,
      UserUncheckedUpdateManyInputSchema,
    ]),
    where: UserWhereInputSchema.optional(),
    limit: z.number().optional(),
  })
  .strict() as z.ZodType<Prisma.UserUpdateManyArgs>;

export const UserUpdateManyAndReturnArgsSchema: z.ZodType<Prisma.UserUpdateManyAndReturnArgs> =
  z
    .object({
      data: z.union([
        UserUpdateManyMutationInputSchema,
        UserUncheckedUpdateManyInputSchema,
      ]),
      where: UserWhereInputSchema.optional(),
      limit: z.number().optional(),
    })
    .strict() as z.ZodType<Prisma.UserUpdateManyAndReturnArgs>;

export const UserDeleteManyArgsSchema: z.ZodType<Prisma.UserDeleteManyArgs> = z
  .object({
    where: UserWhereInputSchema.optional(),
    limit: z.number().optional(),
  })
  .strict() as z.ZodType<Prisma.UserDeleteManyArgs>;

export const VendorCreateArgsSchema: z.ZodType<Prisma.VendorCreateArgs> = z
  .object({
    select: VendorSelectSchema.optional(),
    include: VendorIncludeSchema.optional(),
    data: z.union([VendorCreateInputSchema, VendorUncheckedCreateInputSchema]),
  })
  .strict() as z.ZodType<Prisma.VendorCreateArgs>;

export const VendorUpsertArgsSchema: z.ZodType<Prisma.VendorUpsertArgs> = z
  .object({
    select: VendorSelectSchema.optional(),
    include: VendorIncludeSchema.optional(),
    where: VendorWhereUniqueInputSchema,
    create: z.union([
      VendorCreateInputSchema,
      VendorUncheckedCreateInputSchema,
    ]),
    update: z.union([
      VendorUpdateInputSchema,
      VendorUncheckedUpdateInputSchema,
    ]),
  })
  .strict() as z.ZodType<Prisma.VendorUpsertArgs>;

export const VendorCreateManyArgsSchema: z.ZodType<Prisma.VendorCreateManyArgs> =
  z
    .object({
      data: z.union([
        VendorCreateManyInputSchema,
        VendorCreateManyInputSchema.array(),
      ]),
      skipDuplicates: z.boolean().optional(),
    })
    .strict() as z.ZodType<Prisma.VendorCreateManyArgs>;

export const VendorCreateManyAndReturnArgsSchema: z.ZodType<Prisma.VendorCreateManyAndReturnArgs> =
  z
    .object({
      data: z.union([
        VendorCreateManyInputSchema,
        VendorCreateManyInputSchema.array(),
      ]),
      skipDuplicates: z.boolean().optional(),
    })
    .strict() as z.ZodType<Prisma.VendorCreateManyAndReturnArgs>;

export const VendorDeleteArgsSchema: z.ZodType<Prisma.VendorDeleteArgs> = z
  .object({
    select: VendorSelectSchema.optional(),
    include: VendorIncludeSchema.optional(),
    where: VendorWhereUniqueInputSchema,
  })
  .strict() as z.ZodType<Prisma.VendorDeleteArgs>;

export const VendorUpdateArgsSchema: z.ZodType<Prisma.VendorUpdateArgs> = z
  .object({
    select: VendorSelectSchema.optional(),
    include: VendorIncludeSchema.optional(),
    data: z.union([VendorUpdateInputSchema, VendorUncheckedUpdateInputSchema]),
    where: VendorWhereUniqueInputSchema,
  })
  .strict() as z.ZodType<Prisma.VendorUpdateArgs>;

export const VendorUpdateManyArgsSchema: z.ZodType<Prisma.VendorUpdateManyArgs> =
  z
    .object({
      data: z.union([
        VendorUpdateManyMutationInputSchema,
        VendorUncheckedUpdateManyInputSchema,
      ]),
      where: VendorWhereInputSchema.optional(),
      limit: z.number().optional(),
    })
    .strict() as z.ZodType<Prisma.VendorUpdateManyArgs>;

export const VendorUpdateManyAndReturnArgsSchema: z.ZodType<Prisma.VendorUpdateManyAndReturnArgs> =
  z
    .object({
      data: z.union([
        VendorUpdateManyMutationInputSchema,
        VendorUncheckedUpdateManyInputSchema,
      ]),
      where: VendorWhereInputSchema.optional(),
      limit: z.number().optional(),
    })
    .strict() as z.ZodType<Prisma.VendorUpdateManyAndReturnArgs>;

export const VendorDeleteManyArgsSchema: z.ZodType<Prisma.VendorDeleteManyArgs> =
  z
    .object({
      where: VendorWhereInputSchema.optional(),
      limit: z.number().optional(),
    })
    .strict() as z.ZodType<Prisma.VendorDeleteManyArgs>;

export const RoleCreateArgsSchema: z.ZodType<Prisma.RoleCreateArgs> = z
  .object({
    select: RoleSelectSchema.optional(),
    include: RoleIncludeSchema.optional(),
    data: z.union([RoleCreateInputSchema, RoleUncheckedCreateInputSchema]),
  })
  .strict() as z.ZodType<Prisma.RoleCreateArgs>;

export const RoleUpsertArgsSchema: z.ZodType<Prisma.RoleUpsertArgs> = z
  .object({
    select: RoleSelectSchema.optional(),
    include: RoleIncludeSchema.optional(),
    where: RoleWhereUniqueInputSchema,
    create: z.union([RoleCreateInputSchema, RoleUncheckedCreateInputSchema]),
    update: z.union([RoleUpdateInputSchema, RoleUncheckedUpdateInputSchema]),
  })
  .strict() as z.ZodType<Prisma.RoleUpsertArgs>;

export const RoleCreateManyArgsSchema: z.ZodType<Prisma.RoleCreateManyArgs> = z
  .object({
    data: z.union([
      RoleCreateManyInputSchema,
      RoleCreateManyInputSchema.array(),
    ]),
    skipDuplicates: z.boolean().optional(),
  })
  .strict() as z.ZodType<Prisma.RoleCreateManyArgs>;

export const RoleCreateManyAndReturnArgsSchema: z.ZodType<Prisma.RoleCreateManyAndReturnArgs> =
  z
    .object({
      data: z.union([
        RoleCreateManyInputSchema,
        RoleCreateManyInputSchema.array(),
      ]),
      skipDuplicates: z.boolean().optional(),
    })
    .strict() as z.ZodType<Prisma.RoleCreateManyAndReturnArgs>;

export const RoleDeleteArgsSchema: z.ZodType<Prisma.RoleDeleteArgs> = z
  .object({
    select: RoleSelectSchema.optional(),
    include: RoleIncludeSchema.optional(),
    where: RoleWhereUniqueInputSchema,
  })
  .strict() as z.ZodType<Prisma.RoleDeleteArgs>;

export const RoleUpdateArgsSchema: z.ZodType<Prisma.RoleUpdateArgs> = z
  .object({
    select: RoleSelectSchema.optional(),
    include: RoleIncludeSchema.optional(),
    data: z.union([RoleUpdateInputSchema, RoleUncheckedUpdateInputSchema]),
    where: RoleWhereUniqueInputSchema,
  })
  .strict() as z.ZodType<Prisma.RoleUpdateArgs>;

export const RoleUpdateManyArgsSchema: z.ZodType<Prisma.RoleUpdateManyArgs> = z
  .object({
    data: z.union([
      RoleUpdateManyMutationInputSchema,
      RoleUncheckedUpdateManyInputSchema,
    ]),
    where: RoleWhereInputSchema.optional(),
    limit: z.number().optional(),
  })
  .strict() as z.ZodType<Prisma.RoleUpdateManyArgs>;

export const RoleUpdateManyAndReturnArgsSchema: z.ZodType<Prisma.RoleUpdateManyAndReturnArgs> =
  z
    .object({
      data: z.union([
        RoleUpdateManyMutationInputSchema,
        RoleUncheckedUpdateManyInputSchema,
      ]),
      where: RoleWhereInputSchema.optional(),
      limit: z.number().optional(),
    })
    .strict() as z.ZodType<Prisma.RoleUpdateManyAndReturnArgs>;

export const RoleDeleteManyArgsSchema: z.ZodType<Prisma.RoleDeleteManyArgs> = z
  .object({
    where: RoleWhereInputSchema.optional(),
    limit: z.number().optional(),
  })
  .strict() as z.ZodType<Prisma.RoleDeleteManyArgs>;

export const PermissionCreateArgsSchema: z.ZodType<Prisma.PermissionCreateArgs> =
  z
    .object({
      select: PermissionSelectSchema.optional(),
      include: PermissionIncludeSchema.optional(),
      data: z.union([
        PermissionCreateInputSchema,
        PermissionUncheckedCreateInputSchema,
      ]),
    })
    .strict() as z.ZodType<Prisma.PermissionCreateArgs>;

export const PermissionUpsertArgsSchema: z.ZodType<Prisma.PermissionUpsertArgs> =
  z
    .object({
      select: PermissionSelectSchema.optional(),
      include: PermissionIncludeSchema.optional(),
      where: PermissionWhereUniqueInputSchema,
      create: z.union([
        PermissionCreateInputSchema,
        PermissionUncheckedCreateInputSchema,
      ]),
      update: z.union([
        PermissionUpdateInputSchema,
        PermissionUncheckedUpdateInputSchema,
      ]),
    })
    .strict() as z.ZodType<Prisma.PermissionUpsertArgs>;

export const PermissionCreateManyArgsSchema: z.ZodType<Prisma.PermissionCreateManyArgs> =
  z
    .object({
      data: z.union([
        PermissionCreateManyInputSchema,
        PermissionCreateManyInputSchema.array(),
      ]),
      skipDuplicates: z.boolean().optional(),
    })
    .strict() as z.ZodType<Prisma.PermissionCreateManyArgs>;

export const PermissionCreateManyAndReturnArgsSchema: z.ZodType<Prisma.PermissionCreateManyAndReturnArgs> =
  z
    .object({
      data: z.union([
        PermissionCreateManyInputSchema,
        PermissionCreateManyInputSchema.array(),
      ]),
      skipDuplicates: z.boolean().optional(),
    })
    .strict() as z.ZodType<Prisma.PermissionCreateManyAndReturnArgs>;

export const PermissionDeleteArgsSchema: z.ZodType<Prisma.PermissionDeleteArgs> =
  z
    .object({
      select: PermissionSelectSchema.optional(),
      include: PermissionIncludeSchema.optional(),
      where: PermissionWhereUniqueInputSchema,
    })
    .strict() as z.ZodType<Prisma.PermissionDeleteArgs>;

export const PermissionUpdateArgsSchema: z.ZodType<Prisma.PermissionUpdateArgs> =
  z
    .object({
      select: PermissionSelectSchema.optional(),
      include: PermissionIncludeSchema.optional(),
      data: z.union([
        PermissionUpdateInputSchema,
        PermissionUncheckedUpdateInputSchema,
      ]),
      where: PermissionWhereUniqueInputSchema,
    })
    .strict() as z.ZodType<Prisma.PermissionUpdateArgs>;

export const PermissionUpdateManyArgsSchema: z.ZodType<Prisma.PermissionUpdateManyArgs> =
  z
    .object({
      data: z.union([
        PermissionUpdateManyMutationInputSchema,
        PermissionUncheckedUpdateManyInputSchema,
      ]),
      where: PermissionWhereInputSchema.optional(),
      limit: z.number().optional(),
    })
    .strict() as z.ZodType<Prisma.PermissionUpdateManyArgs>;

export const PermissionUpdateManyAndReturnArgsSchema: z.ZodType<Prisma.PermissionUpdateManyAndReturnArgs> =
  z
    .object({
      data: z.union([
        PermissionUpdateManyMutationInputSchema,
        PermissionUncheckedUpdateManyInputSchema,
      ]),
      where: PermissionWhereInputSchema.optional(),
      limit: z.number().optional(),
    })
    .strict() as z.ZodType<Prisma.PermissionUpdateManyAndReturnArgs>;

export const PermissionDeleteManyArgsSchema: z.ZodType<Prisma.PermissionDeleteManyArgs> =
  z
    .object({
      where: PermissionWhereInputSchema.optional(),
      limit: z.number().optional(),
    })
    .strict() as z.ZodType<Prisma.PermissionDeleteManyArgs>;

export const RolePermissionCreateArgsSchema: z.ZodType<Prisma.RolePermissionCreateArgs> =
  z
    .object({
      select: RolePermissionSelectSchema.optional(),
      include: RolePermissionIncludeSchema.optional(),
      data: z.union([
        RolePermissionCreateInputSchema,
        RolePermissionUncheckedCreateInputSchema,
      ]),
    })
    .strict() as z.ZodType<Prisma.RolePermissionCreateArgs>;

export const RolePermissionUpsertArgsSchema: z.ZodType<Prisma.RolePermissionUpsertArgs> =
  z
    .object({
      select: RolePermissionSelectSchema.optional(),
      include: RolePermissionIncludeSchema.optional(),
      where: RolePermissionWhereUniqueInputSchema,
      create: z.union([
        RolePermissionCreateInputSchema,
        RolePermissionUncheckedCreateInputSchema,
      ]),
      update: z.union([
        RolePermissionUpdateInputSchema,
        RolePermissionUncheckedUpdateInputSchema,
      ]),
    })
    .strict() as z.ZodType<Prisma.RolePermissionUpsertArgs>;

export const RolePermissionCreateManyArgsSchema: z.ZodType<Prisma.RolePermissionCreateManyArgs> =
  z
    .object({
      data: z.union([
        RolePermissionCreateManyInputSchema,
        RolePermissionCreateManyInputSchema.array(),
      ]),
      skipDuplicates: z.boolean().optional(),
    })
    .strict() as z.ZodType<Prisma.RolePermissionCreateManyArgs>;

export const RolePermissionCreateManyAndReturnArgsSchema: z.ZodType<Prisma.RolePermissionCreateManyAndReturnArgs> =
  z
    .object({
      data: z.union([
        RolePermissionCreateManyInputSchema,
        RolePermissionCreateManyInputSchema.array(),
      ]),
      skipDuplicates: z.boolean().optional(),
    })
    .strict() as z.ZodType<Prisma.RolePermissionCreateManyAndReturnArgs>;

export const RolePermissionDeleteArgsSchema: z.ZodType<Prisma.RolePermissionDeleteArgs> =
  z
    .object({
      select: RolePermissionSelectSchema.optional(),
      include: RolePermissionIncludeSchema.optional(),
      where: RolePermissionWhereUniqueInputSchema,
    })
    .strict() as z.ZodType<Prisma.RolePermissionDeleteArgs>;

export const RolePermissionUpdateArgsSchema: z.ZodType<Prisma.RolePermissionUpdateArgs> =
  z
    .object({
      select: RolePermissionSelectSchema.optional(),
      include: RolePermissionIncludeSchema.optional(),
      data: z.union([
        RolePermissionUpdateInputSchema,
        RolePermissionUncheckedUpdateInputSchema,
      ]),
      where: RolePermissionWhereUniqueInputSchema,
    })
    .strict() as z.ZodType<Prisma.RolePermissionUpdateArgs>;

export const RolePermissionUpdateManyArgsSchema: z.ZodType<Prisma.RolePermissionUpdateManyArgs> =
  z
    .object({
      data: z.union([
        RolePermissionUpdateManyMutationInputSchema,
        RolePermissionUncheckedUpdateManyInputSchema,
      ]),
      where: RolePermissionWhereInputSchema.optional(),
      limit: z.number().optional(),
    })
    .strict() as z.ZodType<Prisma.RolePermissionUpdateManyArgs>;

export const RolePermissionUpdateManyAndReturnArgsSchema: z.ZodType<Prisma.RolePermissionUpdateManyAndReturnArgs> =
  z
    .object({
      data: z.union([
        RolePermissionUpdateManyMutationInputSchema,
        RolePermissionUncheckedUpdateManyInputSchema,
      ]),
      where: RolePermissionWhereInputSchema.optional(),
      limit: z.number().optional(),
    })
    .strict() as z.ZodType<Prisma.RolePermissionUpdateManyAndReturnArgs>;

export const RolePermissionDeleteManyArgsSchema: z.ZodType<Prisma.RolePermissionDeleteManyArgs> =
  z
    .object({
      where: RolePermissionWhereInputSchema.optional(),
      limit: z.number().optional(),
    })
    .strict() as z.ZodType<Prisma.RolePermissionDeleteManyArgs>;

export const UserVendorRoleCreateArgsSchema: z.ZodType<Prisma.UserVendorRoleCreateArgs> =
  z
    .object({
      select: UserVendorRoleSelectSchema.optional(),
      include: UserVendorRoleIncludeSchema.optional(),
      data: z.union([
        UserVendorRoleCreateInputSchema,
        UserVendorRoleUncheckedCreateInputSchema,
      ]),
    })
    .strict() as z.ZodType<Prisma.UserVendorRoleCreateArgs>;

export const UserVendorRoleUpsertArgsSchema: z.ZodType<Prisma.UserVendorRoleUpsertArgs> =
  z
    .object({
      select: UserVendorRoleSelectSchema.optional(),
      include: UserVendorRoleIncludeSchema.optional(),
      where: UserVendorRoleWhereUniqueInputSchema,
      create: z.union([
        UserVendorRoleCreateInputSchema,
        UserVendorRoleUncheckedCreateInputSchema,
      ]),
      update: z.union([
        UserVendorRoleUpdateInputSchema,
        UserVendorRoleUncheckedUpdateInputSchema,
      ]),
    })
    .strict() as z.ZodType<Prisma.UserVendorRoleUpsertArgs>;

export const UserVendorRoleCreateManyArgsSchema: z.ZodType<Prisma.UserVendorRoleCreateManyArgs> =
  z
    .object({
      data: z.union([
        UserVendorRoleCreateManyInputSchema,
        UserVendorRoleCreateManyInputSchema.array(),
      ]),
      skipDuplicates: z.boolean().optional(),
    })
    .strict() as z.ZodType<Prisma.UserVendorRoleCreateManyArgs>;

export const UserVendorRoleCreateManyAndReturnArgsSchema: z.ZodType<Prisma.UserVendorRoleCreateManyAndReturnArgs> =
  z
    .object({
      data: z.union([
        UserVendorRoleCreateManyInputSchema,
        UserVendorRoleCreateManyInputSchema.array(),
      ]),
      skipDuplicates: z.boolean().optional(),
    })
    .strict() as z.ZodType<Prisma.UserVendorRoleCreateManyAndReturnArgs>;

export const UserVendorRoleDeleteArgsSchema: z.ZodType<Prisma.UserVendorRoleDeleteArgs> =
  z
    .object({
      select: UserVendorRoleSelectSchema.optional(),
      include: UserVendorRoleIncludeSchema.optional(),
      where: UserVendorRoleWhereUniqueInputSchema,
    })
    .strict() as z.ZodType<Prisma.UserVendorRoleDeleteArgs>;

export const UserVendorRoleUpdateArgsSchema: z.ZodType<Prisma.UserVendorRoleUpdateArgs> =
  z
    .object({
      select: UserVendorRoleSelectSchema.optional(),
      include: UserVendorRoleIncludeSchema.optional(),
      data: z.union([
        UserVendorRoleUpdateInputSchema,
        UserVendorRoleUncheckedUpdateInputSchema,
      ]),
      where: UserVendorRoleWhereUniqueInputSchema,
    })
    .strict() as z.ZodType<Prisma.UserVendorRoleUpdateArgs>;

export const UserVendorRoleUpdateManyArgsSchema: z.ZodType<Prisma.UserVendorRoleUpdateManyArgs> =
  z
    .object({
      data: z.union([
        UserVendorRoleUpdateManyMutationInputSchema,
        UserVendorRoleUncheckedUpdateManyInputSchema,
      ]),
      where: UserVendorRoleWhereInputSchema.optional(),
      limit: z.number().optional(),
    })
    .strict() as z.ZodType<Prisma.UserVendorRoleUpdateManyArgs>;

export const UserVendorRoleUpdateManyAndReturnArgsSchema: z.ZodType<Prisma.UserVendorRoleUpdateManyAndReturnArgs> =
  z
    .object({
      data: z.union([
        UserVendorRoleUpdateManyMutationInputSchema,
        UserVendorRoleUncheckedUpdateManyInputSchema,
      ]),
      where: UserVendorRoleWhereInputSchema.optional(),
      limit: z.number().optional(),
    })
    .strict() as z.ZodType<Prisma.UserVendorRoleUpdateManyAndReturnArgs>;

export const UserVendorRoleDeleteManyArgsSchema: z.ZodType<Prisma.UserVendorRoleDeleteManyArgs> =
  z
    .object({
      where: UserVendorRoleWhereInputSchema.optional(),
      limit: z.number().optional(),
    })
    .strict() as z.ZodType<Prisma.UserVendorRoleDeleteManyArgs>;

export const CategoryCreateArgsSchema: z.ZodType<Prisma.CategoryCreateArgs> = z
  .object({
    select: CategorySelectSchema.optional(),
    include: CategoryIncludeSchema.optional(),
    data: z.union([
      CategoryCreateInputSchema,
      CategoryUncheckedCreateInputSchema,
    ]),
  })
  .strict() as z.ZodType<Prisma.CategoryCreateArgs>;

export const CategoryUpsertArgsSchema: z.ZodType<Prisma.CategoryUpsertArgs> = z
  .object({
    select: CategorySelectSchema.optional(),
    include: CategoryIncludeSchema.optional(),
    where: CategoryWhereUniqueInputSchema,
    create: z.union([
      CategoryCreateInputSchema,
      CategoryUncheckedCreateInputSchema,
    ]),
    update: z.union([
      CategoryUpdateInputSchema,
      CategoryUncheckedUpdateInputSchema,
    ]),
  })
  .strict() as z.ZodType<Prisma.CategoryUpsertArgs>;

export const CategoryCreateManyArgsSchema: z.ZodType<Prisma.CategoryCreateManyArgs> =
  z
    .object({
      data: z.union([
        CategoryCreateManyInputSchema,
        CategoryCreateManyInputSchema.array(),
      ]),
      skipDuplicates: z.boolean().optional(),
    })
    .strict() as z.ZodType<Prisma.CategoryCreateManyArgs>;

export const CategoryCreateManyAndReturnArgsSchema: z.ZodType<Prisma.CategoryCreateManyAndReturnArgs> =
  z
    .object({
      data: z.union([
        CategoryCreateManyInputSchema,
        CategoryCreateManyInputSchema.array(),
      ]),
      skipDuplicates: z.boolean().optional(),
    })
    .strict() as z.ZodType<Prisma.CategoryCreateManyAndReturnArgs>;

export const CategoryDeleteArgsSchema: z.ZodType<Prisma.CategoryDeleteArgs> = z
  .object({
    select: CategorySelectSchema.optional(),
    include: CategoryIncludeSchema.optional(),
    where: CategoryWhereUniqueInputSchema,
  })
  .strict() as z.ZodType<Prisma.CategoryDeleteArgs>;

export const CategoryUpdateArgsSchema: z.ZodType<Prisma.CategoryUpdateArgs> = z
  .object({
    select: CategorySelectSchema.optional(),
    include: CategoryIncludeSchema.optional(),
    data: z.union([
      CategoryUpdateInputSchema,
      CategoryUncheckedUpdateInputSchema,
    ]),
    where: CategoryWhereUniqueInputSchema,
  })
  .strict() as z.ZodType<Prisma.CategoryUpdateArgs>;

export const CategoryUpdateManyArgsSchema: z.ZodType<Prisma.CategoryUpdateManyArgs> =
  z
    .object({
      data: z.union([
        CategoryUpdateManyMutationInputSchema,
        CategoryUncheckedUpdateManyInputSchema,
      ]),
      where: CategoryWhereInputSchema.optional(),
      limit: z.number().optional(),
    })
    .strict() as z.ZodType<Prisma.CategoryUpdateManyArgs>;

export const CategoryUpdateManyAndReturnArgsSchema: z.ZodType<Prisma.CategoryUpdateManyAndReturnArgs> =
  z
    .object({
      data: z.union([
        CategoryUpdateManyMutationInputSchema,
        CategoryUncheckedUpdateManyInputSchema,
      ]),
      where: CategoryWhereInputSchema.optional(),
      limit: z.number().optional(),
    })
    .strict() as z.ZodType<Prisma.CategoryUpdateManyAndReturnArgs>;

export const CategoryDeleteManyArgsSchema: z.ZodType<Prisma.CategoryDeleteManyArgs> =
  z
    .object({
      where: CategoryWhereInputSchema.optional(),
      limit: z.number().optional(),
    })
    .strict() as z.ZodType<Prisma.CategoryDeleteManyArgs>;

export const ProductCreateArgsSchema: z.ZodType<Prisma.ProductCreateArgs> = z
  .object({
    select: ProductSelectSchema.optional(),
    include: ProductIncludeSchema.optional(),
    data: z.union([
      ProductCreateInputSchema,
      ProductUncheckedCreateInputSchema,
    ]),
  })
  .strict() as z.ZodType<Prisma.ProductCreateArgs>;

export const ProductUpsertArgsSchema: z.ZodType<Prisma.ProductUpsertArgs> = z
  .object({
    select: ProductSelectSchema.optional(),
    include: ProductIncludeSchema.optional(),
    where: ProductWhereUniqueInputSchema,
    create: z.union([
      ProductCreateInputSchema,
      ProductUncheckedCreateInputSchema,
    ]),
    update: z.union([
      ProductUpdateInputSchema,
      ProductUncheckedUpdateInputSchema,
    ]),
  })
  .strict() as z.ZodType<Prisma.ProductUpsertArgs>;

export const ProductCreateManyArgsSchema: z.ZodType<Prisma.ProductCreateManyArgs> =
  z
    .object({
      data: z.union([
        ProductCreateManyInputSchema,
        ProductCreateManyInputSchema.array(),
      ]),
      skipDuplicates: z.boolean().optional(),
    })
    .strict() as z.ZodType<Prisma.ProductCreateManyArgs>;

export const ProductCreateManyAndReturnArgsSchema: z.ZodType<Prisma.ProductCreateManyAndReturnArgs> =
  z
    .object({
      data: z.union([
        ProductCreateManyInputSchema,
        ProductCreateManyInputSchema.array(),
      ]),
      skipDuplicates: z.boolean().optional(),
    })
    .strict() as z.ZodType<Prisma.ProductCreateManyAndReturnArgs>;

export const ProductDeleteArgsSchema: z.ZodType<Prisma.ProductDeleteArgs> = z
  .object({
    select: ProductSelectSchema.optional(),
    include: ProductIncludeSchema.optional(),
    where: ProductWhereUniqueInputSchema,
  })
  .strict() as z.ZodType<Prisma.ProductDeleteArgs>;

export const ProductUpdateArgsSchema: z.ZodType<Prisma.ProductUpdateArgs> = z
  .object({
    select: ProductSelectSchema.optional(),
    include: ProductIncludeSchema.optional(),
    data: z.union([
      ProductUpdateInputSchema,
      ProductUncheckedUpdateInputSchema,
    ]),
    where: ProductWhereUniqueInputSchema,
  })
  .strict() as z.ZodType<Prisma.ProductUpdateArgs>;

export const ProductUpdateManyArgsSchema: z.ZodType<Prisma.ProductUpdateManyArgs> =
  z
    .object({
      data: z.union([
        ProductUpdateManyMutationInputSchema,
        ProductUncheckedUpdateManyInputSchema,
      ]),
      where: ProductWhereInputSchema.optional(),
      limit: z.number().optional(),
    })
    .strict() as z.ZodType<Prisma.ProductUpdateManyArgs>;

export const ProductUpdateManyAndReturnArgsSchema: z.ZodType<Prisma.ProductUpdateManyAndReturnArgs> =
  z
    .object({
      data: z.union([
        ProductUpdateManyMutationInputSchema,
        ProductUncheckedUpdateManyInputSchema,
      ]),
      where: ProductWhereInputSchema.optional(),
      limit: z.number().optional(),
    })
    .strict() as z.ZodType<Prisma.ProductUpdateManyAndReturnArgs>;

export const ProductDeleteManyArgsSchema: z.ZodType<Prisma.ProductDeleteManyArgs> =
  z
    .object({
      where: ProductWhereInputSchema.optional(),
      limit: z.number().optional(),
    })
    .strict() as z.ZodType<Prisma.ProductDeleteManyArgs>;

export const ProductVariantCreateArgsSchema: z.ZodType<Prisma.ProductVariantCreateArgs> =
  z
    .object({
      select: ProductVariantSelectSchema.optional(),
      include: ProductVariantIncludeSchema.optional(),
      data: z.union([
        ProductVariantCreateInputSchema,
        ProductVariantUncheckedCreateInputSchema,
      ]),
    })
    .strict() as z.ZodType<Prisma.ProductVariantCreateArgs>;

export const ProductVariantUpsertArgsSchema: z.ZodType<Prisma.ProductVariantUpsertArgs> =
  z
    .object({
      select: ProductVariantSelectSchema.optional(),
      include: ProductVariantIncludeSchema.optional(),
      where: ProductVariantWhereUniqueInputSchema,
      create: z.union([
        ProductVariantCreateInputSchema,
        ProductVariantUncheckedCreateInputSchema,
      ]),
      update: z.union([
        ProductVariantUpdateInputSchema,
        ProductVariantUncheckedUpdateInputSchema,
      ]),
    })
    .strict() as z.ZodType<Prisma.ProductVariantUpsertArgs>;

export const ProductVariantCreateManyArgsSchema: z.ZodType<Prisma.ProductVariantCreateManyArgs> =
  z
    .object({
      data: z.union([
        ProductVariantCreateManyInputSchema,
        ProductVariantCreateManyInputSchema.array(),
      ]),
      skipDuplicates: z.boolean().optional(),
    })
    .strict() as z.ZodType<Prisma.ProductVariantCreateManyArgs>;

export const ProductVariantCreateManyAndReturnArgsSchema: z.ZodType<Prisma.ProductVariantCreateManyAndReturnArgs> =
  z
    .object({
      data: z.union([
        ProductVariantCreateManyInputSchema,
        ProductVariantCreateManyInputSchema.array(),
      ]),
      skipDuplicates: z.boolean().optional(),
    })
    .strict() as z.ZodType<Prisma.ProductVariantCreateManyAndReturnArgs>;

export const ProductVariantDeleteArgsSchema: z.ZodType<Prisma.ProductVariantDeleteArgs> =
  z
    .object({
      select: ProductVariantSelectSchema.optional(),
      include: ProductVariantIncludeSchema.optional(),
      where: ProductVariantWhereUniqueInputSchema,
    })
    .strict() as z.ZodType<Prisma.ProductVariantDeleteArgs>;

export const ProductVariantUpdateArgsSchema: z.ZodType<Prisma.ProductVariantUpdateArgs> =
  z
    .object({
      select: ProductVariantSelectSchema.optional(),
      include: ProductVariantIncludeSchema.optional(),
      data: z.union([
        ProductVariantUpdateInputSchema,
        ProductVariantUncheckedUpdateInputSchema,
      ]),
      where: ProductVariantWhereUniqueInputSchema,
    })
    .strict() as z.ZodType<Prisma.ProductVariantUpdateArgs>;

export const ProductVariantUpdateManyArgsSchema: z.ZodType<Prisma.ProductVariantUpdateManyArgs> =
  z
    .object({
      data: z.union([
        ProductVariantUpdateManyMutationInputSchema,
        ProductVariantUncheckedUpdateManyInputSchema,
      ]),
      where: ProductVariantWhereInputSchema.optional(),
      limit: z.number().optional(),
    })
    .strict() as z.ZodType<Prisma.ProductVariantUpdateManyArgs>;

export const ProductVariantUpdateManyAndReturnArgsSchema: z.ZodType<Prisma.ProductVariantUpdateManyAndReturnArgs> =
  z
    .object({
      data: z.union([
        ProductVariantUpdateManyMutationInputSchema,
        ProductVariantUncheckedUpdateManyInputSchema,
      ]),
      where: ProductVariantWhereInputSchema.optional(),
      limit: z.number().optional(),
    })
    .strict() as z.ZodType<Prisma.ProductVariantUpdateManyAndReturnArgs>;

export const ProductVariantDeleteManyArgsSchema: z.ZodType<Prisma.ProductVariantDeleteManyArgs> =
  z
    .object({
      where: ProductVariantWhereInputSchema.optional(),
      limit: z.number().optional(),
    })
    .strict() as z.ZodType<Prisma.ProductVariantDeleteManyArgs>;

export const ProductCategoryCreateArgsSchema: z.ZodType<Prisma.ProductCategoryCreateArgs> =
  z
    .object({
      select: ProductCategorySelectSchema.optional(),
      include: ProductCategoryIncludeSchema.optional(),
      data: z.union([
        ProductCategoryCreateInputSchema,
        ProductCategoryUncheckedCreateInputSchema,
      ]),
    })
    .strict() as z.ZodType<Prisma.ProductCategoryCreateArgs>;

export const ProductCategoryUpsertArgsSchema: z.ZodType<Prisma.ProductCategoryUpsertArgs> =
  z
    .object({
      select: ProductCategorySelectSchema.optional(),
      include: ProductCategoryIncludeSchema.optional(),
      where: ProductCategoryWhereUniqueInputSchema,
      create: z.union([
        ProductCategoryCreateInputSchema,
        ProductCategoryUncheckedCreateInputSchema,
      ]),
      update: z.union([
        ProductCategoryUpdateInputSchema,
        ProductCategoryUncheckedUpdateInputSchema,
      ]),
    })
    .strict() as z.ZodType<Prisma.ProductCategoryUpsertArgs>;

export const ProductCategoryCreateManyArgsSchema: z.ZodType<Prisma.ProductCategoryCreateManyArgs> =
  z
    .object({
      data: z.union([
        ProductCategoryCreateManyInputSchema,
        ProductCategoryCreateManyInputSchema.array(),
      ]),
      skipDuplicates: z.boolean().optional(),
    })
    .strict() as z.ZodType<Prisma.ProductCategoryCreateManyArgs>;

export const ProductCategoryCreateManyAndReturnArgsSchema: z.ZodType<Prisma.ProductCategoryCreateManyAndReturnArgs> =
  z
    .object({
      data: z.union([
        ProductCategoryCreateManyInputSchema,
        ProductCategoryCreateManyInputSchema.array(),
      ]),
      skipDuplicates: z.boolean().optional(),
    })
    .strict() as z.ZodType<Prisma.ProductCategoryCreateManyAndReturnArgs>;

export const ProductCategoryDeleteArgsSchema: z.ZodType<Prisma.ProductCategoryDeleteArgs> =
  z
    .object({
      select: ProductCategorySelectSchema.optional(),
      include: ProductCategoryIncludeSchema.optional(),
      where: ProductCategoryWhereUniqueInputSchema,
    })
    .strict() as z.ZodType<Prisma.ProductCategoryDeleteArgs>;

export const ProductCategoryUpdateArgsSchema: z.ZodType<Prisma.ProductCategoryUpdateArgs> =
  z
    .object({
      select: ProductCategorySelectSchema.optional(),
      include: ProductCategoryIncludeSchema.optional(),
      data: z.union([
        ProductCategoryUpdateInputSchema,
        ProductCategoryUncheckedUpdateInputSchema,
      ]),
      where: ProductCategoryWhereUniqueInputSchema,
    })
    .strict() as z.ZodType<Prisma.ProductCategoryUpdateArgs>;

export const ProductCategoryUpdateManyArgsSchema: z.ZodType<Prisma.ProductCategoryUpdateManyArgs> =
  z
    .object({
      data: z.union([
        ProductCategoryUpdateManyMutationInputSchema,
        ProductCategoryUncheckedUpdateManyInputSchema,
      ]),
      where: ProductCategoryWhereInputSchema.optional(),
      limit: z.number().optional(),
    })
    .strict() as z.ZodType<Prisma.ProductCategoryUpdateManyArgs>;

export const ProductCategoryUpdateManyAndReturnArgsSchema: z.ZodType<Prisma.ProductCategoryUpdateManyAndReturnArgs> =
  z
    .object({
      data: z.union([
        ProductCategoryUpdateManyMutationInputSchema,
        ProductCategoryUncheckedUpdateManyInputSchema,
      ]),
      where: ProductCategoryWhereInputSchema.optional(),
      limit: z.number().optional(),
    })
    .strict() as z.ZodType<Prisma.ProductCategoryUpdateManyAndReturnArgs>;

export const ProductCategoryDeleteManyArgsSchema: z.ZodType<Prisma.ProductCategoryDeleteManyArgs> =
  z
    .object({
      where: ProductCategoryWhereInputSchema.optional(),
      limit: z.number().optional(),
    })
    .strict() as z.ZodType<Prisma.ProductCategoryDeleteManyArgs>;

export const ProductImageCreateArgsSchema: z.ZodType<Prisma.ProductImageCreateArgs> =
  z
    .object({
      select: ProductImageSelectSchema.optional(),
      include: ProductImageIncludeSchema.optional(),
      data: z.union([
        ProductImageCreateInputSchema,
        ProductImageUncheckedCreateInputSchema,
      ]),
    })
    .strict() as z.ZodType<Prisma.ProductImageCreateArgs>;

export const ProductImageUpsertArgsSchema: z.ZodType<Prisma.ProductImageUpsertArgs> =
  z
    .object({
      select: ProductImageSelectSchema.optional(),
      include: ProductImageIncludeSchema.optional(),
      where: ProductImageWhereUniqueInputSchema,
      create: z.union([
        ProductImageCreateInputSchema,
        ProductImageUncheckedCreateInputSchema,
      ]),
      update: z.union([
        ProductImageUpdateInputSchema,
        ProductImageUncheckedUpdateInputSchema,
      ]),
    })
    .strict() as z.ZodType<Prisma.ProductImageUpsertArgs>;

export const ProductImageCreateManyArgsSchema: z.ZodType<Prisma.ProductImageCreateManyArgs> =
  z
    .object({
      data: z.union([
        ProductImageCreateManyInputSchema,
        ProductImageCreateManyInputSchema.array(),
      ]),
      skipDuplicates: z.boolean().optional(),
    })
    .strict() as z.ZodType<Prisma.ProductImageCreateManyArgs>;

export const ProductImageCreateManyAndReturnArgsSchema: z.ZodType<Prisma.ProductImageCreateManyAndReturnArgs> =
  z
    .object({
      data: z.union([
        ProductImageCreateManyInputSchema,
        ProductImageCreateManyInputSchema.array(),
      ]),
      skipDuplicates: z.boolean().optional(),
    })
    .strict() as z.ZodType<Prisma.ProductImageCreateManyAndReturnArgs>;

export const ProductImageDeleteArgsSchema: z.ZodType<Prisma.ProductImageDeleteArgs> =
  z
    .object({
      select: ProductImageSelectSchema.optional(),
      include: ProductImageIncludeSchema.optional(),
      where: ProductImageWhereUniqueInputSchema,
    })
    .strict() as z.ZodType<Prisma.ProductImageDeleteArgs>;

export const ProductImageUpdateArgsSchema: z.ZodType<Prisma.ProductImageUpdateArgs> =
  z
    .object({
      select: ProductImageSelectSchema.optional(),
      include: ProductImageIncludeSchema.optional(),
      data: z.union([
        ProductImageUpdateInputSchema,
        ProductImageUncheckedUpdateInputSchema,
      ]),
      where: ProductImageWhereUniqueInputSchema,
    })
    .strict() as z.ZodType<Prisma.ProductImageUpdateArgs>;

export const ProductImageUpdateManyArgsSchema: z.ZodType<Prisma.ProductImageUpdateManyArgs> =
  z
    .object({
      data: z.union([
        ProductImageUpdateManyMutationInputSchema,
        ProductImageUncheckedUpdateManyInputSchema,
      ]),
      where: ProductImageWhereInputSchema.optional(),
      limit: z.number().optional(),
    })
    .strict() as z.ZodType<Prisma.ProductImageUpdateManyArgs>;

export const ProductImageUpdateManyAndReturnArgsSchema: z.ZodType<Prisma.ProductImageUpdateManyAndReturnArgs> =
  z
    .object({
      data: z.union([
        ProductImageUpdateManyMutationInputSchema,
        ProductImageUncheckedUpdateManyInputSchema,
      ]),
      where: ProductImageWhereInputSchema.optional(),
      limit: z.number().optional(),
    })
    .strict() as z.ZodType<Prisma.ProductImageUpdateManyAndReturnArgs>;

export const ProductImageDeleteManyArgsSchema: z.ZodType<Prisma.ProductImageDeleteManyArgs> =
  z
    .object({
      where: ProductImageWhereInputSchema.optional(),
      limit: z.number().optional(),
    })
    .strict() as z.ZodType<Prisma.ProductImageDeleteManyArgs>;

export const OrderCreateArgsSchema: z.ZodType<Prisma.OrderCreateArgs> = z
  .object({
    select: OrderSelectSchema.optional(),
    include: OrderIncludeSchema.optional(),
    data: z.union([OrderCreateInputSchema, OrderUncheckedCreateInputSchema]),
  })
  .strict() as z.ZodType<Prisma.OrderCreateArgs>;

export const OrderUpsertArgsSchema: z.ZodType<Prisma.OrderUpsertArgs> = z
  .object({
    select: OrderSelectSchema.optional(),
    include: OrderIncludeSchema.optional(),
    where: OrderWhereUniqueInputSchema,
    create: z.union([OrderCreateInputSchema, OrderUncheckedCreateInputSchema]),
    update: z.union([OrderUpdateInputSchema, OrderUncheckedUpdateInputSchema]),
  })
  .strict() as z.ZodType<Prisma.OrderUpsertArgs>;

export const OrderCreateManyArgsSchema: z.ZodType<Prisma.OrderCreateManyArgs> =
  z
    .object({
      data: z.union([
        OrderCreateManyInputSchema,
        OrderCreateManyInputSchema.array(),
      ]),
      skipDuplicates: z.boolean().optional(),
    })
    .strict() as z.ZodType<Prisma.OrderCreateManyArgs>;

export const OrderCreateManyAndReturnArgsSchema: z.ZodType<Prisma.OrderCreateManyAndReturnArgs> =
  z
    .object({
      data: z.union([
        OrderCreateManyInputSchema,
        OrderCreateManyInputSchema.array(),
      ]),
      skipDuplicates: z.boolean().optional(),
    })
    .strict() as z.ZodType<Prisma.OrderCreateManyAndReturnArgs>;

export const OrderDeleteArgsSchema: z.ZodType<Prisma.OrderDeleteArgs> = z
  .object({
    select: OrderSelectSchema.optional(),
    include: OrderIncludeSchema.optional(),
    where: OrderWhereUniqueInputSchema,
  })
  .strict() as z.ZodType<Prisma.OrderDeleteArgs>;

export const OrderUpdateArgsSchema: z.ZodType<Prisma.OrderUpdateArgs> = z
  .object({
    select: OrderSelectSchema.optional(),
    include: OrderIncludeSchema.optional(),
    data: z.union([OrderUpdateInputSchema, OrderUncheckedUpdateInputSchema]),
    where: OrderWhereUniqueInputSchema,
  })
  .strict() as z.ZodType<Prisma.OrderUpdateArgs>;

export const OrderUpdateManyArgsSchema: z.ZodType<Prisma.OrderUpdateManyArgs> =
  z
    .object({
      data: z.union([
        OrderUpdateManyMutationInputSchema,
        OrderUncheckedUpdateManyInputSchema,
      ]),
      where: OrderWhereInputSchema.optional(),
      limit: z.number().optional(),
    })
    .strict() as z.ZodType<Prisma.OrderUpdateManyArgs>;

export const OrderUpdateManyAndReturnArgsSchema: z.ZodType<Prisma.OrderUpdateManyAndReturnArgs> =
  z
    .object({
      data: z.union([
        OrderUpdateManyMutationInputSchema,
        OrderUncheckedUpdateManyInputSchema,
      ]),
      where: OrderWhereInputSchema.optional(),
      limit: z.number().optional(),
    })
    .strict() as z.ZodType<Prisma.OrderUpdateManyAndReturnArgs>;

export const OrderDeleteManyArgsSchema: z.ZodType<Prisma.OrderDeleteManyArgs> =
  z
    .object({
      where: OrderWhereInputSchema.optional(),
      limit: z.number().optional(),
    })
    .strict() as z.ZodType<Prisma.OrderDeleteManyArgs>;

export const OrderItemCreateArgsSchema: z.ZodType<Prisma.OrderItemCreateArgs> =
  z
    .object({
      select: OrderItemSelectSchema.optional(),
      include: OrderItemIncludeSchema.optional(),
      data: z.union([
        OrderItemCreateInputSchema,
        OrderItemUncheckedCreateInputSchema,
      ]),
    })
    .strict() as z.ZodType<Prisma.OrderItemCreateArgs>;

export const OrderItemUpsertArgsSchema: z.ZodType<Prisma.OrderItemUpsertArgs> =
  z
    .object({
      select: OrderItemSelectSchema.optional(),
      include: OrderItemIncludeSchema.optional(),
      where: OrderItemWhereUniqueInputSchema,
      create: z.union([
        OrderItemCreateInputSchema,
        OrderItemUncheckedCreateInputSchema,
      ]),
      update: z.union([
        OrderItemUpdateInputSchema,
        OrderItemUncheckedUpdateInputSchema,
      ]),
    })
    .strict() as z.ZodType<Prisma.OrderItemUpsertArgs>;

export const OrderItemCreateManyArgsSchema: z.ZodType<Prisma.OrderItemCreateManyArgs> =
  z
    .object({
      data: z.union([
        OrderItemCreateManyInputSchema,
        OrderItemCreateManyInputSchema.array(),
      ]),
      skipDuplicates: z.boolean().optional(),
    })
    .strict() as z.ZodType<Prisma.OrderItemCreateManyArgs>;

export const OrderItemCreateManyAndReturnArgsSchema: z.ZodType<Prisma.OrderItemCreateManyAndReturnArgs> =
  z
    .object({
      data: z.union([
        OrderItemCreateManyInputSchema,
        OrderItemCreateManyInputSchema.array(),
      ]),
      skipDuplicates: z.boolean().optional(),
    })
    .strict() as z.ZodType<Prisma.OrderItemCreateManyAndReturnArgs>;

export const OrderItemDeleteArgsSchema: z.ZodType<Prisma.OrderItemDeleteArgs> =
  z
    .object({
      select: OrderItemSelectSchema.optional(),
      include: OrderItemIncludeSchema.optional(),
      where: OrderItemWhereUniqueInputSchema,
    })
    .strict() as z.ZodType<Prisma.OrderItemDeleteArgs>;

export const OrderItemUpdateArgsSchema: z.ZodType<Prisma.OrderItemUpdateArgs> =
  z
    .object({
      select: OrderItemSelectSchema.optional(),
      include: OrderItemIncludeSchema.optional(),
      data: z.union([
        OrderItemUpdateInputSchema,
        OrderItemUncheckedUpdateInputSchema,
      ]),
      where: OrderItemWhereUniqueInputSchema,
    })
    .strict() as z.ZodType<Prisma.OrderItemUpdateArgs>;

export const OrderItemUpdateManyArgsSchema: z.ZodType<Prisma.OrderItemUpdateManyArgs> =
  z
    .object({
      data: z.union([
        OrderItemUpdateManyMutationInputSchema,
        OrderItemUncheckedUpdateManyInputSchema,
      ]),
      where: OrderItemWhereInputSchema.optional(),
      limit: z.number().optional(),
    })
    .strict() as z.ZodType<Prisma.OrderItemUpdateManyArgs>;

export const OrderItemUpdateManyAndReturnArgsSchema: z.ZodType<Prisma.OrderItemUpdateManyAndReturnArgs> =
  z
    .object({
      data: z.union([
        OrderItemUpdateManyMutationInputSchema,
        OrderItemUncheckedUpdateManyInputSchema,
      ]),
      where: OrderItemWhereInputSchema.optional(),
      limit: z.number().optional(),
    })
    .strict() as z.ZodType<Prisma.OrderItemUpdateManyAndReturnArgs>;

export const OrderItemDeleteManyArgsSchema: z.ZodType<Prisma.OrderItemDeleteManyArgs> =
  z
    .object({
      where: OrderItemWhereInputSchema.optional(),
      limit: z.number().optional(),
    })
    .strict() as z.ZodType<Prisma.OrderItemDeleteManyArgs>;

export const OrderAddressCreateArgsSchema: z.ZodType<Prisma.OrderAddressCreateArgs> =
  z
    .object({
      select: OrderAddressSelectSchema.optional(),
      include: OrderAddressIncludeSchema.optional(),
      data: z.union([
        OrderAddressCreateInputSchema,
        OrderAddressUncheckedCreateInputSchema,
      ]),
    })
    .strict() as z.ZodType<Prisma.OrderAddressCreateArgs>;

export const OrderAddressUpsertArgsSchema: z.ZodType<Prisma.OrderAddressUpsertArgs> =
  z
    .object({
      select: OrderAddressSelectSchema.optional(),
      include: OrderAddressIncludeSchema.optional(),
      where: OrderAddressWhereUniqueInputSchema,
      create: z.union([
        OrderAddressCreateInputSchema,
        OrderAddressUncheckedCreateInputSchema,
      ]),
      update: z.union([
        OrderAddressUpdateInputSchema,
        OrderAddressUncheckedUpdateInputSchema,
      ]),
    })
    .strict() as z.ZodType<Prisma.OrderAddressUpsertArgs>;

export const OrderAddressCreateManyArgsSchema: z.ZodType<Prisma.OrderAddressCreateManyArgs> =
  z
    .object({
      data: z.union([
        OrderAddressCreateManyInputSchema,
        OrderAddressCreateManyInputSchema.array(),
      ]),
      skipDuplicates: z.boolean().optional(),
    })
    .strict() as z.ZodType<Prisma.OrderAddressCreateManyArgs>;

export const OrderAddressCreateManyAndReturnArgsSchema: z.ZodType<Prisma.OrderAddressCreateManyAndReturnArgs> =
  z
    .object({
      data: z.union([
        OrderAddressCreateManyInputSchema,
        OrderAddressCreateManyInputSchema.array(),
      ]),
      skipDuplicates: z.boolean().optional(),
    })
    .strict() as z.ZodType<Prisma.OrderAddressCreateManyAndReturnArgs>;

export const OrderAddressDeleteArgsSchema: z.ZodType<Prisma.OrderAddressDeleteArgs> =
  z
    .object({
      select: OrderAddressSelectSchema.optional(),
      include: OrderAddressIncludeSchema.optional(),
      where: OrderAddressWhereUniqueInputSchema,
    })
    .strict() as z.ZodType<Prisma.OrderAddressDeleteArgs>;

export const OrderAddressUpdateArgsSchema: z.ZodType<Prisma.OrderAddressUpdateArgs> =
  z
    .object({
      select: OrderAddressSelectSchema.optional(),
      include: OrderAddressIncludeSchema.optional(),
      data: z.union([
        OrderAddressUpdateInputSchema,
        OrderAddressUncheckedUpdateInputSchema,
      ]),
      where: OrderAddressWhereUniqueInputSchema,
    })
    .strict() as z.ZodType<Prisma.OrderAddressUpdateArgs>;

export const OrderAddressUpdateManyArgsSchema: z.ZodType<Prisma.OrderAddressUpdateManyArgs> =
  z
    .object({
      data: z.union([
        OrderAddressUpdateManyMutationInputSchema,
        OrderAddressUncheckedUpdateManyInputSchema,
      ]),
      where: OrderAddressWhereInputSchema.optional(),
      limit: z.number().optional(),
    })
    .strict() as z.ZodType<Prisma.OrderAddressUpdateManyArgs>;

export const OrderAddressUpdateManyAndReturnArgsSchema: z.ZodType<Prisma.OrderAddressUpdateManyAndReturnArgs> =
  z
    .object({
      data: z.union([
        OrderAddressUpdateManyMutationInputSchema,
        OrderAddressUncheckedUpdateManyInputSchema,
      ]),
      where: OrderAddressWhereInputSchema.optional(),
      limit: z.number().optional(),
    })
    .strict() as z.ZodType<Prisma.OrderAddressUpdateManyAndReturnArgs>;

export const OrderAddressDeleteManyArgsSchema: z.ZodType<Prisma.OrderAddressDeleteManyArgs> =
  z
    .object({
      where: OrderAddressWhereInputSchema.optional(),
      limit: z.number().optional(),
    })
    .strict() as z.ZodType<Prisma.OrderAddressDeleteManyArgs>;

export const PromotionCreateArgsSchema: z.ZodType<Prisma.PromotionCreateArgs> =
  z
    .object({
      select: PromotionSelectSchema.optional(),
      include: PromotionIncludeSchema.optional(),
      data: z.union([
        PromotionCreateInputSchema,
        PromotionUncheckedCreateInputSchema,
      ]),
    })
    .strict() as z.ZodType<Prisma.PromotionCreateArgs>;

export const PromotionUpsertArgsSchema: z.ZodType<Prisma.PromotionUpsertArgs> =
  z
    .object({
      select: PromotionSelectSchema.optional(),
      include: PromotionIncludeSchema.optional(),
      where: PromotionWhereUniqueInputSchema,
      create: z.union([
        PromotionCreateInputSchema,
        PromotionUncheckedCreateInputSchema,
      ]),
      update: z.union([
        PromotionUpdateInputSchema,
        PromotionUncheckedUpdateInputSchema,
      ]),
    })
    .strict() as z.ZodType<Prisma.PromotionUpsertArgs>;

export const PromotionCreateManyArgsSchema: z.ZodType<Prisma.PromotionCreateManyArgs> =
  z
    .object({
      data: z.union([
        PromotionCreateManyInputSchema,
        PromotionCreateManyInputSchema.array(),
      ]),
      skipDuplicates: z.boolean().optional(),
    })
    .strict() as z.ZodType<Prisma.PromotionCreateManyArgs>;

export const PromotionCreateManyAndReturnArgsSchema: z.ZodType<Prisma.PromotionCreateManyAndReturnArgs> =
  z
    .object({
      data: z.union([
        PromotionCreateManyInputSchema,
        PromotionCreateManyInputSchema.array(),
      ]),
      skipDuplicates: z.boolean().optional(),
    })
    .strict() as z.ZodType<Prisma.PromotionCreateManyAndReturnArgs>;

export const PromotionDeleteArgsSchema: z.ZodType<Prisma.PromotionDeleteArgs> =
  z
    .object({
      select: PromotionSelectSchema.optional(),
      include: PromotionIncludeSchema.optional(),
      where: PromotionWhereUniqueInputSchema,
    })
    .strict() as z.ZodType<Prisma.PromotionDeleteArgs>;

export const PromotionUpdateArgsSchema: z.ZodType<Prisma.PromotionUpdateArgs> =
  z
    .object({
      select: PromotionSelectSchema.optional(),
      include: PromotionIncludeSchema.optional(),
      data: z.union([
        PromotionUpdateInputSchema,
        PromotionUncheckedUpdateInputSchema,
      ]),
      where: PromotionWhereUniqueInputSchema,
    })
    .strict() as z.ZodType<Prisma.PromotionUpdateArgs>;

export const PromotionUpdateManyArgsSchema: z.ZodType<Prisma.PromotionUpdateManyArgs> =
  z
    .object({
      data: z.union([
        PromotionUpdateManyMutationInputSchema,
        PromotionUncheckedUpdateManyInputSchema,
      ]),
      where: PromotionWhereInputSchema.optional(),
      limit: z.number().optional(),
    })
    .strict() as z.ZodType<Prisma.PromotionUpdateManyArgs>;

export const PromotionUpdateManyAndReturnArgsSchema: z.ZodType<Prisma.PromotionUpdateManyAndReturnArgs> =
  z
    .object({
      data: z.union([
        PromotionUpdateManyMutationInputSchema,
        PromotionUncheckedUpdateManyInputSchema,
      ]),
      where: PromotionWhereInputSchema.optional(),
      limit: z.number().optional(),
    })
    .strict() as z.ZodType<Prisma.PromotionUpdateManyAndReturnArgs>;

export const PromotionDeleteManyArgsSchema: z.ZodType<Prisma.PromotionDeleteManyArgs> =
  z
    .object({
      where: PromotionWhereInputSchema.optional(),
      limit: z.number().optional(),
    })
    .strict() as z.ZodType<Prisma.PromotionDeleteManyArgs>;

export const OrderPromotionCreateArgsSchema: z.ZodType<Prisma.OrderPromotionCreateArgs> =
  z
    .object({
      select: OrderPromotionSelectSchema.optional(),
      include: OrderPromotionIncludeSchema.optional(),
      data: z.union([
        OrderPromotionCreateInputSchema,
        OrderPromotionUncheckedCreateInputSchema,
      ]),
    })
    .strict() as z.ZodType<Prisma.OrderPromotionCreateArgs>;

export const OrderPromotionUpsertArgsSchema: z.ZodType<Prisma.OrderPromotionUpsertArgs> =
  z
    .object({
      select: OrderPromotionSelectSchema.optional(),
      include: OrderPromotionIncludeSchema.optional(),
      where: OrderPromotionWhereUniqueInputSchema,
      create: z.union([
        OrderPromotionCreateInputSchema,
        OrderPromotionUncheckedCreateInputSchema,
      ]),
      update: z.union([
        OrderPromotionUpdateInputSchema,
        OrderPromotionUncheckedUpdateInputSchema,
      ]),
    })
    .strict() as z.ZodType<Prisma.OrderPromotionUpsertArgs>;

export const OrderPromotionCreateManyArgsSchema: z.ZodType<Prisma.OrderPromotionCreateManyArgs> =
  z
    .object({
      data: z.union([
        OrderPromotionCreateManyInputSchema,
        OrderPromotionCreateManyInputSchema.array(),
      ]),
      skipDuplicates: z.boolean().optional(),
    })
    .strict() as z.ZodType<Prisma.OrderPromotionCreateManyArgs>;

export const OrderPromotionCreateManyAndReturnArgsSchema: z.ZodType<Prisma.OrderPromotionCreateManyAndReturnArgs> =
  z
    .object({
      data: z.union([
        OrderPromotionCreateManyInputSchema,
        OrderPromotionCreateManyInputSchema.array(),
      ]),
      skipDuplicates: z.boolean().optional(),
    })
    .strict() as z.ZodType<Prisma.OrderPromotionCreateManyAndReturnArgs>;

export const OrderPromotionDeleteArgsSchema: z.ZodType<Prisma.OrderPromotionDeleteArgs> =
  z
    .object({
      select: OrderPromotionSelectSchema.optional(),
      include: OrderPromotionIncludeSchema.optional(),
      where: OrderPromotionWhereUniqueInputSchema,
    })
    .strict() as z.ZodType<Prisma.OrderPromotionDeleteArgs>;

export const OrderPromotionUpdateArgsSchema: z.ZodType<Prisma.OrderPromotionUpdateArgs> =
  z
    .object({
      select: OrderPromotionSelectSchema.optional(),
      include: OrderPromotionIncludeSchema.optional(),
      data: z.union([
        OrderPromotionUpdateInputSchema,
        OrderPromotionUncheckedUpdateInputSchema,
      ]),
      where: OrderPromotionWhereUniqueInputSchema,
    })
    .strict() as z.ZodType<Prisma.OrderPromotionUpdateArgs>;

export const OrderPromotionUpdateManyArgsSchema: z.ZodType<Prisma.OrderPromotionUpdateManyArgs> =
  z
    .object({
      data: z.union([
        OrderPromotionUpdateManyMutationInputSchema,
        OrderPromotionUncheckedUpdateManyInputSchema,
      ]),
      where: OrderPromotionWhereInputSchema.optional(),
      limit: z.number().optional(),
    })
    .strict() as z.ZodType<Prisma.OrderPromotionUpdateManyArgs>;

export const OrderPromotionUpdateManyAndReturnArgsSchema: z.ZodType<Prisma.OrderPromotionUpdateManyAndReturnArgs> =
  z
    .object({
      data: z.union([
        OrderPromotionUpdateManyMutationInputSchema,
        OrderPromotionUncheckedUpdateManyInputSchema,
      ]),
      where: OrderPromotionWhereInputSchema.optional(),
      limit: z.number().optional(),
    })
    .strict() as z.ZodType<Prisma.OrderPromotionUpdateManyAndReturnArgs>;

export const OrderPromotionDeleteManyArgsSchema: z.ZodType<Prisma.OrderPromotionDeleteManyArgs> =
  z
    .object({
      where: OrderPromotionWhereInputSchema.optional(),
      limit: z.number().optional(),
    })
    .strict() as z.ZodType<Prisma.OrderPromotionDeleteManyArgs>;

export const CartCreateArgsSchema: z.ZodType<Prisma.CartCreateArgs> = z
  .object({
    select: CartSelectSchema.optional(),
    include: CartIncludeSchema.optional(),
    data: z.union([CartCreateInputSchema, CartUncheckedCreateInputSchema]),
  })
  .strict() as z.ZodType<Prisma.CartCreateArgs>;

export const CartUpsertArgsSchema: z.ZodType<Prisma.CartUpsertArgs> = z
  .object({
    select: CartSelectSchema.optional(),
    include: CartIncludeSchema.optional(),
    where: CartWhereUniqueInputSchema,
    create: z.union([CartCreateInputSchema, CartUncheckedCreateInputSchema]),
    update: z.union([CartUpdateInputSchema, CartUncheckedUpdateInputSchema]),
  })
  .strict() as z.ZodType<Prisma.CartUpsertArgs>;

export const CartCreateManyArgsSchema: z.ZodType<Prisma.CartCreateManyArgs> = z
  .object({
    data: z.union([
      CartCreateManyInputSchema,
      CartCreateManyInputSchema.array(),
    ]),
    skipDuplicates: z.boolean().optional(),
  })
  .strict() as z.ZodType<Prisma.CartCreateManyArgs>;

export const CartCreateManyAndReturnArgsSchema: z.ZodType<Prisma.CartCreateManyAndReturnArgs> =
  z
    .object({
      data: z.union([
        CartCreateManyInputSchema,
        CartCreateManyInputSchema.array(),
      ]),
      skipDuplicates: z.boolean().optional(),
    })
    .strict() as z.ZodType<Prisma.CartCreateManyAndReturnArgs>;

export const CartDeleteArgsSchema: z.ZodType<Prisma.CartDeleteArgs> = z
  .object({
    select: CartSelectSchema.optional(),
    include: CartIncludeSchema.optional(),
    where: CartWhereUniqueInputSchema,
  })
  .strict() as z.ZodType<Prisma.CartDeleteArgs>;

export const CartUpdateArgsSchema: z.ZodType<Prisma.CartUpdateArgs> = z
  .object({
    select: CartSelectSchema.optional(),
    include: CartIncludeSchema.optional(),
    data: z.union([CartUpdateInputSchema, CartUncheckedUpdateInputSchema]),
    where: CartWhereUniqueInputSchema,
  })
  .strict() as z.ZodType<Prisma.CartUpdateArgs>;

export const CartUpdateManyArgsSchema: z.ZodType<Prisma.CartUpdateManyArgs> = z
  .object({
    data: z.union([
      CartUpdateManyMutationInputSchema,
      CartUncheckedUpdateManyInputSchema,
    ]),
    where: CartWhereInputSchema.optional(),
    limit: z.number().optional(),
  })
  .strict() as z.ZodType<Prisma.CartUpdateManyArgs>;

export const CartUpdateManyAndReturnArgsSchema: z.ZodType<Prisma.CartUpdateManyAndReturnArgs> =
  z
    .object({
      data: z.union([
        CartUpdateManyMutationInputSchema,
        CartUncheckedUpdateManyInputSchema,
      ]),
      where: CartWhereInputSchema.optional(),
      limit: z.number().optional(),
    })
    .strict() as z.ZodType<Prisma.CartUpdateManyAndReturnArgs>;

export const CartDeleteManyArgsSchema: z.ZodType<Prisma.CartDeleteManyArgs> = z
  .object({
    where: CartWhereInputSchema.optional(),
    limit: z.number().optional(),
  })
  .strict() as z.ZodType<Prisma.CartDeleteManyArgs>;

export const CartItemCreateArgsSchema: z.ZodType<Prisma.CartItemCreateArgs> = z
  .object({
    select: CartItemSelectSchema.optional(),
    include: CartItemIncludeSchema.optional(),
    data: z.union([
      CartItemCreateInputSchema,
      CartItemUncheckedCreateInputSchema,
    ]),
  })
  .strict() as z.ZodType<Prisma.CartItemCreateArgs>;

export const CartItemUpsertArgsSchema: z.ZodType<Prisma.CartItemUpsertArgs> = z
  .object({
    select: CartItemSelectSchema.optional(),
    include: CartItemIncludeSchema.optional(),
    where: CartItemWhereUniqueInputSchema,
    create: z.union([
      CartItemCreateInputSchema,
      CartItemUncheckedCreateInputSchema,
    ]),
    update: z.union([
      CartItemUpdateInputSchema,
      CartItemUncheckedUpdateInputSchema,
    ]),
  })
  .strict() as z.ZodType<Prisma.CartItemUpsertArgs>;

export const CartItemCreateManyArgsSchema: z.ZodType<Prisma.CartItemCreateManyArgs> =
  z
    .object({
      data: z.union([
        CartItemCreateManyInputSchema,
        CartItemCreateManyInputSchema.array(),
      ]),
      skipDuplicates: z.boolean().optional(),
    })
    .strict() as z.ZodType<Prisma.CartItemCreateManyArgs>;

export const CartItemCreateManyAndReturnArgsSchema: z.ZodType<Prisma.CartItemCreateManyAndReturnArgs> =
  z
    .object({
      data: z.union([
        CartItemCreateManyInputSchema,
        CartItemCreateManyInputSchema.array(),
      ]),
      skipDuplicates: z.boolean().optional(),
    })
    .strict() as z.ZodType<Prisma.CartItemCreateManyAndReturnArgs>;

export const CartItemDeleteArgsSchema: z.ZodType<Prisma.CartItemDeleteArgs> = z
  .object({
    select: CartItemSelectSchema.optional(),
    include: CartItemIncludeSchema.optional(),
    where: CartItemWhereUniqueInputSchema,
  })
  .strict() as z.ZodType<Prisma.CartItemDeleteArgs>;

export const CartItemUpdateArgsSchema: z.ZodType<Prisma.CartItemUpdateArgs> = z
  .object({
    select: CartItemSelectSchema.optional(),
    include: CartItemIncludeSchema.optional(),
    data: z.union([
      CartItemUpdateInputSchema,
      CartItemUncheckedUpdateInputSchema,
    ]),
    where: CartItemWhereUniqueInputSchema,
  })
  .strict() as z.ZodType<Prisma.CartItemUpdateArgs>;

export const CartItemUpdateManyArgsSchema: z.ZodType<Prisma.CartItemUpdateManyArgs> =
  z
    .object({
      data: z.union([
        CartItemUpdateManyMutationInputSchema,
        CartItemUncheckedUpdateManyInputSchema,
      ]),
      where: CartItemWhereInputSchema.optional(),
      limit: z.number().optional(),
    })
    .strict() as z.ZodType<Prisma.CartItemUpdateManyArgs>;

export const CartItemUpdateManyAndReturnArgsSchema: z.ZodType<Prisma.CartItemUpdateManyAndReturnArgs> =
  z
    .object({
      data: z.union([
        CartItemUpdateManyMutationInputSchema,
        CartItemUncheckedUpdateManyInputSchema,
      ]),
      where: CartItemWhereInputSchema.optional(),
      limit: z.number().optional(),
    })
    .strict() as z.ZodType<Prisma.CartItemUpdateManyAndReturnArgs>;

export const CartItemDeleteManyArgsSchema: z.ZodType<Prisma.CartItemDeleteManyArgs> =
  z
    .object({
      where: CartItemWhereInputSchema.optional(),
      limit: z.number().optional(),
    })
    .strict() as z.ZodType<Prisma.CartItemDeleteManyArgs>;

export const NotificationCreateArgsSchema: z.ZodType<Prisma.NotificationCreateArgs> =
  z
    .object({
      select: NotificationSelectSchema.optional(),
      include: NotificationIncludeSchema.optional(),
      data: z.union([
        NotificationCreateInputSchema,
        NotificationUncheckedCreateInputSchema,
      ]),
    })
    .strict() as z.ZodType<Prisma.NotificationCreateArgs>;

export const NotificationUpsertArgsSchema: z.ZodType<Prisma.NotificationUpsertArgs> =
  z
    .object({
      select: NotificationSelectSchema.optional(),
      include: NotificationIncludeSchema.optional(),
      where: NotificationWhereUniqueInputSchema,
      create: z.union([
        NotificationCreateInputSchema,
        NotificationUncheckedCreateInputSchema,
      ]),
      update: z.union([
        NotificationUpdateInputSchema,
        NotificationUncheckedUpdateInputSchema,
      ]),
    })
    .strict() as z.ZodType<Prisma.NotificationUpsertArgs>;

export const NotificationCreateManyArgsSchema: z.ZodType<Prisma.NotificationCreateManyArgs> =
  z
    .object({
      data: z.union([
        NotificationCreateManyInputSchema,
        NotificationCreateManyInputSchema.array(),
      ]),
      skipDuplicates: z.boolean().optional(),
    })
    .strict() as z.ZodType<Prisma.NotificationCreateManyArgs>;

export const NotificationCreateManyAndReturnArgsSchema: z.ZodType<Prisma.NotificationCreateManyAndReturnArgs> =
  z
    .object({
      data: z.union([
        NotificationCreateManyInputSchema,
        NotificationCreateManyInputSchema.array(),
      ]),
      skipDuplicates: z.boolean().optional(),
    })
    .strict() as z.ZodType<Prisma.NotificationCreateManyAndReturnArgs>;

export const NotificationDeleteArgsSchema: z.ZodType<Prisma.NotificationDeleteArgs> =
  z
    .object({
      select: NotificationSelectSchema.optional(),
      include: NotificationIncludeSchema.optional(),
      where: NotificationWhereUniqueInputSchema,
    })
    .strict() as z.ZodType<Prisma.NotificationDeleteArgs>;

export const NotificationUpdateArgsSchema: z.ZodType<Prisma.NotificationUpdateArgs> =
  z
    .object({
      select: NotificationSelectSchema.optional(),
      include: NotificationIncludeSchema.optional(),
      data: z.union([
        NotificationUpdateInputSchema,
        NotificationUncheckedUpdateInputSchema,
      ]),
      where: NotificationWhereUniqueInputSchema,
    })
    .strict() as z.ZodType<Prisma.NotificationUpdateArgs>;

export const NotificationUpdateManyArgsSchema: z.ZodType<Prisma.NotificationUpdateManyArgs> =
  z
    .object({
      data: z.union([
        NotificationUpdateManyMutationInputSchema,
        NotificationUncheckedUpdateManyInputSchema,
      ]),
      where: NotificationWhereInputSchema.optional(),
      limit: z.number().optional(),
    })
    .strict() as z.ZodType<Prisma.NotificationUpdateManyArgs>;

export const NotificationUpdateManyAndReturnArgsSchema: z.ZodType<Prisma.NotificationUpdateManyAndReturnArgs> =
  z
    .object({
      data: z.union([
        NotificationUpdateManyMutationInputSchema,
        NotificationUncheckedUpdateManyInputSchema,
      ]),
      where: NotificationWhereInputSchema.optional(),
      limit: z.number().optional(),
    })
    .strict() as z.ZodType<Prisma.NotificationUpdateManyAndReturnArgs>;

export const NotificationDeleteManyArgsSchema: z.ZodType<Prisma.NotificationDeleteManyArgs> =
  z
    .object({
      where: NotificationWhereInputSchema.optional(),
      limit: z.number().optional(),
    })
    .strict() as z.ZodType<Prisma.NotificationDeleteManyArgs>;

export const PaymentCreateArgsSchema: z.ZodType<Prisma.PaymentCreateArgs> = z
  .object({
    select: PaymentSelectSchema.optional(),
    include: PaymentIncludeSchema.optional(),
    data: z.union([
      PaymentCreateInputSchema,
      PaymentUncheckedCreateInputSchema,
    ]),
  })
  .strict() as z.ZodType<Prisma.PaymentCreateArgs>;

export const PaymentUpsertArgsSchema: z.ZodType<Prisma.PaymentUpsertArgs> = z
  .object({
    select: PaymentSelectSchema.optional(),
    include: PaymentIncludeSchema.optional(),
    where: PaymentWhereUniqueInputSchema,
    create: z.union([
      PaymentCreateInputSchema,
      PaymentUncheckedCreateInputSchema,
    ]),
    update: z.union([
      PaymentUpdateInputSchema,
      PaymentUncheckedUpdateInputSchema,
    ]),
  })
  .strict() as z.ZodType<Prisma.PaymentUpsertArgs>;

export const PaymentCreateManyArgsSchema: z.ZodType<Prisma.PaymentCreateManyArgs> =
  z
    .object({
      data: z.union([
        PaymentCreateManyInputSchema,
        PaymentCreateManyInputSchema.array(),
      ]),
      skipDuplicates: z.boolean().optional(),
    })
    .strict() as z.ZodType<Prisma.PaymentCreateManyArgs>;

export const PaymentCreateManyAndReturnArgsSchema: z.ZodType<Prisma.PaymentCreateManyAndReturnArgs> =
  z
    .object({
      data: z.union([
        PaymentCreateManyInputSchema,
        PaymentCreateManyInputSchema.array(),
      ]),
      skipDuplicates: z.boolean().optional(),
    })
    .strict() as z.ZodType<Prisma.PaymentCreateManyAndReturnArgs>;

export const PaymentDeleteArgsSchema: z.ZodType<Prisma.PaymentDeleteArgs> = z
  .object({
    select: PaymentSelectSchema.optional(),
    include: PaymentIncludeSchema.optional(),
    where: PaymentWhereUniqueInputSchema,
  })
  .strict() as z.ZodType<Prisma.PaymentDeleteArgs>;

export const PaymentUpdateArgsSchema: z.ZodType<Prisma.PaymentUpdateArgs> = z
  .object({
    select: PaymentSelectSchema.optional(),
    include: PaymentIncludeSchema.optional(),
    data: z.union([
      PaymentUpdateInputSchema,
      PaymentUncheckedUpdateInputSchema,
    ]),
    where: PaymentWhereUniqueInputSchema,
  })
  .strict() as z.ZodType<Prisma.PaymentUpdateArgs>;

export const PaymentUpdateManyArgsSchema: z.ZodType<Prisma.PaymentUpdateManyArgs> =
  z
    .object({
      data: z.union([
        PaymentUpdateManyMutationInputSchema,
        PaymentUncheckedUpdateManyInputSchema,
      ]),
      where: PaymentWhereInputSchema.optional(),
      limit: z.number().optional(),
    })
    .strict() as z.ZodType<Prisma.PaymentUpdateManyArgs>;

export const PaymentUpdateManyAndReturnArgsSchema: z.ZodType<Prisma.PaymentUpdateManyAndReturnArgs> =
  z
    .object({
      data: z.union([
        PaymentUpdateManyMutationInputSchema,
        PaymentUncheckedUpdateManyInputSchema,
      ]),
      where: PaymentWhereInputSchema.optional(),
      limit: z.number().optional(),
    })
    .strict() as z.ZodType<Prisma.PaymentUpdateManyAndReturnArgs>;

export const PaymentDeleteManyArgsSchema: z.ZodType<Prisma.PaymentDeleteManyArgs> =
  z
    .object({
      where: PaymentWhereInputSchema.optional(),
      limit: z.number().optional(),
    })
    .strict() as z.ZodType<Prisma.PaymentDeleteManyArgs>;
